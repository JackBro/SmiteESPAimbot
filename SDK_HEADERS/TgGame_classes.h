/*
#############################################################################################
# Smite (v3.24.3804.2) SDK
# Generated with TheFeckless UE3 SDK Generator v1.4_Beta-Rev.51
# ========================================================================================= #
# File: TgGame_classes.h
# ========================================================================================= #
# Credits: uNrEaL, Tamimego, SystemFiles, R00T88, _silencer, the1domo, K@N@VEL
# Thanks: HOOAH07, lowHertz
# Forums: www.uc-forum.com, www.gamedeception.net
#############################################################################################
*/

#ifdef _MSC_VER
	#pragma pack ( push, 0x4 )
#endif

/*
# ========================================================================================= #
# Constants
# ========================================================================================= #
*/

#define CONST_TGACHIEVEMENT_JUMP_JUMP_ACTIVITY_ID                1933
#define CONST_TGACH_BELL_HAND_ID                                 11133
#define CONST_TGACH_BELL_HAMMER_ID                               11138
#define CONST_TGACH_BELL_HAMMER_DEV_ID                           11137
#define CONST_TGACH_BELL_SCRG_ID                                 11139
#define CONST_TGACH_BELL_SCRG_DEV_ID                             11140
#define CONST_TGACH_BELL_SHLD_ID                                 11134
#define CONST_TGACH_BELL_SHLD_DEV_ID                             11127
#define CONST_TGACH_BELL_RALLY_ID                                11141
#define CONST_TGACH_HADES_DEV4_ID                                7357
#define CONST_TGACH_HOUYI_DEV1_ID                                11416
#define CONST_TGACH_HOUYI_DEV3_ID                                11637
#define CONST_TGACH_HOUYI_DEV4_ID                                10869
#define CONST_CONTEXT_NOTIFY_ATTACK                              116959
#define CONST_CONTEXT_NOTIFY_DEFEND                              116960
#define CONST_CONTEXT_NOTIFY_BE_CAREFUL                          116961
#define CONST_CONTEXT_NOTIFY_PING                                117584
#define CONST_CONTEXT_NOTIFY_ENEMY                               117670
#define CONST_CONTEXT_NOTIFY_MIA                                 117676
#define CONST_CONTEXT_NOTIFY_GANK                                117671
#define CONST_CONTEXT_NOTIFY_HELP                                117672
#define CONST_CONTEXT_NOTIFY_INCOMING                            117673
#define CONST_CONTEXT_NOTIFY_RETREAT                             117674
#define CONST_CONTEXT_NOTIFY_RETURNED                            117675
#define CONST_CONTEXT_NOTIFY_SELF_ATTACK                         118524
#define CONST_CONTEXT_NOTIFY_SELF_DEFEND                         118525
#define CONST_CONTEXT_NOTIFY_SELF_GANK                           118526
#define CONST_CONTEXT_NOTIFY_SELF_RETURNED                       118527
#define CONST_CONTEXT_NOTIFY_SELF_RETREAT                        118528
#define CONST_CONTEXT_NOTIFY_WARD_HERE                           122294
#define CONST_ITEM_QUALITY_EPIC                                  1162
#define CONST_ITEM_QUALITY_RARE                                  1163
#define CONST_ITEM_QUALITY_UNCOMMON                              1164
#define CONST_ITEM_QUALITY_COMMON                                1165
#define CONST_VV_BOT_RANK_FAMILIAR                               10425
#define CONST_VV_BOT_RANK_MINION                                 10123
#define CONST_VV_BOT_RANK_TOWER                                  10127
#define CONST_VV_BOT_RANK_GUARDIAN                               10124
#define CONST_VV_BOT_RANK_PHOENIX                                10125
#define CONST_VV_BOT_RANK_GOD                                    10126
#define CONST_VV_BOT_RANK_MONSTER                                10085
#define CONST_VV_BOT_RANK_LARGE_MONSTER                          10140
#define CONST_VV_BOT_RANK_BUFFMONSTER                            10178
#define CONST_VV_BOT_RANK_NEUTRAL_BOSS                           10270
#define CONST_VV_BOT_RANK_DECOY                                  10679
#define CONST_VV_BOT_RANK_DEPLOYABLE                             10678
#define CONST_VV_BOT_RANK_ELITE_MINION                           10787
#define CONST_TGPAWN_GENERIC_EFFECT_GROUP_SITUATIONAL_01         10693
#define CONST_TGPAWN_GENERIC_EFFECT_GROUP_SITUATIONAL_02         10694
#define CONST_TGMT_NONE                                          0
#define CONST_TGMT_MOVEMENT                                      10583
#define CONST_TGMT_LEAP                                          10955
#define CONST_TGMT_DASH                                          10956
#define CONST_DEVICE_TIER                                        10756
#define CONST_DEVICE_TIER01                                      10757
#define CONST_DEVICE_TIER02                                      10758
#define CONST_DEVICE_TIER_ARTIFACT                               11343
#define CONST_ITEM_ID_BUMBAS_MASK                                8987
#define CONST_ITEM_ID_BUMBAS_MASK_S3                             12285
#define CONST_ITEM_ID_WATCHERS_GIFT                              9089
#define CONST_ITEM_ID_WATCHERS_GIFT_S3                           12288
#define CONST_ITEM_ID_TRANSCENDENCE                              8547
#define CONST_ITEM_ID_TRANSCENDENCE_S3                           12161
#define CONST_ITEM_ID_RUNEFORGED_HAMMER                          8959
#define CONST_ITEM_ID_RUNEFORGED_HAMMER_S3                       12207
#define CONST_ITEM_ID_ETHEREAL_STAFF                             8599
#define CONST_ITEM_ID_ETHEREAL_STAFF_S3                          12293
#define CONST_ITEM_ID_BANCROFTS_TALON                            8551
#define CONST_ITEM_ID_BANCROFTS_TALON_S3                         12209
#define CONST_ITEM_ID_BOOK_OF_THOTH                              7334
#define CONST_ITEM_ID_BOOK_OF_THOTH_S3                           12263
#define CONST_ITEM_ID_BOOK_OF_THOTH_B_S3                         12557
#define CONST_ITEM_ID_ANCILE                                     10127
#define CONST_TG_EQP_POINT_MAX                                   25
#define CONST_EQ_MAX_LOAD_DEVICE                                 15
#define CONST_FADE_TIME                                          1.0f
#define CONST_MAX_HEARING_DISTANCE                               1300
#define CONST_FEET_TO_UNREAL_UNITS                               16
#define CONST_BNT_NONE                                           0
#define CONST_BNT_COMPOSITE_SEQUENCE                             1
#define CONST_BNT_COMPOSITE_SEQUENCE_SCRIPTED                    2
#define CONST_BNT_COMPOSITE_RANDOM                               3
#define CONST_BNT_COMPOSITE_GATED                                4
#define CONST_BNT_SENSOR_GODS                                    8
#define CONST_BNT_SENSOR_SIGHT_RADIUS                            9
#define CONST_BNT_SENSOR_TOWERS                                  10
#define CONST_BNT_SENSOR_IN_HOSTILE_ABILITY                      11
#define CONST_BNT_SENSOR_PURCHASE_SKILLS                         12
#define CONST_BNT_SENSOR_SAFE_TO_RECALL                          13
#define CONST_BNT_SENSOR_LEASH                                   14
#define CONST_BNT_SENSOR_LANE                                    15
#define CONST_BNT_SENSOR_DEVICE_TARGETING                        16
#define CONST_BNT_SENSOR_INCOMING_DAMAGE                         17
#define CONST_BNT_SENSOR_RALLY_POINTS                            18
#define CONST_BNT_CONDITION_IS_AT_SPAWN                          256
#define CONST_BNT_CONDITION_IS_SAFE_TO_RECALL                    257
#define CONST_BNT_CONDITION_IS_IN_HOSTILE_ABILITY                258
#define CONST_BNT_CONDITION_CAN_PURCHASE_ITEMS                   259
#define CONST_BNT_CONDITION_CAN_PURCHASE_SKILLS                  260
#define CONST_BNT_CONDITION_COMBAT_DAMAGEABLE                    261
#define CONST_BNT_CONDITION_COMBAT_DAMAGEABLE_DEVICE             262
#define CONST_BNT_CONDITION_COMBAT_HEALTH_PERCENT                263
#define CONST_BNT_CONDITION_CURRENT_LEVEL                        264
#define CONST_BNT_CONDITION_DEVICE_READY                         265
#define CONST_BNT_CONDITION_COMBAT_HAS_TARGET                    266
#define CONST_BNT_CONDITION_LANE_HAS_TARGET                      267
#define CONST_BNT_CONDITION_HEALTH_PERCENT                       268
#define CONST_BNT_CONDITION_COMBAT_IS_HOSTILE                    269
#define CONST_BNT_CONDITION_COMBAT_IS_OF_TYPE                    270
#define CONST_BNT_CONDITION_IS_IN_MINOTAUR_RADIUS                271
#define CONST_BNT_CONDITION_IS_IN_TOWER_RADIUS                   272
#define CONST_BNT_CONDITION_IS_TARGET_OF_TWR_OR_MTR              273
#define CONST_BNT_CONDITION_COMBAT_IS_IN_DISTANCE                274
#define CONST_BNT_CONDITION_NEARBY_GOD_COUNT                     275
#define CONST_BNT_CONDITION_NEARBY_GOD_DELTA                     276
#define CONST_BNT_CONDITION_NEARBY_MINION_COUNT                  277
#define CONST_BNT_CONDITION_NEARBY_MINION_DELTA                  278
#define CONST_BNT_CONDITION_COMBAT_IS_TARGETING_TYPE             279
#define CONST_BNT_CONDITION_MANA_PERCENT                         280
#define CONST_BNT_CONDITION_MINIONS_IN_TOWER_RADIUS              281
#define CONST_BNT_CONDITION_DISTANCE_FROM_SPAWN                  282
#define CONST_BNT_CONDITION_COMBAT_IS_VISIBLE                    283
#define CONST_BNT_CONDITION_TIME_SINCE_TOOK_DAMAGE               284
#define CONST_BNT_CONDITION_COMBAT_IS_IN_MINOTAUR_RADIUS         285
#define CONST_BNT_CONDITION_COMBAT_IS_IN_TOWER_RADIUS            286
#define CONST_BNT_CONDITION_COMBAT_IS_TARGET_OF_TWR_OR_MTR       287
#define CONST_BNT_CONDITION_DISTANCE_FROM_NEAREST_GOD            288
#define CONST_BNT_CONDITION_COMBAT_IS_STEALTHED                  289
#define CONST_BNT_CONDITION_COMBAT_IS_LOOKING_AT                 290
#define CONST_BNT_CONDITION_DISTANCE_FROM_COMBAT_TARGET          291
#define CONST_BNT_CONDITION_IS_LAST_ATTACKER_OF_TYPE             292
#define CONST_BNT_CONDITION_NEAREST_GOD_HEALTH_PCT               293
#define CONST_BNT_CONDITION_GODS_IN_TOWER_RADIUS                 294
#define CONST_BNT_CONDITION_NEAREST_TOWER_HEALTH_PCT             295
#define CONST_BNT_CONDITION_COMBAT_IS_IN_FOUNTAIN                296
#define CONST_BNT_CONDITION_COMBAT_IS_IN_LEASH                   297
#define CONST_BNT_CONDITION_COMBAT_IS_IN_SIGHT_RADIUS            298
#define CONST_BNT_CONDITION_IS_OUTSIDE_LEASH                     299
#define CONST_BNT_CONDITION_TIMER                                300
#define CONST_BNT_CONDITION_HAS_SPREAD_LOCATION                  301
#define CONST_BNT_CONDITION_TARGET_TYPE_IS_IN_LEASH              302
#define CONST_BNT_CONDITION_ENERGY                               303
#define CONST_BNT_CONDITION_COMBAT_DAMAGED_FRIENDLY_GOD          304
#define CONST_BNT_CONDITION_IS_TOO_FAR_FROM_LANE                 305
#define CONST_BNT_CONDITION_COMBAT_HAS_EFFECT_CATEGORY           306
#define CONST_BNT_CONDITION_HAS_EFFECT_CATEGORY                  307
#define CONST_BNT_CONDITION_TARGETS_DAMAGEABLE_BY_DEVICE         308
#define CONST_BNT_CONDITION_GAMETYPE                             309
#define CONST_BNT_CONDITION_COMBAT_IS_LAST_ATTACKER              310
#define CONST_BNT_CONDITION_DIFFICULTY_LEVEL                     311
#define CONST_BNT_CONDITION_INCOMING_DAMAGE                      312
#define CONST_BNT_CONDITION_HAS_CONSUMABLE                       313
#define CONST_BNT_CONDITION_HAS_ACTIVE                           314
#define CONST_BNT_CONDITION_DISTANCE_FROM_LANE_TARGET            315
#define CONST_BNT_CONDITION_IS_ACTIVE_READY                      316
#define CONST_BNT_CONDITION_TASKFORCE                            317
#define CONST_BNT_CONDITION_COMBAT_HEALTH_AFTER_ATTACK           318
#define CONST_BNT_CONDITION_RETURN_ALWAYS                        319
#define CONST_BNT_CONDITION_LAST_ATTACKER_IS_TARGET_TYPE         320
#define CONST_BNT_CONDITION_DEVICE_IS_FIRING                     321
#define CONST_BNT_CONDITION_COMBAT_DROPPED                       322
#define CONST_BNT_CONDITION_IS_AT_RALLY_POINT                    323
#define CONST_BNT_CONDITION_MINIONS_IN_MINOTAUR_RADIUS           324
#define CONST_BNT_CONDITION_GODS_IN_MINOTAUR_RADIUS              325
#define CONST_BNT_CONDITION_MINOTAUR_HEALTH_PCT                  326
#define CONST_BNT_CONDITION_NEAREST_PAWN_TOWER_RADIUS            327
#define CONST_BNT_CONDITION_NEAREST_PAWN_MINOTAUR_RADIUS         328
#define CONST_BNT_CONDITION_PET_PHASE                            329
#define CONST_BNT_CONDITION_PHYSICS_STATE                        330
#define CONST_BNT_CONDITION_COMBAT_PHYSICS_STATE                 331
#define CONST_BNT_CONDITION_AIM_TOWER_RADIUS                     332
#define CONST_BNT_CONDITION_IS_NON_COMBAT                        333
#define CONST_BNT_CONDITION_IS_IN_JUNGLE                         334
#define CONST_BNT_CONDITION_COMBAT_IS_HITTABLE                   335
#define CONST_BNT_CONDITION_NEARBY_TARGET_COUNT                  336
#define CONST_BNT_CONDITION_NEARBY_TARGET_DELTA                  337
#define CONST_BNT_CONDITION_NEAREST_TARGET_HEALTH_PCT            338
#define CONST_BNT_ACTION_CLEAR_NAVIGATION_QUEUE                  1048576
#define CONST_BNT_ACTION_USE_DEVICE                              1048577
#define CONST_BNT_ACTION_RUN_TO_SPAWN                            1048578
#define CONST_BNT_ACTION_FOLLOW_COMBAT_TARGET                    1048579
#define CONST_BNT_ACTION_LOOK_AT_COMBAT_TARGET                   1048580
#define CONST_BNT_ACTION_MOVE_TO_LANE_TARGET                     1048581
#define CONST_BNT_ACTION_PLAY_EMOTE                              1048582
#define CONST_BNT_ACTION_PURCHASE_ITEMS                          1048583
#define CONST_BNT_ACTION_PURCHASE_SKILLS                         1048584
#define CONST_BNT_ACTION_SELECT_COMBAT_LANE                      1048585
#define CONST_BNT_ACTION_SELECT_COMBAT_LASTATTACKER              1048586
#define CONST_BNT_ACTION_SELECT_LANE_MOVE                        1048587
#define CONST_BNT_ACTION_SELECT_LANE_JUNGLE                      1048588
#define CONST_BNT_ACTION_SELECT_LANE_MINOTAUR                    1048589
#define CONST_BNT_ACTION_CLEAR_LANE_MOVE_TARGET                  1048590
#define CONST_BNT_ACTION_CLEAR_COMBAT_TARGET                     1048591
#define CONST_BNT_ACTION_CLEAR_LOOK_AT                           1048592
#define CONST_BNT_ACTION_LEASH_TO_SPAWN                          1048593
#define CONST_BNT_ACTION_SELECT_COMBAT_THREAT                    1048594
#define CONST_BNT_ACTION_LOOK_AT_SPAWN_ROTATION                  1048595
#define CONST_BNT_ACTION_SELECT_COMBAT_LEASH                     1048596
#define CONST_BNT_ACTION_RUN_TO_SPREAD_LOCATION                  1048597
#define CONST_BNT_ACTION_SELECT_COMBAT_SQUAD                     1048598
#define CONST_BNT_ACTION_SUGGEST_COMBAT_SQUAD                    1048599
#define CONST_BNT_ACTION_CLEAR_SPREAD_LOCATION                   1048600
#define CONST_BNT_ACTION_RUN_TO_OWNER                            1048601
#define CONST_BNT_ACTION_FOLLOW_LANE                             1048602
#define CONST_BNT_ACTION_CLEAR_LAST_ATTACKER                     1048603
#define CONST_BNT_ACTION_SELECT_LANE_MOVE_AS_COMBAT_TARGET       1048604
#define CONST_BNT_ACTION_MOVE_TO_LANE_VOLUME                     1048605
#define CONST_BNT_ACTION_JUKE                                    1048606
#define CONST_BNT_ACTION_USE_CONSUMABLE                          1048607
#define CONST_BNT_ACTION_USE_ACTIVE                              1048608
#define CONST_BNT_ACTION_FOLLOW_PATROL                           1048609
#define CONST_BNT_ACTION_REGEN_HEALTH                            1048610
#define CONST_BNT_ACTION_PAUSE_AI                                1048611
#define CONST_BNT_ACTION_PLAY_VGS                                1048612
#define CONST_BNT_ACTION_ASSIGN_LANE                             1048613
#define CONST_BNT_ACTION_SELECT_COMBAT_JUNGLE                    1048614
#define CONST_BNT_ACTION_MOVE_TO_RALLY_POINT                     1048615
#define CONST_BNT_ACTION_CLEAR_RALLY_POINT                       1048616
#define CONST_BNT_ACTION_CANCEL_FIRING                           1048617
#define CONST_BNT_ACTION_SELECT_COMBAT_TARGETS_TARGET            1048618
#define CONST_BNT_ACTION_FOLLOW_LANE_REVERSE                     1048619
#define CONST_TG_MINIMUM_GROUNDSPEED                             150.0f
#define CONST_MAX_DEVICE_EQPOINT                                 15
#define CONST_MAX_NUM_DEPLOYED_BOTS                              3
#define CONST_TGFXP_SCALAR                                       299
#define CONST_TGFXP_VECTOR                                       300
#define CONST_TGFXP_COLOR                                        301
#define CONST_TGFXP_TEXTURE                                      307
#define CONST_TGFXT_NO_PRIORITY                                  0
#define CONST_TGFXT_PRIORITY_SHIELD                              625
#define CONST_TGFXT_PRIORITY_STEALTH                             626
#define CONST_TGFXT_PRIORITY_STEALTH_DETECTION                   627
#define CONST_TGFXT_PRIORITY_FLAME                               838
#define CONST_TGFXT_PRIORITY_SPAWN_SORTORDER                     15
#define CONST_TGFXMAT_GENERIC                                    615
#define CONST_TGFXMAT_HAIR                                       616
#define CONST_TGFXMAT_HEAD                                       617
#define CONST_TGFXMAT_BODY                                       618
#define CONST_TGFXMAT_HELMET                                     1010
#define CONST_TGFXMAT_BACKPACK                                   1011
#define CONST_TGFXMAT_INHAND                                     1192
#define CONST_TGFXT_DPG_WORLD                                    10823
#define CONST_TGFXT_DPG_MIDDLEGROUND                             10834
#define CONST_TGFXT_DPG_FOREGROUND                               10835
#define CONST_TGFXT_AUDIENCE_ALL                                 10825
#define CONST_TGFXT_AUDIENCE_SELF                                10829
#define CONST_TGFXT_AUDIENCE_FRIENDLY                            10830
#define CONST_TGFXT_AUDIENCE_ENEMY                               10831
#define CONST_TGFXT_AUDIENCE_TASKFORCE1                          10832
#define CONST_TGFXT_AUDIENCE_TASKFORCE2                          10833
#define CONST_PLAYER_NOT_TAGGED                                  -1
#define CONST_DAMAGE_CAP_HEALTH_END_PERC                         10
#define CONST_DAMAGE_CAP_HEALTH_START_PERC                       90
#define CONST_TG_ASSIST_TIMEOUT_NONGOD                           5
#define CONST_TG_ASSIST_TIMEOUT_GOD                              10
#define CONST_GLOBAL_OFFHAND_CLIENT_COOLDOWN                     0.3
#define CONST_GLOBAL_OFFHAND_COOLDOWN                            0.2
#define CONST_IgnoreBlockingDeployAll                            0XF0
#define CONST_IgnoreBlockingWall                                 0XC0
#define CONST_IgnoreBlockingDeploy                               0X30
#define CONST_IgnoreBlockingPawn                                 0x0F
#define CONST_IgnoreBlockingMinion                               0x0C
#define CONST_IgnoreBlockingGod                                  0x03
#define CONST_IgnoreBlockingWallEnemy                            0x80
#define CONST_IgnoreBlockingWallFriendly                         0x40
#define CONST_IgnoreBlockingDeployEnemy                          0x20
#define CONST_IgnoreBlockingDeployFriendly                       0x10
#define CONST_IgnoreBlockingMinionEnemy                          0x08
#define CONST_IgnoreBlockingMinionFriendly                       0x04
#define CONST_IgnoreBlockingGodEnemy                             0x02
#define CONST_IgnoreBlockingGodFriendly                          0x01
#define CONST_TG_GROUND_PORTAL_TELEPORT_DIST_RATIO               0.3333f
#define CONST_TG_DEFAULT_WINE_MIC                                2430
#define CONST_TG_KILLGODEMOTE_SPACING                            15.0f
#define CONST_TG_DISTANCE_FADE_TIME                              1.0f
#define CONST_TG_VOLUME_STEALTH_FADE_TIME                        1.0f
#define CONST_AttackComboTimeout                                 1.0f
#define CONST_TG_SPAWNFX_VALID_DURATION                          5
#define CONST_TG_MIN_AIM_TRACE_LENGTH                            160
#define CONST_TG_PHYSICALITY_MINIONS                             10035
#define CONST_TG_PHYSICALITY_GODS                                10034
#define CONST_TG_PHYSICALITY_STRUCTURES                          861
#define CONST_TG_PHYSICALITY_HUMANOIDS                           860
#define CONST_MAX_NBR_OF_DAMAGEINFO                              8
#define CONST_TG_MAX_FLASH_EVENTS                                32
#define CONST_AI_TEAM_PASSTHRU_DISTANCE                          100000
#define CONST_AI_DEFAULT_DISTANCE_OFFSET                         50
#define CONST_SMITE_MIDPOINT_ROUTE_THRESHOLD                     160.0f
#define CONST_SMITE_MINION_INTRASQUAD_SPAWN_DELAY                0.5f
#define CONST_AIBOARD_BEHAVIOR_GOD                               0x01
#define CONST_AIBOARD_BEHAVIOR_MAPNPC                            0x02
#define CONST_AIBOARD_BEHAVIOR_PET                               0x04
#define CONST_AIBOARD_SQUAD                                      0x08
#define CONST_AIBOARD_BEHAVIOR_LANENPC                           0x10
#define CONST_TGC_REMEMBER_PLAYER_ATTACKED_TIME                  2
#define CONST_TGC_KILL_STREAK_MAX_TIME                           10
#define CONST_TGC_TELEPORT_DESTINATION_CACHE_TIME                0.1
#define CONST_TGPAWN_BELLONA_PASSIVE_EFFECT_GROUP                39517
#define CONST_TGPAWN_FREYA_PIXEL_BUSTER_SKIN_ID                  10478
#define CONST_TGPAWN_FREYA_RANGED_WEAPON_SUB_FX_ID               2256
#define CONST_TGPAWN_FREYA_RANGED_WEAPON_SUB_ID                  8368
#define CONST_TGPAWN_FREYA_ULT_WEAPON_ID                         8424
#define CONST_TGPAWN_FREYA_RANGED_WEAPON_ID                      8367
#define CONST_TGPAWN_FREYA_CLOAK_MARK_MAX                        4
#define CONST_TGPAWN_FREYA_CLOAK_MARK_ID                         8373
#define CONST_TGPAWN_FREYA_RANGED_GAUNTLET_FX_NUM                2
#define CONST_TGPAWN_FREYA_RANGED_GAUNTLET_FX_ID                 2278
#define CONST_TGPAWN_FREYA_RANGED_WEAPON_TIME                    6.0f
#define CONST_TGPAWN_FREYA_DAMAGE_BUFF_TIME                      5.0f
#define CONST_TGPAWN_FREYA_DAMAGE_BUFF_MAX                       1
#define CONST_TGPAWN_FREYA_DAMAGE_BUFF_ID                        8362
#define CONST_TGPAWN_THOTH_BASIC_ATTACK_DEVICE_ID                13558
#define CONST_TGPAWN_THOTH_DEV1_DEVICE_ID                        13561
#define CONST_TGPAWN_THOTH_DEV1_SHOOTER_DEVICE_ID                13559
#define CONST_TGPAWN_THOTH_SPEED_GLYPH_LISTENER_CATEGORY_CODE    15221
#define CONST_TGPAWN_THOTH_DEV2_SHOOTER_DEVICE_ID                13741
#define CONST_TGPAWN_THOTH_DEV3_DEVICE_ID                        13566
#define CONST_TGPAWN_THOTH_MAX_TRACKED_PROJ                      18
#define CONST_TGPAWN_THOTH_SPEED_GLYPH_PROJ_FX_ID                10240
#define CONST_TGPAWN_THOTH_SPEED_GLYPH_PROJ_ULT_FX_ID            10493
#define CONST_TGPAWN_THOTH_DEV4_SHOOTER_DEVICE_ID                13576
#define CONST_TGPAWN_THOTH_DEATH_ID                              7210
#define CONST_TGPAWN_THOTH_DEV2_DEVICE_ID                        13740
#define CONST_BOT_ENCOUNTER_DESPAWN_TIME                         60
#define CONST_CONTEXT_NOTIFY_ATTACK_SPECIALFX                    2928
#define CONST_CONTEXT_NOTIFY_DEFEND_SPECIALFX                    2929
#define CONST_CONTEXT_NOTIFY_BE_CAREFUL_SPECIALFX                2930
#define CONST_CONTEXT_NOTIFY_PING_SPECIALFX                      2954
#define CONST_COVER_DEFAULT_RANGE                                150
#define CONST_GT_ABILITY_USE_TIME                                120
#define CONST_MAX_LEVEL                                          20
#define CONST_VGS_SPAM_LENGTH                                    0.5
#define CONST_PING_LENGTH                                        4
#define CONST_PING_INTERVAL                                      0.5
#define CONST_MAX_FLASH_SIM_PROJECTILES                          24
#define CONST_MAX_BROADCAST_CHANNELS                             4
#define CONST_TGDPT_DEFAULT                                      666
#define CONST_TGDPT_HEALTHCRATE                                  667
#define CONST_DEPLOYABLE_STARTING_HEALTH_PCT                     0.10f
#define CONST_TORNADO_PROJ_FIREMODE_ID                           5526
#define CONST_TGDEPLOYABLE_WARD_ODYSSEY_2017_SKIN_ID             13550
#define CONST_TGDEPLOYABLE_WARD_ODYSSEY_2017_SKIN_LEVELS         4
#define CONST_TGDEPLOYABLE_WARD_ODYSSEY_2017_ACTIVITY_ID         2219
#define CONST_INTERP_ANCHOR_MAX                                  3
#define CONST_HIVE_EFFECT_GROUP_CATEGORY_CODE                    10722
#define CONST_HONEY_EFFECT_GROUP_CATEGORY_CODE                   10712
#define CONST_HONEY_BEES_EFFECT_GROUP_CATEGORY_CODE              10721
#define CONST_TGPID_ARES_CHAIN_PYLON_PULL_SUB_ID                 8288
#define CONST_TGDEPLOYABLE_ARTEMIS_TRAP_HIDDEN_FX_ID             8902
#define CONST_TGEGC_JUNGLE_BUFF_CATEGORY                         10667
#define CONST_TGDEPLOY_HERCULES_HERCSMASH_DEPLOYABLE_CLIENT_ID   393
#define CONST_PORTAL_TRIGGER_TIME                                1.0f
#define CONST_PORTAL_REUSE_DELAY                                 2.0f
#define CONST_TGPAWN_SUSANO_DEV4_START_RADIUS                    10
#define CONST_TGPAWN_SUSANO_DEV4_MAX_RADIUS                      20
#define CONST_TGPAWN_SUSANO_DEV4_GROWTH_TIME                     4
#define CONST_TGPAWN_SUSANO_DEV4_TRAVEL_TIME                     4
#define CONST_TGPAWN_SUSANO_DEV4_TRAVEL_RANGE                    40
#define CONST_TGDEPLOYABLE_THOTH_SPEED_GLYPH_IMPACT_ULT_FX_ID    10498
#define CONST_TGDEPLOYABLE_THOTH_SPEED_GLYPH_IMPACT_FX_ID        10441
#define CONST_TGDEPLOY_MAX_TRAIL_POINTS                          30
#define CONST_TGDEPLOY_YMIR_ICEWALL_THRESHOLD                    40.0f
#define CONST_TGDEPLOYABLE_ZEUS_SHIELD_RETURNPROJECTILE_ID       563
#define CONST_TGDEPLOYABLE_ZEUS_SHILED_RETURNPROJ_MODE_ID        11298
#define CONST_TGT_MAX_TIMERS                                     32
#define CONST_DEPLOYMODE_GROUND_DELTA_CHECK_DIST                 60.0f
#define CONST_DEPLOYMODE_MINIMUM_RADIUS_CHECK_DIST               30.0f
#define CONST_OFFHAND_EQUIP_COOLDOWN                             30.0f
#define CONST_REFIRE_SERVER_GRACE                                0.1f
#define CONST_COOLDOWN_SERVER_GRACE                              0.5f
#define CONST_TGDT_RANGED                                        388
#define CONST_TGDT_SPECIALTY                                     981
#define CONST_TGDT_MELEE                                         389
#define CONST_TGDT_OFF_HAND                                      390
#define CONST_TGDT_SUB_COMPONENT                                 956
#define CONST_TGDT_BASE_HUMAN_ATTRIB                             392
#define CONST_TGDT_PLAYER_SENSOR                                 393
#define CONST_TGDT_MORALE                                        476
#define CONST_TGDT_TRAVEL                                        806
#define CONST_TGDT_TOGGLE                                        1595
#define CONST_TGDT_ITEM_STORE                                    10024
#define CONST_TGDT_LOBBY_ACTIVE_ABILITY                          10039
#define CONST_TGDT_GAME_ACTIVE_ABILITY                           10099
#define CONST_TGDT_CONSUMABLE                                    10097
#define CONST_TGDT_PASSIVE                                       10102
#define CONST_TGDT_BOT_MELEE                                     671
#define CONST_TGDT_BOT_RANGED                                    670
#define CONST_NO_FIRE_SEQUENCE                                   255
#define CONST_TG_AIM_FUDGE_FACTOR                                256.0f
#define CONST_TG_VV_PACING_TYPE_ENERGY                           10014
#define CONST_TG_VV_PACING_TYPE_MANA                             10013
#define CONST_TG_VV_PACING_TYPE_HEALTH                           10692
#define CONST_TGD_ANIMSET_DEST_CHAR_SELECT                       1275
#define CONST_TGD_ANIMSET_DEST_PAWN                              859
#define CONST_TGD_ANIMSET_DEST_DEVICE                            858
#define CONST_TGD_MESH_TYPE_FIRSTPERSON                          1593
#define CONST_TGD_MESH_TYPE_LEFT_HAND                            1418
#define CONST_TGD_MESH_TYPE_ALT_ATTACHED                         857
#define CONST_TGD_MESH_TYPE_ATTACHED                             856
#define CONST_TGD_MESH_TYPE_INHAND                               855
#define CONST_TGD_RIGHT_CLICK_FIRE_MODE                          1
#define CONST_TGDRCB_SET_SECOND_FIRE_MODE                        1600
#define CONST_TGDRCB_CUSTOM                                      832
#define CONST_TGDRCB_DETONATE                                    831
#define CONST_TGDRCB_AIM_MODE                                    833
#define CONST_TGDRCB_SECOND_FIRE_MODE                            830
#define CONST_TGDRCB_NONE                                        829
#define CONST_TGEGT_OFF_COOLDOWN                                 10308
#define CONST_TGEGT_HIT_AURA                                     10060
#define CONST_TGEGT_HIT_SPECIAL_INSTANT                          10681
#define CONST_TGEGT_HIT_SPECIAL_MANAGED                          10036
#define CONST_TGEGT_HIT_INITIAL                                  10063
#define CONST_TGEGT_HIT                                          264
#define CONST_TGEGT_FIRED_PER_SHOT                               10030
#define CONST_TGEGT_REACTIVE_SKILL                               1104
#define CONST_TGEGT_SUCCESSFUL_HIT                               759
#define CONST_TGEGT_EQUIP_MODE                                   283
#define CONST_TGEGT_AIM                                          266
#define CONST_TGEGT_COOLDOWN                                     265
#define CONST_TGEGT_POST_HIT_DELAY                               10456
#define CONST_TGEGT_PRE_HIT_DELAY                                10455
#define CONST_TGEGT_WHILE_FIRING                                 263
#define CONST_TGEGT_BUILDUP                                      262
#define CONST_TGEGT_EQUIP                                        261
#define CONST_TGMAX_FIRE_MODE                                    5
#define CONST_RainFireMaximumAmmunitionCount                     3
#define CONST_TGDEVICE_AHPUCH_EMPTYTHECRYPTS_OFFSET              240.0f
#define CONST_TGEGC_AWILIX_MOONLIGHT_BUFF                        10957
#define CONST_BAKASURA_MAXIMUM_MINION_AMMUNITION                 6
#define CONST_TGDEVICE_BASTETPOUNCE_CC                           10743
#define CONST_TGPAWN_ERLANGSHEN_Psv_ID                           13022
#define CONST_TGPAWN_ERLANGSHEN_A01_ID                           13026
#define CONST_TGPAWN_ERLANGSHEN_A02_ID                           13030
#define CONST_TGPAWN_ERLANGSHEN_A03_IDa                          13019
#define CONST_TGPAWN_ERLANGSHEN_A03_IDb                          13020
#define CONST_TGPAWN_ERLANGSHEN_A04_ID                           13156
#define CONST_TGPAWN_ERLANGSHEN_MESH_ID                          6620
#define CONST_TGPAWN_ERLANGSHEN_MINK_MESH_ID                     6668
#define CONST_TGPAWN_ERLANGSHEN_TURTLE_MESH_ID                   6669
#define CONST_TGPAWN_ERLANGSHEN_PET_SPEED_PCT_RUN                3.3f
#define CONST_TGPAWN_ERLANGSHEN_PET_SPEED_PCT_JOG                2.2f
#define CONST_TGPAWN_ERLANGSHEN_PET_SPEED_PCT_WALK               1.0f
#define CONST_TGDEVICE_GEB_BOULDER_DEFAULT_ACCELTIME             2.0f
#define CONST_TGDEVICE_MONKEY_FURIOUSMONKEY_TARGET_FX_ID         6186
#define CONST_TGDEVICE_MONKEY_FURIOUSMONKEY_DIRECTION_FX_ID      6184
#define CONST_TGDEVICE_NUWA_PASSIVE_SITUATIONAL_TYPE             10718
#define CONST_TGDEV_RAVANA_DEV4_TARGET_SITUATIONAL_TYPE          11259
#define CONST_TGDEVICE_SCYLLA_NUM3_TARGET_FX_ID                  3794
#define CONST_TGDEVICE_SCYLLA_NUM3_TARGETABLE_FX_ID              0
#define CONST_Situational_Type_Serqet_DeStealth                  10850
#define CONST_TGDEVICE_SERGET_PASSIVE_BACKUP_COOLDOWNTIME        3.0f
#define CONST_TGEGC_SOL_HEAT                                     11308
#define CONST_TGPAWN_SOL_HEAT_BOOST                              11309
#define CONST_TGPAWN_SUNWUKONG_ULT_BUILDUP_FX_ID                 3362
#define CONST_TGPAWN_SUNWUKONG_ULT_BUILDUP_FX_ID01               3401
#define CONST_TGPAWN_SUNWUKONG_ULT_BUILDUP_FX_ID02               3400
#define CONST_TGPAWN_SUNWUKONG_ULT_JUMP_DEV_ID                   9325
#define CONST_TGDEVICE_SUSANO_DEV3_TIMER_FX_ID                   8659
#define CONST_TGDEVICE_SUSANO_DEV3_DIRECTION_FX_ID               8799
#define CONST_TGDEVICE_SUSANO_DEV3_TARGET_FX_ID                  8727
#define CONST_TGDEVICE_YMIR_EXPLOSION_STOPFIRE_SITUTATON_TYPE    10809
#define CONST_TGAB_NORMAL                                        1595
#define CONST_TGHT_EXAGGERATED_POKE                              0x02
#define CONST_TGHT_DEFAULT                                       0x01
#define CONST_TGHT_NONE                                          0x00
#define CONST_TGAUF_ALLOW_CRIPPLE                                8
#define CONST_TGAUF_ALLOW_GRAB                                   4
#define CONST_TGAUF_ALLOW_SILENCE                                2
#define CONST_TGAUF_ALLOW_STUN                                   1
#define CONST_TGAUF_ALLOW_NONE                                   0
#define CONST_TGRF_RESTRICT_POWERPACK                            64
#define CONST_TGRF_RESTRICT_SUIT                                 32
#define CONST_TGRF_RESTRICT_SENSOR                               16
#define CONST_TGRF_RESTRICT_SPECIALITY                           8
#define CONST_TGRF_RESTRICT_MOVEMENT                             4
#define CONST_TGRF_RESTRICT_RANGED                               2
#define CONST_TGRF_RESTRICT_MELEE                                1
#define CONST_TGRF_RESTRICT_NONE                                 0
#define CONST_TGDT_Magical                                       10057
#define CONST_TGDT_Physical                                      113
#define CONST_TGDT_None                                          112
#define CONST_TGTT_REMOTE_TYPE_PROX_PROJ                         123
#define CONST_TGTT_REMOTE_TYPE_TRIGGER                           92
#define CONST_TGTT_REMOTE_TYPE_TIME                              91
#define CONST_TGTT_REMOTE_TYPE_PROXIMITY                         90
#define CONST_TGTT_REMOTE_TYPE_NA                                89
#define CONST_TGTT_TARGET_NOT_SELF                               10587
#define CONST_TGTT_TARGET_FRIEND_AND_ENEMY                       10029
#define CONST_TGTT_TARGET_FRIEND_ONLY                            884
#define CONST_TGTT_TARGET_ENEMY_AND_SELF                         10805
#define CONST_TGTT_TARGET_ALL                                    703
#define CONST_TGTT_TARGET_ENEMY                                  212
#define CONST_TGTT_TARGET_FRIEND                                 10184
#define CONST_TGTT_TARGET_SELF                                   214
#define CONST_TGTT_ATTACK_PLAYER_SELECT                          15264
#define CONST_TGTT_ATTACK_ATTACHED_DEPLOYABLE                    10670
#define CONST_TGTT_ATTACK_MAP_TARGET_TELEPORT                    10658
#define CONST_TGTT_ATTACK_MAP_TELEPORT                           10657
#define CONST_TGTT_ATTACK_GROUND_TARGET_TELEPORT                 10636
#define CONST_TGTT_ATTACK_GROUND_TARGET_PROJECTILE               10251
#define CONST_TGTT_ATTACK_INSTANT_LINE                           10015
#define CONST_TGTT_ATTACK_GROUND_TARGET_BOT                      10382
#define CONST_TGTT_ATTACK_GROUND_TARGET_DEPLOYABLE               10011
#define CONST_TGTT_ATTACK_GROUND_TARGET                          10032
#define CONST_TGTT_ATTACK_JETPACK                                1599
#define CONST_TGTT_ATTACK_TELEPORT_TO_SPAWN                      1442
#define CONST_TGTT_ATTACK_ARTILLERY_STRIKE                       1177
#define CONST_TGTT_ATTACK_POWER_DOWN                             239
#define CONST_TGTT_ATTACK_INSTANT_BOT                            817
#define CONST_TGTT_ATTACK_INSTANT_DEPLOYABLE                     342
#define CONST_TGTT_ATTACK_SPAWN_PET                              306
#define CONST_TGTT_ATTACK_MELEE                                  170
#define CONST_TGTT_ATTACK_PROJECTILE_RANGED                      177
#define CONST_TGTT_ATTACK_PLACE_DEPLOYABLE                       209
#define CONST_TGTT_ATTACK_THROWN                                 87
#define CONST_TGTT_ATTACK_INSTANT_RANGED                         85
#define CONST_TGTT_ATTACK_NA                                     83
#define CONST_TGEGC_AWILIX_MOONLIGHT_PULL                        11020
#define CONST_TGPAWN_G72_SITUATIONAL_D41                         11319
#define CONST_TGPAWN_G72_SITUATIONAL_D42                         11320
#define CONST_TGPAWN_G72_SITUATIONAL_D43                         11321
#define CONST_TGDEVICEFIRE_NUWA_MINIONSPAWN_MAX_DELAY            0.07f
#define CONST_TGDEVICE_SOL_SOLARFLAIR_TARGETSMASK                0xffff
#define CONST_TGDEVICE_SOL_SOLARFLAIR_UNSTABLE_MASK              0x10000
#define CONST_TGATDT_ANIM_TREE_RANGE                             0.0
#define CONST_TGATDT_ANIM_TREE_MELEE                             1.0
#define CONST_TG_DEVICEFORM_RANGED                               1
#define CONST_TG_DEVICEFORM_MELEE                                2
#define CONST_TG_DEVICEFORM_DEPLOYABLE                           3
#define CONST_TG_DEVICEFORM_BASIC                                4
#define CONST_TG_DEVICEFORM_GRENADE                              5
#define CONST_TMS_FADEDAMAGE_TIMER                               1
#define CONST_IDLE_STATE_OFF                                     0
#define CONST_IDLE_STATE_TIMING                                  1
#define CONST_IDLE_STATE_ON                                      2
#define CONST_DEFAULT_FX_RADIUS                                  240.0f
#define CONST_TGCM_NA                                            119
#define CONST_TGCM_ADD                                           67
#define CONST_TGCM_SUBTRACT                                      70
#define CONST_TGCM_PERC_INCREASE                                 68
#define CONST_TGCM_PERC_DECREASE                                 69
#define CONST_TG_ROOT_GROUNDSPEED                                10000
#define CONST_TGEGT_NEWEST                                       156
#define CONST_TGEGT_STACKING                                     155
#define CONST_TGEGT_STRONGEST                                    157
#define CONST_TGEGT_REFRESH                                      10257
#define CONST_TGEGT_OLDEST                                       874
#define CONST_TGEGT_STACK_IN_PLACE                               10309
#define CONST_TGEGT_STACK_IN_PLACE_INSTIGATOR                    10821
#define CONST_TGEGT_STRONGEST_BEFORE_NEWEST                      10886
#define CONST_TGEGC_LOCAL                                        302
#define CONST_TGEGC_BUFF_DAMAGE_INTERNAL                         963
#define CONST_TGEGC_GENERAL_BUFF                                 775
#define CONST_TGEGC_REMOVE_EFFECT                                877
#define CONST_TGEGC_SLOW                                         10048
#define CONST_TGEGC_STUN                                         10049
#define CONST_TGEGC_MESMERIZE                                    10438
#define CONST_TGEGC_KNOCKBACK                                    10052
#define CONST_TGEGC_ROOT                                         10050
#define CONST_TGEGC_SILENCE                                      10053
#define CONST_TGEGC_DISARM                                       10423
#define CONST_TGEGC_CRIPPLE                                      10585
#define CONST_TGEGC_FEAR_OR_PANIC                                10051
#define CONST_TGEGC_STUN_TAUNT                                   10649
#define CONST_TGEGC_CHARM                                        10826
#define CONST_TGEGC_SHIELD_HEALTH                                10795
#define CONST_TGEGC_DAMAGE_OVERRIDE                              11240
#define CONST_TGEGC_YMIR_FREEZE                                  10027
#define CONST_TGEGC_BASTET_BLEED                                 10074
#define CONST_TGEGC_BASTET_PASSIVE                               10699
#define CONST_TGEGC_ZEUS_AEGIS_SHIELD                            10268
#define CONST_TGEGC_BAKASURA_BUFF                                10422
#define CONST_TGEGC_ANHUR_SLOW                                   10435
#define CONST_TGEGC_ARES_SEARING_FLESH                           10448
#define CONST_TGEGC_TOWER_BUFF                                   10453
#define CONST_TGEGC_JUMONG_COMBO_BUFF                            10461
#define CONST_TGEGC_LOKI_STIM_BUFF                               10463
#define CONST_TGEGC_LOKI_VANISH_BUFF                             10464
#define CONST_TGEGC_LOKI_STEALTH                                 10465
#define CONST_TGEGC_NEITH_PATH_OF_THE_HUNTER_HEAL_BUFF           10568
#define CONST_TGEGC_VULCAN_PASSIVE_TURRET_SURVIVAL_BUFF          10564
#define CONST_TGEGC_VULCAN_ULTIMATE_TURRET_SURVIVAL_BUFF         10563
#define CONST_TGEGC_VULCAN_EXHAUSTED_DEBUFF                      10569
#define CONST_TGEGC_VULCAN_OVERDRIVE_BUFF                        10570
#define CONST_TGEGC_VULCAN_BACKFIRE_MARK                         10673
#define CONST_TGEGC_XBALANQUE_APOCALYPSE_SHROUD                  10532
#define CONST_TGEGC_APOLLO_SERENADE                              10617
#define CONST_TGEGC_FENRIR_BITE                                  10628
#define CONST_TGEGC_FENRIR_BITE_BUFF                             10629
#define CONST_TGEGC_FENRIR_HOWL_BUFF                             10630
#define CONST_TGEGC_KALI_BLEED                                   10631
#define CONST_TGEGC_KALI_RAGE                                    10632
#define CONST_TGEGC_KALI_INCENSE                                 10727
#define CONST_TGEGC_ISIS_DEATHWARD                               10644
#define CONST_TGEGC_CHRONOS_PHASE_SHIFT_BUFF                     10653
#define CONST_TGEGC_CHRONOS_FAST_BUFF                            10654
#define CONST_TGEGC_CHRONOS_PASSIVE_BUFF_INHAND                  10655
#define CONST_TGEGC_CHRONOS_PASSIVE_BUFF_MANA_REFUND             10668
#define CONST_TGEGC_FURIOUS_MONKEY_CRIT                          10656
#define CONST_TGEGC_SLOW_EXPOSE_EVIL                             10669
#define CONST_TGEGC_THANATOS_SCENT_OF_DEATH_BASE                 10686
#define CONST_TGEGC_THANATOS_SCENT_OF_DEATH_EXTRA                10687
#define CONST_TGEGC_SUNWUKONG_PASSIVE                            10696
#define CONST_TGEGC_SUNWUKONG_STEALTH                            10698
#define CONST_TGEGC_NUWA_STEALTH                                 10716
#define CONST_TGEGC_NUWA_CANNOT_STEALTH                          10717
#define CONST_TGEGC_NUWA_FIRESHARDS_REVEAL                       10871
#define CONST_TGEGC_NEMESIS_PASSIVE_VICTIM_HIT                   10761
#define CONST_TGEGC_ULLR_TRANSFORM                               10777
#define CONST_TGEGC_KUMBHAKARNA_SLEEP                            10780
#define CONST_TGEGC_KUMBHAKARNA_GROGGY                           10788
#define CONST_TGEGC_KUMBHAKARNA_ULT                              10789
#define CONST_TGEGC_ULLR_BOW_STIM                                10785
#define CONST_TGEGC_OSIRIS_SICKLE_SLOW                           10790
#define CONST_TGEGC_FULLHEALTH_MOVEMENT_BUFF                     10791
#define CONST_TGEGC_SIEGE_TELEPORT_COOLDOWN                      10794
#define CONST_TGEGC_JANUS_EXTRA_DAMAGE                           10810
#define CONST_TGEGC_RAM_INHAND_SLOW_IMMUNITY                     10817
#define CONST_TGEGC_RAM_CIRCLE_DEBUFF                            10818
#define CONST_TGEGC_SERQET_DEATHBANE                             10837
#define CONST_TGEGC_SERQET_COBRAS_KISS                           10838
#define CONST_TGEGC_SERQET_LAST_BREATH                           10836
#define CONST_TGEGC_CABRAKAN_2_BUFF                              10868
#define CONST_TGEGC_OSIRIS_SICKLE_STRIKE                         10872
#define CONST_TGEGC_ATHENA_BASIC_ATTACK_ABSORB                   10641
#define CONST_TGEGC_THYRSUS                                      10896
#define CONST_TGEGC_ARACHNE_TRAIL_SLOW                           10902
#define CONST_TGEGC_KALI_MARKED                                  10909
#define CONST_TGEGC_KALI_MARKED_LOWHEALTH                        10910
#define CONST_TGEGC_AOKUANG_WILDSTORM_DEBUFF                     10926
#define CONST_TGEGC_NOX_DARKNESS_DEBUFF                          10939
#define CONST_TGEGC_AOKUANG_DELAYED_KNOCKUP_STUN                 10942
#define CONST_TGEGC_AOKUANG_DELAYED_KNOCKUP_STUN_NOKILL          10943
#define CONST_TGEGC_AOKUANG_DELAYED_KNOCKUP_STUN_PROTECT         10948
#define CONST_TGEGC_HOUYI_GOLDEN_CROW_MARK                       11044
#define CONST_TGEGC_CRIT_BLOCKER                                 11057
#define CONST_TGEGC_BELLONA_SHIELD_BASH_BLOCK                    11064
#define CONST_TGEGC_MEDUSA_ULT_SLOW                              11079
#define CONST_TGEGC_MEDUSA_ULT_STUN                              11084
#define CONST_TGEGC_RATATOSKR_TOPAZ_ACORN_TRIGGER                11196
#define CONST_TGEGC_KHEPRI_ABDUCTION                             11238
#define CONST_TGEGC_KHEPRI_OFFHAND                               11239
#define CONST_TGEGC_XBALANQUE_POISON_DARTS                       11247
#define CONST_TGEGC_NEZHA_SASH_STUN                              11254
#define CONST_TGEGC_AHMUZENCAB_SWARM                             10711
#define CONST_TGEGC_WRATH_OF_THE_GODS                            11271
#define CONST_TGEGC_NOX_SHADOW_LOCK                              11258
#define CONST_TGEGC_XINGTIAN_IGNITE                              11282
#define CONST_TGEGC_XINGTIAN_PASSIVE_BUFF_STACKS                 11284
#define CONST_TGEGC_SOL_TRAILING                                 11287
#define CONST_TGEGC_SOL_COOLDOWN                                 11303
#define CONST_TGEGC_SOL_HANDSTIM                                 11304
#define CONST_TGEGC_SOL_DECAYLOCK                                11306
#define CONST_TGEGC_SOL_DECAY                                    11307
#define CONST_TGEGC_PET_TARGET_MINOR                             11353
#define CONST_TGEGC_PET_TARGET_MAJOR                             11354
#define CONST_TGEGC_PET_IMMUNITY                                 11373
#define CONST_TGEGC_JING_WEI_BANISH_SELF                         11409
#define CONST_TGEGC_JING_WEI_BANISH_ENEMY                        11410
#define CONST_TGEGC_ARTEMIS_VENGEFUL_ASSAULT_BUFF                11421
#define CONST_TGEGC_SUSANO_DEV3_STACKS                           11424
#define CONST_TGEGC_FAFNIR_DRAGON                                15088
#define CONST_TGEGC_FAFNIR_GRAB                                  15089
#define CONST_TGEGC_FAFNIR_TIMEOUT                               15094
#define CONST_TGEGC_FAFNIR_TRANSFORMING                          15102
#define CONST_TGEGC_ERLANG_SHEN_NINE_TURNS_BLESSING_SKILL        15110
#define CONST_TGEGC_ERLANG_SHEN_NINE_TURNS_BLESSING_MARK         15111
#define CONST_TGEGC_ERLANG_SHEN_NINE_TURNS_BLESSING_WARN         15116
#define CONST_TGEGC_ERLANG_SHEN_SPOT_WEAKNESS_STIM               15133
#define CONST_TGEGC_ERLANG_SHEN_TURTLE_SHIELD_HEALTH             15138
#define CONST_TGEGC_TERRA_MOTHER_EARTH_BUFF                      15112
#define CONST_TGEGC_FREYA_USE_RANGED                             15117
#define CONST_TGEGC_CAMAZOTZ_SCREECH_BUFF                        15168
#define CONST_TGEGC_CAMAZOTZ_SIPHON_POWER_LOCK                   15172
#define CONST_TGEGC_CAMAZOTZ_SIPHON_POWER_BUFF                   15174
#define CONST_TGEGC_CAMAZOTZ_SIPHON_POWER_VICTIM                 15175
#define CONST_TGEGC_CAMAZOTZ_DEADLY_BITE_GRAB                    15177
#define CONST_TGEGC_CAMAZOTZ_DEADLY_BITE_BUFF                    15179
#define CONST_TGEGC_CAMAZOTZ_DEADLY_BITE_DEBUFF                  15181
#define CONST_TGEGC_CAMAZOTZ_VAMPIRE_BATS_LOCK                   15211
#define CONST_TGEGC_CAMAZOTZ_VAMPIRE_BATS_BUFF                   15214
#define CONST_TGEGC_CAMAZOTZ_VAMPIRE_BATS_VICTIM                 15213
#define CONST_TGEGC_CAMAZOTZ_VAMPIRE_BATS_VAMP                   15223
#define CONST_TGEGC_BULWARK_OF_HOPE                              10555
#define CONST_TGEGC_RACER_SPEED_BOOST                            15336
#define CONST_TGEGC_INVULNERABLE                                 -200
#define CONST_TGEGC_STEALTH                                      -100
#define CONST_TGPORTALFALL_SITUATIONAL_TYPE                      0
#define CONST_TIMER_INTERVAL                                     0
#define CONST_TIMER_LIFEDONE                                     1
#define CONST_DEFAULT_MAX_EFFECT_STACKS                          100
#define CONST_TGST_HIGHEST_VALUE                                 10130
#define CONST_TGST_IN_HAND                                       10131
#define CONST_TGST_ITEM_POWER                                    10552
#define CONST_TGST_TOTAL_POWER                                   10553
#define CONST_TGST_BASE_POWER                                    10625
#define CONST_TGST_PER_LEVEL                                     11389
#define CONST_TGEGC_NIKE_A04_ARMOR                               15278
#define CONST_TGEGC_NIKE_PASSIVE                                 15269
#define CONST_TGEA_MAX_EFFECTS                                   16
#define CONST_TGEA_MAX_EFFECTS_QUEUE                             16
#define CONST_TGEGS_EMPTY                                        0
#define CONST_TGEGS_ACTIVE_REP                                   1
#define CONST_TGEGS_ACTIVE                                       2
#define CONST_TGEGS_FLASH_REP                                    3
#define CONST_TGEGS_EMPTY_REP                                    4
#define CONST_REFRESH_NONE                                       0
#define CONST_REFRESH_REUSE                                      1
#define CONST_REFRESH_ADD                                        2
#define CONST_REFRESH_STACK                                      3
#define CONST_AIE_DAMAGE                                         0
#define CONST_AIE_HEALTH                                         1
#define CONST_AIE_MANA                                           2
#define CONST_AIE_STASIS                                         4
#define CONST_AIE_STUN                                           5
#define CONST_AIE_PROPERTY                                       6
#define CONST_AIE_PROPERTY_PERC                                  7
#define CONST_AIE_ENERGY                                         8
#define CONST_AIE_UNSTOPPABLEKILL                                9
#define CONST_AIE_STUN_PROXY_EFFECT_GROUP_ID                     33431
#define CONST_CONTRIBUTION_BUFFER                                0.75f
#define CONST_CONTRIBUTION_BUFFEE                                0.25f
#define CONST_HARD_CC_TIME_SECS                                  15.0f
#define CONST_HARD_CC_DIM_RETURNS                                0.33f
#define CONST_HARD_CC_KNOCKBACK_DIM_RETURNS                      0.15f
#define CONST_BASE_RESPAWN_TIME_SEC                              5
#define CONST_TG_MAX_MAP_OBJECTIVES                              75
#define CONST_TG_MAX_CAPTURE_POINTS                              5
#define CONST_TG_MAX_BANNED_GODS                                 8
#define CONST_SURRENDER_TIME_SECS                                60.0
#define CONST_SURRENDER_TIME_BETWEEN                             180.0
#define CONST_MISSION_TIME_SETUP_SECS                            90.0
#define CONST_PLAYER_END_GAME_DELAY                              10.0f
#define CONST_FINISH_END_MISSION_DELAY                           300.0
#define CONST_PRE_GUARDIAN_PHASE_START                           7110.0f
#define CONST_GUARDIAN_PHASE_START                               7200.0f
#define CONST_PRE_MATCH_FROZEN_TIME_SECS                         3.0f
#define CONST_LAST_MAN_STANDING_ACTIVITY_ID                      1909
#define CONST_REBORN_ACTIVITY_ID                                 1911
#define CONST_COME_BACK_ACTIVITY_ID                              1912
#define CONST_DOMINATION_ACTIVITY_ID                             1913
#define CONST_MAX_GENERAL_PHYSICAL_STAT                          180.0f
#define CONST_MAX_GENERAL_MAGICAL_STAT                           540.0f
#define CONST_MAX_GENERAL_DEFENSE_STAT                           228.0f
#define CONST_MAX_GENERAL_UTILITY_STAT                           318.0f
#define CONST_DOWN_TO_THE_WIRE_ACTIVITY_ID                       1914
#define CONST_TGGAME_ARENA_GOD_KILLS_PER_ESCORT                  10
#define CONST_LANE_PUSHER_BOT_ID                                 2004
#define CONST_NO_RESPAWN_TIME_SEC                                99
#define CONST_PVE_MISSION_SETUP_TIME_SECS                        65.0
#define CONST_AUTO_FORFEIT_TIME_SEC                              120.0f
#define CONST_SIEGE2_TIME_SETUP_SECS                             45.0
#define CONST_GT_LEVEL_GAINED                                    1
#define CONST_GT_DEATH                                           80
#define CONST_GT_HIGH_GOLD                                       79
#define CONST_GT_TARGETED                                        102
#define CONST_GT_LOW_HEALTH                                      103
#define CONST_GT_LOW_MANA                                        107
#define CONST_GT_USE_ABILITY                                     105
#define CONST_GT_USE_SKILLPOINT                                  104
#define CONST_GT_HIT_BASIC                                       106
#define CONST_GT_BASICS_TO_MISS                                  6
#define CONST_GT_MIN_REFRESH                                     300
#define CONST_TFT_ENEMY                                          10133
#define CONST_TFT_FRIENDLY                                       10132
#define CONST_LOW_PRIORITY_REMINDERS_SECS                        120.f
#define CONST_MIN_TIME_ON_TOP                                    5.f
#define CONST_GTT_HUD                                            10634
#define CONST_GTT_HUD_POPUP                                      10742
#define CONST_MAX_REPLICATED_TRANSACTIONS                        32
#define CONST_TG_SECOND_TRINKET_UPGRADE_LEVEL                    12
#define CONST_AOKUANG_KINGS_SWORD_MASK                           0x00000010
#define CONST_TGEGC_AWILIX_FIRST_STRIKE                          10953
#define CONST_BELLONA_SHIELD_SCOURGE_HEAL_SITUATIONAL            11067
#define CONST_BELLONA_SHIELD_BASH_BLOCK_SITUATIONAL              11065
#define CONST_HST_CP_CAST_STACK                                  10674
#define CONST_HST_CP_CAST_ACTIVE                                 10675
#define CONST_TGEGC_CUPID_HEARTBOMB                              11069
#define CONST_TGEGC_CUPID_HEARTBOMB_STUN                         11072
#define CONST_TGPAWN_NUWA_SNAKEKNOCKBACK_SITUATIONAL_TYPE        0
#define CONST_TG_NAV_ROUTE_INDICATOR_SPINDOWN_FX_ID              0
#define CONST_TG_NAV_ROUTE_INDICATOR_PATHING_FX_ID               2276
#define CONST_TG_NAV_ROUTE_INDICATOR_SPINUP_FX_ID                0
#define CONST_STINGER_EFFECT_GROUP_CATEGORY_CODE                 10714
#define CONST_STINGER_DEPLOYABLE_ID                              520
#define CONST_TGPAWN_AHPUCH_PASSIVE_ID                           11361
#define CONST_TGPAWN_AHPUCH_DEV3_SUB_ID                          11379
#define CONST_TGPAWN_AHPUCH_DEV4_SUB_ID                          11436
#define CONST_TGPAWN_AHPUCH_CORPSE_EX_CAP                        6
#define CONST_TGEGC_AHPUCH_PASSIVE_HEAL                          11142
#define CONST_TGEGC_AHPUCH_DEV3_DOT                              11103
#define CONST_TGEGC_AHPUCH_DEV3_STUN                             11107
#define CONST_TGPAWN_AOKUANG_CHARGE_COST                         25.0f
#define CONST_TGPAWN_APHRODITE_KISS_SUB_ID                       8791
#define CONST_TGPID_TGPAWN_APOLLO_SKYJUMP_SUB_ID                 8813
#define CONST_TGPID_TGPAWN_APOLLO_SKYJUMP_KNOCKBACK_SUB_ID       8810
#define CONST_TGPID_TGPAWN_APOLLO_CHARGE_SUB_ID                  8784
#define CONST_TGPID_TGPAWN_APOLLO_CHARIOT_ID                     3502
#define CONST_TGPID_TGPAWN_APOLLO_CHARIOT_SOUNDFX_ID             2627
#define CONST_TGPID_TGPAWN_APOLLO_PASSIVE_FX_START_ID            2631
#define CONST_TGPID_TGPAWN_APOLLO_PASSIVE_FX_WRIST_ID            2630
#define CONST_TGPID_TGPAWN_APOLLO_SKYJUMP_BEAM_FX_ID             2638
#define CONST_TGPID_TGPAWN_APOLLO_AGENT_SKIN_ID                  10233
#define CONST_TGPID_TGPAWN_APOLLO_AGENT_FUSELAGE_ID              4603
#define CONST_TGEGC_ARACHNE_WRAP                                 10901
#define CONST_TGEGC_ARACHNE_COCOON                               10889
#define CONST_TGEGC_ARACHNE_FANGS                                10888
#define CONST_TGPM_REMEMBER_PLAYER_ATTACKED_TIME                 4
#define CONST_TGPID_ARES_SPEED_EFFECT_GROUP_CATEGORY             10444
#define CONST_TGPID_ARES_SLOW_EFFECT_GROUP_CATEGORY              10445
#define CONST_TGPID_ARES_SHACKLE_DOT_EFFECT_GROUP_CATEGORY       10572
#define CONST_ARES_SHACKLE_MAXIMUM_DISTANCE                      65.0f
#define CONST_ARES_TETHER_MAXIMUM_DISTANCE                       150.0f
#define CONST_TGPAWN_ARTEMIS_RECON_SKIN_ID                       12786
#define CONST_TGPID_BOAR_CHARGE_SUB_ID                           8136
#define CONST_TGPAWN_TOWER_SIDE_COUNT                            4
#define CONST_TGPAWN_ATHENA_STRIKE_FX                            2761
#define CONST_TGPAWN_ATHENA_STRIKE_FX_SKN2                       3753
#define CONST_TGPAWN_ATHENA_LEAPING_LUNGE_SUB_ID                 8890
#define CONST_TGPAWN_ATHENA_PASSIVE_ID                           8958
#define CONST_TGPAWN_ATHENA_ULT_SHOOTER_ID                       8972
#define CONST_TGPAWN_ATHENA_ULT_EXPLOSION_SUB_ID                 8932
#define CONST_TGPAWN_ATHENA_ALL_OUT_FRIENDLY_REFLECT_DAMAGE_SUB_ID 8942
#define CONST_TGEGC_AWILIX_MOUNT_BUFF                            10959
#define CONST_TGPAWN_BACCHUS_DRUNK_MODE_NUM                      3
#define CONST_TGPAWN_BACCHUS_THIRSTY_MIN                         0.0f
#define CONST_TGPAWN_BACCHUS_TIPSY_MIN                           30.0f
#define CONST_TGPAWN_BACCHUS_SMASHED_MIN                         60.0f
#define CONST_TGPAWN_BACCHUS_THIRSTY_FX_ID                       2316
#define CONST_TGPAWN_BACCHUS_TIPSY_FX_ID                         2317
#define CONST_TGPAWN_BACCHUS_SMASHED_FX_ID                       2318
#define CONST_TGPAWN_BACCHUS_BELCH_CONE_FX_ID                    2312
#define CONST_TGPAWN_BACCHUS_BELCH_SHAKE_FX_ID                   7472
#define CONST_TGPID_TRUE_DAMAGE_SUB_ID                           8188
#define CONST_TGPAWN_CABRAKAN_DEV2_MESH_ID                       4743
#define CONST_TGPAWN_CABRAKAN_DEV2_MESH_B_ID                     4817
#define CONST_TGPAWN_CABRAKAN_DEV1_STUN_CODE                     10880
#define CONST_TGPAWN_CAMAZOTZ_MESH_ID                            6899
#define CONST_TGPAWN_CAMAZOTZ_A04_IDb                            13505
#define CONST_TGPAWN_CAMAZOTZ_A04_IDa                            13509
#define CONST_TGPAWN_CAMAZOTZ_A03_ID                             13562
#define CONST_TGPAWN_CAMAZOTZ_A02_IDc                            13573
#define CONST_TGPAWN_CAMAZOTZ_A02_IDb                            13568
#define CONST_TGPAWN_CAMAZOTZ_A02_IDa                            13560
#define CONST_TGPAWN_CAMAZOTZ_A01_IDb                            13395
#define CONST_TGPAWN_CAMAZOTZ_A01_IDa                            13391
#define CONST_TGPAWN_CAMAZOTZ_Psv_ID                             13389
#define CONST_TGPAWN_CAMAZOTZ_DISABLED_SITUATIONAL_TYPE          15204
#define CONST_TGPAWN_MONSTER_IDLE_SITUATIONALTYPE                11040
#define CONST_TGPAWN_CHAAC_NUM1_PROJECTILE_EFFECTS_DEVICE_ID     9542
#define CONST_TG_PAWN_CHANGE_BUNNY_DEATH_MESH_ID                 3708
#define CONST_TG_PAWN_CHANGE_AVOID_HEAL_FX_ID                    2935
#define CONST_TG_PAWN_CHANGE_RABBIT_TELEPORT_FX                  2900
#define CONST_TGPAWN_CHIRON_INHAND_ID                            11974
#define CONST_TGPAWN_CHIRON_TRAINING_EXERCISE_ID                 11944
#define CONST_TGPAWN_CHIRON_SPREADSHOT_ID                        11959
#define CONST_TGPAWN_CHIRON_SPREADSHOT_SHOOTER_ID                12020
#define CONST_TGPAWN_CHIRON_CHARGE_LONG_ID                       11983
#define CONST_TGPAWN_CHIRON_ULTIMATE_ID                          11990
#define CONST_TGPAWN_CHIRON_ULTIMATE_SHOOTER_ID                  12022
#define CONST_TGPAWN_CHIRON_PASSIVE_ID                           12034
#define CONST_TGPAWN_CHIRON_REVIVE_FX_ID                         7702
#define CONST_TGPID_TGPAWN_CHRONOS_REWIND_MESH_ID                3653
#define CONST_TGPID_TGPAWN_CHRONOS_REWIND_FX_ID                  2819
#define CONST_TGPID_TGPAWN_CHRONOS_PHASESHIFT_MESH_ID            3654
#define CONST_TGPID_TGPAWN_CHRONOS_BASIC_ATTACK_LINK_FX_ID       2820
#define CONST_TGPID_TGPAWN_CHRONOS_HASTEN_WING_FX_ID             2889
#define CONST_TGPID_TGPAWN_CHRONOS_PHASESHIFT_CHARGED_FX_1_ID    0
#define CONST_TGPID_TGPAWN_CHRONOS_PHASESHIFT_CHARGED_FX_2_ID    0
#define CONST_TGPID_TGPAWN_CHRONOS_PHASESHIFT_MANA_QUADRANT      1
#define CONST_TG_PAWN_CHRONOS_HIT_SITUATIONAL_QUAD               10662
#define CONST_TG_PAWN_CHRONOS_HIT_SITUATIONAL_QUAD01             10663
#define CONST_TG_PAWN_CHRONOS_HIT_SITUATIONAL_QUAD02             10664
#define CONST_TG_PAWN_CHRONOS_HIT_SITUATIONAL_QUAD03             10665
#define CONST_TGPID_TIMED_BOMB_SUB_ID                            8226
#define CONST_TGPID_TIMED_BOMB_INSTANT_EFFECT_GROUP_ID           29621
#define CONST_LoveStruckCounterMax                               8
#define CONST_COOLDOWN_DEPLOY_ID                                 466
#define CONST_SPEED_DEPLOY_ID                                    464
#define CONST_MANA_DEPLOY_ID                                     463
#define CONST_DAMAGE_DEPLOY_ID                                   465
#define CONST_HEALTH_DEPLOY_ID                                   468
#define CONST_PROTECTION_DEPLOY_ID                               467
#define CONST_ATTACKSPD_DEPLOY_ID                                727
#define CONST_MOVESPD_DEPLOY_ID                                  729
#define CONST_BIG_DAMAGE_DEPLOY_ID                               952
#define CONST_BIG_MANA_DEPLOY_ID                                 953
#define CONST_TALARIA_BUFF_DEPLOY_ID                             969
#define CONST_TGPAWN_DOM_CYCLOPS_DAMAGE_TEAM_BUFF_ID             13023
#define CONST_TGPAWN_DOM_CYCLOPS_SPEED_TEAM_BUFF_ID              13024
#define CONST_TGPAWN_DOM_CYCLOPS_ATTACK_TEAM_BUFF_ID             13025
#define CONST_ELEMENTAL_DEPLOY_ID                                836
#define CONST_FAFNIR_DRAGON_MESH                                 6505
#define CONST_TGPID_TGPAWN_FENRIR_MAUL_BONUS_DMG_SUB_ID          8911
#define CONST_TGPID_TGPAWN_FENRIR_MAUL_DAMAGE_SUB_ID             8838
#define CONST_TGPID_TGPAWN_FENRIR_BITE_FX_ID                     2725
#define CONST_TGPID_TGPAWN_FENRIR_BITE_INHAND_ID                 8823
#define CONST_TGPID_TGPAWN_FENRIR_HOWL_AOE_SUB_ID                8888
#define CONST_TGPID_TGPAWN_FENRIR_HOWL_MESH_ID                   3582
#define CONST_TGPID_TGPAWN_FENRIR_HOWL_FX_HAND_ID                2722
#define CONST_TGG72_SITUATIONAL_A1                               11315
#define CONST_TGG72_SITUATIONAL_A2                               11316
#define CONST_TGG72_SITUATIONAL_A3                               11317
#define CONST_TGG72_SITUATIONAL_A1_INIT                          11340
#define CONST_TGG72_SITUATIONAL_A2_INIT                          11341
#define CONST_TGG72_SITUATIONAL_A3_INIT                          11342
#define CONST_TGG72_SITUATIONAL_A1_PER                           11350
#define CONST_TGG72_SITUATIONAL_A2_PER                           11351
#define CONST_TGG72_SITUATIONAL_A3_PER                           11352
#define CONST_TGEGC_G72_CHARGE                                   11322
#define CONST_TGEGC_G72_PASSIVE                                  11323
#define CONST_TGEGC_G72_PASSIVE_STACK                            11324
#define CONST_TGEGC_G72_PASSIVE_COUNT                            11327
#define CONST_G72_MAX_PASSIVE_TARGETS                            3
#define CONST_TGPAWN_GUANYUV2_WARHORSE_ID                        3674
#define CONST_TGPAWN_GUAN_YU_V2_ULT_SHOOTER_ID                   9189
#define CONST_TGPAWN_GUAN_YU_V2_ULT_DISMOUNT_ID                  9193
#define CONST_MAX_POWER_LEVEL                                    15
#define CONST_TGPID_DEVOUR_SOULS_SUB_ID                          7477
#define CONST_TGPID_CLOUD_FX_ID                                  1763
#define CONST_TGPAWN_HEL_RESTORATION_REBOUND_FX_ID               3236
#define CONST_TGPAWN_HERCULES_PUNCH_KNOCKBACK_BUFF_DIST          320.0f
#define CONST_TGPAWN_HERCULES_BOULDER_THROWER_ID                 8501
#define CONST_TGPAWN_HERCULES_BOULDER_MESH_ID                    3396
#define CONST_TGPAWN_HERCULES_BOULDER_ERUPTION_MESH_ID           3362
#define CONST_TGPAWN_HERCULES_BOULDER_CC_PROTECTION_ID           8616
#define CONST_TGPAWN_HOUYI_DEV3_SUBDEVICE_ID                     10993
#define CONST_TGPAWN_HOUYI_PASSIVE_EFFECT_GROUP_ID               39294
#define CONST_TGEGC_HOUYI_STIM                                   11019
#define CONST_TGPID_TGPAWN_ISIS_DISPELMAGIC_FX_ID                2758
#define CONST_TGPID_TGPAWN_ISIS_DISPELMAGIC_WARMUP_FX_ID         2771
#define CONST_TGEGC_BITING_STRIKE                                15147
#define CONST_TGEGC_BITING_STRIKE_SELF                           15148
#define CONST_TGEGC_IZANAMI_STEALTH                              15159
#define CONST_TGEGC_IZANAMI_ICY_GRASP                            15171
#define CONST_TGEGC_IZANAMI_SLOW                                 15182
#define CONST_IZANAMI_BITING_STRIKE_PAC_MESH                     6963
#define CONST_TGPAWN_JING_WEI_DEATH_ID                           6517
#define CONST_TGPAWN_JING_WEI_BOW_MESH_ID                        6493
#define CONST_TGPAWN_JING_WEI_DEV_4_PROXY_FX_ID                  8380
#define CONST_TGPAWN_JING_WEI_DEV_1_TWEEN_DURATION               0.25f
#define CONST_TGPAWN_JING_WEI_DEV_1_OFFSET_HEIGHT                15.0f
#define CONST_TGPAWN_JINGWEI_OFFHAND4_LANDING_ID                 12865
#define CONST_TGPAWN_JINGWEI_OFFHAND4_ID                         13261
#define CONST_TGPAWN_JINGWEI_OFFHAND3_ID                         12764
#define CONST_TGPAWN_JINGWEI_OFFHAND2_ID                         12767
#define CONST_TGPAWN_JINGWEI_OFFHAND1_ID                         12763
#define CONST_TGPAWN_JINGWEI_PASSIVE_SUB_ID                      12769
#define CONST_TGPAWN_JINGWEI_PASSIVE_ID                          12766
#define CONST_TGPAWN_JINGWEI_SUPER_INHAND_ID                     12894
#define CONST_TGPAWN_JINGWEI_INHAND_ID                           12765
#define CONST_PUSHER_PING_INTERVAL                               3.0f
#define CONST_KALDR_DAMAGE_HISTORY_COUNT                         16
#define CONST_TGEGC_KALDR_HEAL                                   11411
#define CONST_TGEGC_KALDR_BUFF                                   11414
#define CONST_TGPAWN_KALIV2_BLOODLASH_MESH_ID                    4002
#define CONST_TGPAWN_KALIV2_ULTIMATE_MESH_ID                     4001
#define CONST_TGPAWN_KALI_MARKED_MAX                             2
#define CONST_TGPAWN_KALI_MARKED_SITUATIONALTYPE                 10911
#define CONST_TGPAWN_KALI_MARKED_LOWHEALTH_SITUATIONALTYPE       10912
#define CONST_TGPAWN_KALI_MARKED_NOTIFY_SITUATIONALTYPE          15267
#define CONST_TGEGC_KHEPRI_OFFHAND01                             11236
#define CONST_REVIVE_FX_ID                                       6725
#define CONST_REVIVE_MESH_ID                                     5755
#define CONST_TGPID_KUKULKAN_ULTIMATE_KNOCKBACK_SUB_ID           7989
#define CONST_TGPID_LOKI_STIM_SUB_ID                             8465
#define CONST_LOKI_EXTRA_DEATH_MESH_ID                           5780
#define CONST_TGPAWN_MEDUSA_STONE_MATERIAL_FX_ID                 7200
#define CONST_TGPAWN_MEDUSA_TGEGC_OFFHAND1_BUFF                  11106
#define CONST_TGPAWN_MEDUSA_SITUATIONAL_NUM3_HIT                 11074
#define CONST_TGPAWN_MEDUSA_SITUATIONAL_NUM3_SELF                11075
#define CONST_TGPAWN_MERCURY_NUM1_SUBDEVICE_ID                   9267
#define CONST_TGPAWN_MERCURY_NUM1_DEPLOYABLE_ID                  499
#define CONST_TGPAWN_MERCURY_SITUATIONAL_NUM3_HIT_TARGET         10688
#define CONST_TGPAWN_MERCURY_SITUATIONAL_NUM3_THROW              10690
#define CONST_TGPAWN_MERCURY_SITUATIONAL_NUM3_SELF_EFFECTS       10691
#define CONST_TGPAWN_MERCURY_WHIRLWIND_TARGETER_FX_ID            0
#define CONST_TGPAWN_MERCURY_ULT_SHOOTER_ID                      9222
#define CONST_TGPAWN_MERCURY_ULT_DEPLOYABLE_ID                   494
#define CONST_TGPAWN_MERCURY_ULT_DEPLOYABLE_ID01                 495
#define CONST_TGPAWN_MERCURY_ULT_DEPLOYABLE_ID02                 496
#define CONST_TGPAWN_MERCURY_ULT_DEPLOYABLE_ID03                 497
#define CONST_TGPAWN_MERCURY_ULT_DEPLOYABLE_ID04                 498
#define CONST_TGPAWN_MERCURY_NUM4_SUBDEVICE_ID                   9307
#define CONST_TGPAWN_MERCURY_SONICBOOM_FX                        3226
#define CONST_TGPAWN_MERCURY_RUNEXE_SONICBOOM_FX                 4714
#define CONST_TGPAWN_NEITH_ULT_WEAPON_ID                         8673
#define CONST_TGPID_TGPAWN_NEZHA_ULT_POSTPROCESS_RES_ID_SKIN2    24083
#define CONST_TGPID_TGPAWN_NEZHA_ULT_POSTPROCESS_RES_ID_DIAMOND  24082
#define CONST_TGPID_TGPAWN_NEZHA_ULT_POSTPROCESS_RES_ID          24081
#define CONST_TGPID_TGPAWN_NEZHA_SASH_PAC_MESH_ID                6293
#define CONST_TGPID_TGPAWN_NEZHA_LOTUS_MESH_ID                   3566
#define CONST_TGPID_TGPAWN_NEZHA_SASH_MESH_ID                    6157
#define CONST_TGPID_TGPAWN_NEZHA_WINDFIRE_QTE_SUB_ID             8843
#define CONST_TGPID_TGPAWN_NEZHA_WINDFIRE_LANDED_BLAST_FX_ID     2698
#define CONST_TGPID_TGPAWN_NEZHA_WINDFIRE_LANDED_BLAST_SUB_ID    8803
#define CONST_TGPID_TGPAWN_NEZHA_WINDFIRE_KNOCK_DOWN_SUB_ID      8805
#define CONST_TGPID_TGPAWN_NEZHA_WINDFIRE_AIR_DASH_SUB_ID        8804
#define CONST_TGPID_TGPAWN_NEZHA_WINDFIRE_HIT_COUNT              3
#define CONST_TGPID_TGPAWN_NEZHA_SASH_AOE_BLAST_SUB_ID           8806
#define CONST_TGPAWN_NIKE_PASSIVE_ONE_GOAL_SITUATIONAL_TYPE      15242
#define CONST_TGPAWN_NIKE_PASSIVE_TWO_GOALS_SITUATIONAL_TYPE     15243
#define CONST_TGPAWN_NIKE_PASSIVE_THREE_GOALS_SITUATIONAL_TYPE   15244
#define CONST_TGPAWN_NIKE_Psv_ID                                 13656
#define CONST_TGPANW_NIKE_A04_STIMMED_SHIELD_SITUTAIONAL_TYPE    15299
#define CONST_TGPAWN_NIKE_A01_ID                                 13684
#define CONST_TGPAWN_NIKE_A02_ID                                 13647
#define CONST_TGPAWN_NIKE_A03_ID                                 13682
#define CONST_TGPAWN_NIKE_A04_ID                                 13649
#define CONST_TGPAWN_NIKE_ULT_WINGS_MESH_ID                      7299
#define CONST_TGPANW_NIKE_A04_BASIC_SHIELD_SITUTAIONAL_TYPE      15298
#define CONST_TGPAWN_NIKE_A02_A04_COMBO_SITUATIONAL_TYPE         15288
#define CONST_TGPAWN_NIKE_A02_A03_COMBO_SITUATIONAL_TYPE         15287
#define CONST_TGPAWN_NIKE_A02_A01_COMBO_SITUATIONAL_TYPE         15286
#define CONST_NOX_PASSIVE_CANDLE_COUNT                           4
#define CONST_NOX_PASSIVE_CANDLE_FX_ID                           5250
#define CONST_NOX_PASSIVE_CANDLE_FX_ID01                         8771
#define CONST_NOX_PASSIVE_CANDLE_FX_ID02                         8772
#define CONST_NOX_PASSIVE_CANDLE_FX_ID03                         8773
#define CONST_NOX_PASSIVE_MAX_FX_ID                              5252
#define CONST_NOX_BIRD_DEATH_MESH_ID                             5058
#define CONST_NOX_TGEGC_ULT_CATEGORY_CODE                        10940
#define CONST_NOX_TGEGC_DEV1_SHIELD_CATEGORY_CODE                10950
#define CONST_NOX_ULT_LINK_MESH_ID                               5047
#define CONST_NOX_ULT_LINK_WARNING_DIST                          20
#define CONST_NOX_ULT_MAX_LINK_TARGETS                           3
#define CONST_NOX_ULT_HIT_1_SITUATIONAL                          11255
#define CONST_NOX_ULT_HIT_2_SITUATIONAL                          11256
#define CONST_NOX_ULT_HIT_3_SITUATIONAL                          11257
#define CONST_TGPAWN_NUWA_MAX_CRYSTAL_EVENTS                     16
#define CONST_TGPAWN_NUWA_AOEINHAND_DEV_ID                       9455
#define CONST_TGPAWN_NUWA_SNAKE_MESH_ID                          4078
#define CONST_TGPID_TGPAWN_ODIN_GUNGNIRS_MIGHT_SUB_ID            9264
#define CONST_TGEGC_ODIN_RING                                    10887
#define CONST_OSIRIS_ULT_PASSIVE_TIMER                           8.0f
#define CONST_OSIRIS_MAX_PASSIVE_TIMER                           6.0f
#define CONST_OSIRIS_TETHER_FX                                   4064
#define CONST_OSIRIS_TETHER_MESH                                 4376
#define CONST_OSIRIS_TETHER_MAXIMUM_DISTANCE                     35.0f
#define CONST_TGPID_OSIRIS_TETHER_DOT_EFFECT_GROUP_CATEGORY      10793
#define CONST_OSIRIS_PASSIVE_LOSS_FX                             3850
#define CONST_OSIRIS_PASSIVE_MESH                                4389
#define CONST_TGPAWN_POSEIDON_TRIDENT_ID                         8765
#define CONST_TGPAWN_POSEIDON_TRIDENT_SPLITS_ID                  8699
#define CONST_TGPAWN_POSEIDON_FEET_FX_ID                         2522
#define CONST_TGPID_DivineLightDetonationDeviceID                7692
#define CONST_TGPID_DivineLightBlindDetonationItemID             7703
#define CONST_TGPID_DivineLightSlowDetonationItemID              7697
#define CONST_TGPAWN_RAIJIN_INHAND_ID                            12349
#define CONST_TGPAWN_RAIJIN_PASSIVE_ID                           12348
#define CONST_TGPAWN_RAIJIN_OFFHAND1_ID                          12652
#define CONST_TGPAWN_RAIJIN_OFFHAND2_ID                          12351
#define CONST_TGPAWN_RAIJIN_OFFHAND3_ID                          12352
#define CONST_TGPAWN_RAIJIN_OFFHAND4_ID                          12353
#define CONST_TGPAWN_RAIJIN_OFFHAND2_SUB_ID                      12609
#define CONST_TGPAWN_RAIJIN_KOTO_DRUMS_ID                        12657
#define CONST_TGPAWN_RAIJIN_OFFHAND4_BEAT1_ID                    12656
#define CONST_TGPAWN_RAIJIN_OFFHAND4_BEAT2_ID                    12638
#define CONST_TGPAWN_RAIJIN_OFFHAND4_BEAT3_ID                    12639
#define CONST_TGPAWN_RAIJIN_PASSIVE_EFFECT_GROUP_ID              42893
#define CONST_TGPAWN_RAIJIN_OFFHAND2_WARNING_DEPLOYABLE          856
#define CONST_TGPAWN_RAIJIN_OFFHAND3_WARNING_DEPLOYABLE          835
#define CONST_TGPAWN_RAIJIN_RAIJUU_MESH_ID                       6307
#define CONST_TGPAWN_RAIJIN_RAIJUU_BELLYBUTTON_FX_ID             8135
#define CONST_TGPAWN_RAIJIN_DRUM_CHARGED_FX_ID                   8154
#define CONST_TGPAWN_RAIJIN_THUNDER_CRASH_BURST_FX               8245
#define CONST_QuiverMaxAmmoCount                                 5
#define CONST_TGPAWN_RAM_OFFHAND3_TARGETTER_FX                   4421
#define CONST_TGPAWN_RAM_OFFHAND1_TARGETTER_FX                   4422
#define CONST_TGPAWN_RAM_IGNORE_INHAND_SLOW_TIME                 5.0f
#define CONST_TGPAWN_RAM_ULT_PROP_MESH_ID                        6337
#define CONST_TGPAWN_RAM_ULT_WEAPON_ID                           10115
#define CONST_TGPAWN_RAM_ULT_MARK_MAX                            3
#define CONST_TGPAWN_RAM_ULT_MARK_ID                             10117
#define CONST_TGPAWN_RATATOSKR_ULT_TARGET_XSEC_SITUATIONAL       11160
#define CONST_TGPAWN_RATATOSKR_ULT_TARGET_SITUATIONAL            11158
#define CONST_TGPAWN_RATATOSKR_ULT_SELF_SITUATIONAL              11157
#define CONST_TGPAWN_RATATOSKR_TOPAZ_SITUATIONAL                 11190
#define CONST_TGPAWN_RATATOSKR_OPAL_SITUATIONAL                  11189
#define CONST_TGPAWN_RATATOSKR_SAPPHIRE_SITUATIONAL              11188
#define CONST_TGPAWN_RATATOSKR_EMERALD_SITUATIONAL               11183
#define CONST_TGPAWN_RATATOSKR_YELLOW_SITUATIONAL                11139
#define CONST_TGPAWN_RATATOSKR_BLUE_SITUATIONAL                  11138
#define CONST_TGPAWN_SCYLLA_TENTACLE_BUDDY_MESH_ID               4260
#define CONST_TGPAWN_SCYLLA_ULTIMATE_LAUGH_FX_ID                 3866
#define CONST_TGPAWN_SCYLLA_TENTACLE_MESH_ID                     4296
#define CONST_SOBEK_PASSIVE_EFFECT_GROUP_CATEGORY_CODE           10919
#define CONST_TGPAWN_SOBEK_SITUATIONAL_ULT_IMMUNITY              10676
#define CONST_TGPAWN_SOBEK_SICKENINGSTRIKE_MESH_ID               3736
#define CONST_TGPAWN_SOBEK_PASSIVE_BLESSING_MAX_LIFE             4
#define CONST_TGPAWN_SUNWUKONG_DECOY_RETURN_PROJ_ID              411
#define CONST_TGPAWN_SUSANO_PASSIVE_MAX                          4
#define CONST_TGPAWN_SUSANO_TELEPORT_FX_ID                       8658
#define CONST_TGPAWN_SUSANO_OFFHAND1_COMBO_SIZE                  3
#define CONST_TGPAWN_SUSANO_OFFHAND1_P1_ID                       12813
#define CONST_TGPAWN_SUSANO_OFFHAND1_P2_ID                       12814
#define CONST_TGPAWN_SUSANO_OFFHAND1_P3_ID                       12812
#define CONST_TGPAWN_SUSANO_OFFHAND3_ID                          12869
#define CONST_TGPAWN_SUSANO_DEATH_ID                             6568
#define CONST_SYLVANUS_PULL_BEAM_FX_ID                           7429
#define CONST_BLOOM_EFFECT_GROUP_CATEGORY_CODE                   10905
#define CONST_TGPAWN_TERRA_DEV4_EFFECT_COUNT                     5
#define CONST_TGPAWN_TERRA_SHATTER_EXTEND_PASSIVE_TIME           3
#define CONST_TGPAWN_TERRA_PASSIVE_ID                            13149
#define CONST_TGPAWN_TERRA_SHATTER_ID                            13150
#define CONST_TGPAWN_TERRA_DEV3_SHATTER_ID                       13160
#define CONST_TGPAWN_TERRA_DEV4_DETONATE_ID                      13332
#define CONST_TGPAWN_TERRA_WARDSTONE_MESH_ID                     6897
#define CONST_TGPAWN_TERRA_SPIKE_ARMOR_MESH_ID                   6860
#define CONST_TGPAWN_TERRA_DEATH_ID                              6904
#define CONST_TGEGC_THANATOS_PASSIVE_HEAL                        11159
#define CONST_TGPAWN_THANATOS_HARVESTER_SITUATION_GOD            10684
#define CONST_TGPAWN_THANATOS_HARVESTER_SITUATION_OTHER          0
#define CONST_TGPAWN_THANATOS_HARVESTER_BALLMESH_GOD_ID          3852
#define CONST_TGPAWN_THANATOS_HARVESTER_BALLMESH_OTHER_ID        3853
#define CONST_TGPAWN_THANATOS_HARVESTER_POOF_FX_ID               3156
#define CONST_TGPAWN_THANATOS_HARVESTER_SOUND_FX_ID              3175
#define CONST_TGPAWN_THANATOS_LOW_HEALTH_FX_ID                   3174
#define CONST_TGPAWN_THANATOS_HARVESTER_FX_MAX                   16
#define CONST_TGPAWN_THANATOS_EXECUTION_MAX                      16
#define CONST_TGPAWN_THANATOS_EXECUTION_GOD_FX_ID                3184
#define CONST_TGPAWN_THANATOS_EXECUTION_OTHER_FX_ID              3201
#define CONST_TGPAWN_THANATOS_HOVERINGDEATH_STRIKE_DEV_ID        9237
#define CONST_TGPAWN_THANATOS_SCENTOFDEATH_DEV_ID                9229
#define CONST_TGPAWN_THANATOS_FLAPUP_TIME                        0.802f
#define CONST_TGPAWN_THANATOS_FLAPDOWN_TIME                      1.196f
#define CONST_TGPAWN_THANATOS_EXECUTE_LAUGH_FX                   3208
#define CONST_TGPAWN_THANATOS_ULT_POSTPROCESS_RES_ID             24080
#define CONST_THOR_HAMMER_SPIN_FXID                              2229
#define CONST_TGEGC_OBELISK_SHIELD                               15164
#define CONST_TGPAWN_TYR_D_BASIC_ATTACK_ID                       9088
#define CONST_TGPAWN_TYR_D_3_SUB_ID                              9031
#define CONST_TGPAWN_TYR_D_4_SUB_ID                              9152
#define CONST_TGPAWN_TYR_D_2_SUB_ID                              9029
#define CONST_TGPAWN_TYR_D_1_STAGE3_SUB_ID                       9030
#define CONST_TGPAWN_TYR_D_1_STAGE2_SUB_ID                       9028
#define CONST_TGPAWN_TYR_D_1_STAGE1_SUB_ID                       9027
#define CONST_TGPAWN_TYR_D_1_SUB_ID                              9026
#define CONST_TGPAWN_TYR_A_1_STAGE3_SUB_ID                       9007
#define CONST_TGPAWN_TYR_A_1_STAGE2_SUB_ID                       9006
#define CONST_TGPAWN_ULLR_AP_MELEE                               9920
#define CONST_TGPAWN_ULLR_A4_MELEE                               9801
#define CONST_TGPAWN_ULLR_A3_MELEE                               9887
#define CONST_TGPAWN_ULLR_A2_MELEE                               9917
#define CONST_TGPAWN_ULLR_A1_MELEE                               9891
#define CONST_UllrReloadSpecialFXID                              3988
#define CONST_TGPAWN_ULLR_MELEE_ANIMSET_RES_ID                   15380
#define CONST_TGPAWN_ULLR_STANCE_COOLDOWN_TIME                   1.00f
#define CONST_TGPAWN_ULLR_BOW_MESH_ID                            4343
#define CONST_TGPAWN_ULLR_MELEE_WEAPON_ID                        9789
#define CONST_TGPID_TGPAWN_ULLR_LEAP_AOE_BLAST_SUB_ID            9874
#define CONST_VamanaGiantScaleMultiplier                         3.76f
#define CONST_TGPID_SPLIT_PROJECTILE_DEVICE_ID                   8523
#define CONST_TGPID_RAINING_DARTS_SUB_DEVICE_ID                  8532
#define CONST_TGPID_RAINING_POISON_DARTS_SUB_DEVICE_ID           8576
#define CONST_TGPID_APOCALYPSE_SHROUD_STUN_SUB_DEVICE_ID         8536
#define CONST_TGPID_BOLA_POWER_GLOW_FX_ID                        2893
#define CONST_TGPAWN_XINGTIAN_PASSIVE_BUFF_SITUATIONAL           11283
#define CONST_TGPAWN_XINGTIAN_PASSIVE_BUFF_ID                    41566
#define CONST_TGDEVICE_XINGTIAN_ENRAGED_SITUATIONAL              11274
#define CONST_TGDEVICE_XINGTIAN_ULTSWEEP_ID                      11823
#define CONST_TGDEVICE_XINGTIAN_SKYCUTTINGAXE_ID                 13553
#define CONST_YMIR_CACODEMON_SHARDS_ID                           3286
#define CONST_YMIR_OBSIDIANSHARD_SHARDS_ID                       3737
#define CONST_YMIR_DIGIMIR_SHARDS_ID                             3641
#define CONST_YMIR_NUCLEAR_SHARDS_ID                             4625
#define CONST_YMIR_SHARDS_EXPLOSION_ID                           5245
#define CONST_TGPAWN_ZEUS_DETONATE_SUB_FX_ID                     8637
#define CONST_TGEGC_ZEUS_DEV3_DISARM                             11275
#define CONST_TGPAWN_ZHONGKUI_SCROLL_MESH_ID                     3720
#define CONST_TGPAWN_ZHONGKUI_SCROLL_DEV_ID                      9151
#define CONST_TGPAWN_ZHONGKUI_FIERCEGLARE_HEAL_SUB_ID            9172
#define CONST_TGPAWN_ZHONGKUI_FIERCEGLARE_MESH_ID                3724
#define CONST_TGPAWN_ZHONGKUI_FIERCEGLARE_POOF_FX_ID             3029
#define CONST_TGPAWN_ZHONGKUI_FIERCEGLARE_MAX                    16
#define CONST_TGPAWN_ZHONGKUI_MARKED_SITUATIONAL_TYPE            10680
#define CONST_TGPAWN_ZHONGKUI_BAGMORPH_CURVE_MAX                 10
#define CONST_TGPAWN_ZHONGKUI_RECALLDEMON_SHOTS                  5
#define CONST_PROJECTILE_LINE_TRACE_DISTANCE                     32
#define CONST_TG_ANHUR_SPACE_SKIN                                11603
#define CONST_TGPROJ_HERCULES_BOULDER_MESH_HEIGHT                -20.0f
#define CONST_TGPROJ_HERCULES_BOULDER_GROUNDHIT_FX_ID            2363
#define CONST_MaxHitsPerJumongFanOfArrows                        3
#define CONST_TGPROJ_NEITH_WORLDWEAVER_TARGET_FX_ID              2546
#define CONST_TGPROJ_NEITH_WORLDWEAVER_TARGET_HIT_SOUND_FX_ID    2568
#define CONST_TGPT_FLOAT                                         137
#define CONST_TGPT_INT                                           176
#define CONST_TGPT_COMBO                                         503
#define CONST_TGPID_PROJECTILE_SPEED                             46
#define CONST_TGPID_DAMAGE_RADIUS                                6
#define CONST_TGPID_REMOTE_ACTIVATION_TIME                       7
#define CONST_TGPID_PROXIMITY_DISTANCE                           8
#define CONST_TGPID_REMOTE_ACQUIRE_DISTANCE                      47
#define CONST_TGPID_CONE_ATTACK_ANGLE                            64
#define CONST_TGPID_CONE_ATTACK_ANGLE_OFFSET                     1627
#define CONST_TGPID_EFFECTIVE_RADIUS                             343
#define CONST_TGPID_MINIMUM_RADIUS                               1048
#define CONST_TGPID_FIRE_LOCK_TIME                               437
#define CONST_TGPID_ACCURACY                                     10
#define CONST_TGPID_ACCURACY_CROUCH                              249
#define CONST_TGPID_ACCURACY_SPRINT                              246
#define CONST_TGPID_ACCURACY_WALK                                245
#define CONST_TGPID_ACCURACY_AIM_MODE_BONUS                      250
#define CONST_TGPID_ACCURACY_CORRECTION_RATE                     247
#define CONST_TGPID_ACCURACY_CORRECTION_RATE_CROUCH              248
#define CONST_TGPID_ACCURACY_LOSS_MAX                            253
#define CONST_TGPID_ACCURACY_LOSS_ON_JUMP                        251
#define CONST_TGPID_ACCURACY_LOSS_ON_SHOOT                       252
#define CONST_TGPID_SCOPE_POWER                                  259
#define CONST_TGPID_LOCK_TARGET_TIME                             446
#define CONST_TGPID_GROUND_SPEED                                 49
#define CONST_TGPID_NO_BACKPEDAL_PENALTY                         1524
#define CONST_TGPID_HEALTH_MAX_MODIFIER                          412
#define CONST_TGPID_RANGE                                        5
#define CONST_TGPID_MIN_RANGE                                    48
#define CONST_TGPID_FLIGHT_ACCELERATION                          59
#define CONST_TGPID_KNOCKBACK                                    60
#define CONST_TGPID_KNOCKDOWN                                    164
#define CONST_TGPID_KNOCKUP                                      1019
#define CONST_TGPID_KNOCKSTRAIGHTUP                              1435
#define CONST_TGPID_KNOCKUP_TIMED                                1622
#define CONST_TGPID_KNOCKSTRAIGHTUP_TIMED                        1767
#define CONST_TGPID_KNOCKBACK_PLUS_GRAVITY                       1507
#define CONST_TGPID_KNOCKBACK_MINION                             1510
#define CONST_TGPID_KNOCKBACK_SPECIAL_DELIVERY                   1695
#define CONST_TGPID_PUSHBACK_MINION                              1512
#define CONST_TGPID_PUSHBACK                                     295
#define CONST_TGPID_LOCK_YAW_ROTATION                            323
#define CONST_TGPID_THREAT                                       420
#define CONST_TGPID_THREAT_MODIFIER                              421
#define CONST_TGPID_TYR_ABILITY_1_KNOCKUP                        1563
#define CONST_TGPID_TYR_ABILITY_2_KNOCKBACK                      1564
#define CONST_TGPID_INTERRUPT_CHANCE                             96
#define CONST_TGPID_VISION_RANGE                                 152
#define CONST_TGPID_DEVICE_MODE_EQUIP_TIME                       146
#define CONST_TGPID_DEVICE_MODE_BUILDUP_TIME                     2
#define CONST_TGPID_DEVICE_MODE_FIRE_TIME                        53
#define CONST_TGPID_DEVICE_MODE_COOLDOWN_TIME                    4
#define CONST_TGPID_DEVICE_MODE_TIME_TO_HOLD_BLOCK               258
#define CONST_TGPID_DEVICE_SHOTS_PER_FIRE                        287
#define CONST_TGPID_TIME_TO_DEPLOY_SECS                          279
#define CONST_TGPID_MAX_CONTROL_RANGE                            283
#define CONST_TGPID_HIT_TIME                                     310
#define CONST_TGPID_FULL_BODY_ANIM_TIME                          419
#define CONST_TGPID_FIRE_PRE_HIT_DELAY                           1016
#define CONST_TGPID_FIRE_POST_HIT_DELAY                          1017
#define CONST_TGPID_FIRE_CHAIN_SWING_TIME                        1562
#define CONST_TGPID_REPAIR                                       260
#define CONST_TGPID_MAP_PLAYER_KILL_VALUE                        95
#define CONST_TGPID_TUTORIAL_MAP                                 368
#define CONST_TGPID_CAPTURE_TIME                                 87
#define CONST_TGPID_HOLD_TIME                                    88
#define CONST_TGPID_TICK_TIME                                    89
#define CONST_TGPID_CAPTURE_SCORE                                97
#define CONST_TGPID_TICK_SCORE                                   98
#define CONST_TGPID_TICKET_TICK_DELAY                            411
#define CONST_TGPID_STUN                                         166
#define CONST_TGPID_FEAR                                         1418
#define CONST_TGPID_PANIC                                        1018
#define CONST_TGPID_INTOXICATED                                  1433
#define CONST_TGPID_TREMBLE                                      1656
#define CONST_TGPID_SILENCE                                      1023
#define CONST_TGPID_DISARM                                       303
#define CONST_TGPID_STASIS                                       1051
#define CONST_TGPID_REVEAL                                       1053
#define CONST_TGPID_REVEAL_GLOBAL                                1743
#define CONST_TGPID_REVEAL_INSTIGATOR                            1744
#define CONST_TGPID_BLIND                                        1055
#define CONST_TGPID_CRIPPLE                                      1523
#define CONST_TGPID_STUNTAUNT                                    1555
#define CONST_TGPID_STUN_NOPOSTURE                               1673
#define CONST_TGPID_REDIRECT_DAMAGE                              1557
#define CONST_TGPID_SLOW_TO_HALT                                 1558
#define CONST_TGPID_DISORIENT                                    1583
#define CONST_TGPID_PORTAL_FALL                                  1632
#define CONST_TGPID_CANNOT_USE_AUTO_PORTAL                       1634
#define CONST_TGPID_STUN_NOREDUCTION                             1653
#define CONST_TGPID_ATTACK_SLOW                                  1671
#define CONST_TGPID_SLIDE                                        1799
#define CONST_TGPID_WHITEOUT                                     1810
#define CONST_TGPID_NUM_RESPAWNS                                 387
#define CONST_TGPID_PLAYER_RELEASE                               116
#define CONST_TGPID_PLAYER_HEALTH_AUTO_RELEASE                   117
#define CONST_TGPID_PLAYER_HEALTH_MAN_RELEASE                    118
#define CONST_TGPID_PLAYER_RELEASE_LENGTH                        119
#define CONST_TGPID_PLAYER_RELEASE_LENGTH_ATTACKERS              313
#define CONST_TGPID_PLAYER_RELEASE_LENGTH_DEFENDERS              314
#define CONST_TGPID_MISSION_TIME_SECS                            299
#define CONST_TGPID_QUIET_END_MISSION                            342
#define CONST_TGPID_ROUND_TIME                                   416
#define CONST_TGPID_GAME_SPEED_MODIFIER                          122
#define CONST_TGPID_REMOVE_EFFECT                                140
#define CONST_TGPID_SWEEP_TYPE                                   142
#define CONST_TGPID_SWEEP_DIRECTION                              143
#define CONST_TGPID_SWEEP_RATE                                   144
#define CONST_TGPID_SWEEP_RANGE                                  145
#define CONST_TGPID_PERSIST_TIME                                 150
#define CONST_TGPID_PERSIST_PULSE                                151
#define CONST_TGPID_CHARACTER_VISION_RANGE                       152
#define CONST_TGPID_DEVICE_EFFECTIVE_RANGE                       153
#define CONST_TGPID_MAX_DEPLOYABLES_OUT                          154
#define CONST_TGPID_TAG_ENEMY                                    161
#define CONST_TGPID_DEPLOYABLE_ARTILLERY_RADIUS                  397
#define CONST_TGPID_DISABLE_CC_IMMUNITY_GLOW                     1679
#define CONST_INDEX_DISPLAY_TARGET_MINIMAP                       0
#define CONST_INDEX_DISPLAY_TARGET_INGAME                        1
#define CONST_INDEX_DISPLAY_TARGET_BRACKET                       2
#define CONST_INDEX_DISPLAY_TARGET_DISTANCE                      3
#define CONST_INDEX_DISPLAY_TARGET_TAGGED                        4
#define CONST_INDEX_DISPLAY_SEND_AUDIO_WARNING                   5
#define CONST_INDEX_DISPLAY_TARGET_LOW_HEALTH                    6
#define CONST_INDEX_SEE_NON_MOVING_ENEMY                         0
#define CONST_INDEX_SEE_WALKING_ENEMY                            1
#define CONST_INDEX_SEE_MAKING_NOISE_ENEMY                       2
#define CONST_INDEX_SEE_FLYING_ENEMY                             3
#define CONST_INDEX_SEE_STEALTHED_ENEMY                          4
#define CONST_INDEX_SEE_DEPLOYABLES                              5
#define CONST_INDEX_SEE_BEACONS                                  6
#define CONST_INDEX_SEE_BOTS_ONLY                                7
#define CONST_TGPID_PROTECTION_PHYSICAL                          155
#define CONST_TGPID_PROTECTION_PHYSICAL_PERC                     1551
#define CONST_TGPID_PHYSICAL_IMMUNITY                            1606
#define CONST_TGPID_PROTECTION_MAGICAL                           157
#define CONST_TGPID_PROTECTION_MAGICAL_PERC                      1552
#define CONST_TGPID_MAGICAL_IMMUNITY                             1607
#define CONST_TGPID_THERE_CAN_BE_ONLY_ONE                        1513
#define CONST_TGPID_DODGE_BASIC                                  1559
#define CONST_TGPID_PROTECTION_SLOW                              158
#define CONST_TGPID_PROTECTION_STUN                              163
#define CONST_TGPID_PROTECTION_MESMERIZE                         168
#define CONST_TGPID_PROTECTION_KNOCKBACK                         233
#define CONST_TGPID_PROTECTION_FEAR_AND_PANIC                    1022
#define CONST_TGPID_PROTECTION_ROOT                              1020
#define CONST_TGPID_PROTECTION_CRIPPLE                           1623
#define CONST_TGPID_PROTECTION_SILENCE                           1021
#define CONST_TGPID_PROTECTION_ATTACK_SLOW                       1670
#define CONST_TGPID_PROTECTION_CC                                1591
#define CONST_TGPID_CC_IMMUNITY                                  1417
#define CONST_TGPID_PROTECTION_PULL                              1360
#define CONST_TGPID_PROTECTION_VORTEX                            1801
#define CONST_TGPID_REMOVE_PROTECTION_CC                         1560
#define CONST_TGPID_BASIC_ATTACK_SLOW_IMMUNITY                   1483
#define CONST_TGPID_ABSORB_BASIC_ATTACK                          1550
#define CONST_TGPID_BASIC_ATTACK_DAMAGE                          1592
#define CONST_TGPID_ALLOW_PET_DOMINATION                         236
#define CONST_TGPID_HEALING_MODIFIER                             330
#define CONST_TGPID_GROUNDSPEED_MODIFIER                         66
#define CONST_TGPID_ACCURACY_MODIFIER                            113
#define CONST_TGPID_RANGE_MODIFIER                               114
#define CONST_TGPID_EFFECTIVE_RANGE_MODIFIER                     207
#define CONST_TGPID_TARGET_AUTOLOCK                              200
#define CONST_TGPID_INSTANT_POWER                                201
#define CONST_TGPID_RECHARGE_TIME_MODIFIER                       203
#define CONST_TGPID_EFFECT_LIFETIME_MODIFIER                     208
#define CONST_TGPID_EFFECT_POTENCY_MODIFIER                      376
#define CONST_TGPID_EFFECT_SHIELD_MODIFIER                       386
#define CONST_TGPID_REMOVE_MEZ                                   209
#define CONST_TGPID_EFFECT_HEAL_MODIFIER_SELF                    210
#define CONST_TGPID_EFFECT_REPAIR_MODIFIER_SELF                  261
#define CONST_TGPID_MISSING_HEALTH                               211
#define CONST_TGPID_MISSING_MANA                                 1590
#define CONST_TGPID_MELEE_ATTACKRATING_MODIFIER                  213
#define CONST_TGPID_RANGED_ATTACKRATING_MODIFIER                 215
#define CONST_TGPID_SILENT_MOVEMENT                              224
#define CONST_TGPID_XDEPLOY_ABILITY                              225
#define CONST_TGPID_MELEE_ATTACKRATE_MODIFIER                    231
#define CONST_TGPID_RANGED_ATTACKRATE_MODIFIER                   232
#define CONST_TGPID_ACCURACY_CORR_RATE_MODIFIER                  256
#define CONST_TGPID_CRITICAL_STRIKE                              280
#define CONST_TGPID_CRITICAL_STRIKE_DAMAGE                       1025
#define CONST_TGPID_CRITICAL_STRIKE_DIMINISHING                  1662
#define CONST_TGPID_MAX_CONTROL_RANGE_MODIFIER                   284
#define CONST_TGPID_ARCING_JUMPS                                 309
#define CONST_TGPID_ARC_RANGE                                    1057
#define CONST_TGPID_ARC_MAX_RANGE                                1058
#define CONST_TGPID_CONTAGIOUS_RADIUS                            312
#define CONST_TGPID_DAMAGE_REFLECT                               335
#define CONST_TGPID_DAMAGE_REFLECT_UNMITIGATED                   1754
#define CONST_TGPID_REMOTE_TIME_MODIFIER                         349
#define CONST_TGPID_PET_DAMAGE_MODIFIER                          350
#define CONST_TGPID_AOE_RADIUS_MODIFIER                          352
#define CONST_TGPID_PET_LIFESPAN_MODIFIER                        355
#define CONST_TGPID_PET_LIFESPAN                                 354
#define CONST_TGPID_PROJECTILE_SPEED_MODIFIER                    356
#define CONST_TGPID_MORALE_POINTS_MODIFIER                       357
#define CONST_TGPID_PET_MAX_HEALTH_MODIFIER                      366
#define CONST_TGPID_HEALTH_MAX_DEPLOYABLES                       339
#define CONST_TGPID_EFFICIENCY_MODIFIER                          385
#define CONST_TGPID_EFFICIENCY_HEALTH_MODIFIER                   390
#define CONST_TGPID_MAX_TARGET_COUNT                             415
#define CONST_TGPID_PET_RANGE_MODIFIER                           381
#define CONST_TGPID_PET_DAMAGE_RADIUS_MODIFIER                   382
#define CONST_TGPID_PET_ACCURACY_MODIFIER                        383
#define CONST_TGPID_PET_RECHARGE_RATE_MODIFIER                   384
#define CONST_TGPID_MELEE_DAMAGE_MODIFIER                        212
#define CONST_TGPID_RANGED_DAMAGE_MODIFIER                       214
#define CONST_TGPID_AOE_DAMAGE_MODIFIER                          321
#define CONST_TGPID_BIOLOGICAL_DAMAGE_MODIFIER                   389
#define CONST_TGPID_MECHANICAL_DAMAGE_MODIFIER                   388
#define CONST_TGPID_AUTO_SPAWN                                   170
#define CONST_TGPID_RESPAWN                                      171
#define CONST_TGPID_BOT_COUNT                                    172
#define CONST_TGPID_RESPAWN_DELAY                                173
#define CONST_TGPID_SPAWN_DELAY                                  174
#define CONST_TGPID_TEAM_NUMBER                                  175
#define CONST_TGPID_TASK_FORCE_NUMBER                            176
#define CONST_TGPID_SELECTION_METHOD                             178
#define CONST_TGPID_BOT_SELECTION_LIST                           179
#define CONST_TGPID_PLACEMENT_METHOD                             180
#define CONST_TGPID_PATROL_LOOP                                  181
#define CONST_TGPID_GLOBAL_ALARM_NUMBER                          182
#define CONST_TGPID_SPAWN_LOCATION_LIST                          183
#define CONST_TGPID_PATROL_LOCATION_LIST                         184
#define CONST_TGPID_DEPLOYABLE_SELECTION_LIST                    185
#define CONST_TGPID_DESTRUCTIBLE_SELECTION_LIST                  188
#define CONST_TGPID_INSTANCE_SELECTION_LIST                      229
#define CONST_TGPID_DEVICE_SELECTION_LIST                        282
#define CONST_TGPID_NAME_SELECTION_LIST                          292
#define CONST_TGPID_BULK_SPAWN                                   230
#define CONST_TGPID_LOOT_TABLE_ID                                332
#define CONST_TGPID_SPAWN_TABLE_ID                               340
#define CONST_TGPID_START_RATING                                 189
#define CONST_TGPID_CURRENT_RATING                               190
#define CONST_TGPID_RESET_RATING                                 191
#define CONST_TGPID_DECREASE_RATE                                192
#define CONST_TGPID_RETURN_MAP_TYPE                              325
#define CONST_TGPID_DISABLED                                     345
#define CONST_TGPID_MAP_ID                                       193
#define CONST_TGPID_GROUP_NUMBER                                 194
#define CONST_TGPID_PRELOAD                                      195
#define CONST_TGPID_SET_TASK_FORCE                               196
#define CONST_TGPID_BALANCE_TASK_FORCE                           197
#define CONST_TGPID_IGNORE_NON_MEMBERS                           198
#define CONST_TGPID_USE_PLAYER_START                             199
#define CONST_TGPID_REQUEST_MISSION                              329
#define CONST_TGPID_PET_DEPLOY_TIME_MODIFIER                     391
#define CONST_TGPID_DEPLOY_RATE_MODIFIER                         278
#define CONST_TGPID_TRAINING_DEVICE_LIST                         281
#define CONST_TGPID_TIME_TO_CAPTURE                              288
#define CONST_TGPID_CAPTURE_ONLY_ONCE                            289
#define CONST_TGPID_ALLOW_AIBOT_INTERACTION                      290
#define CONST_TGPID_ALLOW_PLAYERBOT_INTERACTION                  291
#define CONST_TGPID_TIME_TO_HOLD                                 294
#define CONST_TGPID_DEFENDER_RECAP_RATE                          296
#define CONST_TGPID_CAPTURE_ACCEL_RATE                           297
#define CONST_TGPID_CAPTURE_ACCEL_RATE_CAP                       298
#define CONST_TGPID_OBJECTIVE_BOT_ID                             301
#define CONST_TGPID_CAPTURE_TIME_EXTENTION                       300
#define CONST_TGPID_OVERTIME_RATE_MODIFIER                       317
#define CONST_TGPID_END_OT_ON_DEFENDER_PROGRESS                  320
#define CONST_TGPID_POINTS_PER_SECOND                            326
#define CONST_TGPID_POINTS_TO_WIN                                327
#define CONST_TGPID_OBJECTIVE_UNLOCK_DELAY                       331
#define CONST_TGPID_BLOCK_FRIENDLY_FIRE                          302
#define CONST_TGPID_TAUNT                                        305
#define CONST_TGPID_REQUIRED_POINTS_TO_FIRE                      318
#define CONST_TGPID_BOOST_CHARGE_RATE                            337
#define CONST_TGPID_ROOT                                         338
#define CONST_TGPID_CAPTURE_TIME_RESET                           358
#define CONST_TGPID_PRIORITY                                     346
#define CONST_TGPID_OBJECTIVE_ID                                 347
#define CONST_TGPID_MIN_AGENTS                                   401
#define CONST_TGPID_POINTS                                       398
#define CONST_TGPID_CREDITS                                      399
#define CONST_TGPID_REWARD_XP                                    400
#define CONST_TGPID_OBJECTIVE_COOLDOWN_SECONDS                   409
#define CONST_TGPID_MINIMUM_LEVEL                                410
#define CONST_TGPID_REDUCE_ACTIVE_COOLDOWN                       1554
#define CONST_TGPID_CAPTURE_RADIUS                               425
#define CONST_TGPID_CAPTURE_RATE_PERCENT                         426
#define CONST_TGPID_MINI_MAP_MIN_X                               402
#define CONST_TGPID_MINI_MAP_MIN_Y                               403
#define CONST_TGPID_MINI_MAP_MAX_X                               404
#define CONST_TGPID_MINI_MAP_MAX_Y                               405
#define CONST_TGPID_MINI_MAP_TEXTURE_ID                          406
#define CONST_TGPID_MINI_MAP_TEXTURE_UL                          407
#define CONST_TGPID_MINI_MAP_TEXTURE_VL                          408
#define CONST_TGPID_NEXT_MAP_GAME                                344
#define CONST_TGPID_ROUTE_NUMBER                                 348
#define CONST_TGPID_TELEPORT_BOTS                                359
#define CONST_TGPID_PAUSE_ON_CAPTURE                             365
#define CONST_TGPID_SPAWN_ORDER                                  367
#define CONST_TGPID_PVE_NORMAL_FLAG                              377
#define CONST_TGPID_PVE_EXPERT_FLAG                              378
#define CONST_TGPID_PVE_HEROIC_FLAG                              379
#define CONST_TGPID_PVE_EXTREME_FLAG                             380
#define CONST_TGPID_FRICTION_MULTIPLIER                          395
#define CONST_TGPID_AMMO_COUNT                                   424
#define CONST_TGPID_AMMO_CLIP_RELOAD_TIME                        425
#define CONST_TGPID_AMMO_CLIP_SIZE                               426
#define CONST_TGPID_AMMO_REPLENISH                               427
#define CONST_TGPID_ONSLAUGHT_SHIELD_POINTS                      428
#define CONST_TGPID_OS_SHIELD_HEALTH_TO_REMOVE                   429
#define CONST_TGPID_OS_BOT_HEALTH_TO_REMOVE                      430
#define CONST_TGPID_OS_SHIELD_HEALTH_TO_REMOVE_PK                431
#define CONST_TGPID_OS_BOT_HEALTH_TO_REMOVE_PK                   432
#define CONST_TGPID_OS_DISABLE_LATTICE_NETWORK                   433
#define CONST_TGPID_HEALTH                                       51
#define CONST_TGPID_HEALTH_MAX                                   304
#define CONST_TGPID_HEALTH_MAX_PERCENT                           1620
#define CONST_TGPID_HP5                                          1011
#define CONST_TGPID_HP5_PERCENT                                  1565
#define CONST_TGPID_MANA_MAX                                     1001
#define CONST_TGPID_MANA                                         1002
#define CONST_TGPID_MP5                                          1003
#define CONST_TGPID_ENERGY                                       1004
#define CONST_TGPID_ENERGY_PERCENT                               1666
#define CONST_TGPID_ENERGY_MAX                                   1005
#define CONST_TGPID_EP5                                          1006
#define CONST_TGPID_SHIELD                                       1598
#define CONST_TGPID_SHIELD_MAX                                   1599
#define CONST_TGPID_SHIELD_MAX_INSTIGATOR_LEVEL_SCALE            1612
#define CONST_TGPID_SHIELD_MAX_INSTIGATOR_MAXHEALTH_SCALE        1791
#define CONST_TGPID_POWER_PHYSICAL_BOT                           1082
#define CONST_TGPID_POWER_PHYSICAL_ITEM                          1007
#define CONST_TGPID_POWER_PHYSICAL_PERC                          1047
#define CONST_TGPID_POWER_MAGICAL_BOT                            1083
#define CONST_TGPID_POWER_MAGICAL_ITEM                           1008
#define CONST_TGPID_POWER_MAGICAL_PERC                           1046
#define CONST_TGPID_POWER_UTILITY_BOT                            1484
#define CONST_TGPID_POWER_UTILITY_ITEM                           1485
#define CONST_TGPID_PHYSICAL_LIFESTEAL                           1010
#define CONST_TGPID_LIFESTEAL_BLOCK                              1751
#define CONST_TGPID_LIFESTEAL_REDUCTION                          1782
#define CONST_TGPID_HEALTH_COST                                  1578
#define CONST_TGPID_MANA_COST                                    1012
#define CONST_TGPID_ENERGY_COST                                  1013
#define CONST_TGPID_ATTACK_SPEED                                 1015
#define CONST_TGPID_SPELL_VAMP                                   1026
#define CONST_TGPID_PENETRATION_PHYSICAL                         1027
#define CONST_TGPID_PENETRATION_PHYSICAL_PERC                    1028
#define CONST_TGPID_PENETRATION_MAGICAL                          1029
#define CONST_TGPID_PENETRATION_MAGICAL_PERC                     1030
#define CONST_TGPID_REDUCTION_PHYSICAL                           1034
#define CONST_TGPID_REDUCTION_PHYSICAL_PERC                      1036
#define CONST_TGPID_REDUCTION_MAGICAL                            1035
#define CONST_TGPID_REDUCTION_MAGICAL_PERC                       1037
#define CONST_TGPID_COOLDOWN_REDUCTION_PERC                      1039
#define CONST_TGPID_REVIVE_REDUCTION_PERC                        1040
#define CONST_TGPID_XP_GAIN_PERC                                 1041
#define CONST_TGPID_GOLD_GAIN_PERC                               1042
#define CONST_TGPID_GOLD_PER                                     1561
#define CONST_TGPID_GOLD_PER_5_PERC                              1043
#define CONST_TGPID_SPELL_SHIELD                                 1054
#define CONST_TGPID_MINION_DAMAGE_BONUS                          1498
#define CONST_TGPID_OBJECTIVE_DAMAGE_BONUS                       1798
#define CONST_TGPID_POWER_HEALING_PERC_ITEM                      1750
#define CONST_TGPID_PLAYER_PASS_THROUGH                          1800
#define CONST_TGPID_MANA_COST_MODIFIER                           1804
#define CONST_TGPID_STRUCTURE_DAMAGE_MODIFIER                    1805
#define CONST_TGPID_MINIMAP_LOS_IGNORED                          1032
#define CONST_TGPID_MINIMAP_DETECTOR                             1033
#define CONST_TGPID_MINIMAP_WARD_VISION_PERC                     1031
#define CONST_TGPID_HEALTH_PERCENT                               1044
#define CONST_TGPID_MANA_PERCENT                                 1045
#define CONST_TGPID_HEALTH_OWNER_PERC                            1570
#define CONST_TGPID_MANA_OWNER_PERC                              1571
#define CONST_TGPID_HEALTH_INSTIGATOR_PERC                       1792
#define CONST_TGPID_MANA_INSTIGATOR_PERC                         1793
#define CONST_TGPID_CUSTOM_VALUE                                 1049
#define CONST_TGPID_CUSTOM_VALUE01                               1050
#define CONST_TGPID_CUSTOM_VALUE02                               1594
#define CONST_TGPID_CUSTOM_VALUE03                               1595
#define CONST_TGPID_CUSTOM_VALUE04                               1596
#define CONST_TGPID_SLOW_DIMINISHING                             1231
#define CONST_TGPID_HEALING_TAKEN_PERC                           1056
#define CONST_TGPID_DAMAGE_TAKEN_PERC                            316
#define CONST_TGPID_DAMAGE_TAKEN_PERC_PHYS                       1630
#define CONST_TGPID_DAMAGE_TAKEN_PERC_MAG                        1631
#define CONST_TGPID_DAMAGE_DEALT_PERC                            65
#define CONST_TGPID_DAMAGE_DEALT_PERC_BASIC                      1605
#define CONST_TGPID_STEALTH                                      1416
#define CONST_TGPID_STEALTH_WITHFADING                           1597
#define CONST_TGPID_STEALTH_WARDVIS                              1809
#define CONST_TGPID_CHARM                                        1432
#define CONST_TGPID_ENAMORED                                     1514
#define CONST_TGPID_BREAK_GRAB                                   1556
#define CONST_TGPID_ALWAYS_APPLY                                 1790
#define CONST_TGPID_GP_SURRENDER_TIME                            1386
#define CONST_TGPID_GP_STARTING_GOLD                             1426
#define CONST_TGPID_GP_STARTING_LEVEL                            1427
#define CONST_TGPID_GP_GOLD_SPOOL                                1500
#define CONST_TGPID_GP_XP_SPOOL                                  1501
#define CONST_TGPID_GP_ENABLE_NEW_FOW                            1568
#define CONST_TGPID_GP_MAX_RESPAWN_TIME                          1569
#define CONST_TGPID_GP_GOD_XP_COEFFICIENT                        1581
#define CONST_TGPID_GP_COOLDOWN_MAX                              1681
#define CONST_TGPID_GP_COOLDOWN_MIN                              1682
#define CONST_TGPID_GP_COOLDOWN_START                            1683
#define CONST_TGPID_GP_INFINITE_ENERGY                           1741
#define CONST_TGPID_GP_MINION_DEATHS_ARENA                       1768
#define CONST_TGPID_GP_TICKET_COUNT                              1769
#define CONST_TGPID_GP_FOUNTAIN_DAMAGE                           1772
#define CONST_TGPID_GP_ARENA_PORTAL_POINTS                       1774
#define CONST_TGPID_GP_ARENA_ESCORT                              1775
#define CONST_TGPID_GP_FOUNTAIN_HEALING                          1776
#define CONST_TGPID_GP_INVENTORY_LIMITER                         1779
#define CONST_TGPID_GP_LANE_MINIONS                              1780
#define CONST_TGPID_GP_SIEGE_TICKETS                             1781
#define CONST_TGPID_GP_JUNGLE_CAMPS                              1783
#define CONST_TGPID_GP_GOLD_FURY                                 1784
#define CONST_TGPID_GP_FIRE_GIANT                                1785
#define CONST_TGPID_GP_LOCKED_DEVICES                            1786
#define CONST_TGPID_AI_DEVICE_RANGE                              1486
#define CONST_TGPID_AI_DEVICE_RADIUS                             1487
#define CONST_TGPID_AI_DEVICE_DAMAGE                             1638
#define CONST_TGPID_AI_DEVICE_SCALING                            1639
#define CONST_PROTECTION_IMMUNITY_VALUE                          100
#define CONST_PROTECTION_DAMAGE_IMMUNITY_VALUE                   10000
#define CONST_TG_MAX_PING_INFO                                   4
#define CONST_TG_ITEM_STORE_MAX                                  6
#define CONST_TG_ACTIVE_ITEMS_MAX                                3
#define CONST_TG_CONSUMABLE_MAX                                  2
#define CONST_TG_GENERAL_STATS_MAX                               4
#define CONST_TG_PROPS_MAX                                       20
#define CONST_TG_SURRENDER_VOTE_NONE                             0x00
#define CONST_TG_SURRENDER_VOTE_YES                              0x01
#define CONST_TG_SURRENDER_VOTE_NO                               0x02
#define CONST_MAX_CORE_STATS                                     18
#define CONST_MAX_STATS_DEVICES                                  9
#define CONST_NUM_SCORE_TYPES                                    22
#define CONST_TG_MAX_PREMADE_DEPLOYS                             20
#define CONST_TG_MAX_PRIMARY_OBJECTIVES                          5
#define CONST_TG_MAX_TASK_TEAM_NUMBER                            10
#define CONST_MERCURY_GHOST_MESH_ID                              3799
#define CONST_FX_SCALE_BY_DAMAGE                                 745
#define CONST_FX_SCALE_BY_RADIUS                                 746
#define CONST_FX_SCALE_ABSOLUTE                                  10677
#define CONST_FX_SCALE_BY_RADIUS_SQUARED                         1023
#define CONST_INVALID_LIGHT_SCORE                                2
#define CONST_INVALID_LIGHTARRAY_INDEX                           -1
#define CONST_TGFXLIGHT_MAX_SETTINGS_VALUE                       5
#define CONST_TGEGC_G84_PSV                                      15282
#define CONST_TGEGC_G84_D2                                       15283

/*
# ========================================================================================= #
# Enums
# ========================================================================================= #
*/

// Enum TgGame.AlienFXManager.FXOverlay
/*enum FXOverlay
{
	FXO_NONE                                           = 0,
	FXO_MENU                                           = 1,
	FXO_DYING                                          = 2,
	FXO_EVENT                                          = 3,
	FXO_MAX                                            = 4
};*/

// Enum TgGame.TgActionPoint.eActionPointType
/*enum eActionPointType
{
	ACTION_NONE                                        = 0,
	ACTION_RELAX_OPEN                                  = 1,
	ACTION_MINE_DEFAULT                                = 2,
	ACTION_RELAX_WALL                                  = 3,
	ACTION_CONSOLE_STANDARD                            = 4,
	ACTION_CONSOLE_LAB_DEFAULT                         = 5,
	ACTION_GUARD_WATCH_NORMAL                          = 6,
	ACTION_GUARD_WATCH_ELEVATED                        = 7,
	ACTION_FACTORY_LINE_DEFAULT                        = 8,
	ACTION_SNIPE                                       = 9,
	ACTION_PLACE_TURRET                                = 10,
	ACTION_PLACE_SHIELD                                = 11,
	ACTION_PLACE_CRATE                                 = 12,
	ACTION_PLACE_MINE                                  = 13,
	ACTION_PLACE_SENSOR                                = 14,
	ACTION_MAX                                         = 15
};*/

// Enum TgGame.TgObject.PING_TYPE
/*enum PING_TYPE
{
	PT_NORMAL                                          = 0,
	PT_NORMAL_ENEMY                                    = 1,
	PT_RETREAT                                         = 2,
	PT_RETREAT_ENEMY                                   = 3,
	PT_ALERT                                           = 4,
	PT_ALERT_ENEMY                                     = 5,
	PT_SENTINEL                                        = 6,
	PT_SENTINEL_ENEMY                                  = 7,
	PT_ALERT_SILENT                                    = 8,
	PT_MAX                                             = 9
};*/

// Enum TgGame.TgObject.RecoilHitDir
/*enum RecoilHitDir
{
	RECOIL_DIR_FromFront                               = 0,
	RECOIL_DIR_FromBack                                = 1,
	RECOIL_DIR_FromLeft                                = 2,
	RECOIL_DIR_FromRight                               = 3,
	RECOIL_DIR_MAX                                     = 4
};*/

// Enum TgGame.TgObject.HitReactionMoveType
/*enum HitReactionMoveType
{
	HIT_MOVE_TYPE_ALL                                  = 0,
	HIT_MOVE_TYPE_IDLE                                 = 1,
	HIT_MOVE_TYPE_MOVING                               = 2,
	HIT_MOVE_TYPE_MAX                                  = 3
};*/

// Enum TgGame.TgObject.GOD_PANTHEON
/*enum GOD_PANTHEON
{
	PANTHEON_None                                      = 0,
	PANTHEON_Egyptian                                  = 1,
	PANTHEON_Norse                                     = 2,
	PANTHEON_Greek                                     = 3,
	PANTHEON_Roman                                     = 4,
	PANTHEON_Chinese                                   = 5,
	PANTHEON_Mayan                                     = 6,
	PANTHEON_Hindu                                     = 7,
	PANTHEON_Japanese                                  = 8,
	PANTHEON_MAX                                       = 9
};*/

// Enum TgGame.TgObject.ERewardValueType
/*enum ERewardValueType
{
	RVT_None                                           = 0,
	RVT_Initial                                        = 1,
	RVT_Spool                                          = 2,
	RVT_Kill                                           = 3,
	RVT_Assist                                         = 4,
	RVT_Objective                                      = 5,
	RVT_Bonus                                          = 6,
	RVT_MAX                                            = 7
};*/

// Enum TgGame.TgObject.EPurchaseFailure
/*enum EPurchaseFailure
{
	TGPF_None                                          = 0,
	TGPF_UnknownItem                                   = 1,
	TGPF_UnavailableItem                               = 2,
	TGPF_UnknownOwner                                  = 3,
	TGPF_NotEnoughCurrency                             = 4,
	TGPF_NotEquipped                                   = 5,
	TGPF_AtStackLimit                                  = 6,
	TGPF_AlreadyPurchased                              = 7,
	TGPF_NoAvailableSlots                              = 8,
	TGPF_InvalidUpgrade                                = 9,
	TGPF_CannotSell                                    = 10,
	TGPF_CannotSellInUse                               = 11,
	TGPF_InvalidForCourier                             = 12,
	TGPF_NotInTransaction                              = 13,
	TGPF_CannotTransactInUse                           = 14,
	TGPF_Unknown                                       = 15,
	TGPF_MAX                                           = 16
};*/

// Enum TgGame.TgObject.ETrainingQuest
/*enum ETrainingQuest
{
	ETQ_None                                           = 0,
	ETQ_Kills                                          = 1,
	ETQ_Escort                                         = 2,
	ETQ_Other                                          = 3,
	ETQ_MAX                                            = 4
};*/

// Enum TgGame.TgObject.EGodRole
/*enum EGodRole
{
	EGR_Any                                            = 0,
	EGR_Assassin                                       = 1,
	EGR_Guardian                                       = 2,
	EGR_Hunter                                         = 3,
	EGR_Mage                                           = 4,
	EGR_Warrior                                        = 5,
	EGR_MAX                                            = 6
};*/

// Enum TgGame.TgObject.ReplicatedFactoryState
/*enum ReplicatedFactoryState
{
	RFS_None                                           = 0,
	RFS_Vacant                                         = 1,
	RFS_Intro                                          = 2,
	RFS_Spawned                                        = 3,
	RFS_OwnedByTF1                                     = 4,
	RFS_OwnedByTF2                                     = 5,
	RFS_MAX                                            = 6
};*/

// Enum TgGame.TgObject.EPetPhase
/*enum EPetPhase
{
	PETPHASE_Default                                   = 0,
	PETPHASE_CodeOverride                              = 1,
	PETPHASE_Heel                                      = 2,
	PETPHASE_Follow                                    = 3,
	PETPHASE_Guard                                     = 4,
	PETPHASE_MAX                                       = 5
};*/

// Enum TgGame.TgObject.EPetPosition
/*enum EPetPosition
{
	PETPOS_Default                                     = 0,
	PETPOS_Front                                       = 1,
	PETPOS_FrontRight                                  = 2,
	PETPOS_Right                                       = 3,
	PETPOS_BackRight                                   = 4,
	PETPOS_Back                                        = 5,
	PETPOS_BackLeft                                    = 6,
	PETPOS_Left                                        = 7,
	PETPOS_FrontLeft                                   = 8,
	PETPOS_MAX                                         = 9
};*/

// Enum TgGame.TgObject.EUISettingUpdate
/*enum EUISettingUpdate
{
	UISU_All                                           = 0,
	UISU_AudioVideo                                    = 1,
	UISU_Interface                                     = 2,
	UISU_Control                                       = 3,
	UISU_Targeting                                     = 4,
	UISU_Gamepad                                       = 5,
	UISU_MAX                                           = 6
};*/

// Enum TgGame.TgObject.EDeviceFailType
/*enum EDeviceFailType
{
	DFT_None                                           = 0,
	DFT_Unspecified                                    = 1,
	DFT_Custom                                         = 2,
	DFT_NotEnoughPower                                 = 3,
	DFT_OnCooldown                                     = 4,
	DFT_CannotPlace                                    = 5,
	DFT_Stunned                                        = 6,
	DFT_Silenced                                       = 7,
	DFT_Disarmed                                       = 8,
	DFT_Crippled                                       = 9,
	DFT_FireLockout                                    = 10,
	DFT_MAX                                            = 11
};*/

// Enum TgGame.TgObject.TG_EQUIP_POINT
/*enum TG_EQUIP_POINT
{
	EQP_NONE                                           = 0,
	EQP_AUTO                                           = 1,
	EQP_OFFHAND                                        = 2,
	EQP_OFFHAND01                                      = 3,
	EQP_OFFHAND02                                      = 4,
	EQP_OFFHAND03                                      = 5,
	EQP_RECALL                                         = 6,
	EQP_PASSIVE                                        = 7,
	EQP_ACTIVE                                         = 8,
	EQP_ACTIVE01                                       = 9,
	EQP_ACTIVE02                                       = 10,
	EQP_CONSUMABLE                                     = 11,
	EQP_CONSUMABLE01                                   = 12,
	EQP_UNUSED                                         = 13,
	EQP_UNUSED01                                       = 14,
	EQP_UNUSED02                                       = 15,
	EQP_UNUSED03                                       = 16,
	EQP_UNUSED04                                       = 17,
	EQP_UNUSED05                                       = 18,
	EQP_ITEM_STORE                                     = 19,
	EQP_ITEM_STORE01                                   = 20,
	EQP_ITEM_STORE02                                   = 21,
	EQP_ITEM_STORE03                                   = 22,
	EQP_ITEM_STORE04                                   = 23,
	EQP_ITEM_STORE05                                   = 24,
	EQP_MAX                                            = 25
};*/

// Enum TgGame.TgObject.eTutorialForceableElements
/*enum eTutorialForceableElements
{
	ETBUI_Skills                                       = 0,
	ETBUI_ItemShop                                     = 1,
	ETBUI_ItemShopButton                               = 2,
	ETBUI_Intro                                        = 3,
	ETBUI_ItemShopWalkthrough                          = 4,
	ETBUI_ActiveItems                                  = 5,
	ETBUI_ConsumableItems                              = 6,
	ETBUI_Escape                                       = 7,
	ETBUI_MAX                                          = 8
};*/

// Enum TgGame.TgObject.TgSupportedAspectRatios
/*enum TgSupportedAspectRatios
{
	TgAR_4x3                                           = 0,
	TgAR_5x4                                           = 1,
	TgAR_16x9                                          = 2,
	TgAR_16x10                                         = 3,
	TgAR_Other                                         = 4,
	TgAR_MAX                                           = 5
};*/

// Enum TgGame.TgObject.ENPCVoices
/*enum ENPCVoices
{
	NPCVOICE_VendorMale01                              = 0,
	NPCVOICE_VendorMale02                              = 1,
	NPCVOICE_VendorMale03                              = 2,
	NPCVOICE_VendorMale04                              = 3,
	NPCVOICE_VendorMale05                              = 4,
	NPCVOICE_VendorMale06                              = 5,
	NPCVOICE_VendorMale07                              = 6,
	NPCVOICE_VendorMale08                              = 7,
	NPCVOICE_VendorMale09                              = 8,
	NPCVOICE_VendorMale10                              = 9,
	NPCVOICE_VendorFemale01                            = 10,
	NPCVOICE_VendorFemale02                            = 11,
	NPCVOICE_VendorFemale03                            = 12,
	NPCVOICE_VendorFemale04                            = 13,
	NPCVOICE_VendorFemale05                            = 14,
	NPCVOICE_VendorFemale06                            = 15,
	NPCVOICE_VendorFemale07                            = 16,
	NPCVOICE_VendorFemale08                            = 17,
	NPCVOICE_VendorFemale09                            = 18,
	NPCVOICE_VendorFemale10                            = 19,
	NPCVOICE_MAX                                       = 20
};*/

// Enum TgGame.TgObject.OverlayType
/*enum OverlayType
{
	OT_UNKNOWN                                         = 0,
	OT_LOCALPLAYER                                     = 1,
	OT_PLAYER                                          = 2,
	OT_TOWER                                           = 3,
	OT_MINION                                          = 4,
	OT_DEPLOYABLE                                      = 5,
	OT_BUFFMONSTER                                     = 6,
	OT_NEITH_TARGETLOCK                                = 7,
	OT_NEITH_TARGETLOCK_WEAVE                          = 8,
	OT_NEITH_CHARGE                                    = 9,
	OT_NEZHA_ULTQTE                                    = 10,
	OT_ISIS_CIRCLEOFPROTECTION                         = 11,
	OT_ATHENA_TARGETLOCK                               = 12,
	OT_WAYPOINT                                        = 13,
	OT_OBJECTIVEMINION                                 = 14,
	OT_RETICLE                                         = 15,
	OT_RETICLE_O                                       = 16,
	OT_RETICLELOCK                                     = 17,
	OT_RETICLELOCK_QUAD                                = 18,
	OT_KUMBHAKARNA_SLEEP                               = 19,
	OT_SIEGE_MINION                                    = 20,
	OT_KALDR_PET                                       = 21,
	OT_NEUTRAL_BOSS                                    = 22,
	OT_MAX                                             = 23
};*/

// Enum TgGame.TgObject.OverlayLineCheckState
/*enum OverlayLineCheckState
{
	OLCS_Disallowed                                    = 0,
	OLCS_Allowed                                       = 1,
	OLCS_DidLineCheck                                  = 2,
	OLCS_MAX                                           = 3
};*/

// Enum TgGame.TgObject.OverlayOffscreenIndicator
/*enum OverlayOffscreenIndicator
{
	OOI_None                                           = 0,
	OOI_Left                                           = 1,
	OOI_Right                                          = 2,
	OOI_MAX                                            = 3
};*/

// Enum TgGame.TgObject.CourierPetPhase
/*enum CourierPetPhase
{
	CPP_WaitAtSpawn                                    = 0,
	CPP_FollowOwner                                    = 1,
	CPP_StoreGo                                        = 2,
	CPP_StoreDropOff                                   = 3,
	CPP_MAX                                            = 4
};*/

// Enum TgGame.TgObject.MinimapFactoryType
/*enum MinimapFactoryType
{
	MMF_None                                           = 0,
	MMF_FireGiant                                      = 1,
	MMF_Kraken                                         = 2,
	MMF_Speed                                          = 3,
	MMF_Damage                                         = 4,
	MMF_Protection                                     = 5,
	MMF_Mana                                           = 6,
	MMF_Cooldown                                       = 7,
	MMF_HealthRegen                                    = 8,
	MMF_BonusMinions                                   = 9,
	MMF_Tower                                          = 10,
	MMF_Phoenix                                        = 11,
	MMF_CapturePoint                                   = 12,
	MMF_MinorSpawn                                     = 13,
	MMF_GoldFury                                       = 14,
	MMF_SiegeSpawner                                   = 15,
	MMF_AttackSpeed                                    = 16,
	MMF_MAX                                            = 17
};*/

// Enum TgGame.TgObject.AlertType
/*enum AlertType
{
	ATT_Regular                                        = 0,
	ATT_Beneficial                                     = 1,
	ATT_Detrimental                                    = 2,
	ATT_Spectator                                      = 3,
	ATT_Important                                      = 4,
	ATT_MainNotify                                     = 5,
	ATT_SubNotify                                      = 6,
	ATT_MAX                                            = 7
};*/

// Enum TgGame.TgObject.AlertPriority
/*enum AlertPriority
{
	APT_Minimal                                        = 0,
	APT_Normal                                         = 1,
	APT_High                                           = 2,
	APT_Critical                                       = 3,
	APT_MAX                                            = 4
};*/

// Enum TgGame.TgObject.ETargetingHighlightStyle
/*enum ETargetingHighlightStyle
{
	THS_None                                           = 0,
	THS_Silhouette                                     = 1,
	THS_HighlightAndBracketWorld                       = 2,
	THS_MAX                                            = 3
};*/

// Enum TgGame.TgObject.ETargetingReticleStyle
/*enum ETargetingReticleStyle
{
	TRS_None                                           = 0,
	TRS_X                                              = 1,
	TRS_O                                              = 2,
	TRS_MAX                                            = 3
};*/

// Enum TgGame.TgObject.ETargetingPreviewStyle
/*enum ETargetingPreviewStyle
{
	TPS_None                                           = 0,
	TPS_Target                                         = 1,
	TPS_ContrastTarget                                 = 2,
	TPS_3DArrow                                        = 3,
	TPS_MAX                                            = 4
};*/

// Enum TgGame.TgObject.ETargetingLineStyle
/*enum ETargetingLineStyle
{
	TLS_None                                           = 0,
	TLS_Ruler                                          = 1,
	TLS_Line                                           = 2,
	TLS_MAX                                            = 3
};*/

// Enum TgGame.TgObject.MiniMapEntityType
/*enum MiniMapEntityType
{
	MMap_LocalSpectator                                = 0,
	MMap_LocalPlayer                                   = 1,
	MMap_Player                                        = 2,
	MMap_Bot                                           = 3,
	MMap_Factory                                       = 4,
	MMap_Deployable                                    = 5,
	MMap_CapturePoint                                  = 6,
	MMap_LocalWard                                     = 7,
	MMap_MAX                                           = 8
};*/

// Enum TgGame.TgObject.TgMapTeam
/*enum TgMapTeam
{
	MAPTEAM                                            = 0,
	MAPTEAM01                                          = 1,
	MAPTEAM_NEUTRAL                                    = 2,
	MAPTEAM_MAX                                        = 3
};*/

// Enum TgGame.TgObject.PLAYER_COMBAT_EVENT_TYPE
/*enum PLAYER_COMBAT_EVENT_TYPE
{
	PCET_None                                          = 0,
	PCET_Spawn                                         = 1,
	PCET_MAX                                           = 2
};*/

// Enum TgGame.TgObject.ITEM_EVENT_TYPE
/*enum ITEM_EVENT_TYPE
{
	IET_None                                           = 0,
	IET_CastStart                                      = 1,
	IET_CastComplete                                   = 2,
	IET_CastInterrupt                                  = 3,
	IET_ItemPurchase                                   = 4,
	IET_ItemSell                                       = 5,
	IET_AbilityPurchase                                = 6,
	IET_MAX                                            = 7
};*/

// Enum TgGame.TgObject.DAMAGE_INFO_TYPE
/*enum DAMAGE_INFO_TYPE
{
	DIT_None                                           = 0,
	DIT_Death                                          = 1,
	DIT_Damage                                         = 2,
	DIT_Status                                         = 3,
	DIT_Healing                                        = 4,
	DIT_ManaBurn                                       = 5,
	DIT_ManaRestore                                    = 6,
	DIT_Objective                                      = 7,
	DIT_Experience                                     = 8,
	DIT_Currency                                       = 9,
	DIT_Level                                          = 10,
	DIT_CritDamage                                     = 11,
	DIT_Backstab                                       = 12,
	DIT_KillingBlow                                    = 13,
	DIT_Assist                                         = 14,
	DIT_KillingBlowWrath                               = 15,
	DIT_MAX                                            = 16
};*/

// Enum TgGame.TgObject.DeviceTargetMode
/*enum DeviceTargetMode
{
	TGDTM_Self                                         = 0,
	TGDTM_Melee                                        = 1,
	TGDTM_Reticle                                      = 2,
	TGDTM_Projectile                                   = 3,
	TGDTM_AOE                                          = 4,
	TGDTM_Deploy                                       = 5,
	TGDTM_Ground                                       = 6,
	TGDTM_Cone                                         = 7,
	TGDTM_Linear                                       = 8,
	TGDTM_LockOn                                       = 9,
	TGDTM_SpawnPoint                                   = 10,
	TGDTM_WorldMap                                     = 11,
	TGDTM_WorldMapLockOn                               = 12,
	TGDTM_PawnSelect                                   = 13,
	TGDTM_MAX                                          = 14
};*/

// Enum TgGame.TgObject.GameTimerState
/*enum GameTimerState
{
	TGMTS_UNSET                                        = 0,
	TGMTS_WAITING_FOR_PLAYERS                          = 1,
	TGMTS_SETUP                                        = 2,
	TGMTS_MISSION_RUNNING                              = 3,
	TGMTS_MISSION_OVERTIME                             = 4,
	TGMTS_MISSION_COMPLETE                             = 5,
	TGMTS_MISSION_PAUSED                               = 6,
	TGMTS_CUSTOM                                       = 7,
	TGMTS_ROUND_COMPLETE                               = 8,
	TGMTS_MISSION_PRE_OVERTIME                         = 9,
	TGMTS_MISSION_OVERTIME_SETUP                       = 10,
	TGMTS_MAX                                          = 11
};*/

// Enum TgGame.TgObject.TG_GAME_SEASONAL
/*enum TG_GAME_SEASONAL
{
	TGSN_NONE                                          = 0,
	TGSN_HALLOWEEN                                     = 1,
	TGSN_WINTER                                        = 2,
	TGSN_MAX                                           = 3
};*/

// Enum TgGame.TgObject.TG_GAME_TYPE
/*enum TG_GAME_TYPE
{
	TGT_UNSET                                          = 0,
	TGT_CITY                                           = 1,
	TGT_ARENA                                          = 2,
	TGT_ARENA_TRAINING                                 = 3,
	TGT_ARENA_PRACTICE                                 = 4,
	TGT_ARENA_CAPTURE                                  = 5,
	TGT_ARENA_ESCORT                                   = 6,
	TGT_ARENA_ESCORT_PRACTICE                          = 7,
	TGT_BATTLE                                         = 8,
	TGT_BATTLE_EXPERT                                  = 9,
	TGT_BATTLE_PRACTICE                                = 10,
	TGT_BATTLE_JOUST                                   = 11,
	TGT_BATTLE_CASUAL                                  = 12,
	TGT_BATTLE_TRAINING                                = 13,
	TGT_BATTLE_CONQUEST_TRAINING                       = 14,
	TGT_BATTLE_ARAM                                    = 15,
	TGT_BATTLE_ARAM_PRACTICE                           = 16,
	TGT_POINTCAPTURE                                   = 17,
	TGT_DOMINATION                                     = 18,
	TGT_SINGLEPOINTCAPTUREANDHOLD                      = 19,
	TGT_IDOL                                           = 20,
	TGT_SIEGE                                          = 21,
	TGT_BATTLE_TC                                      = 22,
	TGT_BATTLE_SHOOTINGRANGE                           = 23,
	TGT_BATTLE_JOUST_PRACTICE                          = 24,
	TGT_BATTLE_CLASH                                   = 25,
	TGT_BATTLE_CLASH_PRACTICE                          = 26,
	TGT_BATTLE_CLASH_TRAINING                          = 27,
	TGT_BATTLE_ENCOUNTER                               = 28,
	TGT_MAX                                            = 29
};*/

// Enum TgGame.TgObject.GAME_WIN_STATE
/*enum GAME_WIN_STATE
{
	GWS_NONE                                           = 0,
	GWS_TASKFORCE_TWO_WON                              = 1,
	GWS_TASKFORCE_ONE_WON                              = 2,
	GWS_TIE                                            = 3,
	GWS_SD_TF_TWO_WON                                  = 4,
	GWS_SD_TF_ONE_WON                                  = 5,
	GWS_SD_TIE                                         = 6,
	GWS_MAX                                            = 7
};*/

// Enum TgGame.TgActorFactory.eSelectionMethod
/*enum eSelectionMethod
{
	TGSM_RANDOM                                        = 0,
	TGSM_SEQUENTIAL                                    = 1,
	TGSM_MAX                                           = 2
};*/

// Enum TgGame.TgAIBehaviorNode.EBehaviorStatus
/*enum EBehaviorStatus
{
	BEHAVIOR_None                                      = 0,
	BEHAVIOR_Complete                                  = 1,
	BEHAVIOR_Running                                   = 2,
	BEHAVIOR_Paused                                    = 3,
	BEHAVIOR_Failed                                    = 4,
	BEHAVIOR_Aborted                                   = 5,
	BEHAVIOR_MAX                                       = 6
};*/

// Enum TgGame.TgAIBehaviorNode.EBehaviorComparison
/*enum EBehaviorComparison
{
	BEHAVIORCOMPARE_Equal                              = 0,
	BEHAVIORCOMPARE_NotEqual                           = 1,
	BEHAVIORCOMPARE_LessThan                           = 2,
	BEHAVIORCOMPARE_LessThanOrEqual                    = 3,
	BEHAVIORCOMPARE_GreaterThan                        = 4,
	BEHAVIORCOMPARE_GreaterThanOrEqual                 = 5,
	BEHAVIORCOMPARE_MAX                                = 6
};*/

// Enum TgGame.TgPawn.EEmoteFail
/*enum EEmoteFail
{
	EMOTEFAIL_None                                     = 0,
	EMOTEFAIL_DoNotOwn                                 = 1,
	EMOTEFAIL_NoPawn                                   = 2,
	EMOTEFAIL_Cooldown                                 = 3,
	EMOTEFAIL_InCombat                                 = 4,
	EMOTEFAIL_MAX                                      = 5
};*/

// Enum TgGame.TgPawn.EEmote
/*enum EEmote
{
	EMOTE_None                                         = 0,
	EMOTE_Taunt                                        = 1,
	EMOTE_Joke                                         = 2,
	EMOTE_Laugh                                        = 3,
	EMOTE_Health_Low                                   = 4,
	EMOTE_Kill_Jungle_Boss                             = 5,
	EMOTE_Kill_Phoenix                                 = 6,
	EMOTE_Kill_Streak                                  = 7,
	EMOTE_Kill_Tower                                   = 8,
	EMOTE_Purchase_Consumable                          = 9,
	EMOTE_Purchase_Defense                             = 10,
	EMOTE_Purchase_Power                               = 11,
	EMOTE_Purchase_Utility                             = 12,
	EMOTE_Ward_Placed                                  = 13,
	EMOTE_Kill_God                                     = 14,
	EMOTE_Wave                                         = 15,
	EMOTE_Dance                                        = 16,
	EMOTE_Clap                                         = 17,
	EMOTE_God_Special                                  = 18,
	EMOTE_Furious                                      = 19,
	EMOTE_OdySpecial01                                 = 20,
	EMOTE_GlobalEmote                                  = 21,
	EMOTE_OwnerAuto                                    = 22,
	EMOTE_OwnerDev1                                    = 23,
	EMOTE_OwnerDev2                                    = 24,
	EMOTE_OwnerDev3                                    = 25,
	EMOTE_OwnerDev4                                    = 26,
	EMOTE_OwnerRecall                                  = 27,
	EMOTE_PetSelfRecall                                = 28,
	EMOTE_Generic1                                     = 29,
	EMOTE_Generic2                                     = 30,
	EMOTE_Generic3                                     = 31,
	EMOTE_MAX                                          = 32
};*/

// Enum TgGame.TgPawn.ETweenState
/*enum ETweenState
{
	TWEEN_None                                         = 0,
	TWEEN_Default                                      = 1,
	TWEEN_DefaultImmune                                = 2,
	TWEEN_BastetPounce                                 = 3,
	TWEEN_HadesDeathFromBelow                          = 4,
	TWEEN_OdinLeap                                     = 5,
	TWEEN_HeboWave                                     = 6,
	TWEEN_MonkeyLeap                                   = 7,
	TWEEN_ArachnePull                                  = 8,
	TWEEN_ArachneAttach                                = 9,
	TWEEN_AnhurDisarm                                  = 10,
	TWEEN_AnhurImpale                                  = 11,
	TWEEN_BakasuraTakedown                             = 12,
	TWEEN_ThorLeap                                     = 13,
	TWEEN_Levitate                                     = 14,
	TWEEN_LevitateUnbreakable                          = 15,
	TWEEN_Sink                                         = 16,
	TWEEN_BacchusBellyFlop                             = 17,
	TWEEN_HerculesPunch                                = 18,
	TWEEN_HerculesBatterUp                             = 19,
	TWEEN_NeithFlipOut                                 = 20,
	TWEEN_NeithFlipOutPlusKick                         = 21,
	TWEEN_MinionKnockbackMelee                         = 22,
	TWEEN_MinionKnockbackRanged                        = 23,
	TWEEN_AphroditeGetAway                             = 24,
	TWEEN_ApolloDive                                   = 25,
	TWEEN_NeZhaSash                                    = 26,
	TWEEN_NeZhaWindFire                                = 27,
	TWEEN_NeZhaWindFire_SelfKnockDown                  = 28,
	TWEEN_FenrirMaul                                   = 29,
	TWEEN_FenrirDoubleJump                             = 30,
	TWEEN_AthenaUlt                                    = 31,
	TWEEN_AthenaShieldWall                             = 32,
	TWEEN_ChronosRewind                                = 33,
	TWEEN_TyrComboStrike                               = 34,
	TWEEN_TyrPush                                      = 35,
	TWEEN_TyrUltLeap                                   = 36,
	TWEEN_ThanatosStrike                               = 37,
	TWEEN_SunWukongToCloud                             = 38,
	TWEEN_SunWukongAttack                              = 39,
	TWEEN_SunWukongCancel                              = 40,
	TWEEN_ChaacNum2                                    = 41,
	TWEEN_ChaacUlt                                     = 42,
	TWEEN_KaliStrike                                   = 43,
	TWEEN_ScyllaNum3                                   = 44,
	TWEEN_ScyllaTentacle                               = 45,
	TWEEN_UllrNum3                                     = 46,
	TWEEN_AresTether                                   = 47,
	TWEEN_KumbhakarnaNum1                              = 48,
	TWEEN_KumbhakarnaNum4TimedKnockup                  = 49,
	TWEEN_TimedKnockup                                 = 50,
	TWEEN_AutoPortal                                   = 51,
	TWEEN_ArtemisBoar                                  = 52,
	TWEEN_FloorPortal                                  = 53,
	TWEEN_FloorPortal_Friendly                         = 54,
	TWEEN_SerqetLastBreathLeap                         = 55,
	TWEEN_SerqetLastBreathKnockback                    = 56,
	TWEEN_CabrakanChargeKnockback                      = 57,
	TWEEN_CabrakanUlt                                  = 58,
	TWEEN_ArachneCreepy                                = 59,
	TWEEN_AoKuangUltimate                              = 60,
	TWEEN_AoKuangUltimatePart3                         = 61,
	TWEEN_AoKuangUltimateMegaKill                      = 62,
	TWEEN_AwilixMoonlightPull                          = 63,
	TWEEN_AwilixReposition                             = 64,
	TWEEN_HouYi_DiveBomb                               = 65,
	TWEEN_Osiris_UltLeap                               = 66,
	TWEEN_RatatoskrTailSpin                            = 67,
	TWEEN_RatatoskrUltimate                            = 68,
	TWEEN_RavanaUltimate                               = 69,
	TWEEN_ToTarget                                     = 70,
	TWEEN_SolLeapBack                                  = 71,
	TWEEN_SolReappear                                  = 72,
	TWEEN_XingTianLeap                                 = 73,
	TWEEN_CircleTarget                                 = 74,
	TWEEN_Kaldr_Lunge                                  = 75,
	TWEEN_JingWei_AirDash                              = 76,
	TWEEN_JingWei_Land                                 = 77,
	TWEEN_Fafnir_Leap                                  = 78,
	TWEEN_ErlangShen_Impale                            = 79,
	TWEEN_Camazotz_ToothAndNailLeap                    = 80,
	TWEEN_Camazotz_Dev4                                = 81,
	TWEEN_Nike_Dev3                                    = 82,
	TWEEN_MAX                                          = 83
};*/

// Enum TgGame.TgPawn.TG_DEATH_REASON
/*enum TG_DEATH_REASON
{
	DR_NORMAL                                          = 0,
	DR_DESPAWN                                         = 1,
	DR_RECONNECT                                       = 2,
	DR_BAKASURA_CONSUME                                = 3,
	DR_AOKUANG_ULT                                     = 4,
	DR_MEDUSA_STATUE                                   = 5,
	DR_MAX                                             = 6
};*/

// Enum TgGame.TgPawn.STEALTH_TYPE
/*enum STEALTH_TYPE
{
	STEALTH_TYPE_NONE                                  = 0,
	STEALTH_TYPE_INSTANT                               = 1,
	STEALTH_TYPE_FADING                                = 2,
	STEALTH_TYPE_MAX                                   = 3
};*/

// Enum TgGame.TgPawn.EChargeState
/*enum EChargeState
{
	CHARGE_None                                        = 0,
	CHARGE_NoTurn                                      = 1,
	CHARGE_NoTurnBackwards                             = 2,
	CHARGE_Turn                                        = 3,
	CHARGE_MercuryUlt                                  = 4,
	CHARGE_TurnToDesiredRotation                       = 5,
	CHARGE_Slide                                       = 6,
	CHARGE_MAX                                         = 7
};*/

// Enum TgGame.TgPawn.EGrabState
/*enum EGrabState
{
	GRAB_None                                          = 0,
	GRAB_ArachneLifeDrain                              = 1,
	GRAB_FenrirBite                                    = 2,
	GRAB_LokiAssassinate                               = 3,
	GRAB_AthenaUlt                                     = 4,
	GRAB_TyrNum1                                       = 5,
	GRAB_MercuryDelivery                               = 6,
	GRAB_KumbhakarnaToss                               = 7,
	GRAB_SerqetLastBreath                              = 8,
	GRAB_KhepriAbduct                                  = 9,
	GRAB_KhepriRevive                                  = 10,
	GRAB_NoxShadowStep                                 = 11,
	GRAB_XingTianSweep                                 = 12,
	GRAB_ErlangShenImpale                              = 13,
	GRAB_TerraMegaPunch                                = 14,
	GRAB_MAX                                           = 15
};*/

// Enum TgGame.TgPawn.ELevitateType
/*enum ELevitateType
{
	LEVITATE_None                                      = 0,
	LEVITATE_Freya                                     = 1,
	LEVITATE_NeZha                                     = 2,
	LEVITATE_AwilixMoonlight                           = 3,
	LEVITATE_JingWeiSelf                               = 4,
	LEVITATE_JingWeiEnemy                              = 5,
	LEVITATE_Terra                                     = 6,
	LEVITATE_MAX                                       = 7
};*/

// Enum TgGame.TgPawn.TG_POSTURE
/*enum TG_POSTURE
{
	TG_POSTURE_DEFAULT                                 = 0,
	TG_POSTURE_REST                                    = 1,
	TG_POSTURE_FUSSY                                   = 2,
	TG_POSTURE_ENRAGED                                 = 3,
	TG_POSTURE_GENERICFIRE1                            = 4,
	TG_POSTURE_GENERICFIRE2                            = 5,
	TG_POSTURE_GENERICFIRE3                            = 6,
	TG_POSTURE_SCARED                                  = 7,
	TG_POSTURE_STUNNED                                 = 8,
	TG_POSTURE_STASIS                                  = 9,
	TG_POSTURE_KNOCKBACK                               = 10,
	TG_POSTURE_MESMERIZE                               = 11,
	TG_POSTURE_INTRO                                   = 12,
	TG_POSTURE_PATROL                                  = 13,
	TG_POSTURE_DEAD                                    = 14,
	TG_POSTURE_SEARCHING                               = 15,
	TG_POSTURE_FALLING                                 = 16,
	TG_POSTURE_NONE                                    = 17,
	TG_POSTURE_MAX                                     = 18
};*/

// Enum TgGame.TgPawn.OverlayState
/*enum OverlayState
{
	OMS_Normal                                         = 0,
	OMS_ForceVisible                                   = 1,
	OMS_ForceHidden                                    = 2,
	OMS_MAX                                            = 3
};*/

// Enum TgGame.TgPawn.OverlayMICType
/*enum OverlayMICType
{
	OMT_Outline                                        = 0,
	OMT_Fade                                           = 1,
	OMT_AthenaUltTarget                                = 2,
	OMT_HitPulse                                       = 3,
	OMT_ThanatosHarvester                              = 4,
	OMT_MAX                                            = 5
};*/

// Enum TgGame.TgPawn.TG_TELEPORT_STATE
/*enum TG_TELEPORT_STATE
{
	TELEPORT_NONE                                      = 0,
	TELEPORT_ENTER                                     = 1,
	TELEPORT_EXIT                                      = 2,
	TELEPORT_ENTER_BLINK                               = 3,
	TELEPORT_EXIT_BLINK                                = 4,
	TELEPORT_ENTER_THOR_HAMMER                         = 5,
	TELEPORT_EXIT_THOR_HAMMER                          = 6,
	TELEPORT_ISIS_IDMET_BUILDUP                        = 7,
	TELEPORT_ISIS_IDMET_HUMANOID                       = 8,
	TELEPORT_LOKI_ASSASSINATE_ENTER                    = 9,
	TELEPORT_LOKI_ASSASSINATE_EXIT                     = 10,
	TELEPORT_NEITH_REBOUND_FROM_HUMANOID               = 11,
	TELEPORT_NEITH_REBOUND_FROM_BROKENWEAVE            = 12,
	TELEPORT_NEITH_UNRAVEL_AOE                         = 13,
	TELEPORT_DAMAGE_REDIRECT                           = 14,
	TELEPORT_HUNBATZ_ENTER                             = 15,
	TELEPORT_HUNBATZ_EXIT                              = 16,
	TELEPORT_FREYA_PULSE_AOE                           = 17,
	TELEPORT_HEL_REBOUND_RESTORATION                   = 18,
	TELEPORT_AHMUZENCAB_SWARM_INFECT                   = 19,
	TELEPORT_AHMUZENCAB_HIVE_HEAL                      = 20,
	TELEPORT_NEMESIS_PARRY                             = 21,
	TELEPORT_SCYLLA_COBRA_STRIKE                       = 22,
	TELEPORT_SCYLLA_COBRA_EXPLOSION                    = 23,
	TELEPORT_KUMBHAKARNA_BELLYBUCK                     = 24,
	TELEPORT_KUMBHAKARNA_UPPERCUT                      = 25,
	TELEPORT_KUMBHAKARNA_SLEEPTAKEHIT                  = 26,
	TELEPORT_AUTOPORTAL_ENTER                          = 27,
	TELEPORT_AUTOPORTAL_EXIT                           = 28,
	TELEPORT_SIEGE_EXIT                                = 29,
	TELEPORT_LASTBREATH_EXPLOSION                      = 30,
	TELEPORT_SERQET_AMBUSH_ON                          = 31,
	TELEPORT_SERQET_AMBUSH_OFF                         = 32,
	TELEPORT_NUWA_ENVIRONMENT                          = 33,
	TELEPORT_ODIN_RAVENSHOUT_AOE                       = 34,
	TELEPORT_ARACHNE_COCOON_EXPLOSION                  = 35,
	TELEPORT_ENTER_AO_WATER                            = 36,
	TELEPORT_EXIT_AO_WATER                             = 37,
	TELEPORT_HOUYI_DIVEBOMB_EXPLOSION                  = 38,
	TELEPORT_CUPID_HEARTBOMB_INSTANT                   = 39,
	TELEPORT_AHPUCH_CORPSE_WARMUP                      = 40,
	TELEPORT_SOL_REAPPEAR                              = 41,
	TELEPORT_G72_FLASH                                 = 42,
	TELEPORT_RAIJIN_THUNDER_ENTER                      = 43,
	TELEPORT_RAIJIN_THUNDER_EXIT                       = 44,
	TELEPORT_KALDR_ENTER                               = 45,
	TELEPORT_KALDR_EXIT                                = 46,
	TELEPORT_ERLANG_SHEN_DOG_ENTER                     = 47,
	TELEPORT_ERLANG_SHEN_DOG_EXIT                      = 48,
	TELEPORT_RELIC_ENTER                               = 49,
	TELEPORT_RELIC_EXIT                                = 50,
	TELEPORT_ANUBIS_ENVIRONMENT                        = 51,
	TELEPORT_APEP_STRIKE                               = 52,
	TELEPORT_MAX                                       = 53
};*/

// Enum TgGame.TgPawn.EFloorPortalState
/*enum EFloorPortalState
{
	FLOOR_PORTAL_NONE                                  = 0,
	FLOOR_PORTAL_PRETELEPORT                           = 1,
	FLOOR_PORTAL_POSTTELEPORT                          = 2,
	FLOOR_PORTAL_MAX                                   = 3
};*/

// Enum TgGame.TgPawn.EHitReactionType
/*enum EHitReactionType
{
	HIT_REACTION_Anim                                  = 0,
	HIT_Reaction_Procedural                            = 1,
	HIT_MAX                                            = 2
};*/

// Enum TgGame.TgPawn.ECollisionTransitionState
/*enum ECollisionTransitionState
{
	COLTRAN_None                                       = 0,
	COLTRAN_On                                         = 1,
	COLTRAN_Off                                        = 2,
	COLTRAN_MAX                                        = 3
};*/

// Enum TgGame.TgSpecialFx.ELightFxState
/*enum ELightFxState
{
	LFX_UNMANAGED                                      = 0,
	LFX_ACTIVE                                         = 1,
	LFX_KILLEDBYMGR                                    = 2,
	LFX_DYING                                          = 3,
	LFX_INACTIVE                                       = 4,
	LFX_MAX                                            = 5
};*/

// Enum TgGame.TgPawn.ESkinLevelMechanic
/*enum ESkinLevelMechanic
{
	SLM_Manual                                         = 0,
	SLM_Auto                                           = 1,
	SLM_MAX                                            = 2
};*/

// Enum TgGame.TgPawn.ENewChargeState
/*enum ENewChargeState
{
	NEWCHARGE_None                                     = 0,
	NEWCHARGE_Accel                                    = 1,
	NEWCHARGE_MAX                                      = 2
};*/

// Enum TgGame.TgProperty.TG_PAWN_PROPERTIES
/*enum TG_PAWN_PROPERTIES
{
	TGPIDX_ATTACK_SPEED                                = 0,
	TGPIDX_CHARACTER_VISION_RANGE                      = 1,
	TGPIDX_COOLDOWN_REDUCTION_PERC                     = 2,
	TGPIDX_CRITICAL_STRIKE                             = 3,
	TGPIDX_CRITICAL_STRIKE_DAMAGE                      = 4,
	TGPIDX_CRITICAL_STRIKE_DIMINISHING                 = 5,
	TGPIDX_DEPLOY_RATE_MODIFIER                        = 6,
	TGPIDX_ENERGY_MAX                                  = 7,
	TGPIDX_ENERGY                                      = 8,
	TGPIDX_EP5                                         = 9,
	TGPIDX_GOLD_GAIN_PERC                              = 10,
	TGPIDX_GOLD_PER_5_PERC                             = 11,
	TGPIDX_GROUND_SPEED                                = 12,
	TGPIDX_HEALTH_MAX                                  = 13,
	TGPIDX_HEALTH_MAX_PERCENT                          = 14,
	TGPIDX_HEALTH                                      = 15,
	TGPIDX_HP5                                         = 16,
	TGPIDX_MANA_MAX                                    = 17,
	TGPIDX_MANA                                        = 18,
	TGPIDX_MP5                                         = 19,
	TGPIDX_SHIELD                                      = 20,
	TGPIDX_SHIELD_MAX                                  = 21,
	TGPIDX_PENETRATION_MAGICAL                         = 22,
	TGPIDX_PENETRATION_MAGICAL_PERC                    = 23,
	TGPIDX_PENETRATION_PHYSICAL                        = 24,
	TGPIDX_PENETRATION_PHYSICAL_PERC                   = 25,
	TGPIDX_PHYSICAL_LIFESTEAL                          = 26,
	TGPIDX_LIFESTEAL_BLOCK                             = 27,
	TGPIDX_LIFESTEAL_REDUCTION                         = 28,
	TGPIDX_POWER_MAGICAL_BOT                           = 29,
	TGPIDX_POWER_PHYSICAL_BOT                          = 30,
	TGPIDX_PROTECTION_FEAR_AND_PANIC                   = 31,
	TGPIDX_PROTECTION_KNOCKBACK                        = 32,
	TGPIDX_PROTECTION_MAGICAL                          = 33,
	TGPIDX_PROTECTION_MAGICAL_PERC                     = 34,
	TGPIDX_PROTECTION_PHYSICAL                         = 35,
	TGPIDX_PROTECTION_PHYSICAL_PERC                    = 36,
	TGPIDX_PROTECTION_ROOT                             = 37,
	TGPIDX_PROTECTION_CRIPPLE                          = 38,
	TGPIDX_PROTECTION_SILENCE                          = 39,
	TGPIDX_PROTECTION_SLOW                             = 40,
	TGPIDX_PROTECTION_STUN                             = 41,
	TGPIDX_PROTECTION_MESMERIZE                        = 42,
	TGPIDX_PROTECTION_PULL                             = 43,
	TGPIDX_PROTECTION_ATTACK_SLOW                      = 44,
	TGPIDX_PROTECTION_CC                               = 45,
	TGPIDX_PROTECTION_VORTEX                           = 46,
	TGPIDX_CC_IMMUNITY                                 = 47,
	TGPIDX_BASIC_ATTACK_SLOW_IMMUNITY                  = 48,
	TGPIDX_ABSORB_BASIC_ATTACK                         = 49,
	TGPIDX_PUSHBACK                                    = 50,
	TGPIDX_REDUCTION_MAGICAL                           = 51,
	TGPIDX_REDUCTION_MAGICAL_PERC                      = 52,
	TGPIDX_REDUCTION_PHYSICAL                          = 53,
	TGPIDX_REDUCTION_PHYSICAL_PERC                     = 54,
	TGPIDX_REVIVE_REDUCTION_PERC                       = 55,
	TGPIDX_SILENT_MOVEMENT                             = 56,
	TGPIDX_SPELL_VAMP                                  = 57,
	TGPIDX_TAUNT                                       = 58,
	TGPIDX_XP_GAIN_PERC                                = 59,
	TGPIDX_POWER_PHYSICAL_PERC                         = 60,
	TGPIDX_POWER_MAGICAL_PERC                          = 61,
	TGPIDX_HEALING_TAKEN_PERC                          = 62,
	TGPIDX_DAMAGE_TAKEN_PERC                           = 63,
	TGPIDX_DAMAGE_DEALT_PERC                           = 64,
	TGPIDX_DAMAGE_DEALT_PERC_BASIC                     = 65,
	TGPIDX_POWER_PHYSICAL_ITEM                         = 66,
	TGPIDX_POWER_MAGICAL_ITEM                          = 67,
	TGPIDX_POWER_UTILITY_BOT                           = 68,
	TGPIDX_POWER_UTILITY_ITEM                          = 69,
	TGPIDX_SLOW_DIMINISHING                            = 70,
	TGPIDX_ATTACK_SLOW                                 = 71,
	TGPIDX_MINIMAP_WARD_VISION_PERC                    = 72,
	TGPIDX_MINIMAP_LOS_IGNORED                         = 73,
	TGPIDX_MINIMAP_DETECTOR                            = 74,
	TGPIDX_MINION_DAMAGE_BONUS                         = 75,
	TGPIDX_DODGE_BASIC                                 = 76,
	TGPIDX_NO_BACKPEDAL_PENALTY                        = 77,
	TGPIDX_GOLD_PER                                    = 78,
	TGPIDX_HP5_PERC                                    = 79,
	TGPIDX_BASIC_ATTACK_DAMAGE                         = 80,
	TGPIDX_PHYSICAL_IMMUNITY                           = 81,
	TGPIDX_MAGICAL_IMMUNITY                            = 82,
	TGPIDX_DAMAGE_TAKEN_PERC_PHYS                      = 83,
	TGPIDX_DAMAGE_TAKEN_PERC_MAG                       = 84,
	TGPIDX_DISABLE_CC_IMMUNITY_GLOW                    = 85,
	TGPIDX_POWER_HEALING_PERC_ITEM                     = 86,
	TGPIDX_OBJECTIVE_DAMAGE_BONUS                      = 87,
	TGPIDX_MANA_COST_MODIFIER                          = 88,
	TGPIDX_STRUCTURE_DAMAGE_MODIFIER                   = 89,
	TGPIDX_MAX                                         = 90
};*/

// Enum TgGame.TgAIController_Behavior.EUseDeviceAimType
/*enum EUseDeviceAimType
{
	AIDeviceAim_CombatTarget                           = 0,
	AIDeviceAim_Self                                   = 1,
	AIDeviceAim_MAX                                    = 2
};*/

// Enum TgGame.TgAIController_Behavior.EEffectGroupCategory
/*enum EEffectGroupCategory
{
	AIEffectCategory_None                              = 0,
	AIEffectCategory_Slow                              = 1,
	AIEffectCategory_Stun                              = 2,
	AIEffectCategory_Mesmerize                         = 3,
	AIEffectCategory_Knockback                         = 4,
	AIEffectCategory_Root                              = 5,
	AIEffectCategory_Silence                           = 6,
	AIEffectCategory_Disarm                            = 7,
	AIEffectCategory_Cripple                           = 8,
	AIEffectCategory_FearOrPanic                       = 9,
	AIEffectCategory_Taunt                             = 10,
	AIEffectCategory_Charm                             = 11,
	AIEffectCategory_MAX                               = 12
};*/

// Enum TgGame.TgAIController_Behavior.EBotDifficultyLevel
/*enum EBotDifficultyLevel
{
	AIDifficulty_Easy                                  = 0,
	AIDifficulty_Medium                                = 1,
	AIDifficulty_Hard                                  = 2,
	AIDifficulty_Pro                                   = 3,
	AIDifficulty_MAX                                   = 4
};*/

// Enum TgGame.TgAIController_Behavior.EActiveType
/*enum EActiveType
{
	AIActive_Meditation                                = 0,
	AIActive_HandOfGods                                = 1,
	AIActive_Sprint                                    = 2,
	AIActive_Ward                                      = 3,
	AIActive_Aegis                                     = 4,
	AIActive_Beads                                     = 5,
	AIActive_MAX                                       = 6
};*/

// Enum TgGame.TgAIController_Behavior.EConsumableType
/*enum EConsumableType
{
	AIConsumable_HealthPotion                          = 0,
	AIConsumable_ManaPotion                            = 1,
	AIConsumable_MultiPotion                           = 2,
	AIConsumable_Ward                                  = 3,
	AIConsumable_DamagePotion                          = 4,
	AIConsumable_DefensePotion                         = 5,
	AIConsumable_MAX                                   = 6
};*/

// Enum TgGame.TgAIController_Behavior.EJungleTargetType
/*enum EJungleTargetType
{
	AIJungleTarget_Attack                              = 0,
	AIJungleTarget_Mana                                = 1,
	AIJungleTarget_Speed                               = 2,
	AIJungleTarget_BackHarpies                         = 3,
	AIJungleTarget_MidHarpies                          = 4,
	AIJungleTarget_Boars                               = 5,
	AIJungleTarget_FireElementals                      = 6,
	AIJungleTarget_FireGiant                           = 7,
	AIJungleTarget_GoldFury                            = 8,
	AIJungleTarget_Nearest                             = 9,
	AIJungleTarget_AttackSpeed                         = 10,
	AIJungleTarget_MAX                                 = 11
};*/

// Enum TgGame.TgAIController_Behavior.ECombatTargetType
/*enum ECombatTargetType
{
	AICombatTarget_Any                                 = 0,
	AICombatTarget_God                                 = 1,
	AICombatTarget_Guardian                            = 2,
	AICombatTarget_Minion                              = 3,
	AICombatTarget_Tower                               = 4,
	AICombatTarget_JungleCamp                          = 5,
	AICombatTarget_Pet                                 = 6,
	AICombatTarget_Decoy                               = 7,
	AICombatTarget_Deployable                          = 8,
	AICombatTarget_GodBot                              = 9,
	AICombatTarget_GodHuman                            = 10,
	AICombatTarget_MAX                                 = 11
};*/

// Enum TgGame.TgAILocalPositionSolver.ERepulsorWeightMethod
/*enum ERepulsorWeightMethod
{
	RWM_Cubic                                          = 0,
	RWM_Lerp                                           = 1,
	RWM_Slerp                                          = 2,
	RWM_MAX                                            = 3
};*/

// Enum TgGame.TgAIObstacleAvoidance.EObstacleAvoidanceStatus
/*enum EObstacleAvoidanceStatus
{
	OAS_NoPath                                         = 0,
	OAS_Pathing                                        = 1,
	OAS_PathFinished                                   = 2,
	OAS_MAX                                            = 3
};*/

// Enum TgGame.TgPawn_Bellona.EBellonaWeaponSwapState
/*enum EBellonaWeaponSwapState
{
	SWAPSTATE_PreSwap                                  = 0,
	SWAPSTATE_DeviceSwapped                            = 1,
	SWAPSTATE_FullSwap                                 = 2,
	SWAPSTATE_MAX                                      = 3
};*/

// Enum TgGame.TgPawn_Bellona.EBellonaWeaponSet
/*enum EBellonaWeaponSet
{
	BWS_Sword                                          = 0,
	BWS_SwordShield                                    = 1,
	BWS_Hammer                                         = 2,
	BWS_Scourge                                        = 3,
	BWS_EmptyHands                                     = 4,
	BWS_MAX                                            = 5
};*/

// Enum TgGame.TgAnimBlendByDirection.EBlendDirTypes
/*enum EBlendDirTypes
{
	FBDir_Forward                                      = 0,
	FBDir_Back                                         = 1,
	FBDir_Left                                         = 2,
	FBDir_Right                                        = 3,
	FBDir_ForwardRight                                 = 4,
	FBDir_ForwardLeft                                  = 5,
	FBDir_BackRight                                    = 6,
	FBDir_BackLeft                                     = 7,
	FBDir_Standing                                     = 8,
	FBDir_None                                         = 9,
	FBDir_MAX                                          = 10
};*/

// Enum TgGame.TgAnimBlendByDirection.EBlendByDirectionSpeedType
/*enum EBlendByDirectionSpeedType
{
	EBBDST_Velocity                                    = 0,
	EBBDST_Accel                                       = 1,
	EBBDST_MAX                                         = 2
};*/

// Enum TgGame.TgAnimBlendByFall.EBlendFallTypes
/*enum EBlendFallTypes
{
	FBT_Up                                             = 0,
	FBT_UpLoop                                         = 1,
	FBT_Down                                           = 2,
	FBT_PreLand                                        = 3,
	FBT_Land                                           = 4,
	FBT_Jump                                           = 5,
	FBT_None                                           = 6,
	FBT_MAX                                            = 7
};*/

// Enum TgGame.TgAnimBlendByFire_ZhongKui.DemonScrollState
/*enum DemonScrollState
{
	DEMONSCROLL_CHARGING                               = 0,
	DEMONSCROLL_CHARGED                                = 1,
	DEMONSCROLL_DISCHARGING                            = 2,
	DEMONSCROLL_DISCHARGED                             = 3,
	DEMONSCROLL_MAX                                    = 4
};*/

// Enum TgGame.TgAnimBlendByFlying.EFlyDirTypes
/*enum EFlyDirTypes
{
	FDir_Forward                                       = 0,
	FDir_Back                                          = 1,
	FDir_Left                                          = 2,
	FDir_Right                                         = 3,
	FDir_Up                                            = 4,
	FDir_Down                                          = 5,
	FDir_UpMidair                                      = 6,
	FDir_None                                          = 7,
	FDir_MAX                                           = 8
};*/

// Enum TgGame.TgPawn_Freya.TgPawn_Freya_WeaponType
/*enum TgPawn_Freya_WeaponType
{
	TGPFWT_MELEE                                       = 0,
	TGPFWT_RANGED                                      = 1,
	TGPFWT_ULTIMATE                                    = 2,
	TGPFWT_MAX                                         = 3
};*/

// Enum TgGame.TgAnimBlendBySpeed.ESpeedType
/*enum ESpeedType
{
	EST_Velocity                                       = 0,
	EST_AccelAndMaxSpeed                               = 1,
	EST_MAX                                            = 2
};*/

// Enum TgGame.TgAnimMetaData_SkelControl_BoneScale_KeyFrame.EOnRelevanceChange
/*enum EOnRelevanceChange
{
	ORC_NORMAL                                         = 0,
	ORC_FORCE_KEYFRAME                                 = 1,
	ORC_FORCE_ACTIVE                                   = 2,
	ORC_FORCE_INACTIVE                                 = 3,
	ORC_FORCE_OTHER                                    = 4,
	ORC_MAX                                            = 5
};*/

// Enum TgGame.TgAnimNodeBlendByKnockdown.EKnockDownChildren
/*enum EKnockDownChildren
{
	KNOCKDOWNANIM_Input                                = 0,
	KNOCKDOWNANIM_DownState                            = 1,
	KNOCKDOWNANIM_GetUp                                = 2,
	KNOCKDOWNANIM_MAX                                  = 3
};*/

// Enum TgGame.TgAnimNodeBlendList_EquipScreen.EEquipScreenAnimTypes
/*enum EEquipScreenAnimTypes
{
	ESAT_Default                                       = 0,
	ESAT_Weapon                                        = 1,
	ESAT_Helmet                                        = 2,
	ESAT_Backpack                                      = 3,
	ESAT_Suit                                          = 4,
	ESAT_MAX                                           = 5
};*/

// Enum TgGame.TgPawn_Thoth.EThothInhandState
/*enum EThothInhandState
{
	ThothInhandState_Basic                             = 0,
	ThothInhandState_Dev1                              = 1,
	ThothInhandState_Dev2                              = 2,
	ThothInhandState_Dev4                              = 3,
	ThothInhandState_MAX                               = 4
};*/

// Enum TgGame.TgAnimNodeBlendNPC.NPCAnimationStates
/*enum NPCAnimationStates
{
	NPCAS_NoCustomerPresent                            = 0,
	NPCAS_CustomerPresent                              = 1,
	NPCAS_Greeting                                     = 2,
	NPCAS_NoSale                                       = 3,
	NPCAS_CallOut                                      = 4,
	NPCAS_Sale                                         = 5,
	NPCAS_TransCustomerPresentToNotPresent             = 6,
	NPCAS_None                                         = 7,
	NPCAS_MAX                                          = 8
};*/

// Enum TgGame.TgAnimNodeFidget.EFidgetType
/*enum EFidgetType
{
	FT_Timed                                           = 0,
	FT_ChanceOnIdleCompletes                           = 1,
	FT_MAX                                             = 2
};*/

// Enum TgGame.TgAnimNotify_AudioGroup.TG_MESH_SOURCE
/*enum TG_MESH_SOURCE
{
	TG_MESH_SOURCE_PAWN                                = 0,
	TG_MESH_SOURCE_IN_HAND_DEVICE                      = 1,
	TG_MESH_SOURCE_MAX                                 = 2
};*/

// Enum TgGame.TgAnimNotify_InterpolateMorphTargetWeight.InterruptMorphTargetBehavior
/*enum InterruptMorphTargetBehavior
{
	ResetToInitial                                     = 0,
	ResetToValue                                       = 1,
	RestToTarget                                       = 2,
	InterruptMorphTargetBehavior_MAX                   = 3
};*/

// Enum TgGame.TgAnimNotify_ToggleMeshAttachment.eMeshAssemblyType
/*enum eMeshAssemblyType
{
	EMT_NONE                                           = 0,
	EMT_MATCH                                          = 1,
	EMT_VICTORY                                        = 2,
	EMT_DEFEAT                                         = 3,
	EMT_MAX                                            = 4
};*/

// Enum TgGame.TgAnimNotify_ToggleRigidBodies.ERigidBodyFixationChange
/*enum ERigidBodyFixationChange
{
	RBF_Fix                                            = 0,
	RBF_Unfix                                          = 1,
	RBF_Toggle                                         = 2,
	RBF_MAX                                            = 3
};*/

// Enum TgGame.TgAnimTurnInPlace.ForcedTransitionAngle
/*enum ForcedTransitionAngle
{
	FTA_NONE                                           = 0,
	FTA                                                = 1,
	FTA01                                              = 2,
	FTA_MAX                                            = 3
};*/

// Enum TgGame.TgBotFactory.eBotSelection
/*enum eBotSelection
{
	BS_RANDOM                                          = 0,
	BS_SEQUENTIAL                                      = 1,
	BS_MAX                                             = 2
};*/

// Enum TgGame.TgRepInfo_Factory_FireGiantGC2015a.EFireGiantChestState
/*enum EFireGiantChestState
{
	CHEST_CLOSED                                       = 0,
	CHEST_OPENING                                      = 1,
	CHEST_OPENED                                       = 2,
	CHEST_MAX                                          = 3
};*/

// Enum TgGame.TgBotFactory_Minions.MinionFactoryType
/*enum MinionFactoryType
{
	MFT_Conquest                                       = 0,
	MFT_Joust                                          = 1,
	MFT_Assault                                        = 2,
	MFT_Mayan                                          = 3,
	MFT_Other                                          = 4,
	MFT_ConquestS2                                     = 5,
	MFT_JoustS2                                        = 6,
	MFT_Clash_Egypt                                    = 7,
	MFT_MAX                                            = 8
};*/

// Enum TgGame.TgCameraModifier_LobbyCameraTransition.CameraTransType
/*enum CameraTransType
{
	CTT_None                                           = 0,
	CTT_PanRight                                       = 1,
	CTT_PanLeft                                        = 2,
	CTT_PanUp                                          = 3,
	CTT_PanDown                                        = 4,
	CTT_MAX                                            = 5
};*/

// Enum TgGame.TgCharmComponent_Serqet.EFiringState
/*enum EFiringState
{
	FIRINGSTATE_NONE                                   = 0,
	FIRINGSTATE_PREHIT                                 = 1,
	FIRINGSTATE_POSTHIT                                = 2,
	FIRINGSTATE_MAX                                    = 3
};*/

// Enum TgGame.TgClientSettings.ECastMode
/*enum ECastMode
{
	CM_Default                                         = 0,
	CM_Quick                                           = 1,
	CM_Instant                                         = 2,
	CM_Use_Global                                      = 3,
	CM_MAX                                             = 4
};*/

// Enum TgGame.TgClientSettings.EFriendStateNotifications
/*enum EFriendStateNotifications
{
	FSN_Never                                          = 0,
	FSN_Lobby_Only                                     = 1,
	FSN_InGame_Only                                    = 2,
	FSN_Always                                         = 3,
	FSN_MAX                                            = 4
};*/

// Enum TgGame.TgClientSettings.ENamePlateName
/*enum ENamePlateName
{
	NPN_PlayerName                                     = 0,
	NPN_GodName                                        = 1,
	NPN_None                                           = 2,
	NPN_MAX                                            = 3
};*/

// Enum TgGame.TgClientSettings.EColorBlindOption
/*enum EColorBlindOption
{
	CB_None                                            = 0,
	CB_Protanope                                       = 1,
	CB_Deuteranope                                     = 2,
	CB_Tritanope                                       = 3,
	CB_MAX                                             = 4
};*/

// Enum TgGame.TgClientSettings.ETgClientSettingVersion
/*enum ETgClientSettingVersion
{
	TCSV_Baseline                                      = 0,
	TCSV_Season3Launch                                 = 1,
	TCSV_MAX                                           = 2
};*/

// Enum TgGame.TgPlayerController.EWatchOtherPlayersMode
/*enum EWatchOtherPlayersMode
{
	WOPM_NONE                                          = 0,
	WOPM_PLAYER                                        = 1,
	WOPM_MAX                                           = 2
};*/

// Enum TgGame.TgPlayerController.EGiveGoldResult
/*enum EGiveGoldResult
{
	GGR_PlayerNotFound                                 = 0,
	GGR_PlayerNotFriendly                              = 1,
	GGR_NotEnoughGold                                  = 2,
	GGR_Success                                        = 3,
	GGR_MAX                                            = 4
};*/

// Enum TgGame.TgSpectatorController.EZoomState
/*enum EZoomState
{
	ZOOM_None                                          = 0,
	ZOOM_In                                            = 1,
	ZOOM_Out                                           = 2,
	ZOOM_MAX                                           = 3
};*/

// Enum TgGame.TgSpectatorController.SpecFlightMode
/*enum SpecFlightMode
{
	SFM_Normal                                         = 0,
	SFM_Heli                                           = 1,
	SFM_HeliNoVert                                     = 2,
	SFM_MAX                                            = 3
};*/

// Enum TgGame.TgSpectatorController.SpectatorCameraMode
/*enum SpectatorCameraMode
{
	SpecCam_None                                       = 0,
	SpecCam_Fly                                        = 1,
	SpecCam_FollowThirdPerson                          = 2,
	SpecCam_FollowTopDown                              = 3,
	SpecCam_Camera                                     = 4,
	SpecCam_Overview                                   = 5,
	SpecCam_LockedView                                 = 6,
	SpecCam_MAX                                        = 7
};*/

// Enum TgGame.TgSpectatorController.SpectatorCameraCycle
/*enum SpectatorCameraCycle
{
	SpecCycle_None                                     = 0,
	SpecCycle_PlayerFriendly                           = 1,
	SpecCycle_PlayerEnemy                              = 2,
	SpecCycle_Player                                   = 3,
	SpecCycle_TowerFriendly                            = 4,
	SpecCycle_TowerEnemy                               = 5,
	SpecCycle_Tower                                    = 6,
	SpecCycle_Cinematic                                = 7,
	SpecCycle_Action                                   = 8,
	SpecCycle_MAX                                      = 9
};*/

// Enum TgGame.TgSpectatorController.ESpectatorMode
/*enum ESpectatorMode
{
	SPECMODE_Manual                                    = 0,
	SPECMODE_Director                                  = 1,
	SPECMODE_Assisted                                  = 2,
	SPECMODE_Broadcast1                                = 3,
	SPECMODE_Broadcast2                                = 4,
	SPECMODE_Broadcast3                                = 5,
	SPECMODE_Broadcast4                                = 6,
	SPECMODE_MAX                                       = 7
};*/

// Enum TgGame.TgDeploy_ForceField.TG_DAMAGETYPE_INDEX
/*enum TG_DAMAGETYPE_INDEX
{
	TDT_THERMAL                                        = 0,
	TDT_PHYSICAL                                       = 1,
	TDT_MAGICAL                                        = 2,
	TDT_BIO                                            = 3,
	TDT_MAX                                            = 4
};*/

// Enum TgGame.TgDeploy_Artillery.ArtilleryType
/*enum ArtilleryType
{
	Artillery_Player                                   = 0,
	Artillery_Self                                     = 1,
	Artillery_MAX                                      = 2
};*/

// Enum TgGame.TgDeployable_Susano_Dev4_Typhoon.ESusanoTyphoonState
/*enum ESusanoTyphoonState
{
	TGPAWN_STS_None                                    = 0,
	TGPAWN_STS_Growing                                 = 1,
	TGPAWN_STS_Traveling                               = 2,
	TGPAWN_STS_MAX                                     = 3
};*/

// Enum TgGame.TgDeployable_Terra_CrushingShale.ETerraCrushingShaleDestructionState
/*enum ETerraCrushingShaleDestructionState
{
	ShaleDestroyed_Crush                               = 0,
	ShaleDestroyed_Shatter                             = 1,
	ShaleDestroyed_Timeout                             = 2,
	ShaleDestroyed_MAX                                 = 3
};*/

// Enum TgGame.TgTimerManager.TGT_EVENT
/*enum TGT_EVENT
{
	TGTE_DONE                                          = 0,
	TGTE_START                                         = 1,
	TGTE_UPDATE                                        = 2,
	TGTE_PAUSED                                        = 3,
	TGTE_MAX                                           = 4
};*/

// Enum TgGame.TgDevice.ETargetingModeStatus
/*enum ETargetingModeStatus
{
	TMS_None                                           = 0,
	TMS_PreFire                                        = 1,
	TMS_CannotFire                                     = 2,
	TMS_CannotPlace                                    = 3,
	TMS_OK                                             = 4,
	TMS_MAX                                            = 5
};*/

// Enum TgGame.TgDevice.EWeaponFireType
/*enum EWeaponFireType
{
	EWFT_InstantHit                                    = 0,
	EWFT_Projectile                                    = 1,
	EWFT_Custom                                        = 2,
	EWFT_Arcing                                        = 3,
	EWFT_Melee                                         = 4,
	EWFT_None                                          = 5,
	EWFT_MAX                                           = 6
};*/

// Enum TgGame.TgDevice.EDeviceChangeEvent
/*enum EDeviceChangeEvent
{
	DCE_Created                                        = 0,
	DCE_ToggleState                                    = 1,
	DCE_CanFire                                        = 2,
	DCE_Selected                                       = 3,
	DCE_Cooldown                                       = 4,
	DCE_PtsAlloc                                       = 5,
	DCE_Refire                                         = 6,
	DCE_InstanceCount                                  = 7,
	DCE_DeviceBuildup                                  = 8,
	DCE_MAX                                            = 9
};*/

// Enum TgGame.TgDevice_TwoPhase.ETwoPhaseState
/*enum ETwoPhaseState
{
	DTP_Normal                                         = 0,
	DTP_Waiting                                        = 1,
	DTP_AltFireReady                                   = 2,
	DTP_AltFireActive                                  = 3,
	DTP_MAX                                            = 4
};*/

// Enum TgGame.TgDevice_TwoPhase.ETwoPhaseCustomValueType
/*enum ETwoPhaseCustomValueType
{
	DTPCV_NormalFire                                   = 0,
	DTPCV_AltFire                                      = 1,
	DTPCV_Never                                        = 2,
	DTPCV_MAX                                          = 3
};*/

// Enum TgGame.TgDevice_TimerFromParent.ETargetingTimerCheckpointType
/*enum ETargetingTimerCheckpointType
{
	TTCT_BuildUp                                       = 0,
	TTCT_StartFire                                     = 1,
	TTCT_Fire                                          = 2,
	TTCT_StopFire                                      = 3,
	TTCT_MAX                                           = 4
};*/

// Enum TgGame.TgDevice_Staging.EBlockAegisType
/*enum EBlockAegisType
{
	BAT_Never                                          = 0,
	BAT_BuildUp                                        = 1,
	BAT_WhileFiring                                    = 2,
	BAT_FullFireLoop                                   = 3,
	BAT_MAX                                            = 4
};*/

// Enum TgGame.TgDevice_TogglableDeployable.ETogglableDeployableState
/*enum ETogglableDeployableState
{
	TDS_Normal                                         = 0,
	TDS_Waiting                                        = 1,
	TDS_ToggleReady                                    = 2,
	TDS_MAX                                            = 3
};*/

// Enum TgGame.TgDevice_BastetPounce.EBastetPounceState
/*enum EBastetPounceState
{
	BPS_Normal                                         = 0,
	BPS_InForwardWaiting                               = 1,
	BPS_ShouldPounceBack                               = 2,
	BPS_InBackwardWaiting                              = 3,
	BPS_MAX                                            = 4
};*/

// Enum TgGame.TgDevice_Charge.ChargeFiringType
/*enum ChargeFiringType
{
	CFT_Fire                                           = 0,
	CFT_PreFire                                        = 1,
	CFT_PostFire                                       = 2,
	CFT_MAX                                            = 3
};*/

// Enum TgGame.TgDevice_Charge.ChargeStopOnHitType
/*enum ChargeStopOnHitType
{
	CSHT_None                                          = 0,
	CSHT_AnyValidTarget                                = 1,
	CSHT_GodOnly                                       = 2,
	CSHT_NotGod                                        = 3,
	CSHT_MAX                                           = 4
};*/

// Enum TgGame.TgDevice_Charge.ChargeEndState
/*enum ChargeEndState
{
	CES_Miss                                           = 0,
	CES_Hit                                            = 1,
	CES_Interrupted                                    = 2,
	CES_MAX                                            = 3
};*/

// Enum TgGame.TgDevice_Bellona_ShieldBash.EShieldBashState
/*enum EShieldBashState
{
	BASH_INACTIVE                                      = 0,
	BASH_START                                         = 1,
	BASH_ACTIVE                                        = 2,
	BASH_MAX                                           = 3
};*/

// Enum TgGame.TgDevice_Bellona_SpinToStrike.ESpinToStrikeState
/*enum ESpinToStrikeState
{
	STRIKE_INACTIVE                                    = 0,
	STRIKE_START                                       = 1,
	STRIKE_ACTIVE                                      = 2,
	STRIKE_MAX                                         = 3
};*/

// Enum TgGame.TgPawn_ErlangShen.ERLANG_SHEN_TRANSFORM
/*enum ERLANG_SHEN_TRANSFORM
{
	ERLANG_SHEN_TRANSFORM_SELF                         = 0,
	ERLANG_SHEN_TRANSFORM_MINK                         = 1,
	ERLANG_SHEN_TRANSFORM_TURTLE                       = 2,
	ERLANG_SHEN_TRANSFORM_MAX                          = 3
};*/

// Enum TgGame.TgDevice_G72_Dev1.G72_AuraType
/*enum G72_AuraType
{
	G72A_AWis                                          = 0,
	G72A_AVal                                          = 1,
	G72A_MAX                                           = 2
};*/

// Enum TgGame.TgDevice_Monkey_FuriousMonkey.EFuriousMonkeyState
/*enum EFuriousMonkeyState
{
	FMS_Normal                                         = 0,
	FMS_ProjectileOut                                  = 1,
	FMS_PostProjectile                                 = 2,
	FMS_MAX                                            = 3
};*/

// Enum TgGame.TgDevice_Neith_BrokenWeave.WeaveSpawnType
/*enum WeaveSpawnType
{
	TG_WEAVESPAWNTYPE_BACKFLIP                         = 0,
	TG_WEAVESPAWNTYPE_PAWNDEATH                        = 1,
	TG_WEAVESPAWNTYPE_UNTRACKED                        = 2,
	TG_WEAVESPAWNTYPE_MAX                              = 3
};*/

// Enum TgGame.TgDevice_NuWa_Passive.CRYSTAL_TYPE
/*enum CRYSTAL_TYPE
{
	CRYSTAL_TYPE_NONE                                  = 0,
	CRYSTAL_TYPE_AURA                                  = 1,
	CRYSTAL_TYPE_SELF                                  = 2,
	CRYSTAL_TYPE_MAX                                   = 3
};*/

// Enum TgGame.TgDevice_Raijin_Dev4.EBeatSelect
/*enum EBeatSelect
{
	BEAT                                               = 0,
	BEAT01                                             = 1,
	BEAT02                                             = 2,
	BEAT_MAX                                           = 3
};*/

// Enum TgGame.TgDevice_Raijin_KotoDrums.EKotoBeat
/*enum EKotoBeat
{
	KOTO                                               = 0,
	KOTO01                                             = 1,
	KOTO02                                             = 2,
	KOTO_MAX                                           = 3
};*/

// Enum TgGame.TgDevice_Scylla_Num3.EScyllaSentinelState
/*enum EScyllaSentinelState
{
	SSS_Normal                                         = 0,
	SSS_Waiting                                        = 1,
	SSS_ToggleReady                                    = 2,
	SSS_ToggleActive                                   = 3,
	SSS_MAX                                            = 4
};*/

// Enum TgGame.TgPawn_Sol.ESolUltState
/*enum ESolUltState
{
	SUS_Inactive                                       = 0,
	SUS_Charging                                       = 1,
	SUS_Exploded                                       = 2,
	SUS_MAX                                            = 3
};*/

// Enum TgGame.TgPawn_Sol.ESolInstabilityState
/*enum ESolInstabilityState
{
	SOL_INSTABILITY_None                               = 0,
	SOL_INSTABILITY_Stage1                             = 1,
	SOL_INSTABILITY_Stage2                             = 2,
	SOL_INSTABILITY_MAX                                = 3
};*/

// Enum TgGame.TgPawn_SunWukong.WUKONG_OX_HIT_ANIM
/*enum WUKONG_OX_HIT_ANIM
{
	WUKONG_OX_HIT_ANIM_LEFT                            = 0,
	WUKONG_OX_HIT_ANIM_RIGHT                           = 1,
	WUKONG_OX_HIT_ANIM_MAX                             = 2
};*/

// Enum TgGame.TgPawn_SunWukong.WUKONG_ULTIMATE
/*enum WUKONG_ULTIMATE
{
	WUKONG_ULTIMATE_INACTIVE                           = 0,
	WUKONG_ULTIMATE_BUILDUP                            = 1,
	WUKONG_ULTIMATE_LEAPBACK                           = 2,
	WUKONG_ULTIMATE_EAT                                = 3,
	WUKONG_ULTIMATE_ATTACK                             = 4,
	WUKONG_ULTIMATE_CANCEL                             = 5,
	WUKONG_ULTIMATE_DEATH                              = 6,
	WUKONG_ULTIMATE_MAX                                = 7
};*/

// Enum TgGame.TgPawn_SunWukong.WUKONG_TRANSFORM
/*enum WUKONG_TRANSFORM
{
	WUKONG_TRANSFORM_SELF                              = 0,
	WUKONG_TRANSFORM_EAGLE                             = 1,
	WUKONG_TRANSFORM_TIGER                             = 2,
	WUKONG_TRANSFORM_OX                                = 3,
	WUKONG_TRANSFORM_MAX                               = 4
};*/

// Enum TgGame.TgDevice_Susano_Dev3.ESusanoDev3State
/*enum ESusanoDev3State
{
	SusanoWindState_Inactive                           = 0,
	SusanoWindState_ProjFired                          = 1,
	SusanoWindState_WaitForTeleport                    = 2,
	SusanoWindState_MAX                                = 3
};*/

// Enum TgGame.TgDevice_Terra_CrushingShale.ETerraDev3State
/*enum ETerraDev3State
{
	TerraDev3State_Inactive                            = 0,
	TerraDev3State_Deploying                           = 1,
	TerraDev3State_Deployed                            = 2,
	TerraDev3State_Crush                               = 3,
	TerraDev3State_WallDestroyed                       = 4,
	TerraDev3State_MAX                                 = 5
};*/

// Enum TgGame.TgDevice_WarningDeployable.EWarningDeployableTimingType
/*enum EWarningDeployableTimingType
{
	WDTT_Buildup                                       = 0,
	WDTT_StartFire                                     = 1,
	WDTT_Fire                                          = 2,
	WDTT_ProjectileShutdown                            = 3,
	WDTT_StopFire                                      = 4,
	WDTT_MAX                                           = 5
};*/

// Enum TgGame.TgDevice_XingTian_AxeSweepShieldBash.EXingAttackState
/*enum EXingAttackState
{
	ATTACK_INACTIVE                                    = 0,
	ATTACK_SWEEP                                       = 1,
	ATTACK_BASH                                        = 2,
	ATTACK_MAX                                         = 3
};*/

// Enum TgGame.TgDevice_Zeus_SuperLightningBolt.ELightningBoltState
/*enum ELightningBoltState
{
	LBS_Normal                                         = 0,
	LBS_ProjectileOut                                  = 1,
	LBS_PostProjectile                                 = 2,
	LBS_MAX                                            = 3
};*/

// Enum TgGame.TgDeviceFire.DeviceTargeterType
/*enum DeviceTargeterType
{
	TGDTT_None                                         = 0,
	TGDTT_Self                                         = 1,
	TGDTT_Friend                                       = 2,
	TGDTT_Enemy                                        = 3,
	TGDTT_Enemy_And_Self                               = 4,
	TGDTT_Friend_Only                                  = 5,
	TGDTT_Not_Self                                     = 6,
	TGDTT_All                                          = 7,
	TGDTT_MAX                                          = 8
};*/

// Enum TgGame.TgDeviceFire.ESweepType
/*enum ESweepType
{
	Sweep_Static                                       = 0,
	Sweep_Rotating                                     = 1,
	Sweep_Moving                                       = 2,
	Sweep_MAX                                          = 3
};*/

// Enum TgGame.TgRatatoskrAcorn.EAcornType
/*enum EAcornType
{
	ACORN_None                                         = 0,
	ACORN_White                                        = 1,
	ACORN_Blue                                         = 2,
	ACORN_Yellow                                       = 3,
	ACORN_Sapphire                                     = 4,
	ACORN_Emerald                                      = 5,
	ACORN_Opal                                         = 6,
	ACORN_Topaz                                        = 7,
	ACORN_MAX                                          = 8
};*/

// Enum TgGame.TgDistributionFloatSoundAttenuation.SoundAttenuationType
/*enum SoundAttenuationType
{
	TG_ATTENUATION_None                                = 0,
	TG_ATTENUATION_Sm_foley                            = 1,
	TG_ATTENUATION_Lg_foley                            = 2,
	TG_ATTENUATION_Melee_Hit                           = 3,
	TG_ATTENUATION_Sm_gun                              = 4,
	TG_ATTENUATION_Med_gun                             = 5,
	TG_ATTENUATION_Lg_gun                              = 6,
	TG_ATTENUATION_Sm_exp                              = 7,
	TG_ATTENUATION_Med_exp                             = 8,
	TG_ATTENUATION_Lg_exp                              = 9,
	TG_ATTENUATION_MAX                                 = 10
};*/

// Enum TgGame.TgDominantDirectionalLightSwitchableComponent.SwitchableDominantLightMode
/*enum SwitchableDominantLightMode
{
	SDLM_Unset                                         = 0,
	SDLM_Dynamic                                       = 1,
	SDLM_DominantDynamic                               = 2,
	SDLM_MAX                                           = 3
};*/

// Enum TgGame.TgDoorMarker.DoorStatus
/*enum DoorStatus
{
	TGD_NONE                                           = 0,
	TGD_LOCKED                                         = 1,
	TGD_OPEN                                           = 2,
	TGD_CLOSE                                          = 3,
	TGD_MAX                                            = 4
};*/

// Enum TgGame.TgEffectForm_BuffBelt.EBuffBeltPriority
/*enum EBuffBeltPriority
{
	BBP_Default                                        = 0,
	BBP_Debuff                                         = 1,
	BBP_InstigatorBuff                                 = 2,
	BBP_MAX                                            = 3
};*/

// Enum TgGame.TgEffectGroup.AttackType
/*enum AttackType
{
	TGAT_None                                          = 0,
	TGAT_Melee                                         = 1,
	TGAT_Range                                         = 2,
	TGAT_AOE                                           = 3,
	TGAT_Falling                                       = 4,
	TGAT_MAX                                           = 5
};*/

// Enum TgGame.TgEffectManager.ERevealType
/*enum ERevealType
{
	REVEAL_GLOBAL                                      = 0,
	REVEAL_TEAM                                        = 1,
	REVEAL_INSTIGATOR                                  = 2,
	REVEAL_MAX                                         = 3
};*/

// Enum TgGame.TgFlagContentData.FlagContentDataType
/*enum FlagContentDataType
{
	FCDT_None                                          = 0,
	FCDT_Egyptian_Lobby                                = 1,
	FCDT_Egyptian_Wall                                 = 2,
	FCDT_Norse_Lobby                                   = 3,
	FCDT_Norse_Wall                                    = 4,
	FCDT_Greek_Lobby                                   = 5,
	FCDT_Greek_Wall                                    = 6,
	FCDT_Roman_Lobby                                   = 7,
	FCDT_Roman_Wall                                    = 8,
	FCDT_Chinese_Lobby                                 = 9,
	FCDT_Chinese_Wall                                  = 10,
	FCDT_Mayan_Lobby                                   = 11,
	FCDT_Mayan_Wall                                    = 12,
	FCDT_Hindu_Lobby                                   = 13,
	FCDT_Hindu_Wall                                    = 14,
	FCDT_Japanese_Lobby                                = 15,
	FCDT_Japanese_Wall                                 = 16,
	FCDT_MAX                                           = 17
};*/

// Enum TgGame.TgRepInfo_Game.MAP_LANE
/*enum MAP_LANE
{
	MAP_LANE_NONE                                      = 0,
	MAP_LANE_LEFT                                      = 1,
	MAP_LANE_MIDDLE                                    = 2,
	MAP_LANE_RIGHT                                     = 3,
	MAP_LANE_MAX                                       = 4
};*/

// Enum TgGame.TgRepInfo_Game.MissionTimerState
/*enum MissionTimerState
{
	MTS_STOPPED                                        = 0,
	MTS_RUNNING                                        = 1,
	MTS_PAUSED                                         = 2,
	MTS_MAX                                            = 3
};*/

// Enum TgGame.TgRepInfo_Game.EFlagState
/*enum EFlagState
{
	FLAG_Home                                          = 0,
	FLAG_HeldFriendly                                  = 1,
	FLAG_HeldEnemy                                     = 2,
	FLAG_Down                                          = 3,
	FLAG_MAX                                           = 4
};*/

// Enum TgGame.TgGame_Battle_Encounters.ERoundState
/*enum ERoundState
{
	BERS_Purchasing                                    = 0,
	BERS_Transition                                    = 1,
	BERS_Active                                        = 2,
	BERS_Pass                                          = 3,
	BERS_Fail                                          = 4,
	BERS_MAX                                           = 5
};*/

// Enum TgGame.TgGame_Battle_Siege2.SIEGE2_BATTLE_PHASE
/*enum SIEGE2_BATTLE_PHASE
{
	SBP_DAY                                            = 0,
	SBP_NIGHT                                          = 1,
	SBP_MAX                                            = 2
};*/

// Enum TgGame.TgInventoryManager.PendingTransactionType
/*enum PendingTransactionType
{
	PTT_None                                           = 0,
	PTT_Purchase                                       = 1,
	PTT_Upgrade                                        = 2,
	PTT_Sell                                           = 3,
	PTT_UpgradeRetry                                   = 4,
	PTT_Swap                                           = 5,
	PTT_MAX                                            = 6
};*/

// Enum TgGame.TgInventoryObject.EReplicatedState
/*enum EReplicatedState
{
	IORS_Ok                                            = 0,
	IORS_Edited                                        = 1,
	IORS_Deleted                                       = 2,
	IORS_MAX                                           = 3
};*/

// Enum TgGame.TgInventoryObject_Listen_AhMuzenCabBees.EBeesApplyType
/*enum EBeesApplyType
{
	BEES_Default                                       = 0,
	BEES_BasicAttack                                   = 1,
	BEES_BasicAttackStrain                             = 2,
	BEES_MAX                                           = 3
};*/

// Enum TgGame.TgInventoryObject_Listen_SuccessfulHit.EDeviceSuccessfulHitType
/*enum EDeviceSuccessfulHitType
{
	SUCCESSFULHIT_PER_TICK                             = 0,
	SUCCESSFULHIT_PER_FIRE                             = 1,
	SUCCESSFULHIT_PER_MAX                              = 2
};*/

// Enum TgGame.TgLevelStreamingSpectator.SpectatorStreamingMethod
/*enum SpectatorStreamingMethod
{
	SSM_OnlyLoadIfSpectating                           = 0,
	SSM_OnlyLoadIfNotSpectating                        = 1,
	SSM_AlwaysLoad                                     = 2,
	SSM_MAX                                            = 3
};*/

// Enum TgGame.TgMenuContentData.MenuContentDataType
/*enum MenuContentDataType
{
	MCDT_None                                          = 0,
	MCDT_Login                                         = 1,
	MCDT_Login2                                        = 2,
	MCDT_Login3                                        = 3,
	MCDT_MainMenu                                      = 4,
	MCDT_MainMenu_Featured                             = 5,
	MCDT_MainMenu_Featured01                           = 6,
	MCDT_MainMenu_Featured02                           = 7,
	MCDT_MainMenu_Featured03                           = 8,
	MCDT_MainMenu_Featured04                           = 9,
	MCDT_MainMenu_Featured05                           = 10,
	MCDT_MainMenu_BetaPromo                            = 11,
	MCDT_MainMenu_GodPack                              = 12,
	MCDT_MainMenu_FacebookPromo                        = 13,
	MCDT_MainMenu_TwitterPromo                         = 14,
	MCDT_MainMenu_NewPlayer_Feature                    = 15,
	MCDT_MainMenu_NewPlayer_Feature01                  = 16,
	MCDT_MainMenu_NewPlayer_Feature02                  = 17,
	MCDT_Play                                          = 18,
	MCDT_Store                                         = 19,
	MCDT_Social_Friends                                = 20,
	MCDT_Social_Followers                              = 21,
	MCDT_Social_Blocked                                = 22,
	MCDT_Settings                                      = 23,
	MCDT_Lobby                                         = 24,
	MCDT_MAX                                           = 25
};*/

// Enum TgGame.TgNavRouteIndicator.eSetRouteResult
/*enum eSetRouteResult
{
	SetRoute_Failed                                    = 0,
	SetRoute_OK                                        = 1,
	SetRoute_AtDestination                             = 2,
	SetRoute_MAX                                       = 3
};*/

// Enum TgGame.TgPawn_AoKuang.EAoKuangUltimateState
/*enum EAoKuangUltimateState
{
	AO_ULT_NORMAL                                      = 0,
	AO_ULT_DASH                                        = 1,
	AO_ULT_NORMALSTUN                                  = 2,
	AO_ULT_MEGAKILLSTUN                                = 3,
	AO_ULT_DRAGONBUILDUP                               = 4,
	AO_ULT_DRAGONACTIVE                                = 5,
	AO_ULT_DRAGONTAKEDOWN                              = 6,
	AO_ULT_DRAGONCANCEL                                = 7,
	AO_ULT_DRAGONDEAD                                  = 8,
	AO_ULT_MAX                                         = 9
};*/

// Enum TgGame.TgPawn_AoKuang.EDragonBushelState
/*enum EDragonBushelState
{
	BUSHEL                                             = 0,
	BUSHEL01                                           = 1,
	BUSHEL02                                           = 2,
	BUSHEL03                                           = 3,
	BUSHEL04                                           = 4,
	BUSHEL05                                           = 5,
	BUSHEL06                                           = 6,
	BUSHEL_DISSIPATE                                   = 7,
	BUSHEL_COMBINE                                     = 8,
	BUSHEL_MAX                                         = 9
};*/

// Enum TgGame.TgPawn_AoKuang.AOKUANG_TRANSFORM
/*enum AOKUANG_TRANSFORM
{
	AOFORM_NORMAL                                      = 0,
	AOFORM_DRAGON                                      = 1,
	AOFORM_MAX                                         = 2
};*/

// Enum TgGame.TgPawn_Apollo.SkyJumpPhase
/*enum SkyJumpPhase
{
	SJP_None                                           = 0,
	SJP_Summon                                         = 1,
	SJP_Ascend                                         = 2,
	SJP_Riding                                         = 3,
	SJP_Dismount                                       = 4,
	SJP_Death                                          = 5,
	SJP_Death_While_Summon                             = 6,
	SJP_MAX                                            = 7
};*/

// Enum TgGame.TgPawn_ArachneV2.EArachneUltState
/*enum EArachneUltState
{
	ARACHNE_ULT_NORMAL                                 = 0,
	ARACHNE_ULT_BUILDUP                                = 1,
	ARACHNE_ULT_MAIN                                   = 2,
	ARACHNE_ULT_FIRED                                  = 3,
	ARACHNE_ULT_CANCELLED                              = 4,
	ARACHNE_ULT_DIED                                   = 5,
	ARACHNE_ULT_MAX                                    = 6
};*/

// Enum TgGame.TgPawn_WiseCleric.EDestroyAnimStages
/*enum EDestroyAnimStages
{
	TowerDestruction_FullHealth_Idle                   = 0,
	TowerDestruction_FirstDestruction                  = 1,
	TowerDestruction_SecondDestruction                 = 2,
	TowerDestruction_MAX                               = 3
};*/

// Enum TgGame.TgPawn_Athena.LeapingLungeState
/*enum LeapingLungeState
{
	LEAPINGLUNGE_INACTIVE                              = 0,
	LEAPINGLUNGE_ACTIVE                                = 1,
	LEAPINGLUNGE_HITTARGET                             = 2,
	LEAPINGLUNGE_MAX                                   = 3
};*/

// Enum TgGame.TgPawn_Awilix.eMoonlightState
/*enum eMoonlightState
{
	EML_UNBUFFED                                       = 0,
	EML_BUFFED                                         = 1,
	EML_MAX                                            = 2
};*/

// Enum TgGame.TgPawn_Awilix.eStarlightLanceState
/*enum eStarlightLanceState
{
	ESL_NONE                                           = 0,
	ESL_NORMAL                                         = 1,
	ESL_KNOCKUP                                        = 2,
	ESL_MAX                                            = 3
};*/

// Enum TgGame.TgPawn_Awilix.eMountState
/*enum eMountState
{
	EMS_NONE                                           = 0,
	EMS_MOUNTED                                        = 1,
	EMS_LEAP                                           = 2,
	EMS_CANCEL                                         = 3,
	EMS_MAX                                            = 4
};*/

// Enum TgGame.TgPawn_Bacchus.TgPawn_Bacchus_DrunkType
/*enum TgPawn_Bacchus_DrunkType
{
	TGPBDT_THIRSTY                                     = 0,
	TGPBDT_TIPSY                                       = 1,
	TGPBDT_SMASHED                                     = 2,
	TGPBDT_MAX                                         = 3
};*/

// Enum TgGame.TgPawn_Camazotz.ECamazotzUltState
/*enum ECamazotzUltState
{
	CAM_ULT_NORMAL                                     = 0,
	CAM_ULT_BUILDUP                                    = 1,
	CAM_ULT_MAIN                                       = 2,
	CAM_ULT_TAKEDOWN                                   = 3,
	CAM_ULT_DIED                                       = 4,
	CAM_ULT_MAX                                        = 5
};*/

// Enum TgGame.TgPawn_Camazotz.ECamazotzWeaponType
/*enum ECamazotzWeaponType
{
	CAM_WT_MELEE                                       = 0,
	CAM_WT_ULTIMATE                                    = 1,
	CAM_WT_MAX                                         = 2
};*/

// Enum TgGame.TgPawn_Fenrir.EBiteState
/*enum EBiteState
{
	BITE_None                                          = 0,
	BITE_Grow                                          = 1,
	BITE_BeforeGrab                                    = 2,
	BITE_Grab                                          = 3,
	BITE_Throwdown                                     = 4,
	BITE_Shrink                                        = 5,
	BITE_MAX                                           = 6
};*/

// Enum TgGame.TgPawn_Geb.GebBoulderState
/*enum GebBoulderState
{
	GBS_Normal                                         = 0,
	GBS_Boulder                                        = 1,
	GBS_BoulderHit                                     = 2,
	GBS_MAX                                            = 3
};*/

// Enum TgGame.TgPawn_GuanYuV2.GuanYuUltPhase
/*enum GuanYuUltPhase
{
	GUANYUV2_UltNone                                   = 0,
	GUANYUV2_UltPhase1                                 = 1,
	GUANYUV2_UltPhase2                                 = 2,
	GUANYUV2_MAX                                       = 3
};*/

// Enum TgGame.TgPawn_Guardian.EThroneState
/*enum EThroneState
{
	THRONE_ONTHRONE                                    = 0,
	THRONE_TRANSITIONING                               = 1,
	THRONE_OFFTHRONE                                   = 2,
	THRONE_MAX                                         = 3
};*/

// Enum TgGame.TgPawn_HelV3.HEL_STANCE
/*enum HEL_STANCE
{
	HEL_STANCE_DARK                                    = 0,
	HEL_STANCE_LIGHT                                   = 1,
	HEL_STANCE_INVALID                                 = 2,
	HEL_STANCE_MAX                                     = 3
};*/

// Enum TgGame.TgPawn_HouYi.EHouYiDivebombState
/*enum EHouYiDivebombState
{
	HDBS_None                                          = 0,
	HDBS_Buildup                                       = 1,
	HDBS_InAir                                         = 2,
	HDBS_Takedown                                      = 3,
	HDBS_DiedInAir                                     = 4,
	HDBS_MAX                                           = 5
};*/

// Enum TgGame.TgPawn_HouYi.EHouyiDev1State
/*enum EHouyiDev1State
{
	HDS_INACTIVE                                       = 0,
	HDS_CHARGING                                       = 1,
	HDS_ACTIVE                                         = 2,
	HDS_MAX                                            = 3
};*/

// Enum TgGame.TgPawn_JingWei.TGJingWeiDev4Phase
/*enum TGJingWeiDev4Phase
{
	TGJingWeiDev4Phase_Inactive                        = 0,
	TGJingWeiDev4Phase_Buildup                         = 1,
	TGJingWeiDev4Phase_Charge                          = 2,
	TGJingWeiDev4Phase_Floating                        = 3,
	TGJingWeiDev4Phase_Landing                         = 4,
	TGJingWeiDev4Phase_MAX                             = 5
};*/

// Enum TgGame.TgPawn_LanePusher.EDestroyedAnimStages
/*enum EDestroyedAnimStages
{
	EngineDestruction_FullHealth_Idle                  = 0,
	EngineDestruction_FirstDestruction                 = 1,
	EngineDestruction_SecondDestruction                = 2,
	EngineDestruction_MAX                              = 3
};*/

// Enum TgGame.TgPawn_Juggernaut.EJuggernautActiveArcher
/*enum EJuggernautActiveArcher
{
	ACTIVEARCHER_FRONT                                 = 0,
	ACTIVEARCHER_BACK                                  = 1,
	ACTIVEARCHER_MAX                                   = 2
};*/

// Enum TgGame.TgPawn_NeZha.WindFireWheelsPhase
/*enum WindFireWheelsPhase
{
	WFWP_None                                          = 0,
	WFWP_Miss                                          = 1,
	WFWP_LiftMiss                                      = 2,
	WFWP_SelfDied                                      = 3,
	WFWP_Lift                                          = 4,
	WFWP_Dash                                          = 5,
	WFWP_KnockDown                                     = 6,
	WFWP_Landed                                        = 7,
	WFWP_MAX                                           = 8
};*/

// Enum TgGame.TgPawn_NeZha.ArmillarySashPhase
/*enum ArmillarySashPhase
{
	ASP_None                                           = 0,
	ASP_Throw                                          = 1,
	ASP_Hit                                            = 2,
	ASP_Miss                                           = 3,
	ASP_MAX                                            = 4
};*/

// Enum TgGame.TgPawn_NeZha.NEZHA_PASSIVE_STATE
/*enum NEZHA_PASSIVE_STATE
{
	NPS_OUTOFCOMBAT                                    = 0,
	NPS_INCOMBAT                                       = 1,
	NPS_TRANSITION                                     = 2,
	NPS_MAX                                            = 3
};*/

// Enum TgGame.TgPawn_Nike.ENikeUltVisualsState
/*enum ENikeUltVisualsState
{
	NIKEULTVISUALS_ACTIVE                              = 0,
	NIKEULTVISUALS_INACTIVE                            = 1,
	NIKEULTVISUALS_MAX                                 = 2
};*/

// Enum TgGame.TgPawn_NuWa.NUWA_FORM
/*enum NUWA_FORM
{
	NUWA_FORM_NORMAL                                   = 0,
	NUWA_FORM_SNAKE                                    = 1,
	NUWA_FORM_MAX                                      = 2
};*/

// Enum TgGame.TgPawn_NuWaV2.ENuWaUltState
/*enum ENuWaUltState
{
	NUWA_ULT_NORMAL                                    = 0,
	NUWA_ULT_BUILDUP                                   = 1,
	NUWA_ULT_MAIN                                      = 2,
	NUWA_ULT_TAKEDOWN                                  = 3,
	NUWA_ULT_DIED                                      = 4,
	NUWA_ULT_MAX                                       = 5
};*/

// Enum TgGame.TgPawn_Osiris.EOsirisBodypartsMissing
/*enum EOsirisBodypartsMissing
{
	OBM_NONE                                           = 0,
	OBM_HAND_LEFT                                      = 1,
	OBM_HAND_RIGHT                                     = 2,
	OBM_ARM_LEFT                                       = 3,
	OBM_ARM_RIGHT                                      = 4,
	OBM_LEG_LEFT                                       = 5,
	OBM_LEG_RIGHT                                      = 6,
	OBM_HEAD                                           = 7,
	OBM_CHEST                                          = 8,
	OBM_MAX                                            = 9
};*/

// Enum TgGame.TgPawn_Osiris.ESoulTearState
/*enum ESoulTearState
{
	STS_None                                           = 0,
	STS_HitMinions                                     = 1,
	STS_HitGod                                         = 2,
	STS_MAX                                            = 3
};*/

// Enum TgGame.TgPawn_Ram.ERamUltState
/*enum ERamUltState
{
	RAM_ULT_NORMAL                                     = 0,
	RAM_ULT_BUILDUP                                    = 1,
	RAM_ULT_MAIN                                       = 2,
	RAM_ULT_TAKEDOWN                                   = 3,
	RAM_ULT_DIED                                       = 4,
	RAM_ULT_MAX                                        = 5
};*/

// Enum TgGame.TgPawn_Ram.ERamProjectile
/*enum ERamProjectile
{
	RIP_DEFAULT                                        = 0,
	RIP_QUIVER_TOGGLE                                  = 1,
	RIP_DODGE_SPECIAL                                  = 2,
	RIP_MAX                                            = 3
};*/

// Enum TgGame.TgPawn_Ratatoskr.ERatatoskrUltimateState
/*enum ERatatoskrUltimateState
{
	RATULT_None                                        = 0,
	RATULT_Targeting                                   = 1,
	RATULT_Buildup                                     = 2,
	RATULT_Climb                                       = 3,
	RATULT_TreeHopping                                 = 4,
	RATULT_Takedown                                    = 5,
	RATULT_DiedTree                                    = 6,
	RATULT_DiedFlying                                  = 7,
	RATULT_MAX                                         = 8
};*/

// Enum TgGame.TgPawn_Scylla.EScyllaUltimateState
/*enum EScyllaUltimateState
{
	SCYLLAULT_Normal                                   = 0,
	SCYLLAULT_Buildup                                  = 1,
	SCYLLAULT_Active                                   = 2,
	SCYLLAULT_Takedown                                 = 3,
	SCYLLAULT_DieInUlt                                 = 4,
	SCYLLAULT_MAX                                      = 5
};*/

// Enum TgGame.TgPawn_Thanatos.HoveringDeathState
/*enum HoveringDeathState
{
	HOVERINGDEATH_INACTIVE                             = 0,
	HOVERINGDEATH_GROUNDBUILDUP                        = 1,
	HOVERINGDEATH_RISING                               = 2,
	HOVERINGDEATH_INAIR                                = 3,
	HOVERINGDEATH_DASH                                 = 4,
	HOVERINGDEATH_GROUNDDEATH                          = 5,
	HOVERINGDEATH_AIRDEATH                             = 6,
	HOVERINGDEATH_MAX                                  = 7
};*/

// Enum TgGame.TgPawn_Tyr.ETyrStance
/*enum ETyrStance
{
	TYR_STANCE_Aggressive                              = 0,
	TYR_STANCE_Defensive                               = 1,
	TYR_STANCE_MAX                                     = 2
};*/

// Enum TgGame.TgPawn_Ullr.EUllrInhandWeapon
/*enum EUllrInhandWeapon
{
	UIW_RANGED                                         = 0,
	UIW_MELEE                                          = 1,
	UIW_MAX                                            = 2
};*/

// Enum TgGame.TgPawn_Ullr.EUllrEquippedDevice
/*enum EUllrEquippedDevice
{
	UED_Inhand                                         = 0,
	UED_Offhand1                                       = 1,
	UED_Offhand2                                       = 2,
	UED_Offhand3                                       = 3,
	UED_MAX                                            = 4
};*/

// Enum TgGame.TgPawn_Vamana.VAMANA_SIZE
/*enum VAMANA_SIZE
{
	VAMANA_SIZE_NORMAL                                 = 0,
	VAMANA_SIZE_GROWING                                = 1,
	VAMANA_SIZE_GIANT                                  = 2,
	VAMANA_SIZE_SHRINKING                              = 3,
	VAMANA_SIZE_MAX                                    = 4
};*/

// Enum TgGame.TgPawn_XingTian.EXingTianUltState
/*enum EXingTianUltState
{
	XTULT_None                                         = 0,
	XTULT_Spin                                         = 1,
	XTULT_Fling                                        = 2,
	XTULT_Miss                                         = 3,
	XTULT_MAX                                          = 4
};*/

// Enum TgGame.TgPawn_Zeus.EZeusShieldThrowState
/*enum EZeusShieldThrowState
{
	ZEUSSHIELD_ATTACHED                                = 0,
	ZEUSSHIELD_DETACHED                                = 1,
	ZEUSSHIELD_RECOVER                                 = 2,
	ZEUSSHIELD_MAX                                     = 3
};*/

// Enum TgGame.TgPawn_ZhongKui.EZhongKuiAbsorbState
/*enum EZhongKuiAbsorbState
{
	ZAS_OFF                                            = 0,
	ZAS_RAMPUP                                         = 1,
	ZAS_ON                                             = 2,
	ZAS_WINDDOWN                                       = 3,
	ZAS_MAX                                            = 4
};*/

// Enum TgGame.TgPhysAnimTestActor.EPATAState
/*enum EPATAState
{
	PATA_FixedAll                                      = 0,
	PATA_FixedLower                                    = 1,
	PATA_MotorRagdoll                                  = 2,
	PATA_Floppy                                        = 3,
	PATA_Recover                                       = 4,
	PATA_MAX                                           = 5
};*/

// Enum TgGame.TgProj_Simulated.eSimProjEvent
/*enum eSimProjEvent
{
	Proj_Spawn                                         = 0,
	Proj_Exploded                                      = 1,
	Proj_Shutdown                                      = 2,
	Proj_Hit                                           = 3,
	Proj_Target                                        = 4,
	Proj_HitWall                                       = 5,
	Proj_MAX                                           = 6
};*/

// Enum TgGame.TgRepInfo_Player.SCORE_TYPE
/*enum SCORE_TYPE
{
	STYPE_REPPTS                                       = 0,
	STYPE_KILLS                                        = 1,
	STYPE_ASSISTS                                      = 2,
	STYPE_DAMAGETAKEN                                  = 3,
	STYPE_DAMAGE                                       = 4,
	STYPE_BUFFVALUE                                    = 5,
	STYPE_HEALING                                      = 6,
	STYPE_DEFENSE                                      = 7,
	STYPE_DEATHS                                       = 8,
	STYPE_OBJS                                         = 9,
	STYPE_KILLS_BOT                                    = 10,
	STYPE_EARNED_XP                                    = 11,
	STYPE_EARNED_GOLD                                  = 12,
	STYPE_CURRENT_GOLD                                 = 13,
	STYPE_GOLD_PER_MIN                                 = 14,
	STYPE_XP_PER_MIN                                   = 15,
	STYPE_PLAYER_DMG                                   = 16,
	STYPE_BOT_DMG                                      = 17,
	STYPE_STRUCT_DMG                                   = 18,
	STYPE_OBJ_ASSISTS                                  = 19,
	STYPE_WARDS_PLACED                                 = 20,
	STYPE_TIME_DEAD                                    = 21,
	STYPE_MAX                                          = 22
};*/

// Enum TgGame.TgRepInfo_Player.DEVICE_STATS
/*enum DEVICE_STATS
{
	DS_ID                                              = 0,
	DS_DAMAGE                                          = 1,
	DS_HEALING                                         = 2,
	DS_PLAYER_KILLS                                    = 3,
	DS_BOT_KILLS                                       = 4,
	DS_DPM                                             = 5,
	DS_HPM                                             = 6,
	DS_MODE_COUNT                                      = 7,
	DS_BUFF_VALUE                                      = 8,
	DS_MAX                                             = 9
};*/

// Enum TgGame.TgSeqAct_ForceClientTutorialAction.eForcedClientTutorialAction
/*enum eForcedClientTutorialAction
{
	FCTA_BlockAvl                                      = 0,
	FCTA_UnblockAvl                                    = 1,
	FCTA_Open                                          = 2,
	FCTA_Close                                         = 3,
	FCTA_MAX                                           = 4
};*/

// Enum TgGame.TgSeqAct_RequestMission.EMissionDifficultyLevel
/*enum EMissionDifficultyLevel
{
	DL_Easy                                            = 0,
	DL_Medium                                          = 1,
	DL_Hard                                            = 2,
	DL_MAX                                             = 3
};*/

// Enum TgGame.TgSeqAct_TutorialHighlighter.eTutorialHighlighterElement
/*enum eTutorialHighlighterElement
{
	THE_Hide_All                                       = 0,
	THE_Ability1                                       = 1,
	THE_ActiveItem                                     = 2,
	THE_ConsumableItem                                 = 3,
	THE_Gold                                           = 4,
	THE_ItemShop_Gold                                  = 5,
	THE_ItemShop_Item                                  = 6,
	THE_ItemShop_Item2                                 = 7,
	THE_ItemShop_Item3                                 = 8,
	THE_ItemShop_Purchase                              = 9,
	THE_ItemShop_AllItems                              = 10,
	THE_ItemShop_RemoveOverlay                         = 11,
	THE_ItemShop_AddBlocker                            = 12,
	THE_Stats_Display                                  = 13,
	THE_Objective_Display                              = 14,
	THE_PlayerLevel_Display                            = 15,
	THE_ItemShop_T2L                                   = 16,
	THE_ItemShop_T2R                                   = 17,
	THE_ItemShop_T3L                                   = 18,
	THE_ItemShop_T3R                                   = 19,
	THE_ItemShop_BootItem                              = 20,
	THE_ItemShop_AddBlocker2                           = 21,
	THE_ItemShop_Item_Grid                             = 22,
	THE_ItemShop_Item_Grid01                           = 23,
	THE_ItemShop_Item_Grid02                           = 24,
	THE_ItemShop_Item_Grid03                           = 25,
	THE_ItemShop_T2M                                   = 26,
	THE_MAX                                            = 27
};*/

// Enum TgGame.TgSeqAct_TutorialImage.eTutorialImageActionEnum
/*enum eTutorialImageActionEnum
{
	TIAE_Show                                          = 0,
	TIAE_Hide                                          = 1,
	TIAE_MAX                                           = 2
};*/

// Enum TgGame.TgSeqCond_HasCondition.ConditionType
/*enum ConditionType
{
	TGCT_POISON                                        = 0,
	TGCT_DISEASE                                       = 1,
	TGCT_REGENERATION                                  = 2,
	TGCT_STUN                                          = 3,
	TGCT_STEALTH                                       = 4,
	TGCT_EMP_STUN                                      = 5,
	TGCT_IGNITE                                        = 6,
	TGCT_INVULNERABLE                                  = 7,
	TGCT_SLOW                                          = 8,
	TGCT_MAX                                           = 9
};*/

// Enum TgGame.TgSeqEvent_MICParameterEvent.eMICEventType
/*enum eMICEventType
{
	MET_NONE                                           = 0,
	MET_DEFENSE_ALARM                                  = 1,
	MET_MAX                                            = 2
};*/

// Enum TgGame.TgSeqEvent_Named.TSE_NAME
/*enum TSE_NAME
{
	TSE_NONE                                           = 0,
	TSE_MENU_CLOSE                                     = 1,
	TSE_MOVIE_DONE                                     = 2,
	TSE_MAX                                            = 3
};*/

// Enum TgGame.TgSeqEvent_TutorialEvent.TUTORIAL_EVENT
/*enum TUTORIAL_EVENT
{
	TUTEVT_OPENED_ITEM_SHOP                            = 0,
	TUTEVT_BOUGHT_ITEM                                 = 1,
	TUTEVT_CLOSED_ITEM_SHOP                            = 2,
	TUTEVT_OPENED_SKILLS                               = 3,
	TUTEVT_BOUGHT_SKILL                                = 4,
	TUTEVT_CLOSED_SKILLS                               = 5,
	TUTEVT_USED_ABILITY                                = 6,
	TUTEVT_USED_RECALL                                 = 7,
	TUTEVT_TARGETED                                    = 8,
	TUTEVT_OPENED_INTRO                                = 9,
	TUTEVT_CLOSED_INTRO                                = 10,
	TUTEVT_USED_ACTIVE_ITEM                            = 11,
	TUTEVT_SELECTED_SHOP_ITEM                          = 12,
	TUTEVT_SELECTED_SHOP_ITEM2                         = 13,
	TUTEVT_SELECTED_SHOP_ITEM3                         = 14,
	TUTEVT_USED_CONSUMABLE_ITEM                        = 15,
	TUTEVT_SELECTED_ALL_ITEMS                          = 16,
	TUTEVT_SELECTED_TIER2                              = 17,
	TUTEVT_SELECTED_TIER3                              = 18,
	TUTEVT_EFFECT_EARNED                               = 19,
	TUTEVT_GRID_SELECTED                               = 20,
	TUTEVT_GOD_SELECTED                                = 21,
	TUTEVT_MAX                                         = 22
};*/

// Enum TgGame.TgSeqEvent_TutorialEvent.TUTORIAL_TARGET_TYPE
/*enum TUTORIAL_TARGET_TYPE
{
	TUT_TARGET_TOWER                                   = 0,
	TUT_TARGET_PHOENIX                                 = 1,
	TUT_TARGET_GUARDIAN                                = 2,
	TUT_TARGET_MAX                                     = 3
};*/

// Enum TgGame.TgSiegePushActor.EPushState
/*enum EPushState
{
	PushState_Paused                                   = 0,
	PushState_Forward                                  = 1,
	PushState_PendingReverse                           = 2,
	PushState_Reverse                                  = 3,
	PushState_MAX                                      = 4
};*/

// Enum TgGame.TgSkelControlSingleBone_DisplayGroup.DisplayGroupOnType
/*enum DisplayGroupOnType
{
	DISPLAYGROUP_ON_INACTIVE                           = 0,
	DISPLAYGROUP_ON_ACTIVE                             = 1,
	DISPLAYGROUP_ON_STRENGTHABOVE                      = 2,
	DISPLAYGROUP_ON_STRENGTHBELOW                      = 3,
	DISPLAYGROUP_ON_MAX                                = 4
};*/

// Enum TgGame.TgSkeletalMeshActor_Loader.LobbyAnimPose
/*enum LobbyAnimPose
{
	LAP_Match                                          = 0,
	LAP_Victory                                        = 1,
	LAP_Defeat                                         = 2,
	LAP_InGame                                         = 3,
	LAP_MAX                                            = 4
};*/

// Enum TgGame.TgSoundGroup.eTG_SOUNDS
/*enum eTG_SOUNDS
{
	TGS_FOOTSTEP                                       = 0,
	TGS_DODGE                                          = 1,
	TGS_JUMP                                           = 2,
	TGS_LAND                                           = 3,
	TGS_DOUBLEJUMP                                     = 4,
	TGS_DOUBLELAND                                     = 5,
	TGS_DYING                                          = 6,
	TGS_HIT                                            = 7,
	TGS_MAX                                            = 8
};*/

// Enum TgGame.TgSpecialFxLightManager.SpecialFxLightState
/*enum SpecialFxLightState
{
	FxLight_Normal                                     = 0,
	FxLight_Dying                                      = 1,
	FxLight_Kill                                       = 2,
	FxLight_MAX                                        = 3
};*/

// Enum TgGame.TgTeleportPlayerVolume.TgTeleportVolumeType
/*enum TgTeleportVolumeType
{
	Inactive                                           = 0,
	Respawn                                            = 1,
	TgTeleportVolumeType_MAX                           = 2
};*/

// Enum TgGame.TgDeviceForm_Thoth_Dash.EThothDashTargetingMode
/*enum EThothDashTargetingMode
{
	EThothDashTargetingMode_NormalDash                 = 0,
	EThothDashTargetingMode_BonusDash                  = 1,
	EThothDashTargetingMode_NoDash                     = 2,
	EThothDashTargetingMode_MAX                        = 3
};*/

// Enum TgGame.TgPawn_Racer.RacerDriftState
/*enum RacerDriftState
{
	RacerDriftState_Inactive                           = 0,
	RacerDriftState_DriftRight                         = 1,
	RacerDriftState_DriftLeft                          = 2,
	RacerDriftState_ExitDrift                          = 3,
	RacerDriftState_MAX                                = 4
};*/

// Enum TgGame.TgPawn_Racer.RacerGear
/*enum RacerGear
{
	RacerGear_Drive                                    = 0,
	RacerGear_Neutral                                  = 1,
	RacerGear_Reverse                                  = 2,
	RacerGear_MAX                                      = 3
};*/


/*
# ========================================================================================= #
# Classes
# ========================================================================================= #
*/

// Class TgGame.AlienFXManager
// 0x0039 (0x0075 - 0x003C)
class UAlienFXManager : public UObject
{
public:
	unsigned long                                      m_bDirty : 1;                                     		// 0x003C (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bLoaded : 1;                                    		// 0x003C (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      bBrighten : 1;                                    		// 0x003C (0x0004) [0x0000000000000000] [0x00000004] 
	float                                              m_fHealthPct;                                     		// 0x0040 (0x0004) [0x0000000000000000]              
	float                                              m_fHealthLow;                                     		// 0x0044 (0x0004) [0x0000000000000000]              
	float                                              m_fDamagePulseTime;                               		// 0x0048 (0x0004) [0x0000000000000000]              
	float                                              m_fDamagePulseRemaining;                          		// 0x004C (0x0004) [0x0000000000000000]              
	float                                              m_fEventPulseTime;                                		// 0x0050 (0x0004) [0x0000000000000000]              
	float                                              m_fEventPulseRemaining;                           		// 0x0054 (0x0004) [0x0000000000000000]              
	int                                                nTarget;                                          		// 0x0058 (0x0004) [0x0000000000000000]              
	float                                              fLowBounds;                                       		// 0x005C (0x0004) [0x0000000000000000]              
	float                                              fHighBounds;                                      		// 0x0060 (0x0004) [0x0000000000000000]              
	float                                              fBoundsPct;                                       		// 0x0064 (0x0004) [0x0000000000000000]              
	float                                              fSpeed;                                           		// 0x0068 (0x0004) [0x0000000000000000]              
	float                                              m_fUpdateFrequency;                               		// 0x006C (0x0004) [0x0000000000000000]              
	float                                              m_fTimeUntilUpdate;                               		// 0x0070 (0x0004) [0x0000000000000000]              
	unsigned char                                      eCurrOverlay;                                     		// 0x0074 (0x0001) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1474 );

		return pClassPointer;
	};

	void UpdateHealth ( float fValue );
	void Tick ( float DeltaTime );
	void Start ( );
	void ShowHealth ( );
	void SetOverlay ( unsigned char Type );
	void OnDamage ( );
	void OnEvent ( );
	void Close ( );
	void Initialize ( );
};

UClass* UAlienFXManager::pClassPointer = NULL;

// Class TgGame.TgAIVolume
// 0x000C (0x0228 - 0x021C)
class ATgAIVolume : public AVolume
{
public:
	int                                                LaneIndex;                                        		// 0x021C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                TaskforceIndex;                                   		// 0x0220 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      bEnabled : 1;                                     		// 0x0224 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1475 );

		return pClassPointer;
	};

	void eventPostBeginPlay ( );
	void OnToggle ( class USeqAct_Toggle* Action );
	struct FVector GetRandomPointInAIVolume ( float CollisionRadius );
};

UClass* ATgAIVolume::pClassPointer = NULL;

// Class TgGame.TgAnimNodeBlendByVerticalAim
// 0x003B (0x0114 - 0x00D9)
class UTgAnimNodeBlendByVerticalAim : public UAnimNodeBlendBase
{
public:
	float                                              m_Aim;                                            		// 0x00DC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FVector2D                                   m_Range;                                          		// 0x00E0 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_AngleOffset;                                    		// 0x00E8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_PreviousAim;                                    		// 0x00EC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned long                                      bInitialized : 1;                                 		// 0x00F0 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	unsigned long                                      m_bLoopChildrenOnRelevant : 1;                    		// 0x00F0 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_bPlayChildrenOnRelevant : 1;                    		// 0x00F0 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	struct FName                                       m_AnimName_Up;                                    		// 0x00F4 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_AnimName_Center;                                		// 0x00FC (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_AnimName_Down;                                  		// 0x0104 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	class UAnimNodeSequence*                           m_SeqNode1;                                       		// 0x010C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UAnimNodeSequence*                           m_SeqNode2;                                       		// 0x0110 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1476 );

		return pClassPointer;
	};

	void eventOnBecomeRelevant ( );
	void PlayAnim ( unsigned long bLoop, float Rate, float StartTime );
};

UClass* UTgAnimNodeBlendByVerticalAim::pClassPointer = NULL;

// Class TgGame.TgAnimNodeSequence
// 0x0008 (0x015C - 0x0154)
class UTgAnimNodeSequence : public UAnimNodeSequence
{
public:
	unsigned long                                      bAutoPlay : 1;                                    		// 0x0154 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      bResetOnActivate : 1;                             		// 0x0154 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      HasDynamicLength : 1;                             		// 0x0154 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      EnableFootControlsOnCease : 1;                    		// 0x0154 (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )
	unsigned long                                      SynchronizeGroupOnReplay : 1;                     		// 0x0154 (0x0004) [0x0000000000000001] [0x00000010] ( CPF_Edit )
	unsigned long                                      bRandomStartPosition : 1;                         		// 0x0154 (0x0004) [0x0000000000000001] [0x00000020] ( CPF_Edit )
	float                                              ChainedSequenceDuration;                          		// 0x0158 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1477 );

		return pClassPointer;
	};

	void PlayAnim ( unsigned long bLoop, float InRate, float StartTime );
};

UClass* UTgAnimNodeSequence::pClassPointer = NULL;

// Class TgGame.TgAnimNodeSelfDestruct
// 0x0034 (0x0190 - 0x015C)
class UTgAnimNodeSelfDestruct : public UTgAnimNodeSequence
{
public:
	int                                                NumberOfLoopsBeforeDestruct;                      		// 0x015C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                LoopsCompleted;                                   		// 0x0160 (0x0004) [0x0000000000000000]              
	TArray< struct FName >                             ScaleOutSkelControlNames;                         		// 0x0164 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	float                                              TimeRemaingForScaleOut;                           		// 0x0170 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	TArray< class USkelControlBase* >                  ScaleOutSkelControls;                             		// 0x0174 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	TArray< float >                                    ScaleOutStartScales;                              		// 0x0180 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	float                                              ScaleOutStartTime;                                		// 0x018C (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1478 );

		return pClassPointer;
	};

};

UClass* UTgAnimNodeSelfDestruct::pClassPointer = NULL;

// Class TgGame.TgAnimNodeSequenceBellonaBlocker
// 0x0000 (0x015C - 0x015C)
class UTgAnimNodeSequenceBellonaBlocker : public UTgAnimNodeSequence
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1479 );

		return pClassPointer;
	};

};

UClass* UTgAnimNodeSequenceBellonaBlocker::pClassPointer = NULL;

// Class TgGame.TgAnimNotify_CameraCut
// 0x003F (0x0080 - 0x0041)
class UTgAnimNotify_CameraCut : public UAnimNotify
{
public:
	float                                              m_fTweenSpeed;                                    		// 0x0044 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FVector                                     m_vTweenDir;                                      		// 0x0048 (0x000C) [0x0000000000000001]              ( CPF_Edit )
	struct FVector                                     m_vLocationOffset;                                		// 0x0054 (0x000C) [0x0000000000000001]              ( CPF_Edit )
	struct FRotator                                    m_rRotationOffset;                                		// 0x0060 (0x000C) [0x0000000000000001]              ( CPF_Edit )
	struct FRotator                                    m_rRotationTarget;                                		// 0x006C (0x000C) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fRotationDuration;                              		// 0x0078 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fRotationDelay;                                 		// 0x007C (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1480 );

		return pClassPointer;
	};

};

UClass* UTgAnimNotify_CameraCut::pClassPointer = NULL;

// Class TgGame.TgAnimNotify_Disappear
// 0x0003 (0x0044 - 0x0041)
class UTgAnimNotify_Disappear : public UAnimNotify
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1481 );

		return pClassPointer;
	};

};

UClass* UTgAnimNotify_Disappear::pClassPointer = NULL;

// Class TgGame.TgAnimNotify_Disappear_AwilixMount
// 0x0003 (0x0044 - 0x0041)
class UTgAnimNotify_Disappear_AwilixMount : public UAnimNotify
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1482 );

		return pClassPointer;
	};

};

UClass* UTgAnimNotify_Disappear_AwilixMount::pClassPointer = NULL;

// Class TgGame.TgAnimNotify_SpectatorSlomo
// 0x0003 (0x0044 - 0x0041)
class UTgAnimNotify_SpectatorSlomo : public UAnimNotify
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1483 );

		return pClassPointer;
	};

};

UClass* UTgAnimNotify_SpectatorSlomo::pClassPointer = NULL;

// Class TgGame.TgAnimNotify_ToggleMeshAttachment
// 0x000F (0x0050 - 0x0041)
class UTgAnimNotify_ToggleMeshAttachment : public UAnimNotify
{
public:
	unsigned long                                      m_bDetachMesh : 1;                                		// 0x0044 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned char                                      m_nChildType;                                     		// 0x0048 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	class USkeletalMesh*                               m_MeshOverride;                                   		// 0x004C (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1484 );

		return pClassPointer;
	};

};

UClass* UTgAnimNotify_ToggleMeshAttachment::pClassPointer = NULL;

// Class TgGame.TgAttachPoint
// 0x0000 (0x01F0 - 0x01F0)
class ATgAttachPoint : public AActor
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1485 );

		return pClassPointer;
	};

};

UClass* ATgAttachPoint::pClassPointer = NULL;

// Class TgGame.TgPlayerController
// 0x05F4 (0x0BDC - 0x05E8)
class ATgPlayerController : public APComPlayerController
{
public:
	int                                                s_nPlayerId;                                      		// 0x05E8 (0x0004) [0x0000000000000000]              
	struct FQWord                                      s_qwNetAccessFlags;                               		// 0x05EC (0x0008) [0x0000000000000000]              
	int                                                r_nXp;                                            		// 0x05F4 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nCurrency;                                      		// 0x05F8 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              s_fCurrencyRemainder;                             		// 0x05FC (0x0004) [0x0000000000000000]              
	float                                              s_fXpRemainder;                                   		// 0x0600 (0x0004) [0x0000000000000000]              
	unsigned long                                      r_bCanPurchaseItems : 1;                          		// 0x0604 (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )
	unsigned long                                      r_bAutoPurchase : 1;                              		// 0x0604 (0x0004) [0x0000000000000020] [0x00000002] ( CPF_Net )
	unsigned long                                      r_bAutoSkillUp : 1;                               		// 0x0604 (0x0004) [0x0000000000000020] [0x00000004] ( CPF_Net )
	unsigned long                                      r_bEmoteFlooded : 1;                              		// 0x0604 (0x0004) [0x0000000000000020] [0x00000008] ( CPF_Net )
	unsigned long                                      s_bSentAutoKickAlert : 1;                         		// 0x0604 (0x0004) [0x0000000000000000] [0x00000010] 
	unsigned long                                      s_bAddDeadTimeStatsTracker : 1;                   		// 0x0604 (0x0004) [0x0000000000002000] [0x00000020] ( CPF_Transient )
	unsigned long                                      c_bAllocateOnCast : 1;                            		// 0x0604 (0x0004) [0x0000000000000000] [0x00000040] 
	unsigned long                                      c_bEnableBasicAttackControllerFeedback : 1;       		// 0x0604 (0x0004) [0x0000000000000000] [0x00000080] 
	unsigned long                                      c_bForceUnrestrictedPitch : 1;                    		// 0x0604 (0x0004) [0x0000000000000000] [0x00000100] 
	unsigned long                                      m_bPlayerOverviewEnabled : 1;                     		// 0x0604 (0x0004) [0x0000000000000000] [0x00000200] 
	unsigned long                                      r_bLockYawRotation : 1;                           		// 0x0604 (0x0004) [0x0000000000000020] [0x00000400] ( CPF_Net )
	unsigned long                                      m_bDeviceLockInput : 1;                           		// 0x0604 (0x0004) [0x0000000000000000] [0x00000800] 
	unsigned long                                      m_bDeviceLockCamera : 1;                          		// 0x0604 (0x0004) [0x0000000000000000] [0x00001000] 
	unsigned long                                      bPressingLeftMouseButton : 1;                     		// 0x0604 (0x0004) [0x0000000000000000] [0x00002000] 
	unsigned long                                      r_bRove : 1;                                      		// 0x0604 (0x0004) [0x0000000000000020] [0x00004000] ( CPF_Net )
	unsigned long                                      bFreeingMouse : 1;                                		// 0x0604 (0x0004) [0x0000000000000000] [0x00008000] 
	unsigned long                                      m_bReceivedIdleWarn : 1;                          		// 0x0604 (0x0004) [0x0000000000000000] [0x00010000] 
	unsigned long                                      s_bClearAchievementIgnoreListsOnNextTick : 1;     		// 0x0604 (0x0004) [0x0000000000000000] [0x00020000] 
	unsigned long                                      c_bAssistModeSublevelLoaded : 1;                  		// 0x0604 (0x0004) [0x0000000000000000] [0x00040000] 
	unsigned long                                      c_bAllowSpecialMaterialEffects : 1;               		// 0x0604 (0x0004) [0x0000000000044000] [0x00080000] ( CPF_Config | CPF_GlobalConfig )
	unsigned long                                      m_bUseSilhouettes : 1;                            		// 0x0604 (0x0004) [0x0000000000002000] [0x00100000] ( CPF_Transient )
	unsigned long                                      m_bIgnoreOverlays : 1;                            		// 0x0604 (0x0004) [0x0000000000002000] [0x00200000] ( CPF_Transient )
	unsigned long                                      m_bForceOverlaysOnVisibleGods : 1;                		// 0x0604 (0x0004) [0x0000000000002000] [0x00400000] ( CPF_Transient )
	unsigned long                                      m_bDetailedViewEnabled : 1;                       		// 0x0604 (0x0004) [0x0000000000002000] [0x00800000] ( CPF_Transient )
	unsigned long                                      m_bContextNotifiesEnabled : 1;                    		// 0x0604 (0x0004) [0x0000000000004000] [0x01000000] ( CPF_Config )
	unsigned long                                      m_bShowPlayerCircles : 1;                         		// 0x0604 (0x0004) [0x0000000000000000] [0x02000000] 
	unsigned long                                      m_bCustomSkillsLoaded : 1;                        		// 0x0604 (0x0004) [0x0000000000002000] [0x04000000] ( CPF_Transient )
	unsigned long                                      c_bShowFootstepInfoDebug : 1;                     		// 0x0604 (0x0004) [0x0000000000000000] [0x08000000] 
	unsigned long                                      m_bDetailedDeviceLogging : 1;                     		// 0x0604 (0x0004) [0x0000000000000000] [0x10000000] 
	unsigned long                                      m_bAllowAllSocialEmotes : 1;                      		// 0x0604 (0x0004) [0x0000000000002000] [0x20000000] ( CPF_Transient )
	unsigned long                                      c_bHideNameplates : 1;                            		// 0x0604 (0x0004) [0x0000000000000000] [0x40000000] 
	float                                              c_fLastGoldNagTime;                               		// 0x0608 (0x0004) [0x0000000000000000]              
	int                                                m_nReviveBuybackCost;                             		// 0x060C (0x0004) [0x0000000000000000]              
	int                                                r_nStatPoints;                                    		// 0x0610 (0x0004) [0x0000000000000020]              ( CPF_Net )
	struct FFLOOD                                      s_VGSFlood;                                       		// 0x0614 (0x0008) [0x0000000000000000]              
	struct FFLOOD                                      s_PingFlood;                                      		// 0x061C (0x0008) [0x0000000000000000]              
	struct FFLOOD                                      s_EmoteFlood;                                     		// 0x0624 (0x0008) [0x0000000000000000]              
	class UTgPlayerInput*                              m_CachedPlayerInput;                              		// 0x062C (0x0004) [0x0000000000000000]              
	class UTgSpectatorInput*                           m_CachedSpectatorInput;                           		// 0x0630 (0x0004) [0x0000000000000000]              
	class AActor*                                      m_aHoverActor;                                    		// 0x0634 (0x0004) [0x0000000000000000]              
	struct FVector                                     m_vHoverLocation;                                 		// 0x0638 (0x000C) [0x0000000000000000]              
	float                                              m_fHoverActorActiveTime;                          		// 0x0644 (0x0004) [0x0000000000000000]              
	struct FVector                                     m_vWorldMapLocation;                              		// 0x0648 (0x000C) [0x0000000000000000]              
	TArray< class AReplicationInfo* >                  m_WorldMapTargetRepInfos;                         		// 0x0654 (0x000C) [0x0000000000502000]              ( CPF_Transient | CPF_NeedCtorLink )
	int                                                m_nPawnPickerId;                                  		// 0x0660 (0x0004) [0x0000000000000000]              
	struct FVector                                     m_vWorldMouseLocation;                            		// 0x0664 (0x000C) [0x0000000000002000]              ( CPF_Transient )
	struct FVector                                     m_vWorldMouseDirection;                           		// 0x0670 (0x000C) [0x0000000000002000]              ( CPF_Transient )
	float                                              c_fTimeTillAFK;                                   		// 0x067C (0x0004) [0x0000000000000000]              
	float                                              s_bAutoKickStartTime;                             		// 0x0680 (0x0004) [0x0000000000000000]              
	class APawn*                                       s_LastPossessedPawn;                              		// 0x0684 (0x0004) [0x0000000000000000]              
	float                                              c_fLastAbilityNagTime;                            		// 0x0688 (0x0004) [0x0000000000000000]              
	float                                              c_fLastHealthNagTime;                             		// 0x068C (0x0004) [0x0000000000000000]              
	float                                              c_fLastManaNagTime;                               		// 0x0690 (0x0004) [0x0000000000000000]              
	float                                              c_fLastSkillPointNagTime;                         		// 0x0694 (0x0004) [0x0000000000000000]              
	float                                              c_fLastBasicAttackNagTime;                        		// 0x0698 (0x0004) [0x0000000000000000]              
	float                                              c_fLastTargetedNagTime;                           		// 0x069C (0x0004) [0x0000000000000000]              
	int                                                r_nNumBasicsToMiss;                               		// 0x06A0 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              r_BlindnessFactor;                                		// 0x06A4 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              m_fRecentLostHealth;                              		// 0x06A8 (0x0004) [0x0000000000000000]              
	float                                              m_fLastLostHealthTime;                            		// 0x06AC (0x0004) [0x0000000000000000]              
	TArray< class AActor* >                            m_TargetedPlayers;                                		// 0x06B0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	float                                              s_fWaitForSpawnSecs;                              		// 0x06BC (0x0004) [0x0000000000000000]              
	float                                              c_fRespawnTime;                                   		// 0x06C0 (0x0004) [0x0000000000000000]              
	float                                              m_fDeathTime;                                     		// 0x06C4 (0x0004) [0x0000000000000000]              
	unsigned char                                      c_eDelayedCastEquipPoint;                         		// 0x06C8 (0x0001) [0x0000000000000000]              
	unsigned char                                      r_WatchOtherPlayer;                               		// 0x06C9 (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      c_GameWinState;                                   		// 0x06CA (0x0001) [0x0000000000000000]              
	unsigned char                                      c_OvertimeWinState;                               		// 0x06CB (0x0001) [0x0000000000000000]              
	unsigned char                                      m_eDetailedDeviceEqp;                             		// 0x06CC (0x0001) [0x0000000000000000]              
	float                                              c_fDelayedCastTime;                               		// 0x06D0 (0x0004) [0x0000000000000000]              
	float                                              c_fLastActionTimeStamp;                           		// 0x06D4 (0x0004) [0x0000000000000000]              
	class UTgControlModule*                            ControlModule;                                    		// 0x06D8 (0x0004) [0x0000000004000001]              ( CPF_Edit | CPF_EditInline )
	class UClass*                                      DefaultControlModuleClass;                        		// 0x06DC (0x0004) [0x0000000000000000]              
	int                                                c_nCameraYawOffset;                               		// 0x06E0 (0x0004) [0x0000000000000000]              
	class AActor*                                      m_EndGameFocus;                                   		// 0x06E4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_fLastVGS;                                       		// 0x06E8 (0x0004) [0x0000000000000000]              
	float                                              m_fTimeToViewOthersCamAfterDeath;                 		// 0x06EC (0x0004) [0x0000000000000000]              
	TArray< class UTgAchievement* >                    s_Achievements;                                   		// 0x06F0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                r_nFlashProjectile[ 0x18 ];                       		// 0x06FC (0x0060) [0x0000000000000020]              ( CPF_Net )
	struct FsSimProjectileFireInfo                     r_FlashProjectileEx[ 0x18 ];                      		// 0x075C (0x0360) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nFlashSimProjIdx;                               		// 0x0ABC (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                c_nLastFlashSimProjIdx;                           		// 0x0AC0 (0x0004) [0x0000000000000000]              
	class ATgGameTipManager*                           c_GameTipManager;                                 		// 0x0AC4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FPointer                                    s_pCombatMessages;                                		// 0x0AC8 (0x0004) [0x0000000000001000]              ( CPF_Native )
	float                                              s_fLastCombatMessageProcess;                      		// 0x0ACC (0x0004) [0x0000000000000000]              
	int                                                c_nCurrentLevel;                                  		// 0x0AD0 (0x0004) [0x0000000000000000]              
	class UTgTutorialAnnouncer*                        c_TutorialAnnouncer;                              		// 0x0AD4 (0x0004) [0x0000000000000000]              
	int                                                r_TutorialBlockedClientActions;                   		// 0x0AD8 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgRepInfo_Player*                           CachedPRI;                                        		// 0x0ADC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UMaterialInstanceConstant*                   m_OverlayPathMaterial;                            		// 0x0AE0 (0x0004) [0x0000000000000000]              
	int                                                m_nContextNotifyGroundTargeterId;                 		// 0x0AE4 (0x0004) [0x0000000000000000]              
	TArray< class ATgPawn* >                           m_HiddenPawns;                                    		// 0x0AE8 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FAbilityLevelInfo                           m_nLevelAbilities[ 0x14 ];                        		// 0x0AF4 (0x00A0) [0x0000000000000000]              
	class UAudioComponent*                             c_AlertAudioComponent;                            		// 0x0B94 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	struct FString                                     Login2StartTime;                                  		// 0x0B98 (0x000C) [0x0000000000444000]              ( CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink )
	struct FString                                     Login3StartTime;                                  		// 0x0BA4 (0x000C) [0x0000000000444000]              ( CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink )
	struct FString                                     Login2StartTimeLive;                              		// 0x0BB0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FString                                     Login3StartTimeLive;                              		// 0x0BBC (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                m_nChargeNumber;                                  		// 0x0BC8 (0x0004) [0x0000000000000000]              
	TArray< class UTgObjectReferencer* >               c_KismetLoadedDevices;                            		// 0x0BCC (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                m_nRespawnPitch;                                  		// 0x0BD8 (0x0004) [0x0000000000000002]              ( CPF_Const )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1486 );

		return pClassPointer;
	};

	void ToggleGandhiMode ( );
	bool ShouldPartySessionsBePublic ( );
	void UpdatePartyUI ( );
	void TryOpenPartyUI ( );
	void BlockPartySceneInput ( unsigned long bBlockInput );
	bool TryAutoLogin ( );
	void LogoutPlayer ( );
	bool IsInGame ( );
	void ShowCustomGameDisallowedPopup ( );
	void ShowPackageNotInstalledForPartyInviteWarning ( );
	void ShowPartyNoLongerAvailableWarning ( );
	void ShowPartyFullWarning ( unsigned long bPartySession );
	void ShowUnableToReadFriendsListWarning ( );
	void ShowNoFriendsForPartyInviteWarning ( );
	void ShowControllerDisconnectedWarning ( );
	void ClearASCIntervals ( );
	bool SetPause ( unsigned long bPause, struct FScriptDelegate CanUnpauseDelegate );
	void OnControllerChanged ( int ControllerId, unsigned long bIsConnected, unsigned long bPauseGame );
	void OnRemoteTalkerStatusChange ( struct FUniqueNetId RemoteNetId, unsigned long bIsTalking );
	void OnCurrentUserChanged ( unsigned char LocalUserNum, struct FString CurrentUser, struct FString LoggedInUser );
	void OnConnectionStatusChange ( unsigned char ConnectionStatus );
	void OnLoginStatusChange ( unsigned char NewStatus, struct FUniqueNetId NewId );
	void SetPlayerOverviewCamera ( unsigned long bOn );
	void ClientPlayerOverviewCamera ( unsigned long bOn );
	void ClientUpdatePosition ( );
	void eventClientPlayRoadkillNotify ( );
	void eventReceivedContextNotify ( int ContextId, struct FVector NotifyLocation, unsigned long bEnemy );
	void eventEnableContextNotify ( int ContextId );
	void eventPlayAthenaReinforcementSound ( int SpecialFXId );
	void eventPlayMercuryIncomingEffects ( );
	void eventSetIgnoreMoveInput ( unsigned long bShow );
	void FreeMouseCursor ( );
	void UnFreeMouseCursor ( );
	void ToggleDetailedView ( );
	bool eventIsPawnWithin ( class APawn* aPawn, float Distance );
	void SetCommandBindPC ( unsigned long bSpectator, int nAlternate, struct FString ExtendedBinding, struct FString Command );
	void SetBindPC ( unsigned long bSpectator, struct FString ExtendedBinding, struct FString Command );
	void UnbindCommandAllPC ( unsigned long bSpectator, struct FString Command );
	void UnbindCommandPC ( unsigned long bSpectator, int nAlternate, struct FString Command );
	class UTgSpectatorInput* eventGetSpectatorInputClass ( );
	class UTgPlayerInput* eventGetPlayerInputClass ( );
	void RemoveAdditionalPostProcess ( class UPostProcessChain* PP, class ATgPawn* OtherDepthTarget );
	void InsertAdditionalPostProcess ( class UPostProcessChain* PP, unsigned long bAlterMeshDepth, class ATgPawn* OtherDepthTarget );
	void IgnoreOverlays ( unsigned long bIgnore );
	void UseSilhoettes ( unsigned long bUse );
	void OnScoreChange ( int nTeam );
	void eventArenaCrowdEvent ( unsigned char EventType );
	void ServerDropFlag ( );
	void DropFlag ( );
	void StopTutorialAnnouncement ( unsigned long bFlushOthers );
	void PlayTutorialAnnouncement ( class USoundCue* OptionalCue, unsigned long bPlayImmediately, unsigned long bFlushOthers );
	void SetAllowAnimationFrameRateLOD ( unsigned long Value, float lLODDistanceFactor, int lLODFrameRate );
	void SetAllowParticleSystems ( unsigned long Value );
	void AllowRagdollUpdated ( );
	bool AllowRagdoll ( );
	bool AllowPausing ( );
	void ServerRequestScoreBoard ( );
	void ResetGameTips ( );
	void SuppressHelpText ( );
	void RequestScoreBoard ( );
	void eventUpdateLockedTarget ( class AActor* LockedActor );
	void ServerPlayEmote ( unsigned char Emote );
	bool CanPlayEmote ( unsigned char Emote, unsigned char* failType );
	void ServerSurrender ( unsigned long bSurrender );
	void ClientSurrender ( unsigned long bSurrender );
	void ClientPlayPing ( float X, float Y, float Z, unsigned char pingType );
	void ClientPlayVGS ( int nId, int usedVPSetting );
	void eventClientPlayLocalEmote ( unsigned char Emote );
	void ClientPlayEmote ( unsigned char Emote );
	void ClientSetLocation ( struct FVector NewLocation, struct FRotator NewRotation );
	bool OnInstantCastOffhandSlotReleased ( unsigned char eqp );
	bool OnInstantCastOffhandSlotPressed ( unsigned char eqp );
	bool OnQuickCastOffhandSlotReleased ( unsigned char eqp );
	bool OnQuickCastOffhandSlotPressed ( unsigned char eqp );
	bool OnDefaultCastOffhandSlotReleased ( unsigned char eqp );
	bool OnDefaultCastOffhandSlotPressed ( unsigned char eqp );
	void ToggleAllocateOnCast ( unsigned long bEnable );
	bool TryLevelUp ( unsigned char eqp );
	bool OnOffhandSlotReleased ( unsigned char eqp );
	bool OnOffhandSlotPressed ( unsigned char eqp, unsigned long bDelayedCast );
	void eventDeviceOnStopFire ( class ATgDevice* Device, unsigned long WasInterrupted );
	void AbilityUsageHelpTimer ( );
	void eventDeviceOnStartFire ( class ATgDevice* Device );
	void eventDeviceOnStopBuildup ( class ATgDevice* Device, unsigned long WasInterrupted );
	void eventDeviceOnStartBuildup ( class ATgDevice* Device );
	void AllocateAbilitySkillPoint ( unsigned char eqp );
	void OnAddPercentVitals ( class UTgSeqAct_AddPercentVitals* inAction );
	void AddPlayerPercentVitals ( float pctHealth, float pctMana );
	void OnGivePercentVitals ( class UTgSeqAct_GivePercentVitals* inAction );
	void GivePlayerPercentVitals ( float pctHealth, float pctMana );
	void OnGiveFullVitals ( class UTgSeqAct_GiveFullVitals* inAction );
	void GivePlayerFullVitals ( );
	void ClientTutorialHighlighter ( unsigned long bShow, int highlightedElement );
	void ClientTutorialImage ( unsigned long bShow, int HeaderMsgId, int ImageId, int msgId );
	void ClientForceTutorialAction ( int Action, int ActionElement );
	void OnTutorialHighlighter ( class UTgSeqAct_TutorialHighlighter* inAction );
	void OnTutorialImage ( class UTgSeqAct_TutorialImage* inAction );
	void OnForceClientTutorialAction ( class UTgSeqAct_ForceClientTutorialAction* inAction );
	void ClientNotifyTutorialUIEvent ( int Evt, int evtData );
	void ServerNotifyTutorialUIEvent ( int Evt, int evtData );
	void OnTutorialPlayerAction ( class UTgSeqAct_LogTutorialAction* inAction );
	void eventStopTgCameraShake ( class UTgCameraShake* CameraShake );
	void eventPlayTgCameraShake ( class UTgCameraShake* CameraShake, struct FVector Epicenter, class AActor* ShakeInstigator );
	void OnTgCameraShake ( class UTgSeqAct_TgCameraShake* inAction );
	void Cloth ( unsigned long bEnabled );
	void DoFade ( unsigned long bIn, float Time );
	void OnClientLoadDevices ( class UTgSeqAct_ClientLoadDevices* Action );
	void ClientSetCameraMode ( struct FName NewCamMode );
	void ServerCamera ( struct FName NewMode );
	void Camera ( struct FName NewMode );
	void ClientCheatFly ( unsigned long bOn );
	void eventCheatFly ( unsigned long bOn );
	void eventServerUpdateStats ( );
	bool CanCommunicate ( );
	void SpeakTTS ( struct FString S, class APlayerReplicationInfo* PRI );
	void DumpClassInfo ( struct FString sClassName );
	void TestCrash ( );
	bool CanPlayerMove ( class APawn* P );
	class ATgRepInfo_TaskForce* GetTFRI ( );
	void ServerCycleTeammateView ( unsigned long bForward );
	void ViewPreviousTeammate ( );
	void ViewNextTeammate ( );
	void GetServerValue ( struct FString strObject, struct FString strVariable );
	void GetClientValue ( struct FString strObject, struct FString strVariable );
	void SetServerValue ( struct FString strObject, struct FString strVariable, struct FString StrValue );
	void SetClientValue ( struct FString strObject, struct FString strVariable, struct FString StrValue );
	void ServerGetValue ( struct FString strObject, struct FString strVariable );
	void ClientGetValue ( struct FString strObject, struct FString strVariable );
	void ServerSetValue ( struct FString strObject, struct FString strVariable, struct FString StrValue );
	void ClientSetValue ( struct FString strObject, struct FString strVariable, struct FString StrValue );
	void ServerKillPets ( );
	void KillPets ( );
	void ServerGotoFly ( );
	void GotoFly ( );
	void StunTypeChanged ( );
	void Stun ( unsigned long bStunController, unsigned char eType );
	void ClientResetStunnedBehavior ( unsigned long bStunController, unsigned char eType );
	bool ShouldStunChangePhysics ( );
	void OnRestartPlayers ( class UTgSeqAct_RestartPlayers* inAction );
	bool ClientPerformedUseAction ( );
	bool ServerPerformedUseAction ( );
	void ClientUse ( );
	void ServerUse ( );
	bool CanUseNow ( );
	void UpdateReviveTimeRemaining ( float fTimeRemaining );
	void ViewObjectiveCamerasTimer ( );
	struct FName eventGetStateNameEx ( );
	void eventReplicatedEvent ( struct FName VarName );
	void OnCanPurchaseItemChange ( );
	void PawnDied ( class APawn* P );
	void ClientSetReadyState ( unsigned long bReadyToPlay );
	void ServerSetReadyToPlay ( );
	void SetReadyToPlay ( );
	void CheckJumpOrDuck ( );
	void eventNotifyJumpApex ( );
	void UpdateAssistModeSubLevel ( );
	void EnableColorBlindEffect ( unsigned long bEnable, int Type, unsigned long bSimulate );
	void eventOnSettingsChanged ( class UTgClientSettings* Settings, int settingsType );
	void eventReceivedPlayer ( );
	void SwitchCamera ( struct FString sCamera );
	void SwitchControl ( class UClass* ControlModuleClass );
	void eventPostBeginPlay ( );
	void ServerToggleSceneCaptureState ( );
	int GetCurrentDeviceBehaviorType ( );
	int GetCurrentDeviceType ( );
	unsigned char GetCurrentEqPoint ( );
	class ATgDevice* GetEqPointDevice ( unsigned char eEqPoint );
	class UTgDeviceFire* GetEqPointDevFire ( );
	bool IsValidTarget ( class AActor* HoverActor );
	bool IsTargetDied ( class AActor* TargetActor );
	bool IsTargetInFrontOfPawn ( struct FVector TargetLocation );
	struct FRotator GetAdjustedAimFor ( class AWeapon* W, struct FVector StartFireLoc );
	void ClientSetOnlineStatus ( );
	void DisplayHiddenActorsTimer ( );
	void DisplayHiddenActors ( float Time );
	bool CanAFK ( class ATgPawn* ThePawn );
	void ServerToggleAFK ( unsigned long bEnabled );
	void GoAFKTimer ( );
	void eventPlayerTick ( float DeltaTime );
	void eventInitInputSystem ( );
	void SetPlayerTeam ( class ATeamInfo* NewTeam );
	void TeamTalk ( );
	void Talk ( );
	void ClientGameEnded ( class AActor* EndGameFocus, unsigned long bIsWinner );
	void GameHasEnded ( class AActor* EndGameFocus, unsigned long bIsWinner );
	void OnDestroyOnlineGameComplete ( struct FName SessionName, unsigned long bWasSuccessful );
	void EndIntro ( );
	void SetupIntro ( );
	void ResetPlayer ( );
	void ClientPlayIntro ( );
	void PlayIntro ( );
	void PrepareIntro ( );
	unsigned char eventGetEOMWinState ( );
	void ClientEndOTTransition ( );
	void eventSendClientEndOTTransition ( );
	void ClientTriggerOTTransition ( float fSceneDelay );
	void eventSendClientTriggerOTTransition ( float fSceneDelay );
	void ClientSetOvertimeWinState ( unsigned char gameWinState );
	void eventSendClientSetOvertimeWinState ( unsigned char gameWinState );
	void ClientSetGameWinState ( unsigned char gameWinState );
	void eventSendClientSetGameWinState ( unsigned char gameWinState );
	void FindGoodView ( );
	void GoSpectate ( );
	void AddNavFailedAlert ( unsigned long bAlreadyThere );
	void eventShowPathTo ( class AActor* destActor );
	void ClientShowPathTo ( class AActor* destActor );
	void eventTutorialMessage ( int msgId, unsigned long bTip );
	void OnPingMinimap ( class UTgSeqAct_PingMinimap* Action );
	void OnNavIndicator ( class UTgSeqAct_NavIndicator* Action );
	void ShowPathToNearestPOI ( );
	void ServerSetZoomFactor ( float fZoom );
	void ZoomOut ( );
	void ZoomIn ( );
	class UTgCameraModule* GetCurrentCameraModule ( );
	void ServerViewAPlayer ( int Dir, unsigned long bFriendlyOnly );
	void HandleViewTargetOnAdjustPosition ( );
	void ServerViewPrevPlayer ( unsigned long bFriendlyOnly );
	void ServerViewNextPlayer ( unsigned long bFriendlyOnly );
	float eventGetFOVAngle ( );
	int BlendRot ( float DeltaTime, int BlendC, int NewC );
	void ClientEnterStartState ( );
	void EnterStartState ( );
	bool AllowVoiceMessage ( struct FName MessageType );
	void ClientSetHUD ( class UClass* newHUDType );
	void eventGetAimingViewPoint ( struct FVector* POVLocation, struct FRotator* POVRotation );
	bool UsingFirstPersonCamera ( );
	void SetRadius ( float NewRadius );
	void eventClientReset ( );
	void Reset ( );
	void ClientSetCinematicMode ( unsigned long bInCinematicMode, unsigned long bAffectsMovement, unsigned long bAffectsTurning, unsigned long bAffectsHUD );
	void SetCinematicMode ( unsigned long bInCinematicMode, unsigned long bHidePlayer, unsigned long bAffectsHUD, unsigned long bAffectsMovement, unsigned long bAffectsTurning, unsigned long bAffectsButtons );
	void OnToggleCinematicMode ( class USeqAct_ToggleCinematicMode* Action );
	void OnToggleImmuneGodMode ( class UTgSeqAct_ToggleImmuneGodMode* inAction );
	void DisplayDebug ( class AHUD* HUD, float* out_YL, float* out_YPos );
	void ViewPlayersTimer ( );
	void ReviveTimer ( );
	void eventRevive ( );
	void LadderLetGo ( );
	void ServerLadderLetGo ( );
	void eventRestartPlayerOnTransfer ( );
	void eventNotifyStructureTargeted ( );
	void CancelInBombRange ( );
	void NotifyInBombRange ( );
	void ClientNotifyBodyUnderAttack ( unsigned char Damage );
	void NotifyBodyUnderAttack ( unsigned char Damage );
	void ClientPlayTakeHit ( struct FRotator HitDir, int Damage, class UClass* DamageType );
	void NotifyTakeHit ( class AController* InstigatedBy, struct FVector HitLocation, int Damage, class UClass* DamageType, struct FVector Momentum );
	void NotifyChangedWeapon ( class AWeapon* PreviousWeapon, class AWeapon* NewWeapon );
	void eventUnPossess ( );
	void eventPossess ( class APawn* aPawn, unsigned long bVehicleTransition );
	void ServerAcknowledgePossession ( class APawn* P );
	void AcknowledgePossession ( class APawn* P );
	void eventPreRender ( class UCanvas* Canvas );
	void eventCopyPropertiesTo ( class AController* C );
	void CleanupPRI ( );
	void InitPlayerReplicationInfo ( );
	void eventDestroyed ( );
	void ClientRevertInventoryTransaction ( );
	void ClientRollbackInventoryTransaction ( int nNumSteps );
	void ClientSellItem ( int nInventoryId );
	void ClientPurchaseItem ( int nLootTableId, int nLootTableItemId, int nItemCount );
	void PressJump ( unsigned long bOn );
	void ServerProfiling ( struct FString Command );
	void ServerProfileScript ( struct FString Command );
	void SelfAlert ( int nPriority, float fDuration, int nMsgId );
	void RemoveAlertScript ( int nMsgId );
	void AddAlertScript ( unsigned char Priority, unsigned char Type, float fDuration, int nMsgId, unsigned long bBlockDuplicates );
	void ClientPingMap ( struct FVector WorldLoc, unsigned char pingType );
	void eventClientSetRotationAndDesired ( struct FRotator NewRotation, unsigned long bResetCamera );
	void eventClientSetRotation ( struct FRotator NewRotation, unsigned long bResetCamera );
	void ServerRove ( unsigned long bOn );
	void ToggleRove ( );
	void ServerViewSelf ( struct FViewTargetTransitionParams TransitionParams );
	void ServerWatchOtherPlayer ( unsigned char Mode );
	void StopWatchOthers ( );
	void StartWatchOthers ( unsigned char Mode );
	void SetCorrectViewTarget ( );
	void ServerSetViewTarget ( );
	void eventSelectPawn ( int nPawnId );
	bool PingMap ( struct FVector WorldLocation, unsigned char Type, TArray< class AReplicationInfo* >* worldActorRepInfos );
	void OnRightMouseReleased ( );
	void OnRightMousePressed ( );
	void OnLeftMouseReleased ( );
	void OnLeftMousePressed ( );
	bool eventControlModuleInterceptRawKey ( int ControllerId, struct FName Key, unsigned char Event, float AmountDepressed );
	void CCE ( struct FName EventName );
	void CauseClientEvent ( struct FName EventName );
	void WhereAmI ( );
	void AddAutoKickAlert ( );
	void AddAssistAlert ( struct FString KilledName, struct FString KillerName );
	void AddKillAlert ( struct FString KilledName, struct FString KillerName, unsigned long KillerWasPlayer );
	void SwapConsumableOrder ( );
	void SwapAbilityOrder ( );
	void ServerSetAutoSkillUp ( unsigned long bAutoSkill, unsigned long bForMatch );
	void SetAutoSkillUp ( unsigned long bAutoSkill, unsigned long bForMatch );
	void ServerSetAutoPurchase ( unsigned long bAutoPurchase, unsigned long bForMatch );
	void SetAutoPurchase ( unsigned long bAutoPurchase, unsigned long bForMatch );
	void SetCanPurchaseFlag ( unsigned long bCanPurchase );
	void SetTaskforceLead ( struct FString fsName );
	void ShowRespawnTimerExpired ( );
	void eventRequestShowRespawnBuyback ( );
	void eventClientShowRespawnBuyback ( int nCost );
	void ClientSendMissionTimerEvent ( int nEventId, int nWinningTaskForce );
	void eventClientgfxProcessSound ( struct FName aThemeName, struct FName aEventName );
	void ClientPlaySound ( class USoundCue* ASound );
	void Logoff ( unsigned long bForced );
	void AllocateDevicePoint ( int nDeviceId );
	void SetPlayerGlobalEmote ( int nGlobalEmoteSkinId );
	void SetPlayerWard ( int nWardSkinId );
	void SetPlayerProfile ( int nProfileId, int nSkinId );
	void SetLevel ( int nLevel );
	float StartReviveTimer ( unsigned long bDoNotUpdateStatsTracker );
	void SetNWCondition ( int nPktLoss, int nPktLag );
	void TestCrashReport ( );
	class UMaterialInstanceConstant* GetMICResource ( int nResourceId );
	void SetSpecialTimeToViewOthers ( int BotID, int SkinId );
	void HideTransitionalEOMScene ( );
	void ShowTransitionalEOMScene ( );
	void AchievementModifiedHealthProp ( int nHealth, int nMaxHealth );
	void AchievementAchievedById ( int nActivityId );
	void AchievementUnPossess ( );
	void AchievementPossess ( class APawn* aPawn );
	void ServerRequestGraphData ( );
	void ServerPlayContextNotify ( int ContextId, struct FVector NotifyLocation );
	void SendContextNotifyVGS ( int ContextId, struct FVector NotifyLocation );
	void ClientAddCheats ( );
	void CheckHealthFX ( float fCurrent, float fMaximum );
	void PlayEventFX ( );
	void StartFX ( );
	void UpdateRuntimeInput ( unsigned long bSpectator );
	void ResetKeysToDefault ( unsigned long bSpectator, struct FString PresetName );
	void UpdateForceFeedback ( float fDeltaTime, float fHealthPCT, float fHealthLostPCT, float fLastCastTime );
	bool IsGMPlayerController ( );
	bool IsLocalPlayerController ( );
	void SpectateStop ( );
	void Spectate ( struct FString sPlayerName, struct FString sPassword );
	void SpectateGM ( struct FString sPlayerName );
	void eventKickWarning ( );
	void SendCombatMessage ( struct FCombatMessageInfo msgInfo );
	void ShowRespawnBuyback ( int nCost );
	void gfxProcessSound ( struct FName aThemeName, struct FName aEventName );
	void UpdateTransitionUI ( );
	void UpdateStoreCanPurchase ( );
	void UpdatePlayerVitalsUI ( );
	void ToggleMiniMapPing ( unsigned long bStart );
	void ClearTargetingList ( );
	void UpdateTargetingList ( TArray< struct FImpactInfo > ImpactList, unsigned long bLightUp );
	bool CanEmoteBePlayed ( unsigned char Emote );
	void HandlePlayEmoteFailure ( unsigned char Emote, unsigned char failType );
	bool ShouldRequestTip ( int nGameTipId );
	void OnSceneLoadChange ( struct FString SceneName, unsigned long bLoaded );
	bool IsTutorialBlockingAction ( unsigned char Action );
	bool HandleTutorialActionOnServer ( class UTgSeqAct_ForceClientTutorialAction* inAction );
	void HandleTutorialHighlighter ( unsigned long bShow, int highlightedElement );
	void HandleTutorialImage ( unsigned long bShow, int HeaderMsgId, int ImageId, int msgId );
	void HandleForcedClientTutorialAction ( int nAction, int nActionElement );
	void TriggerTutorialEvent ( int nTutEvent, int nInfoData );
	void LogTutorialAction ( int nPlayerAction, int nEventData );
	void ClientLogoff ( unsigned long bForced );
	void ServerPlayPing ( float X, float Y, float Z, unsigned char pingType );
	void ServerPlayVGS ( int nVgsId, int usedVPSetting );
	void ServerRevertInventoryTransaction ( );
	void ServerRollbackInventoryTransaction ( int nNumSteps );
	void ServerSellItem ( int nInventoryId );
	void ServerUpgradeItem ( int nLootTableId, int nLootTableItemId, int nUpgradeInvId );
	void ServerPurchaseItem ( int nLootTableId, int nLootTableItemId, int nItemCount );
	void ServerSwapConsumableOrder ( );
	void ServerSwapAbilityOrder ( );
	void DisplayIdleWarning ( );
	int GetTaskForceNumber ( );
	void ClientUpdateTutorialBlockingActions ( );
	bool ClientUpdateUIDeviceState ( );
	void ServerAllocateDevicePoint ( int nDeviceId );
	bool HaveBasicAbilitiesBeenActivated ( );
	int GetDevicePointsSpent ( );
	int GetDevicePointsAvailable ( );
	bool CanAllocateDevicePoint ( int nDeviceId, class ATgDevice* aDevice, unsigned long ignorePause );
	unsigned char ServerTransferGoldBetweenFriendlyPlayers ( int ReceivingPlayerID, int GoldCount );
	unsigned char GiveGoldToFriendlyPlayer ( int PlayerID, int GoldCount );
	void SetAutoSkillUpFlag ( unsigned long bOn, unsigned long bForce );
	void SetAutoPurchaseFlag ( unsigned long bOn, unsigned long bForce );
	void AutoSkillUp ( );
	void AutoPurchase ( );
	void GetDamageAngle ( struct FRotator HitDir, float* PitchDegrees, float* YawDegrees );
	void SendUICurrencyChange ( );
	void SendUIXpChange ( );
	void HandleSimulatedProjectile ( );
	void DebugGetLangMsg ( int nMsgId );
	void SetSoundMode ( struct FName NewSoundMode );
	void DumpPerfTrackData ( );
	void TgPerfTrack ( unsigned long bStart );
	void SetPawnTickState ( int nState );
	void ToggleTick ( struct FString ClassName, unsigned long bDisable );
	void DoClientSidePerfTracking ( int nLength );
	void OutputRelevantActors ( );
	bool CheckMaxEffectDistance ( class APlayerController* P, struct FVector SpawnLocation, float CullDistance );
	void ConvertTimeDisplay ( int nMinutes, struct FString* sDisplay );
	class ATgPawn* GetPlayerControlPawn ( );
	void SendGameOverEvent ( unsigned char gameWinState, unsigned long bPlayerIsAttacker );
	void DumpClassInfoToFile ( struct FString sClassName );
	void ClientLoadDevices ( class UTgSeqAct_ClientLoadDevices* Action );
	int GetDeviceIdByName ( struct FString sDeviceName );
	void SetValue ( struct FString fsObject, struct FString fsVariable, struct FString fsValue );
	void GetValue ( struct FString fsObject, struct FString fsValue );
	bool bIsEditor ( );
	void ForceRelevant ( class AActor* pActor, float fDuration );
	void FinalSave ( );
	void SpectateDefaultSkins ( unsigned long bShow );
	void SpectateExpertMode ( unsigned long bShow );
	void SpectateOutlines ( unsigned long bShow );
	void SpectateXP ( unsigned long bShow );
	void SpectateGold ( unsigned long bShow );
	void SpectateCrits ( unsigned long bShow );
	void SpectateHeals ( unsigned long bShow );
	void SpectateDamage ( unsigned long bShow );
	void DisableProfanityFilter ( unsigned long bDisable );
	void ToggleInHandTargeting ( unsigned long bHide );
	void StopLogTo ( );
	void LogTo ( struct FString fsHost, int nPort );
	void _Crash ( );
	void Bug ( );
	class UTgClientSettings* GetClientSettings ( );
	void eventMatchAccept ( unsigned long bAccepted );
	void MatchLeave ( unsigned long bAsTeam );
	void ConfirmMatchLeave ( unsigned long bLeave );
	void Friend ( struct FString sCmd, struct FString sName );
	void ServerSetTaskforceLead ( struct FString fsName );
	bool CanCameraSeeActorCenter ( class AActor* Other, float ZOffset );
	bool CanCameraSeePawnCenter ( class ATgPawn* Other );
	class UClass* GetHudClass ( class UClass* pNewHudType );
	void QueueReviveTimeChanged ( );
	bool IsReadyForStart ( );
	void CanDoFullSellback ( );
};

UClass* ATgPlayerController::pClassPointer = NULL;

// Class TgGame.TgBattleCheatManager
// 0x0014 (0x007C - 0x0068)
class UTgBattleCheatManager : public UPComCheatManager
{
public:
	class ATgDemoRecSpectator_Debug*                   m_DebugCameraController;                          		// 0x0068 (0x0004) [0x0000000000000000]              
	int                                                m_nYawRotation;                                   		// 0x006C (0x0004) [0x0000000000000000]              
	int                                                m_nPitchRotation;                                 		// 0x0070 (0x0004) [0x0000000000000000]              
	int                                                m_nTiledShotAmount;                               		// 0x0074 (0x0004) [0x0000000000000000]              
	class AActor*                                      m_OriginalViewTarget;                             		// 0x0078 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1487 );

		return pClassPointer;
	};

	void SpawnTwoBots ( struct FString godName, unsigned long shouldHookMeUp );
	void siege ( );
	void lobbymap ( );
	void assault ( );
	void arena ( );
	void conquest ( );
	void ranneytest ( struct FString godName, struct FString skinName );
	void joust ( );
	void tutorial ( );
	void DumpRacerData ( );
	void UpdateCamera ( );
	void DoScreenshot ( );
	void ActivateGlobeCamera ( int YawRotation, int PitchRotation, int TiledShotAmount, class ACameraActor* DesiredCamera );
	void UpdateArenaScore ( int nTaskForce, int NewScore );
	void AdjustArenaScore ( int nTaskForce, int NewScore );
	void ResetCooldown ( unsigned char ItemSlot );
	void ItemCooldown ( unsigned char ItemSlot );
	void PlayerOverviewCamera ( unsigned long bOn );
	void AllEmotes ( unsigned long bOn );
	void TestToggleLightMode ( unsigned char NewMode );
	void InvisMe ( unsigned long bInvis );
	void ToggleSpectatorCamera ( );
	void ShowPlayerCircles ( unsigned long bEnabled );
	void BotsShoot ( int eEquipSlot );
	void TestSilence ( unsigned long isSilenced );
	void TestStun ( unsigned char Type );
	void TestStunEffect ( float fDuration );
	void TestShowInventory ( );
	void HitMeWith ( int Value, int AttackDamageType );
	void DamageMe ( int Value );
	void SetEnergy ( float Value );
	void QuickEndGame ( unsigned long bWin );
	void Qeg ( unsigned long bWin );
	void SetMeLevel ( int nLevel );
	void Obama ( int nCurrency );
	void AddGold ( int nCurrency );
	void EquipDevice ( int nDeviceId, int nEquipPointId );
	void EquipDeviceByName ( struct FString sDeviceName, int nEquipPointId );
	void ChangeTaskForce ( unsigned char nTaskForce );
	void ShowFootstepInfo ( );
	void BeTheBoss ( );
	void TowerKiller ( );
	void ApplyProp ( int nPropId, float nValue, int nCategory );
	void SpectatorCamera ( unsigned long bOn );
	void botsstealth ( unsigned long bOn );
	void botscooldown ( unsigned long bOn );
	void botsenergy ( unsigned long bOn );
	void botslevel ( int nLevel );
	void botsgod ( unsigned long bOn );
	void RequestRelease ( );
	void TestObstacleAvoidance ( int TestType );
	void ToggleVisionRangeDebug ( );
	void ToggleAIVis ( unsigned char TaskforceNum );
	void ToggleAIDebug ( unsigned long bAttachAIDebugger );
	void ToggleCustomPhysics ( );
	void ToggleDeviceLog ( unsigned char eqp );
	void KillAllPawnsByClass ( struct FString PawnClassName );
	void KillAllPawnsHelper ( class UClass* PawnClass );
	void KillAllMinions ( );
	void _SpawnTemplatePlayer ( int nProfileId, int nSkinId );
	void SetInventoryDirty ( );
	void ShowMoveErrors ( );
	void SetWhiteoutHUDFx ( unsigned long bOn );
	void SetStealth ( unsigned long bOn );
	void SetGroundspeed ( float val );
	void GiveRecommendedItems ( );
	void HookMeUp ( );
	void KnockbackDist ( float newdist );
	void MaxPower ( );
	void Cooldown ( );
	void Energy ( );
	void God ( );
	void CheatLog ( struct FString cheatText, unsigned long bOn );
	void SimNWCondition ( int nPktLoss, int nPktLag );
	void MaxLevel ( );
	void TestSkinGalleryLobby ( int nGallery, int nPose );
	void TestSkinGallery ( int nGallery );
	void SpawnBot ( struct FString sName, int nTaskForce, int nCount, struct FString BehaviorTreeName );
	void _SpawnBot ( struct FString sName, int nTaskForce, int nCount );
	void ServerExec ( struct FString FSCommand );
	void Loc ( );
	void echo ( struct FString inputString );
	void SetAILevel ( class ATgAIController_BehaviorGod* aic, int nLevel );
	void StreamMusicTheme ( int themeid );
	void SetFallbackToDefaultSkins ( unsigned long bFallback, unsigned long bForce );
	void SpawnBotAllSkinsLobby ( int nBatch, unsigned char pose );
	void SpawnBotAllSkins ( int nBatch );
	void SpawnBotByName ( struct FString botName, int taskforce, int nCount, struct FString BehaviorTreeName );
	void NativeMaxLevel ( );
	void TestLanguage ( struct FString newLangExt );
	void ListTickableActors ( unsigned char checkgroup );
	void JoinMatchQueue ( int nQueueId, int god1, int god2, int god3, int god4, int god5 );
	void SwitchGlobalEmote ( struct FString globalEmoteSkinName );
	void SwitchWard ( struct FString wardSkinName );
	void SwitchClass ( struct FString godName, struct FString skinName );
	void LogPerfLeakData ( );
};

UClass* UTgBattleCheatManager::pClassPointer = NULL;

// Class TgGame.TgCharacterBuilderLight
// 0x0000 (0x01F8 - 0x01F8)
class ATgCharacterBuilderLight : public ASpotLightToggleable
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1488 );

		return pClassPointer;
	};

};

UClass* ATgCharacterBuilderLight::pClassPointer = NULL;

// Class TgGame.TgClientSettings
// 0x00DC (0x0118 - 0x003C)
class UTgClientSettings : public UObject
{
public:
	unsigned char                                      ClientSettingsVersion;                            		// 0x003C (0x0001) [0x0000000000044000]              ( CPF_Config | CPF_GlobalConfig )
	unsigned char                                      OverlayGodName;                                   		// 0x003D (0x0001) [0x0000000000044001]              ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	unsigned char                                      ShowFriendStateNotifications;                     		// 0x003E (0x0001) [0x0000000000044001]              ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	unsigned char                                      TargetingLineStyle;                               		// 0x003F (0x0001) [0x0000000000044001]              ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	unsigned char                                      TargetingPreviewStyle;                            		// 0x0040 (0x0001) [0x0000000000044001]              ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	unsigned char                                      TargetingReticleStyle;                            		// 0x0041 (0x0001) [0x0000000000044001]              ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	unsigned char                                      TargetingHighlightStyle;                          		// 0x0042 (0x0001) [0x0000000000044001]              ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	unsigned char                                      CastMode;                                         		// 0x0043 (0x0001) [0x0000000000044001]              ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	unsigned char                                      SelectedColorBlindOption;                         		// 0x0044 (0x0001) [0x0000000000044001]              ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	float                                              UIScaling;                                        		// 0x0048 (0x0004) [0x0000000000044001]              ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	float                                              HUDScaling;                                       		// 0x004C (0x0004) [0x0000000000044001]              ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	float                                              CombatTextScaling;                                		// 0x0050 (0x0004) [0x0000000000044001]              ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	float                                              ChatScaling;                                      		// 0x0054 (0x0004) [0x0000000000044001]              ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	float                                              ChatFadeout;                                      		// 0x0058 (0x0004) [0x0000000000044001]              ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	unsigned long                                      OverlayShowLocalPlayer : 1;                       		// 0x005C (0x0004) [0x0000000000044001] [0x00000001] ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	unsigned long                                      DisableHelpMessages : 1;                          		// 0x005C (0x0004) [0x0000000000044001] [0x00000002] ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	unsigned long                                      ShowInHandTargeting : 1;                          		// 0x005C (0x0004) [0x0000000000044001] [0x00000004] ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	unsigned long                                      DisableTargetingAid : 1;                          		// 0x005C (0x0004) [0x0000000000044001] [0x00000008] ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	unsigned long                                      VerticalTargetingPreviews : 1;                    		// 0x005C (0x0004) [0x0000000000044001] [0x00000010] ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	unsigned long                                      DisableProfanityFilter : 1;                       		// 0x005C (0x0004) [0x0000000000044001] [0x00000020] ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	unsigned long                                      ShowTeamTags : 1;                                 		// 0x005C (0x0004) [0x0000000000044001] [0x00000040] ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	unsigned long                                      SpectateDamage : 1;                               		// 0x005C (0x0004) [0x0000000000044001] [0x00000080] ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	unsigned long                                      SpectateHeals : 1;                                		// 0x005C (0x0004) [0x0000000000044001] [0x00000100] ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	unsigned long                                      SpectateCrits : 1;                                		// 0x005C (0x0004) [0x0000000000044001] [0x00000200] ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	unsigned long                                      SpectateGold : 1;                                 		// 0x005C (0x0004) [0x0000000000044001] [0x00000400] ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	unsigned long                                      SpectateXP : 1;                                   		// 0x005C (0x0004) [0x0000000000044001] [0x00000800] ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	unsigned long                                      SpectateOutlines : 1;                             		// 0x005C (0x0004) [0x0000000000044001] [0x00001000] ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	unsigned long                                      SpectateExpertMode : 1;                           		// 0x005C (0x0004) [0x0000000000044001] [0x00002000] ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	unsigned long                                      SpectateDefaultSkins : 1;                         		// 0x005C (0x0004) [0x0000000000044001] [0x00004000] ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	unsigned long                                      ShowRentNotification : 1;                         		// 0x005C (0x0004) [0x0000000000044001] [0x00008000] ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	unsigned long                                      ShowWardPings : 1;                                		// 0x005C (0x0004) [0x0000000000044001] [0x00010000] ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	unsigned long                                      EnableUpcomingFeatures : 1;                       		// 0x005C (0x0004) [0x0000000000044001] [0x00020000] ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	unsigned long                                      LoadAssistModeSubLevel : 1;                       		// 0x005C (0x0004) [0x0000000000044001] [0x00040000] ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	unsigned long                                      LandingPanelMinimized : 1;                        		// 0x005C (0x0004) [0x0000000000044001] [0x00080000] ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	unsigned long                                      bJumpEnabled : 1;                                 		// 0x005C (0x0004) [0x0000000000044001] [0x00100000] ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	unsigned long                                      bPublicParty : 1;                                 		// 0x005C (0x0004) [0x0000000000044001] [0x00200000] ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	unsigned long                                      bOptInNewFeatures : 1;                            		// 0x005C (0x0004) [0x0000000000044001] [0x00400000] ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	unsigned long                                      bResetSensitivity : 1;                            		// 0x005C (0x0004) [0x0000000000044001] [0x00800000] ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	unsigned long                                      bOptInSmiteNewsLetter : 1;                        		// 0x005C (0x0004) [0x0000000000044001] [0x01000000] ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	unsigned long                                      bTargetingAlwaysShowPreview : 1;                  		// 0x005C (0x0004) [0x0000000000044001] [0x02000000] ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	unsigned long                                      bUseCastQueueing : 1;                             		// 0x005C (0x0004) [0x0000000000044001] [0x04000000] ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	unsigned long                                      bUseFixedPitchMode : 1;                           		// 0x005C (0x0004) [0x0000000000044001] [0x08000000] ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	unsigned long                                      NewUserPromptTutorialMatch : 1;                   		// 0x005C (0x0004) [0x0000000000044001] [0x10000000] ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	unsigned long                                      NewUserFinished : 1;                              		// 0x005C (0x0004) [0x0000000000044001] [0x20000000] ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	unsigned long                                      VendorStoreTopTier : 1;                           		// 0x005C (0x0004) [0x0000000000044001] [0x40000000] ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	unsigned long                                      bEnableHelpPopups : 1;                            		// 0x005C (0x0004) [0x0000000000044001] [0x80000000] ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	unsigned long                                      bHideSeasonTicketSpoilers : 1;                    		// 0x0060 (0x0004) [0x0000000000044001] [0x00000001] ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	unsigned long                                      bShowManaUsage : 1;                               		// 0x0060 (0x0004) [0x0000000000044001] [0x00000002] ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	unsigned long                                      GodPageDisplayCard : 1;                           		// 0x0060 (0x0004) [0x0000000000044001] [0x00000004] ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	unsigned long                                      bUseHudv1 : 1;                                    		// 0x0060 (0x0004) [0x0000000000044001] [0x00000008] ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	unsigned long                                      bEnableChatTrayPopup : 1;                         		// 0x0060 (0x0004) [0x0000000000044001] [0x00000010] ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	unsigned long                                      bEnableFriendsTrayPopup : 1;                      		// 0x0060 (0x0004) [0x0000000000044001] [0x00000020] ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	unsigned long                                      ColorBlindMode : 1;                               		// 0x0060 (0x0004) [0x0000000000044001] [0x00000040] ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	unsigned long                                      ColorBlindModeShader : 1;                         		// 0x0060 (0x0004) [0x0000000000044001] [0x00000080] ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	unsigned long                                      ColorBlindModeShaderSimulateMode : 1;             		// 0x0060 (0x0004) [0x0000000000044001] [0x00000100] ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	unsigned long                                      MasterMute : 1;                                   		// 0x0060 (0x0004) [0x0000000000044001] [0x00000200] ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	unsigned long                                      SFXMute : 1;                                      		// 0x0060 (0x0004) [0x0000000000044001] [0x00000400] ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	unsigned long                                      MusicMute : 1;                                    		// 0x0060 (0x0004) [0x0000000000044001] [0x00000800] ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	unsigned long                                      VoiceMute : 1;                                    		// 0x0060 (0x0004) [0x0000000000044001] [0x00001000] ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	unsigned long                                      MatchNotifierMute : 1;                            		// 0x0060 (0x0004) [0x0000000000044001] [0x00002000] ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	unsigned long                                      AllPlayerMute : 1;                                		// 0x0060 (0x0004) [0x0000000000044001] [0x00004000] ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	unsigned long                                      ChatNotifierMute : 1;                             		// 0x0060 (0x0004) [0x0000000000044001] [0x00008000] ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	unsigned long                                      QueueWaitRegion : 1;                              		// 0x0060 (0x0004) [0x0000000000044001] [0x00010000] ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	unsigned long                                      QueueWaitSolo : 1;                                		// 0x0060 (0x0004) [0x0000000000044001] [0x00020000] ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	unsigned long                                      BotPracticeMode : 1;                              		// 0x0060 (0x0004) [0x0000000000044001] [0x00040000] ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	unsigned long                                      AutoPurchase : 1;                                 		// 0x0060 (0x0004) [0x0000000000044001] [0x00080000] ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	unsigned long                                      AutoSkill : 1;                                    		// 0x0060 (0x0004) [0x0000000000044001] [0x00100000] ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	unsigned long                                      DisableJoystickInput : 1;                         		// 0x0060 (0x0004) [0x0000000000044001] [0x00200000] ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	unsigned long                                      bAllowLogitechLedSdk : 1;                         		// 0x0060 (0x0004) [0x0000000000044001] [0x00400000] ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	unsigned long                                      EnableControllerFeedback : 1;                     		// 0x0060 (0x0004) [0x0000000000044001] [0x00800000] ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	unsigned long                                      EnableBasicAttackControllerFeedback : 1;          		// 0x0060 (0x0004) [0x0000000000044001] [0x01000000] ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	unsigned long                                      DisableAimAssist : 1;                             		// 0x0060 (0x0004) [0x0000000000044001] [0x02000000] ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	unsigned long                                      InvertY : 1;                                      		// 0x0060 (0x0004) [0x0000000000044001] [0x04000000] ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	unsigned long                                      blockNonFriendChat : 1;                           		// 0x0060 (0x0004) [0x0000000000000000] [0x08000000] 
	unsigned long                                      newUserFinishedTutorial : 1;                      		// 0x0060 (0x0004) [0x0000000000000000] [0x10000000] 
	unsigned long                                      newUserSkipTraining : 1;                          		// 0x0060 (0x0004) [0x0000000000000000] [0x20000000] 
	unsigned long                                      newUserFinishedEmailSetup : 1;                    		// 0x0060 (0x0004) [0x0000000000000000] [0x40000000] 
	unsigned long                                      newPromotionalCode : 1;                           		// 0x0060 (0x0004) [0x0000000000000000] [0x80000000] 
	unsigned long                                      bSkipSaveOnSettingsChanged : 1;                   		// 0x0064 (0x0004) [0x0000000000000000] [0x00000001] 
	int                                                TeamTagFormat;                                    		// 0x0068 (0x0004) [0x0000000000044001]              ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	int                                                SpectateBottomBarSize;                            		// 0x006C (0x0004) [0x0000000000044001]              ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	float                                              MinimapOpacity;                                   		// 0x0070 (0x0004) [0x0000000000044001]              ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	int                                                HealthBarOpacity;                                 		// 0x0074 (0x0004) [0x0000000000044001]              ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	int                                                HealthBarScale;                                   		// 0x0078 (0x0004) [0x0000000000044001]              ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	int                                                nSelectedPreset;                                  		// 0x007C (0x0004) [0x0000000000044001]              ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	struct FString                                     sEmail;                                           		// 0x0080 (0x000C) [0x0000000000444001]              ( CPF_Edit | CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink )
	float                                              CastQueueTime;                                    		// 0x008C (0x0004) [0x0000000000044001]              ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	float                                              FixedPitchLowerBoundDegrees;                      		// 0x0090 (0x0004) [0x0000000000044001]              ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	float                                              FixedPitchUpperBoundDegrees;                      		// 0x0094 (0x0004) [0x0000000000044001]              ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	int                                                PlayNowTabId;                                     		// 0x0098 (0x0004) [0x0000000000044001]              ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	int                                                VendorStoreTabId;                                 		// 0x009C (0x0004) [0x0000000000044001]              ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	int                                                VendorStoreTypeId;                                		// 0x00A0 (0x0004) [0x0000000000044001]              ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	int                                                VendorStoreTypeRecId;                             		// 0x00A4 (0x0004) [0x0000000000044001]              ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	int                                                LeagueSelection;                                  		// 0x00A8 (0x0004) [0x0000000000044001]              ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	int                                                VPSelection;                                      		// 0x00AC (0x0004) [0x0000000000044001]              ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	struct FString                                     TransformSettings;                                		// 0x00B0 (0x000C) [0x0000000000444001]              ( CPF_Edit | CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink )
	struct FString                                     TransformSettingsV2;                              		// 0x00BC (0x000C) [0x0000000000444001]              ( CPF_Edit | CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink )
	int                                                ColorBlindModeShaderType;                         		// 0x00C8 (0x0004) [0x0000000000044001]              ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	float                                              MasterVolume;                                     		// 0x00CC (0x0004) [0x0000000000044001]              ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	float                                              SFXVolume;                                        		// 0x00D0 (0x0004) [0x0000000000044001]              ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	float                                              MusicVolume;                                      		// 0x00D4 (0x0004) [0x0000000000044001]              ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	float                                              VoiceVolume;                                      		// 0x00D8 (0x0004) [0x0000000000044001]              ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	float                                              MatchNotifierVolume;                              		// 0x00DC (0x0004) [0x0000000000044001]              ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	float                                              Gamma;                                            		// 0x00E0 (0x0004) [0x0000000000044001]              ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	int                                                BotDifficulty;                                    		// 0x00E4 (0x0004) [0x0000000000044001]              ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	float                                              LookSensitivity;                                  		// 0x00E8 (0x0004) [0x0000000000044001]              ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	float                                              LookSensitivityY;                                 		// 0x00EC (0x0004) [0x0000000000044001]              ( CPF_Edit | CPF_Config | CPF_GlobalConfig )
	int                                                loadingPortraitBanner;                            		// 0x00F0 (0x0004) [0x0000000000000000]              
	int                                                bHideGodStats;                                    		// 0x00F4 (0x0004) [0x0000000000000000]              
	int                                                bUseClanAvatar;                                   		// 0x00F8 (0x0004) [0x0000000000000000]              
	TArray< int >                                      newUserWatchedVideos;                             		// 0x00FC (0x000C) [0x0000000000500000]              ( CPF_NeedCtorLink )
	TArray< int >                                      newUserTutorialsPlayed;                           		// 0x0108 (0x000C) [0x0000000000500000]              ( CPF_NeedCtorLink )
	int                                                newUserTrainingProgression;                       		// 0x0114 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1489 );

		return pClassPointer;
	};

	bool eventUpdatePlayerMuteSetting ( unsigned long PlayerMuteSetting );
	unsigned char GetTargetingHighlightStyle ( );
	void SetCastMode ( unsigned char castModeVal, int godId, unsigned char equipPoint );
	unsigned char GetCastMode ( int godId, unsigned char equipPoint );
	void OverrideVoiceInGameSettings ( unsigned long bOverride );
	bool eventWriteSaveGameDataViaInterface ( unsigned char LocalUserNum, struct FString Title, struct FString SubTitle, struct FString Description, struct FString* SaveFileName, TArray< unsigned char >* SaveGameData );
	bool eventGetSaveGameDataViaInterface ( unsigned char LocalUserNum, struct FString* SaveFileName, unsigned char* bIsValid, TArray< unsigned char >* SaveGameData );
	bool eventConditionalReadSaveGameData ( int PlayerID, struct FString SaveFileName );
	void OnReadSaveGameData ( unsigned long bWasSuccessful, unsigned char LocalUserNum, struct FString SaveFileName );
	void SavePlayerSettings ( );
	void LoadPlayerSettingsFromIni ( );
	void LoadPlayerSettings ( );
	void UpdateSettingsVersion ( );
	void VerifySettingsAreValid ( );
	void ApplyVideoSettings ( );
	void ApplyInputSettings ( );
	void ApplyAudioSettings ( );
	void SetSkipSaveOnSettingsChanged ( unsigned long bSkipSave );
	void OnSettingsChanged ( int settingtype, unsigned long bSkipSave );
	void LoadSettingsOnStartup ( );
};

UClass* UTgClientSettings::pClassPointer = NULL;

// Class TgGame.TgCollisionProxy
// 0x0028 (0x0218 - 0x01F0)
class ATgCollisionProxy : public AActor
{
public:
	TArray< class ATgPawn* >                           m_NearByPlayers;                                  		// 0x01F0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	unsigned long                                      m_bIgnoreStealthPlayers : 1;                      		// 0x01FC (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bIgnoreNonPlayers : 1;                          		// 0x01FC (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_bIgnoreInvulnerablePlayers : 1;                 		// 0x01FC (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_bForwardOwnerOnly : 1;                          		// 0x01FC (0x0004) [0x0000000000000000] [0x00000008] 
	struct FScriptDelegate                             __ProxyTouch__Delegate;                           		// 0x0200 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FScriptDelegate                             __ProxyUnTouch__Delegate;                         		// 0x020C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1490 );

		return pClassPointer;
	};

	void ForceProximityScan ( float Radius );
	void GetNearByPlayersTaskforce ( unsigned long bEndWhenMultipleFound, TArray< int >* NearByPlayerTaskforces );
	int GetNearByPlayers ( unsigned long bOnlyValid );
	void OnPlayerRemoved ( class ATgPawn* aPawn );
	void OnPlayerAdded ( class ATgPawn* aPawn );
	void CheckNearByPlayers ( class ATgPawn* aPawn, unsigned long bAdd );
	void Destroyed ( );
	void eventForceClearNearByPlayersList ( );
	bool eventShouldIgnoreActor ( class ATgPawn* aPawn );
	void eventUnTouch ( class AActor* Other );
	void eventTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void TouchOther ( class AActor* Other, class UPrimitiveComponent* OtherComp );
	void DelegatesUpdated ( );
	void ForwardUnTouch ( class AActor* Other );
	void ForwardTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void ProxyUnTouch ( class AActor* Other );
	void ProxyTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
};

UClass* ATgCollisionProxy::pClassPointer = NULL;

// Class TgGame.TgCollisionProxy_Box
// 0x0004 (0x021C - 0x0218)
class ATgCollisionProxy_Box : public ATgCollisionProxy
{
public:
	class UStaticMeshComponent*                        m_CollisionBox;                                   		// 0x0218 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1491 );

		return pClassPointer;
	};

	void SetLocationAndSize ( struct FVector Start, struct FVector End, float Width );
};

UClass* ATgCollisionProxy_Box::pClassPointer = NULL;

// Class TgGame.TgCollisionProxy_Cylinder
// 0x0004 (0x021C - 0x0218)
class ATgCollisionProxy_Cylinder : public ATgCollisionProxy
{
public:
	class UCylinderComponent*                          m_CollisionCylinder;                              		// 0x0218 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1492 );

		return pClassPointer;
	};

};

UClass* ATgCollisionProxy_Cylinder::pClassPointer = NULL;

// Class TgGame.TgCollisionProxy_SpectatorActionListener
// 0x000C (0x0228 - 0x021C)
class ATgCollisionProxy_SpectatorActionListener : public ATgCollisionProxy_Cylinder
{
public:
	struct FScriptDelegate                             __ProxyDeviceOnStartFire__Delegate;               		// 0x021C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1493 );

		return pClassPointer;
	};

	void eventPostDemoRewind ( );
	bool HasMixedTaskforcePlayersNearby ( );
	void ForwardDeviceOnStartFire ( class ATgPawn* FiringPawn, int nEquipSlot );
	void ProxyDeviceOnStartFire ( class ATgPawn* FiringPawn, int nEquipSlot );
};

UClass* ATgCollisionProxy_SpectatorActionListener::pClassPointer = NULL;

// Class TgGame.TgCollisionProxy_GroundPlacementBlocker
// 0x0000 (0x0218 - 0x0218)
class ATgCollisionProxy_GroundPlacementBlocker : public ATgCollisionProxy
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1494 );

		return pClassPointer;
	};

};

UClass* ATgCollisionProxy_GroundPlacementBlocker::pClassPointer = NULL;

// Class TgGame.TgCollisionProxy_JingWei_Dev4
// 0x0000 (0x0218 - 0x0218)
class ATgCollisionProxy_JingWei_Dev4 : public ATgCollisionProxy
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1495 );

		return pClassPointer;
	};

};

UClass* ATgCollisionProxy_JingWei_Dev4::pClassPointer = NULL;

// Class TgGame.TgCollisionProxy_PawnListener
// 0x003C (0x0254 - 0x0218)
class ATgCollisionProxy_PawnListener : public ATgCollisionProxy
{
public:
	struct FScriptDelegate                             __ProxyDeviceOnStartFire__Delegate;               		// 0x0218 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FScriptDelegate                             __ProxyDeviceOnStopFire__Delegate;                		// 0x0224 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FScriptDelegate                             __ProxyPawnOnDamaged__Delegate;                   		// 0x0230 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FScriptDelegate                             __ProxyPawnOnDied__Delegate;                      		// 0x023C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FScriptDelegate                             __ProxyPawnOnDamageMitigation__Delegate;          		// 0x0248 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1496 );

		return pClassPointer;
	};

	void OnPlayerRemoved ( class ATgPawn* aPawn );
	void OnPlayerAdded ( class ATgPawn* aPawn );
	bool eventShouldIgnoreActor ( class ATgPawn* aPawn );
	void DelegatesUpdated ( );
	void ForwardPawnOnDamageMitigation ( class ATgPawn* Other, class ATgPawn* attacker, class UTgEffectGroup* Effect, int nPropertyId, float* Damage );
	void ForwardPawnOnDied ( class ATgPawn* Other );
	void ForwardPawnOnDamaged ( class ATgPawn* Other, struct FOnDamagedParams* DamageParams );
	void ForwardDeviceOnStopFire ( class ATgPawn* Other, class ATgDevice* OtherDevice, unsigned long bWasInterrupted );
	void ForwardDeviceOnStartFire ( class ATgPawn* Other, class ATgDevice* OtherDevice );
	void ProxyPawnOnDamageMitigation ( class ATgPawn* Other, class ATgPawn* attacker, class UTgEffectGroup* Effect, int nPropertyId, float* Damage );
	void ProxyPawnOnDied ( class ATgPawn* Other );
	void ProxyPawnOnDamaged ( class ATgPawn* Other, struct FOnDamagedParams* DamageParams );
	void ProxyDeviceOnStopFire ( class ATgPawn* Other, class ATgDevice* OtherDevice, unsigned long bWasInterrupted );
	void ProxyDeviceOnStartFire ( class ATgPawn* Other, class ATgDevice* OtherDevice );
};

UClass* ATgCollisionProxy_PawnListener::pClassPointer = NULL;

// Class TgGame.TgCollisionProxy_RadialSweep
// 0x0054 (0x026C - 0x0218)
class ATgCollisionProxy_RadialSweep : public ATgCollisionProxy
{
public:
	class UStaticMeshComponent*                        m_CollisionBox;                                   		// 0x0218 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	float                                              m_fSweepRadius;                                   		// 0x021C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_fSweepWidth;                                    		// 0x0220 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_fSweepStartTime;                                		// 0x0224 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_fSweepEndTime;                                  		// 0x0228 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FRotator                                    m_SweepStart;                                     		// 0x022C (0x000C) [0x0000000000002000]              ( CPF_Transient )
	struct FRotator                                    m_SweepEnd;                                       		// 0x0238 (0x000C) [0x0000000000002000]              ( CPF_Transient )
	struct FVector                                     m_SweepLastLocation;                              		// 0x0244 (0x000C) [0x0000000000002000]              ( CPF_Transient )
	struct FRotator                                    m_SweepLast;                                      		// 0x0250 (0x000C) [0x0000000000002000]              ( CPF_Transient )
	unsigned long                                      m_bSweepActive : 1;                               		// 0x025C (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	struct FScriptDelegate                             __ProxyEndSweep__Delegate;                        		// 0x0260 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1497 );

		return pClassPointer;
	};

	void EndSweep ( unsigned long bInterrupt );
	void StartSweep ( float fSweepTime, float fSweepAngle );
	void SetSweepSize ( float fSweepWidth, float fSweepRadius );
	void ProxyEndSweep ( unsigned long bInterrupted );
};

UClass* ATgCollisionProxy_RadialSweep::pClassPointer = NULL;

// Class TgGame.TgCollisionProxy_Vortex
// 0x0018 (0x0230 - 0x0218)
class ATgCollisionProxy_Vortex : public ATgCollisionProxy
{
public:
	float                                              m_fGroundSpeedStrafePct;                          		// 0x0218 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fGroundSpeedToVortex;                           		// 0x021C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fGroundSpeedPctRetained;                        		// 0x0220 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fInnerRadius;                                   		// 0x0224 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_bEnabled : 1;                                   		// 0x0228 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_bOnlyAffectCurrentTarget : 1;                   		// 0x0228 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_bIgnoreFallingTargets : 1;                      		// 0x0228 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	class APawn*                                       m_LastInstigator;                                 		// 0x022C (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1498 );

		return pClassPointer;
	};

	void OnPlayerRemoved ( class ATgPawn* aPawn );
	void OnPlayerAdded ( class ATgPawn* aPawn );
	bool eventShouldIgnoreActor ( class ATgPawn* aPawn );
	void eventUnTouch ( class AActor* Other );
	void eventTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void eventInstigatorChanged ( );
	void eventTick ( float DeltaTime );
};

UClass* ATgCollisionProxy_Vortex::pClassPointer = NULL;

// Class TgGame.TgCollisionProxy_StrongWinds
// 0x0014 (0x0244 - 0x0230)
class ATgCollisionProxy_StrongWinds : public ATgCollisionProxy_Vortex
{
public:
	struct FVector                                     m_vPushDirection;                                 		// 0x0230 (0x000C) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fWindStrength;                                  		// 0x023C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_bAffectsTaskForce1 : 1;                         		// 0x0240 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_bAffectsTaskForce2 : 1;                         		// 0x0240 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_bAffectsTaskForce3 : 1;                         		// 0x0240 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1499 );

		return pClassPointer;
	};

	bool eventShouldIgnoreActor ( class ATgPawn* aPawn );
};

UClass* ATgCollisionProxy_StrongWinds::pClassPointer = NULL;

// Class TgGame.TgCollisionProxy_Vortex_Cabrakan_Dev3
// 0x0000 (0x0230 - 0x0230)
class ATgCollisionProxy_Vortex_Cabrakan_Dev3 : public ATgCollisionProxy_Vortex
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1500 );

		return pClassPointer;
	};

};

UClass* ATgCollisionProxy_Vortex_Cabrakan_Dev3::pClassPointer = NULL;

// Class TgGame.TgCollisionProxy_Vortex_Hades
// 0x0000 (0x0230 - 0x0230)
class ATgCollisionProxy_Vortex_Hades : public ATgCollisionProxy_Vortex
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1501 );

		return pClassPointer;
	};

	void Tick ( float fDeltaSeconds );
};

UClass* ATgCollisionProxy_Vortex_Hades::pClassPointer = NULL;

// Class TgGame.TgCollisionProxy_Vortex_Poseidon
// 0x0000 (0x0230 - 0x0230)
class ATgCollisionProxy_Vortex_Poseidon : public ATgCollisionProxy_Vortex
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1502 );

		return pClassPointer;
	};

};

UClass* ATgCollisionProxy_Vortex_Poseidon::pClassPointer = NULL;

// Class TgGame.TgCollisionProxy_Vortex_Susano
// 0x0000 (0x0230 - 0x0230)
class ATgCollisionProxy_Vortex_Susano : public ATgCollisionProxy_Vortex
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1503 );

		return pClassPointer;
	};

};

UClass* ATgCollisionProxy_Vortex_Susano::pClassPointer = NULL;

// Class TgGame.TgCollisionProxy_WardTrigger
// 0x0004 (0x021C - 0x0218)
class ATgCollisionProxy_WardTrigger : public ATgCollisionProxy
{
public:
	class UCylinderComponent*                          m_CollisionCylinder;                              		// 0x0218 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1504 );

		return pClassPointer;
	};

};

UClass* ATgCollisionProxy_WardTrigger::pClassPointer = NULL;

// Class TgGame.TgCollisionProxy_Wave_Hebo
// 0x0000 (0x0218 - 0x0218)
class ATgCollisionProxy_Wave_Hebo : public ATgCollisionProxy
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1505 );

		return pClassPointer;
	};

};

UClass* ATgCollisionProxy_Wave_Hebo::pClassPointer = NULL;

// Class TgGame.TgCombinedPostProcessEffect
// 0x003B (0x009C - 0x0061)
class UTgCombinedPostProcessEffect : public UPostProcessEffect
{
public:
	struct FColor                                      HitEffectColor;                                   		// 0x0064 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FVector                                     SceneShadows;                                     		// 0x0068 (0x000C) [0x0000000000000000]              
	struct FVector                                     SceneHighLights;                                  		// 0x0074 (0x000C) [0x0000000000000000]              
	struct FVector                                     SceneMidTones;                                    		// 0x0080 (0x000C) [0x0000000000000000]              
	float                                              SceneDesaturation;                                		// 0x008C (0x0004) [0x0000000000000000]              
	struct FVector                                     SceneColorize;                                    		// 0x0090 (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1506 );

		return pClassPointer;
	};

};

UClass* UTgCombinedPostProcessEffect::pClassPointer = NULL;

// Class TgGame.TgContextNotifyActor
// 0x0000 (0x01F0 - 0x01F0)
class ATgContextNotifyActor : public AActor
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1507 );

		return pClassPointer;
	};

	void SetContextNotifyType ( int ContextId );
};

UClass* ATgContextNotifyActor::pClassPointer = NULL;

// Class TgGame.TgDamageType
// 0x0064 (0x00C8 - 0x0064)
class UTgDamageType : public UDamageType
{
public:
	unsigned long                                      m_bImpulseMesh : 1;                               		// 0x0064 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bEnableMotors : 1;                              		// 0x0064 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_bShouldRagdollAfterDeathAnim : 1;               		// 0x0064 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_bCanPlayDeathSpecialFXOnDefaultDeath : 1;       		// 0x0064 (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      m_bHarvestMaterialParameters : 1;                 		// 0x0064 (0x0004) [0x0000000000000000] [0x00000010] 
	unsigned long                                      m_bFreezeAnimsOnDeath : 1;                        		// 0x0064 (0x0004) [0x0000000000000000] [0x00000020] 
	float                                              m_bMinImpulse;                                    		// 0x0068 (0x0004) [0x0000000000000000]              
	float                                              m_bMaxImpulse;                                    		// 0x006C (0x0004) [0x0000000000000000]              
	float                                              m_bMinUpKick;                                     		// 0x0070 (0x0004) [0x0000000000000000]              
	float                                              m_bMaxUpKick;                                     		// 0x0074 (0x0004) [0x0000000000000000]              
	TArray< struct FName >                             m_nmDeathAnimNames;                               		// 0x0078 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< struct FName >                             m_nmDeathFlailAnimNames;                          		// 0x0084 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	float                                              m_fMinAngularVelocity;                            		// 0x0090 (0x0004) [0x0000000000000000]              
	float                                              m_fMaxAngularVelocity;                            		// 0x0094 (0x0004) [0x0000000000000000]              
	int                                                m_nDeathSpecialFXId;                              		// 0x0098 (0x0004) [0x0000000000000000]              
	int                                                m_nDeathSpecial02FXId;                            		// 0x009C (0x0004) [0x0000000000000000]              
	struct FName                                       m_nmDeathSpecialFXSocket;                         		// 0x00A0 (0x0008) [0x0000000000000000]              
	struct FName                                       m_nmDeathSpecial02FXSocket;                       		// 0x00A8 (0x0008) [0x0000000000000000]              
	class UMaterialInstanceConstant*                   m_OverrideMaterial;                               		// 0x00B0 (0x0004) [0x0000000000000000]              
	float                                              m_fLifeAfterDeathSeconds;                         		// 0x00B4 (0x0004) [0x0000000000000000]              
	int                                                m_nFadeOutSpecialFXId;                            		// 0x00B8 (0x0004) [0x0000000000000000]              
	TArray< struct FName >                             ActivateSkelControlListOnDeath;                   		// 0x00BC (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1508 );

		return pClassPointer;
	};

	float GetRagdollImpulseMultiplier ( class AActor* DamageInstigator );
	struct FName GetRandomDeathAnimName ( );
	struct FName GetRandomDeathFlailAnimName ( );
};

UClass* UTgDamageType::pClassPointer = NULL;

// Class TgGame.TgDamageType_AbilityCost
// 0x0000 (0x00C8 - 0x00C8)
class UTgDamageType_AbilityCost : public UTgDamageType
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1509 );

		return pClassPointer;
	};

};

UClass* UTgDamageType_AbilityCost::pClassPointer = NULL;

// Class TgGame.TgDamageType_Major
// 0x0000 (0x00C8 - 0x00C8)
class UTgDamageType_Major : public UTgDamageType
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1510 );

		return pClassPointer;
	};

};

UClass* UTgDamageType_Major::pClassPointer = NULL;

// Class TgGame.TgDamageType_MedusaUlt
// 0x0000 (0x00C8 - 0x00C8)
class UTgDamageType_MedusaUlt : public UTgDamageType
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1511 );

		return pClassPointer;
	};

};

UClass* UTgDamageType_MedusaUlt::pClassPointer = NULL;

// Class TgGame.TgDamageType_Minor
// 0x0000 (0x00C8 - 0x00C8)
class UTgDamageType_Minor : public UTgDamageType
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1512 );

		return pClassPointer;
	};

};

UClass* UTgDamageType_Minor::pClassPointer = NULL;

// Class TgGame.TgDestructible
// 0x0148 (0x037C - 0x0234)
class ATgDestructible : public ASkeletalMeshActor
{
public:
	class ATgEffectManager*                            r_EffectManager;                                  		// 0x0234 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nMaxHealth;                                     		// 0x0238 (0x0004) [0x0000000000000021]              ( CPF_Edit | CPF_Net )
	unsigned long                                      m_bDisplayHealth : 1;                             		// 0x023C (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_bDestroyed : 1;                                 		// 0x023C (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_bFogOfWarBlocker : 1;                           		// 0x023C (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      m_bOneDirectional : 1;                            		// 0x023C (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )
	int                                                m_nPhysicalType;                                  		// 0x0240 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                r_nHealth;                                        		// 0x0244 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nActorInstanceId;                               		// 0x0248 (0x0004) [0x0000000000000020]              ( CPF_Net )
	struct FTG_HUD_INFO                                c_HudInfo;                                        		// 0x024C (0x0130) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1513 );

		return pClassPointer;
	};

	bool eventCanApplyEffects ( );
	void Destroyed ( );
	void DestroyIt ( unsigned long bSkipFx );
	void eventTakeDamage ( int Damage, class AController* EventInstigator, struct FVector HitLocation, struct FVector Momentum, class UClass* DamageType, struct FTraceHitInfo HitInfo, class AActor* DamageCauser );
	void eventReplicatedEvent ( struct FName VarName );
	void PostBeginPlay ( );
	void ForceNetRelevant ( );
};

UClass* ATgDestructible::pClassPointer = NULL;

// Class TgGame.TgDistributionFloatSoundAttenuation
// 0x003C (0x008C - 0x0050)
class UTgDistributionFloatSoundAttenuation : public UDistributionFloat
{
public:
	unsigned char                                      AttenuationType;                                  		// 0x0050 (0x0001) [0x0000000000000000]              
	float                                              Attenuation_Sm_foley;                             		// 0x0054 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              Attenuation_Lg_foley;                             		// 0x0058 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              Attenuation_Melee_hit;                            		// 0x005C (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              Attenuation_Sm_gun;                               		// 0x0060 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              Attenuation_Med_gun;                              		// 0x0064 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              Attenuation_Lg_gun;                               		// 0x0068 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              Attenuation_Sm_exp;                               		// 0x006C (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              Attenuation_Med_exp;                              		// 0x0070 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              Attenuation_Lg_exp;                               		// 0x0074 (0x0004) [0x0000000000004000]              ( CPF_Config )
	struct FName                                       GroupName;                                        		// 0x0078 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	TArray< struct FAttenuationGroup >                 AttenuationGroups;                                		// 0x0080 (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1514 );

		return pClassPointer;
	};

};

UClass* UTgDistributionFloatSoundAttenuation::pClassPointer = NULL;

// Class TgGame.TgEmitterSpawnable
// 0x0000 (0x01FC - 0x01FC)
class ATgEmitterSpawnable : public AEmitter
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1515 );

		return pClassPointer;
	};

};

UClass* ATgEmitterSpawnable::pClassPointer = NULL;

// Class TgGame.TgFlagContentData
// 0x000C (0x0048 - 0x003C)
class UTgFlagContentData : public UObject
{
public:
	TArray< struct FFlagMeshData >                     m_MeshData;                                       		// 0x003C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1516 );

		return pClassPointer;
	};

	void PreloadTextures ( float ForceDuration );
	void eventGetMeshData ( unsigned char ContentDataType, struct FFlagMeshData* Data );
	void Init ( );
};

UClass* UTgFlagContentData::pClassPointer = NULL;

// Class TgGame.TgFogOfWarBarrier
// 0x0008 (0x0204 - 0x01FC)
class ATgFogOfWarBarrier : public AStaticMeshActor
{
public:
	unsigned long                                      m_bOneDirectional : 1;                            		// 0x01FC (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	float                                              m_fBlockMinimumDistance;                          		// 0x0200 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1517 );

		return pClassPointer;
	};

};

UClass* ATgFogOfWarBarrier::pClassPointer = NULL;

// Class TgGame.TgGameEngine
// 0x0000 (0x07E4 - 0x07E4)
class UTgGameEngine : public UPComGameEngine
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1518 );

		return pClassPointer;
	};

};

UClass* UTgGameEngine::pClassPointer = NULL;

// Class TgGame.TgHUD
// 0x0004 (0x047C - 0x0478)
class ATgHUD : public AHUD
{
public:
	class ATgPlayerController*                         m_TgPlayerController;                             		// 0x0478 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1519 );

		return pClassPointer;
	};

	void ToggleStatPanel ( );
	void SetIntendedPanel ( );
	void ShowPreviousInfoPanel ( );
	void ShowNextInfoPanel ( );
	void ShowPreviousStatPanel ( );
	void ShowNextStatPanel ( );
	bool IsLoggedIn ( );
	void PlayDeviceFailResponse ( unsigned char failType );
	void ShowGodTargeter ( unsigned long bShow );
	void ShowTargetingMap ( unsigned long bShow );
	void eventCommitClassSelectionChange ( );
	void ToggleViewSkipCinematic ( unsigned long bShow );
	void ShowCursor ( unsigned long bShow, unsigned long bUpdateCapture );
	void TutorialMessage ( int msgId, unsigned long bTips );
	void HideGameTip ( unsigned long bNoSound );
	void ShowGameTip ( int nTipId, unsigned long bNoSound, unsigned long bPopup );
	void PingWorldLocation ( struct FVector PingLocation, unsigned char Type );
	void OnPingInfoUpdate ( class ATgRepInfo_Player* updatedPri );
	void EndMission ( unsigned long bPlayerAttacker, unsigned char finalWinState );
	bool UpdateItemStoreItems ( class ATgRepInfo_Player* PRI );
	void UpdateScoreboard ( );
	void UpdateSpectatorSettingsMenu ( );
	void UpdateKeyBindSettingsMenu ( int settingtype );
	void UpdateReleaseTimeRemaining ( float fTimeRemaining );
	void PlayTakeHit ( struct FRotator HitDir, int nDamage, class UClass* DamageType );
	bool UpdatePlayerStatUI ( class ATgPawn* changedPawn );
	bool UpdatePlayerVitalsUI ( class ATgPlayerController* PC );
	bool UpdatePlayerInfoUI ( class ATgRepInfo_Player* PRI );
	bool UpdateGameCapturePointsUI ( );
	bool UpdateGameScoreUI ( );
	bool UpdateGameClockUI ( );
	void DeviceChangeEvent ( class ATgDevice* Dev, unsigned char Event );
};

UClass* ATgHUD::pClassPointer = NULL;

// Class TgGame.TgKActorSpawnable
// 0x0000 (0x02EC - 0x02EC)
class ATgKActorSpawnable : public AKActorSpawnable
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1520 );

		return pClassPointer;
	};

};

UClass* ATgKActorSpawnable::pClassPointer = NULL;

// Class TgGame.TgKAsset_ClientSideSim
// 0x0060 (0x0260 - 0x0200)
class ATgKAsset_ClientSideSim : public AKAsset
{
public:
	float                                              m_fDamageImpulse;                                 		// 0x0200 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UArrowComponent*                             m_Arrow;                                          		// 0x0204 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class USpriteComponent*                            m_ForceSprite;                                    		// 0x0208 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	unsigned long                                      m_bEnableWind : 1;                                		// 0x020C (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_bEnableGusts : 1;                               		// 0x020C (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      bAnimates : 1;                                    		// 0x020C (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	float                                              m_fWindForceMin;                                  		// 0x0210 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fWindForceMax;                                  		// 0x0214 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fWindForceStrength;                             		// 0x0218 (0x0004) [0x0000000000000000]              
	float                                              m_fWindForceTargetStrength;                       		// 0x021C (0x0004) [0x0000000000000000]              
	float                                              m_fWindFrequency;                                 		// 0x0220 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fWindForceRemainingTime;                        		// 0x0224 (0x0004) [0x0000000000000000]              
	struct FVector                                     m_vWindDirection;                                 		// 0x0228 (0x000C) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fForceDistance;                                 		// 0x0234 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fForceZOffsetMultiplier;                        		// 0x0238 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fGustActiveTime;                                		// 0x023C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FVector2D                                   m_vTimeBetweenGusts;                              		// 0x0240 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fGustActiveRemainingTime;                       		// 0x0248 (0x0004) [0x0000000000000000]              
	float                                              m_fTimeTillNextGust;                              		// 0x024C (0x0004) [0x0000000000000000]              
	struct FVector2D                                   m_WindFrequencyMultiplier;                        		// 0x0250 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FVector2D                                   m_WindForceMultiplier;                            		// 0x0258 (0x0008) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1521 );

		return pClassPointer;
	};

	void OnHit ( struct FVector HitLocation, struct FVector HitNormal, class AActor* SourceActor, struct FTraceHitInfo HitInfo );
};

UClass* ATgKAsset_ClientSideSim::pClassPointer = NULL;

// Class TgGame.TgKAssetSpawnable
// 0x0000 (0x0200 - 0x0200)
class ATgKAssetSpawnable : public AKAssetSpawnable
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1522 );

		return pClassPointer;
	};

};

UClass* ATgKAssetSpawnable::pClassPointer = NULL;

// Class TgGame.TgLevelStreamingLogin
// 0x0004 (0x00DC - 0x00D8)
class UTgLevelStreamingLogin : public ULevelStreaming
{
public:
	unsigned long                                      UsedByLoginPage1 : 1;                             		// 0x00D8 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      UsedByLoginPage2 : 1;                             		// 0x00D8 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      UsedByLoginPage3 : 1;                             		// 0x00D8 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1523 );

		return pClassPointer;
	};

};

UClass* UTgLevelStreamingLogin::pClassPointer = NULL;

// Class TgGame.TgLevelStreamingWorldDetail
// 0x0010 (0x00E8 - 0x00D8)
class UTgLevelStreamingWorldDetail : public ULevelStreaming
{
public:
	int                                                MinimumWorldDetailLevel;                          		// 0x00D8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                MaximumWorldDetailLevel;                          		// 0x00DC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      CachedDetailCheck;                                		// 0x00E0 (0x0001) [0x0000000000002000]              ( CPF_Transient )
	int                                                LastUpdateTime;                                   		// 0x00E4 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1524 );

		return pClassPointer;
	};

};

UClass* UTgLevelStreamingWorldDetail::pClassPointer = NULL;

// Class TgGame.TgLevelStreamingSpectator
// 0x0001 (0x00E9 - 0x00E8)
class UTgLevelStreamingSpectator : public UTgLevelStreamingWorldDetail
{
public:
	unsigned char                                      m_LoadingMethod;                                  		// 0x00E8 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1525 );

		return pClassPointer;
	};

};

UClass* UTgLevelStreamingSpectator::pClassPointer = NULL;

// Class TgGame.TgLocalPlayer
// 0x0028 (0x0404 - 0x03DC)
class UTgLocalPlayer : public ULocalPlayer
{
public:
	float                                              m_fViewScale;                                     		// 0x03DC (0x0004) [0x0000000000000000]              
	struct FVector                                     m_vViewPan;                                       		// 0x03E0 (0x000C) [0x0000000000000000]              
	unsigned long                                      m_bEnableOutlineEffect : 1;                       		// 0x03EC (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bEnableColorBlindEffect : 1;                    		// 0x03EC (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_bColorBlindSimulate : 1;                        		// 0x03EC (0x0004) [0x0000000000000000] [0x00000004] 
	float                                              m_fHitOnlyAlpha;                                  		// 0x03F0 (0x0004) [0x0000000000000000]              
	float                                              m_fHealthOnlyAlpha;                               		// 0x03F4 (0x0004) [0x0000000000000000]              
	float                                              m_fHealthPPAlpha;                                 		// 0x03F8 (0x0004) [0x0000000000000000]              
	float                                              m_fDeathDesatPPAlpha;                             		// 0x03FC (0x0004) [0x0000000000000000]              
	int                                                m_eColorBlindEffectType;                          		// 0x0400 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1526 );

		return pClassPointer;
	};

	class UPostProcessEffect* eventGetPostProcessEffect ( struct FName EffectName );
	void UpdateLowHealthEffect ( float DeltaSeconds, float fHealthPCT, float fHealthLostPCT, unsigned long bDeathVision );
	void EnableColorBlindEffect ( unsigned long bEnable, int Type, unsigned long bSimulateMode );
	void EnableOutlineEffect ( unsigned long bEnable );
	void InitMaterialEffects ( );
};

UClass* UTgLocalPlayer::pClassPointer = NULL;

// Class TgGame.TgManifestGroup
// 0x0030 (0x006C - 0x003C)
class UTgManifestGroup : public UObject
{
public:
	struct FPointer                                    VfTable_FCallbackEventDevice;                     		// 0x003C (0x0004) [0x0000000000801002]              ( CPF_Const | CPF_Native | CPF_NoExport )
	TArray< struct FPointer >                          m_ManifestList;                                   		// 0x0040 (0x000C) [0x0000000000101000]              ( CPF_Native )
	TArray< class UTgObjectReferencer* >               m_pObjectReferencers;                             		// 0x004C (0x000C) [0x0000000000500000]              ( CPF_NeedCtorLink )
	class UObject*                                     m_OwningObject;                                   		// 0x0058 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bIsInCallback : 1;                              		// 0x005C (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bInitialized : 1;                               		// 0x005C (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_bResetOnMapLoad : 1;                            		// 0x005C (0x0004) [0x0000000000000000] [0x00000004] 
	struct FScriptDelegate                             __OnAllManifestsLoaded__Delegate;                 		// 0x0060 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1527 );

		return pClassPointer;
	};

	void OnAllManifestsLoaded ( );
};

UClass* UTgManifestGroup::pClassPointer = NULL;

// Class TgGame.TgMarkComponent
// 0x002F (0x0084 - 0x0055)
class UTgMarkComponent : public UActorComponent
{
public:
	TArray< struct FTargetMark >                       s_MarkList;                                       		// 0x0058 (0x000C) [0x0000000000502000]              ( CPF_Transient | CPF_NeedCtorLink )
	TArray< class UTgEffectGroup* >                    s_MarkEffectGroup;                                		// 0x0064 (0x000C) [0x0000000000502000]              ( CPF_Transient | CPF_NeedCtorLink )
	int                                                m_nHostItemId;                                    		// 0x0070 (0x0004) [0x0000000000000002]              ( CPF_Const )
	unsigned long                                      m_bStackEffects : 1;                              		// 0x0074 (0x0004) [0x0000000000000002] [0x00000001] ( CPF_Const )
	unsigned long                                      m_bRemoveMarksOnDeath : 1;                        		// 0x0074 (0x0004) [0x0000000000000002] [0x00000002] ( CPF_Const )
	unsigned long                                      m_bSetEffectGroupLifetime : 1;                    		// 0x0074 (0x0004) [0x0000000000000002] [0x00000004] ( CPF_Const )
	float                                              m_fMarkDuration;                                  		// 0x0078 (0x0004) [0x0000000000000002]              ( CPF_Const )
	int                                                m_nMaxMarks;                                      		// 0x007C (0x0004) [0x0000000000000002]              ( CPF_Const )
	int                                                m_nPhysicalType;                                  		// 0x0080 (0x0004) [0x0000000000000002]              ( CPF_Const )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1528 );

		return pClassPointer;
	};

	int GetNumMarksFor ( class AActor* Target );
	void RemoveAllMarks ( );
	void RemoveMarkByIndex ( int nIndex );
	void RemoveAllMarksByIndex ( int nIndex );
	void RemoveMarkByActor ( class AActor* Target );
	void RemoveAllMarksByActor ( class AActor* Target );
	void AddMark ( class AActor* Target );
};

UClass* UTgMarkComponent::pClassPointer = NULL;

// Class TgGame.TgMarkComponent_AhPuch_Dev3
// 0x0018 (0x009C - 0x0084)
class UTgMarkComponent_AhPuch_Dev3 : public UTgMarkComponent
{
public:
	unsigned long                                      m_bUseOwningDeviceEffectGroup : 1;                		// 0x0084 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bReapplyOnDeviceModeChange : 1;                 		// 0x0084 (0x0004) [0x0000000000000000] [0x00000002] 
	class UTgDeviceFire*                               m_OwningDeviceMode;                               		// 0x0088 (0x0004) [0x0000000000000000]              
	int                                                m_nDamageBuffDeviceId;                            		// 0x008C (0x0004) [0x0000000000000000]              
	TArray< class UTgInventoryObject* >                s_DamageBuffInvObj;                               		// 0x0090 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1529 );

		return pClassPointer;
	};

	void DeviceOnSetFireMode ( class UTgDeviceFire* DeviceMode );
	void RemoveMarkByIndex ( int nIndex );
	void AddMark ( class AActor* Target );
};

UClass* UTgMarkComponent_AhPuch_Dev3::pClassPointer = NULL;

// Class TgGame.TgMarkComponent_Aphrodite_Base
// 0x0020 (0x00A4 - 0x0084)
class UTgMarkComponent_Aphrodite_Base : public UTgMarkComponent
{
public:
	unsigned long                                      m_bUseOwningDeviceEffectGroup : 1;                		// 0x0084 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bReapplyOnDeviceModeChange : 1;                 		// 0x0084 (0x0004) [0x0000000000000000] [0x00000002] 
	class UTgDeviceFire*                               m_OwningDeviceMode;                               		// 0x0088 (0x0004) [0x0000000000000000]              
	float                                              m_fLinkRange;                                     		// 0x008C (0x0004) [0x0000000000000000]              
	float                                              m_fAbsoluteLinkRange;                             		// 0x0090 (0x0004) [0x0000000000000000]              
	float                                              m_fWorryMoveDistance;                             		// 0x0094 (0x0004) [0x0000000000000000]              
	TArray< struct FVector >                           s_LastTickLocation;                               		// 0x0098 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1530 );

		return pClassPointer;
	};

	void DeviceOnSetFireMode ( class UTgDeviceFire* DeviceMode );
	void RemoveMarkByIndex ( int nIndex );
	void AddMark ( class AActor* Target );
};

UClass* UTgMarkComponent_Aphrodite_Base::pClassPointer = NULL;

// Class TgGame.TgMarkComponent_Aphrodite_FertileGround
// 0x0018 (0x00BC - 0x00A4)
class UTgMarkComponent_Aphrodite_FertileGround : public UTgMarkComponent_Aphrodite_Base
{
public:
	TArray< class UTgTrailComponent_Aphrodite_FertileGround* > s_TrailList;                                      		// 0x00A4 (0x000C) [0x0000000004480008]              ( CPF_ExportObject | CPF_Component | CPF_NeedCtorLink | CPF_EditInline )
	class UTgDeviceFire*                               m_PendingDeviceMode;                              		// 0x00B0 (0x0004) [0x0000000000000000]              
	class UTgDeviceFire*                               m_PendingTrailFireMode;                           		// 0x00B4 (0x0004) [0x0000000000000000]              
	class UTgDeviceFire*                               m_TrailFireMode;                                  		// 0x00B8 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1531 );

		return pClassPointer;
	};

	void SetTrailFireMode ( class UTgDeviceFire* DeviceMode );
	void DeviceOnSetFireMode ( class UTgDeviceFire* DeviceMode );
	void RemoveMarkByIndex ( int nIndex );
	void AddMark ( class AActor* Target );
};

UClass* UTgMarkComponent_Aphrodite_FertileGround::pClassPointer = NULL;

// Class TgGame.TgMarkComponent_Aphrodite_KissDamageBuff
// 0x0014 (0x00B8 - 0x00A4)
class UTgMarkComponent_Aphrodite_KissDamageBuff : public UTgMarkComponent_Aphrodite_Base
{
public:
	int                                                m_nDamageBuffDeviceId;                            		// 0x00A4 (0x0004) [0x0000000000000000]              
	TArray< class UTgInventoryObject* >                s_DamageBuffInvObj;                               		// 0x00A8 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class AActor*                                      s_KissedActor;                                    		// 0x00B4 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1532 );

		return pClassPointer;
	};

	void SetKissedActor ( class AActor* KissedActor );
	void RemoveMarkByIndex ( int nIndex );
	void AddMark ( class AActor* Target );
};

UClass* UTgMarkComponent_Aphrodite_KissDamageBuff::pClassPointer = NULL;

// Class TgGame.TgMarkComponent_Aphrodite_SoulMates
// 0x0010 (0x00B4 - 0x00A4)
class UTgMarkComponent_Aphrodite_SoulMates : public UTgMarkComponent_Aphrodite_Base
{
public:
	float                                              m_fGracePeriod;                                   		// 0x00A4 (0x0004) [0x0000000000000000]              
	TArray< float >                                    s_GracePeriodTimes;                               		// 0x00A8 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1533 );

		return pClassPointer;
	};

	void RemoveMarkByIndex ( int nIndex );
	void AddMark ( class AActor* Target );
};

UClass* UTgMarkComponent_Aphrodite_SoulMates::pClassPointer = NULL;

// Class TgGame.TgMarkComponent_Cabrakan_Dev2
// 0x0000 (0x0084 - 0x0084)
class UTgMarkComponent_Cabrakan_Dev2 : public UTgMarkComponent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1534 );

		return pClassPointer;
	};

	void RemoveMarkByIndex ( int nIndex );
	void AddMark ( class AActor* Target );
};

UClass* UTgMarkComponent_Cabrakan_Dev2::pClassPointer = NULL;

// Class TgGame.TgMarkComponent_Chiron_Lockon
// 0x0000 (0x0084 - 0x0084)
class UTgMarkComponent_Chiron_Lockon : public UTgMarkComponent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1535 );

		return pClassPointer;
	};

	void UpdateLockonState ( );
	void RemoveMarkByIndex ( int nIndex );
	void AddMark ( class AActor* Target );
};

UClass* UTgMarkComponent_Chiron_Lockon::pClassPointer = NULL;

// Class TgGame.TgMarkComponent_Cupid_TimedBomb
// 0x0004 (0x0088 - 0x0084)
class UTgMarkComponent_Cupid_TimedBomb : public UTgMarkComponent
{
public:
	int                                                s_LovestruckCount;                                		// 0x0084 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1536 );

		return pClassPointer;
	};

	void RemoveMarkByIndex ( int nIndex );
};

UClass* UTgMarkComponent_Cupid_TimedBomb::pClassPointer = NULL;

// Class TgGame.TgMarkComponent_Freya_AttackBuff
// 0x0000 (0x0084 - 0x0084)
class UTgMarkComponent_Freya_AttackBuff : public UTgMarkComponent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1537 );

		return pClassPointer;
	};

	void RemoveMarkByIndex ( int nIndex );
};

UClass* UTgMarkComponent_Freya_AttackBuff::pClassPointer = NULL;

// Class TgGame.TgMarkComponent_WithEnergy
// 0x0004 (0x0088 - 0x0084)
class UTgMarkComponent_WithEnergy : public UTgMarkComponent
{
public:
	float                                              m_fEnergyPerMark;                                 		// 0x0084 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1538 );

		return pClassPointer;
	};

	void RemoveMarkByIndex ( int nIndex );
	void AddMark ( class AActor* Target );
};

UClass* UTgMarkComponent_WithEnergy::pClassPointer = NULL;

// Class TgGame.TgMarkComponent_Zeus_Lockon
// 0x0000 (0x0084 - 0x0084)
class UTgMarkComponent_Zeus_Lockon : public UTgMarkComponent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1539 );

		return pClassPointer;
	};

	void UpdateLockonState ( );
	void RemoveMarkByIndex ( int nIndex );
	void AddMark ( class AActor* Target );
};

UClass* UTgMarkComponent_Zeus_Lockon::pClassPointer = NULL;

// Class TgGame.TgMarkComponent_ZhongKui_BookOfDemons
// 0x0008 (0x008C - 0x0084)
class UTgMarkComponent_ZhongKui_BookOfDemons : public UTgMarkComponent
{
public:
	class ATgDevice*                                   s_Device;                                         		// 0x0084 (0x0004) [0x0000000000000000]              
	class UTgDeviceFire*                               s_DeviceMode;                                     		// 0x0088 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1540 );

		return pClassPointer;
	};

	void DeviceOnSetFireMode ( class ATgDevice* Dev );
	void RemoveMarkByIndex ( int nIndex );
	void AddMark ( class AActor* Target );
};

UClass* UTgMarkComponent_ZhongKui_BookOfDemons::pClassPointer = NULL;

// Class TgGame.TgMenuContentData
// 0x000C (0x0048 - 0x003C)
class UTgMenuContentData : public UObject
{
public:
	TArray< struct FMeshData >                         m_MeshData;                                       		// 0x003C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1541 );

		return pClassPointer;
	};

	void PreloadTextures ( float ForceDuration );
	void eventGetMeshData ( unsigned char ContentDataType, struct FMeshData* Data );
	void Init ( );
};

UClass* UTgMenuContentData::pClassPointer = NULL;

// Class TgGame.TgMenuMeshInfo
// 0x0070 (0x00AC - 0x003C)
class UTgMenuMeshInfo : public UObject
{
public:
	struct FLobbyMeshInfo                              MeshInfo;                                         		// 0x003C (0x0050) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< class UTgMenuMeshInfo* >                   Children;                                         		// 0x008C (0x000C) [0x0000000004400001]              ( CPF_Edit | CPF_NeedCtorLink | CPF_EditInline )
	struct FName                                       ParentSocketName;                                 		// 0x0098 (0x0008) [0x0000000000000000]              
	TArray< struct FParticleSystemInfo >               AttachedParticleSystems;                          		// 0x00A0 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1542 );

		return pClassPointer;
	};

	void PreloadTextures ( float ForceDuration );
	bool IsFullyConfigured ( );
	void AddFxAttachments ( class UTgSkeletalMeshComponent* SkelComp );
	void SetupMeshFromMeshInfo ( class UTgSkeletalMeshComponent* SkelComp );
	void ConfigureMesh ( class ATgSkeletalMeshActor_Loader* lobbyOwner );
};

UClass* UTgMenuMeshInfo::pClassPointer = NULL;

// Class TgGame.TgMeshAssembly
// 0x0010 (0x0200 - 0x01F0)
class ATgMeshAssembly : public AActor
{
public:
	int                                                m_nMeshAsmId;                                     		// 0x01F0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_nTeam;                                          		// 0x01F4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UMeshComponent*                              m_Mesh;                                           		// 0x01F8 (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )
	class ULightEnvironmentComponent*                  m_LightEnvironment;                               		// 0x01FC (0x0004) [0x00000000040A000A]              ( CPF_Const | CPF_ExportObject | CPF_EditConst | CPF_Component | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1543 );

		return pClassPointer;
	};

	void NotifyLocalPlayerTeamReceived ( );
	void PostBeginPlay ( );
	void RecalculateTeamColor ( );
	void LoadMesh ( );
};

UClass* ATgMeshAssembly::pClassPointer = NULL;

// Class TgGame.TgNewUserSettings
// 0x000C (0x0048 - 0x003C)
class UTgNewUserSettings : public UObject
{
public:
	TArray< int >                                      WatchedVideoIds;                                  		// 0x003C (0x000C) [0x0000000000444001]              ( CPF_Edit | CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1544 );

		return pClassPointer;
	};

};

UClass* UTgNewUserSettings::pClassPointer = NULL;

// Class TgGame.TgObject
// 0x0000 (0x003C - 0x003C)
class UTgObject : public UObject
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1545 );

		return pClassPointer;
	};

	void eventStartFire ( );
	void eventSetTaskForceNumber ( );
	void eventInitializeDefaultProps ( );
	void eventSortDamageDisplay ( );
	void eventIsFriendlyWithLocalPawn ( );
};

UClass* UTgObject::pClassPointer = NULL;

// Class TgGame.TgObjectReferencer
// 0x0004 (0x004C - 0x0048)
class UTgObjectReferencer : public UObjectReferencer
{
public:
	struct FPointer                                    m_Manifest;                                       		// 0x0048 (0x0004) [0x0000000000001000]              ( CPF_Native )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1546 );

		return pClassPointer;
	};

};

UClass* UTgObjectReferencer::pClassPointer = NULL;

// Class TgGame.TgProjGroundTargetInterface
// 0x0000 (0x003C - 0x003C)
class UTgProjGroundTargetInterface : public UInterface
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1547 );

		return pClassPointer;
	};

	void eventSetGroundTarget ( struct FVector GTLocation );
};

UClass* UTgProjGroundTargetInterface::pClassPointer = NULL;

// Class TgGame.TgProperty
// 0x001C (0x0058 - 0x003C)
class UTgProperty : public UObject
{
public:
	int                                                m_nPropIndex;                                     		// 0x003C (0x0004) [0x0000000000000000]              
	int                                                m_nPropertyId;                                    		// 0x0040 (0x0004) [0x0000000000000000]              
	float                                              m_fBase;                                          		// 0x0044 (0x0004) [0x0000000000000000]              
	float                                              m_fRaw;                                           		// 0x0048 (0x0004) [0x0000000000000000]              
	float                                              m_fMinimum;                                       		// 0x004C (0x0004) [0x0000000000000000]              
	float                                              m_fMaximum;                                       		// 0x0050 (0x0004) [0x0000000000000000]              
	float                                              m_fScalingFactor;                                 		// 0x0054 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1548 );

		return pClassPointer;
	};

	int GetPropIndex ( int propId );
	void eventCopy ( class UTgProperty* pProperty );
	float GetCurrentValue ( );
};

UClass* UTgProperty::pClassPointer = NULL;

// Class TgGame.TgRacingCheckpoint
// 0x0020 (0x0210 - 0x01F0)
class ATgRacingCheckpoint : public AActor
{
public:
	class ATgVolume*                                   m_CollisionVolume;                                		// 0x01F0 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	float                                              m_fSegmentLength;                                 		// 0x01F4 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	float                                              m_fSegmentWidth;                                  		// 0x01F8 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	class ATgRacingCheckpoint*                         m_NextCheckpoint;                                 		// 0x01FC (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	class ATgRacingCheckpoint*                         m_PreviousCheckpoint;                             		// 0x0200 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	TArray< class ATgPawn_Racer* >                     m_NearByPlayers;                                  		// 0x0204 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1549 );

		return pClassPointer;
	};

	void eventUnTouch ( class AActor* Other );
	void eventTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void eventPreBeginPlay ( );
	bool IsRacerNearby ( class ATgPawn_Racer* Racer );
	void CalculateLocalPosition ( struct FVector TestLoc, float* Fwd, float* Side );
};

UClass* ATgRacingCheckpoint::pClassPointer = NULL;

// Class TgGame.TgSeqEvent_BotDied
// 0x000C (0x00E8 - 0x00DC)
class UTgSeqEvent_BotDied : public USequenceEvent
{
public:
	unsigned long                                      bUseCountingOutput : 1;                           		// 0x00DC (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	int                                                nCountingMultiple;                                		// 0x00E0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                nLastDiedCount;                                   		// 0x00E4 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1550 );

		return pClassPointer;
	};

};

UClass* UTgSeqEvent_BotDied::pClassPointer = NULL;

// Class TgGame.TgSeqEvent_BotSpawned
// 0x000C (0x00E8 - 0x00DC)
class UTgSeqEvent_BotSpawned : public USequenceEvent
{
public:
	unsigned long                                      bUseCountingOutput : 1;                           		// 0x00DC (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	int                                                nCountingMultiple;                                		// 0x00E0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                nLastSpawnCount;                                  		// 0x00E4 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1551 );

		return pClassPointer;
	};

};

UClass* UTgSeqEvent_BotSpawned::pClassPointer = NULL;

// Class TgGame.TgSeqEvent_ClassSelected
// 0x0000 (0x00DC - 0x00DC)
class UTgSeqEvent_ClassSelected : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1552 );

		return pClassPointer;
	};

};

UClass* UTgSeqEvent_ClassSelected::pClassPointer = NULL;

// Class TgGame.TgSeqEvent_DoorStatusChanged
// 0x0000 (0x00DC - 0x00DC)
class UTgSeqEvent_DoorStatusChanged : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1553 );

		return pClassPointer;
	};

};

UClass* UTgSeqEvent_DoorStatusChanged::pClassPointer = NULL;

// Class TgGame.TgSeqEvent_FactoryEmpty
// 0x000C (0x00E8 - 0x00DC)
class UTgSeqEvent_FactoryEmpty : public USequenceEvent
{
public:
	unsigned long                                      bUseCountingOutput : 1;                           		// 0x00DC (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	int                                                nCountingMultiple;                                		// 0x00E0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                nLastEmptyCount;                                  		// 0x00E4 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1554 );

		return pClassPointer;
	};

};

UClass* UTgSeqEvent_FactoryEmpty::pClassPointer = NULL;

// Class TgGame.TgSeqEvent_LocalPlayerDied
// 0x0000 (0x00DC - 0x00DC)
class UTgSeqEvent_LocalPlayerDied : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1555 );

		return pClassPointer;
	};

};

UClass* UTgSeqEvent_LocalPlayerDied::pClassPointer = NULL;

// Class TgGame.TgSeqEvent_LocalPlayerRecalled
// 0x0000 (0x00DC - 0x00DC)
class UTgSeqEvent_LocalPlayerRecalled : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1556 );

		return pClassPointer;
	};

};

UClass* UTgSeqEvent_LocalPlayerRecalled::pClassPointer = NULL;

// Class TgGame.TgSeqEvent_LocalPlayerScoredKill
// 0x0000 (0x00DC - 0x00DC)
class UTgSeqEvent_LocalPlayerScoredKill : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1557 );

		return pClassPointer;
	};

};

UClass* UTgSeqEvent_LocalPlayerScoredKill::pClassPointer = NULL;

// Class TgGame.TgSeqEvent_LocalPlayersTeamScoredPhoenixKill
// 0x0000 (0x00DC - 0x00DC)
class UTgSeqEvent_LocalPlayersTeamScoredPhoenixKill : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1558 );

		return pClassPointer;
	};

};

UClass* UTgSeqEvent_LocalPlayersTeamScoredPhoenixKill::pClassPointer = NULL;

// Class TgGame.TgSeqEvent_LocalPlayersTeamScoredTowerKill
// 0x0000 (0x00DC - 0x00DC)
class UTgSeqEvent_LocalPlayersTeamScoredTowerKill : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1559 );

		return pClassPointer;
	};

};

UClass* UTgSeqEvent_LocalPlayersTeamScoredTowerKill::pClassPointer = NULL;

// Class TgGame.TgSeqEvent_MICParameterEvent
// 0x0010 (0x00EC - 0x00DC)
class UTgSeqEvent_MICParameterEvent : public USequenceEvent
{
public:
	unsigned char                                      MICEventType;                                     		// 0x00DC (0x0001) [0x0000000000000001]              ( CPF_Edit )
	TArray< class UMaterialInstanceConstant* >         AttachedMICs;                                     		// 0x00E0 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1560 );

		return pClassPointer;
	};

	void SetVectorParameterValue ( struct FName ParamName, struct FLinearColor Value );
	void SetScalarParameterValue ( struct FName ParamName, float fValue );
};

UClass* UTgSeqEvent_MICParameterEvent::pClassPointer = NULL;

// Class TgGame.TgSeqEvent_PlaceableDestroyed
// 0x0000 (0x00DC - 0x00DC)
class UTgSeqEvent_PlaceableDestroyed : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1561 );

		return pClassPointer;
	};

};

UClass* UTgSeqEvent_PlaceableDestroyed::pClassPointer = NULL;

// Class TgGame.TgSeqEvent_PlayerCountHit
// 0x0000 (0x00DC - 0x00DC)
class UTgSeqEvent_PlayerCountHit : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1562 );

		return pClassPointer;
	};

};

UClass* UTgSeqEvent_PlayerCountHit::pClassPointer = NULL;

// Class TgGame.TgSeqEvent_PlayerInitialized
// 0x0004 (0x00E0 - 0x00DC)
class UTgSeqEvent_PlayerInitialized : public USequenceEvent
{
public:
	unsigned long                                      bLocalPlayerOnly : 1;                             		// 0x00DC (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1563 );

		return pClassPointer;
	};

};

UClass* UTgSeqEvent_PlayerInitialized::pClassPointer = NULL;

// Class TgGame.TgSeqEvent_TutorialEvent
// 0x0008 (0x00E4 - 0x00DC)
class UTgSeqEvent_TutorialEvent : public USequenceEvent
{
public:
	unsigned char                                      TutEvent;                                         		// 0x00DC (0x0001) [0x0000000000000001]              ( CPF_Edit )
	int                                                EventData;                                        		// 0x00E0 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1564 );

		return pClassPointer;
	};

	int eventGetObjClassVersion ( );
};

UClass* UTgSeqEvent_TutorialEvent::pClassPointer = NULL;

// Class TgGame.TgSoundNodeAttenuation
// 0x0000 (0x006C - 0x006C)
class UTgSoundNodeAttenuation : public USoundNodeAttenuation
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1565 );

		return pClassPointer;
	};

};

UClass* UTgSoundNodeAttenuation::pClassPointer = NULL;

// Class TgGame.TgSpectatorDirector
// 0x0084 (0x0274 - 0x01F0)
class ATgSpectatorDirector : public AInfo
{
public:
	unsigned long                                      m_bIsActive : 1;                                  		// 0x01F0 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	unsigned long                                      m_bIsPending : 1;                                 		// 0x01F0 (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	unsigned long                                      m_bAutoSwitchCameraViews : 1;                     		// 0x01F0 (0x0004) [0x0000000000002000] [0x00000004] ( CPF_Transient )
	unsigned long                                      m_bForceThirdPersonView : 1;                      		// 0x01F0 (0x0004) [0x0000000000002000] [0x00000008] ( CPF_Transient )
	float                                              m_fRemainingAutoUpdateCheckTime;                  		// 0x01F4 (0x0004) [0x0000000000000000]              
	float                                              m_fTimeSinceViewSwitchedTeams;                    		// 0x01F8 (0x0004) [0x0000000000000000]              
	float                                              m_fTimeSinceViewSwitchedMode;                     		// 0x01FC (0x0004) [0x0000000000000000]              
	float                                              m_fRemainingAutoReturnCheckTime;                  		// 0x0200 (0x0004) [0x0000000000000000]              
	unsigned char                                      m_CurrentCameraMode;                              		// 0x0204 (0x0001) [0x0000000000000000]              
	struct FViewTargetInfo                             m_CurrentRatedViewTarget;                         		// 0x0208 (0x0030) [0x0000000000000000]              
	struct FViewTargetInfo                             m_DemoRewindViewTarget;                           		// 0x0238 (0x0030) [0x0000000000002000]              ( CPF_Transient )
	struct FVector2D                                   m_v2dForcedDirectorLocation;                      		// 0x0268 (0x0008) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_fForcedDirectorLocationTimestamp;               		// 0x0270 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1566 );

		return pClassPointer;
	};

	void SetForcedDirectorLocation ( struct FVector2D NewLocation );
	void eventClearAssistModeTarget ( );
	void eventPostDemoRewind ( );
	void eventPreDemoRewind ( );
	bool IsPending ( );
	bool IsActive ( );
	bool IsCurrentlyViewing ( );
	void ResetCamera ( class ATgSpectatorController* PC );
	void SetActive ( unsigned long bIsActive );
	void eventSetCameraMode ( unsigned char NewCameraMode );
	void eventSetViewTarget ( struct FViewTargetInfo NewViewTarget );
	void UpdateOverviewCamUI ( unsigned long bEnable );
	void OnPlayerMoved ( );
};

UClass* ATgSpectatorDirector::pClassPointer = NULL;

// Class TgGame.TgSplineLoftActorSpawnable
// 0x0000 (0x0288 - 0x0288)
class ATgSplineLoftActorSpawnable : public ASplineLoftActorMovable
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1567 );

		return pClassPointer;
	};

};

UClass* ATgSplineLoftActorSpawnable::pClassPointer = NULL;

// Class TgGame.TgSplineLoftActorSpawnableLinear
// 0x0000 (0x0288 - 0x0288)
class ATgSplineLoftActorSpawnableLinear : public ATgSplineLoftActorSpawnable
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1568 );

		return pClassPointer;
	};

	void UpdateSplineParams ( );
};

UClass* ATgSplineLoftActorSpawnableLinear::pClassPointer = NULL;

// Class TgGame.TgTimerManager
// 0x0044 (0x0080 - 0x003C)
class UTgTimerManager : public UObject
{
public:
	struct FPointer                                    VfTable_FTickableObject;                          		// 0x003C (0x0004) [0x0000000000801002]              ( CPF_Const | CPF_Native | CPF_NoExport )
	unsigned char                                      UnknownData00[ 0x3C ];                            		// 0x0040 (0x003C) UNKNOWN PROPERTY: MapProperty TgGame.TgTimerManager.m_TimerMap
	unsigned long                                      m_bActive : 1;                                    		// 0x007C (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bGameWasPaused : 1;                             		// 0x007C (0x0004) [0x0000000000000000] [0x00000002] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1569 );

		return pClassPointer;
	};

	void CloseAllTimers ( unsigned long bFireEvent );
	bool IsActiveTimers ( );
	bool UnRegisterForEvents ( int byTimerIndex, class UObject* HostObject );
	bool RegisterForEvents ( int byTimerIndex, class UObject* HostObject, struct FName nmFunc );
	float GetTimeInitial ( int byTimerIndex );
	float GetPercentRemaining ( int byTimerIndex );
	float GetTimeRemaining ( int byTimerIndex );
	float GetTimeElapsed ( int byTimerIndex );
	bool IsPaused ( int byTimerIndex );
	bool IsSet ( int byTimerIndex );
	bool Close ( int byTimerIndex, unsigned long bFireEvent );
	bool Pause ( int byTimerIndex, float fTime );
	bool Update ( int byTimerIndex, float fTime, float fTimeInitial );
	bool Start ( int byTimerIndex, float fTime, unsigned long bRepeat, unsigned long bPausedByGame );
};

UClass* UTgTimerManager::pClassPointer = NULL;

// Class TgGame.TgTrailComponent_Aphrodite_FertileGround
// 0x0037 (0x008C - 0x0055)
class UTgTrailComponent_Aphrodite_FertileGround : public UActorComponent
{
public:
	class UTgDeviceFire*                               m_FireMode;                                       		// 0x0058 (0x0004) [0x0000000000000000]              
	TArray< class ATgDeployable* >                     s_Children;                                       		// 0x005C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	float                                              m_fSeperationDistance;                            		// 0x0068 (0x0004) [0x0000000000000000]              
	float                                              m_fEffectsApplicationPeriod;                      		// 0x006C (0x0004) [0x0000000000000000]              
	float                                              m_fDeployableLifeSec;                             		// 0x0070 (0x0004) [0x0000000000000000]              
	TArray< struct FTouchInfo >                        s_MasterTouchList;                                		// 0x0074 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	float                                              m_fTimeUntilApplyEffects;                         		// 0x0080 (0x0004) [0x0000000000000000]              
	float                                              m_fTrailLifetime;                                 		// 0x0084 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bCanSpawnTrail : 1;                             		// 0x0088 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1570 );

		return pClassPointer;
	};

	struct FVector eventLastDroppedLoc ( );
	float eventTraveledDist ( );
	void OnChildUnTouch ( class AActor* Other, class ATgDeployable* Child );
	void OnChildTouch ( class AActor* Other, class ATgDeployable* Child );
	void InitializeTrail ( class UTgDeviceFire* pMode );
	void RemoveFlowerBedByIndex ( int I );
	void RemoveFlowerBedByActor ( class ATgDeployable* FlowerBed );
	bool SpawnNewFlowerBed ( struct FVector DeployLocation, struct FRotator DeployRotation );
	bool SpawnNewFlowerBedAtOwner ( );
	void PrepareForSelfDetach ( );
};

UClass* UTgTrailComponent_Aphrodite_FertileGround::pClassPointer = NULL;

// Class TgGame.TgTrailComponent_Sol_Passive
// 0x0018 (0x00A4 - 0x008C)
class UTgTrailComponent_Sol_Passive : public UTgTrailComponent_Aphrodite_FertileGround
{
public:
	TArray< class ATgDeployable* >                     s_DisconnectedCrumbs;                             		// 0x008C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FVector                                     s_vLastPoop;                                      		// 0x0098 (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1571 );

		return pClassPointer;
	};

	struct FVector eventLastDroppedLoc ( );
	float eventTraveledDist ( );
	void OnChildUnTouch ( class AActor* Other, class ATgDeployable* Child );
	void OnChildTouch ( class AActor* Other, class ATgDeployable* Child );
	void eventIgniteTrailStartingAt ( class ATgDeployable* TrailCrumb );
	void RemoveFlowerBedByIndex ( int I );
	bool SpawnNewFlowerBed ( struct FVector DeployLocation, struct FRotator DeployRotation );
	bool SpawnNewFlowerBedAtOwner ( );
	void PrepareForSelfDetach ( );
};

UClass* UTgTrailComponent_Sol_Passive::pClassPointer = NULL;

// Class TgGame.TgVolumePathNode
// 0x0018 (0x02D0 - 0x02B8)
class ATgVolumePathNode : public AVolumePathNode
{
public:
	unsigned long                                      m_bIsAboveGround : 1;                             		// 0x02B8 (0x0004) [0x0000000000020001] [0x00000001] ( CPF_Edit | CPF_EditConst )
	struct FVector                                     m_vGroundHitLocation;                             		// 0x02BC (0x000C) [0x0000000000020001]              ( CPF_Edit | CPF_EditConst )
	float                                              m_fGroundTraceDistance;                           		// 0x02C8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class USpriteComponent*                            m_GroundSprite;                                   		// 0x02CC (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1572 );

		return pClassPointer;
	};

};

UClass* ATgVolumePathNode::pClassPointer = NULL;

// Class TgGame.TgAnimBlendByPosture_Player
// 0x0000 (0x0154 - 0x0154)
class UTgAnimBlendByPosture_Player : public UAnimNodeSequence
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1573 );

		return pClassPointer;
	};

};

UClass* UTgAnimBlendByPosture_Player::pClassPointer = NULL;

// Class TgGame.TgAnimBlendByPropertyIfNotRelevant
// 0x0000 (0x0130 - 0x0130)
class UTgAnimBlendByPropertyIfNotRelevant : public UAnimNodeBlendByProperty
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1574 );

		return pClassPointer;
	};

	void PlayAnim ( unsigned long bLoop, float Rate, float StartTime );
	void SetActiveAnimationIndex ( );
	void SetActiveChild ( int ChildIndex, float ChildBlendTime );
};

UClass* UTgAnimBlendByPropertyIfNotRelevant::pClassPointer = NULL;

// Class TgGame.TgAnimBlendBySpeed
// 0x008C (0x01B4 - 0x0128)
class UTgAnimBlendBySpeed : public UAnimNodeBlendBySpeed
{
public:
	class ATgPawn*                                     m_TgPawn;                                         		// 0x0128 (0x0004) [0x0000000000000000]              
	unsigned char                                      m_SpeedType;                                      		// 0x012C (0x0001) [0x0000000000000001]              ( CPF_Edit )
	TArray< struct FResetSynchGroup >                  ResetSynchGroups;                                 		// 0x0130 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	unsigned long                                      m_bIgnoreRootMotion : 1;                          		// 0x013C (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_bIgnoreZVelocity : 1;                           		// 0x013C (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_bNotifyOwnerOnChildChange : 1;                  		// 0x013C (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      m_bEnableClassOverrides : 1;                      		// 0x013C (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )
	TArray< int >                                      m_WalkChildren;                                   		// 0x0140 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< int >                                      m_SprintChildren;                                 		// 0x014C (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< float >                                    m_BaseSpeed;                                      		// 0x0158 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< unsigned char >                            m_IgnoredPhysics;                                 		// 0x0164 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	int                                                m_nIndexToOverride;                               		// 0x0170 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fBaseSpeedRecon;                                		// 0x0174 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fBaseSpeedRobotics;                             		// 0x0178 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fBaseSpeedAssault;                              		// 0x017C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fBaseSpeedMedic;                                		// 0x0180 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fBaseSpeedReconFemale;                          		// 0x0184 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fBaseSpeedRoboticsFemale;                       		// 0x0188 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fBaseSpeedAssaultFemale;                        		// 0x018C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fBaseSpeedMedicFemale;                          		// 0x0190 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fBaseSpeedReconCity;                            		// 0x0194 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fBaseSpeedRoboticsCity;                         		// 0x0198 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fBaseSpeedAssaultCity;                          		// 0x019C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fBaseSpeedMedicCity;                            		// 0x01A0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fBaseSpeedReconFemaleCity;                      		// 0x01A4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fBaseSpeedRoboticsFemaleCity;                   		// 0x01A8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fBaseSpeedAssaultFemaleCity;                    		// 0x01AC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fBaseSpeedMedicFemaleCity;                      		// 0x01B0 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1575 );

		return pClassPointer;
	};

	void eventOnInit ( );
	class UAnimNodeSynch* FindSynchAnimNode ( struct FName nmNodeName );
};

UClass* UTgAnimBlendBySpeed::pClassPointer = NULL;

// Class TgGame.TgAnimBlendBySpeedWithExhaustion
// 0x0030 (0x01E4 - 0x01B4)
class UTgAnimBlendBySpeedWithExhaustion : public UTgAnimBlendBySpeed
{
public:
	unsigned long                                      m_bEnableExhaustion : 1;                          		// 0x01B4 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	float                                              m_fExhaustionLevel;                               		// 0x01B8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	TArray< int >                                      m_ExhaustedChildren;                              		// 0x01BC (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< int >                                      m_GainExhaustionChildren;                         		// 0x01C8 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	float                                              m_fExhaustionGainSpeed;                           		// 0x01D4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fExhaustionLossSpeed;                           		// 0x01D8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fExhaustionLevelMax;                            		// 0x01DC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fExhaustionLevelMin;                            		// 0x01E0 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1576 );

		return pClassPointer;
	};

};

UClass* UTgAnimBlendBySpeedWithExhaustion::pClassPointer = NULL;

// Class TgGame.TgAnimBlendPerBone
// 0x0034 (0x0148 - 0x0114)
class UTgAnimBlendPerBone : public UAnimNodeBlendPerBone
{
public:
	unsigned long                                      m_bLoopSourceChild : 1;                           		// 0x0114 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_bLoopTargetChild : 1;                           		// 0x0114 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_bPlaySourceChild : 1;                           		// 0x0114 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      m_bPlayTargetChild : 1;                           		// 0x0114 (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )
	unsigned long                                      m_bSetStrengthFromAnimNode : 1;                   		// 0x0114 (0x0004) [0x0000000000000001] [0x00000010] ( CPF_Edit )
	unsigned long                                      m_bInvertStrengthFromAnimNode : 1;                		// 0x0114 (0x0004) [0x0000000000000001] [0x00000020] ( CPF_Edit )
	unsigned long                                      m_bInitializedCachedNodeList : 1;                 		// 0x0114 (0x0004) [0x0000000000002000] [0x00000040] ( CPF_Transient )
	TArray< struct FName >                             m_StrengthAnimNodeNameList;                       		// 0x0118 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< unsigned char >                            m_StrengthEmoteList;                              		// 0x0124 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< class UAnimNode* >                         m_CachedNodeList;                                 		// 0x0130 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	TArray< class UTgAnimNodeEmoteSequence* >          m_CachedEmoteSequences;                           		// 0x013C (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1577 );

		return pClassPointer;
	};

	void PlayAnim ( unsigned long bLoop, float Rate, float StartTime );
};

UClass* UTgAnimBlendPerBone::pClassPointer = NULL;

// Class TgGame.TgAnimBlendPerBone_DynamicLooping
// 0x0000 (0x0148 - 0x0148)
class UTgAnimBlendPerBone_DynamicLooping : public UTgAnimBlendPerBone
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1578 );

		return pClassPointer;
	};

	void PlayAnim ( unsigned long bLoop, float Rate, float StartTime );
};

UClass* UTgAnimBlendPerBone_DynamicLooping::pClassPointer = NULL;

// Class TgGame.TgAnimMetaData_BellonaFlagMesh
// 0x0010 (0x004C - 0x003C)
class UTgAnimMetaData_BellonaFlagMesh : public UAnimMetaData
{
public:
	unsigned long                                      bAllowOverlayMesh : 1;                            		// 0x003C (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	TArray< struct FFlagMeshParameterKeyFrame >        KeyFrames;                                        		// 0x0040 (0x000C) [0x0000000004400001]              ( CPF_Edit | CPF_NeedCtorLink | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1579 );

		return pClassPointer;
	};

};

UClass* UTgAnimMetaData_BellonaFlagMesh::pClassPointer = NULL;

// Class TgGame.TgAnimMetaData_BellonaWeaponSetOverride
// 0x0010 (0x004C - 0x003C)
class UTgAnimMetaData_BellonaWeaponSetOverride : public UAnimMetaData
{
public:
	unsigned char                                      WeaponSetOverride;                                		// 0x003C (0x0001) [0x0000000000000001]              ( CPF_Edit )
	TArray< struct FWeaponSetParameterKeyFrame >       KeyFrames;                                        		// 0x0040 (0x000C) [0x0000000004400001]              ( CPF_Edit | CPF_NeedCtorLink | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1580 );

		return pClassPointer;
	};

};

UClass* UTgAnimMetaData_BellonaWeaponSetOverride::pClassPointer = NULL;

// Class TgGame.TgAnimMetaData_InvisibleWallFailSafe
// 0x0008 (0x0044 - 0x003C)
class UTgAnimMetaData_InvisibleWallFailSafe : public UAnimMetaData
{
public:
	struct FName                                       WallEnableBaseName;                               		// 0x003C (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1581 );

		return pClassPointer;
	};

};

UClass* UTgAnimMetaData_InvisibleWallFailSafe::pClassPointer = NULL;

// Class TgGame.TgAnimMetaData_LobbyCameraModifier
// 0x0020 (0x005C - 0x003C)
class UTgAnimMetaData_LobbyCameraModifier : public UAnimMetaData
{
public:
	struct FVector                                     CameraPositionOffset;                             		// 0x003C (0x000C) [0x0000000000000001]              ( CPF_Edit )
	struct FRotator                                    CameraRotationOffset;                             		// 0x0048 (0x000C) [0x0000000000000001]              ( CPF_Edit )
	float                                              OffsetStartTime;                                  		// 0x0054 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              OffsetEndTime;                                    		// 0x0058 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1582 );

		return pClassPointer;
	};

};

UClass* UTgAnimMetaData_LobbyCameraModifier::pClassPointer = NULL;

// Class TgGame.TgAnimMetaData_MICScalarParameter
// 0x001C (0x0058 - 0x003C)
class UTgAnimMetaData_MICScalarParameter : public UAnimMetaData
{
public:
	struct FName                                       MICParameterName;                                 		// 0x003C (0x0008) [0x0000000000000001]              ( CPF_Edit )
	int                                                MaterialIndex;                                    		// 0x0044 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	TArray< struct FMICScalarParameterKeyFrame >       KeyFrames;                                        		// 0x0048 (0x000C) [0x0000000004400001]              ( CPF_Edit | CPF_NeedCtorLink | CPF_EditInline )
	unsigned long                                      bForceFirstKeyFrameOnBecomeRelevant : 1;          		// 0x0054 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      bForceLastKeyFrameOnCeaseRelevant : 1;            		// 0x0054 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      bApplyToParentAnimComponentChildren : 1;          		// 0x0054 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1583 );

		return pClassPointer;
	};

};

UClass* UTgAnimMetaData_MICScalarParameter::pClassPointer = NULL;

// Class TgGame.TgAnimMetaData_ScyllaTentacleMesh
// 0x0004 (0x0040 - 0x003C)
class UTgAnimMetaData_ScyllaTentacleMesh : public UAnimMetaData
{
public:
	unsigned long                                      bTentaclesActive : 1;                             		// 0x003C (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      bTentacleOverlaysActive : 1;                      		// 0x003C (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      bTentacleFlamesActive : 1;                        		// 0x003C (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1584 );

		return pClassPointer;
	};

};

UClass* UTgAnimMetaData_ScyllaTentacleMesh::pClassPointer = NULL;

// Class TgGame.TgAnimMetaData_SkelControl_BoneScale
// 0x001C (0x0058 - 0x003C)
class UTgAnimMetaData_SkelControl_BoneScale : public UAnimMetaData
{
public:
	TArray< struct FName >                             SkelControlNameList;                              		// 0x003C (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	float                                              BoneScale;                                        		// 0x0048 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      bFullControlOverController : 1;                   		// 0x004C (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	struct FName                                       SkelControlName;                                  		// 0x0050 (0x0008) [0x0000000020000000]              ( CPF_Deprecated )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1585 );

		return pClassPointer;
	};

};

UClass* UTgAnimMetaData_SkelControl_BoneScale::pClassPointer = NULL;

// Class TgGame.TgAnimMetaData_SkelControl_BoneScale_KeyFrame
// 0x0030 (0x006C - 0x003C)
class UTgAnimMetaData_SkelControl_BoneScale_KeyFrame : public UAnimMetaData
{
public:
	TArray< struct FName >                             SkelControlNameList;                              		// 0x003C (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< struct FTimeModifier >                     KeyFrames;                                        		// 0x0048 (0x000C) [0x0000000004400001]              ( CPF_Edit | CPF_NeedCtorLink | CPF_EditInline )
	unsigned long                                      bAllowScaleUp : 1;                                		// 0x0054 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      bAllowScaleDown : 1;                              		// 0x0054 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      bAdjustControllerStrength : 1;                    		// 0x0054 (0x0004) [0x0000000000000002] [0x00000004] ( CPF_Const )
	unsigned long                                      bFullControlOverController : 1;                   		// 0x0054 (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )
	unsigned long                                      bForceFirstKeyFrameOnBecomeRelevant : 1;          		// 0x0054 (0x0004) [0x0000000020000000] [0x00000010] ( CPF_Deprecated )
	unsigned long                                      bForceLastKeyFrameOnCeaseRelevant : 1;            		// 0x0054 (0x0004) [0x0000000020000000] [0x00000020] ( CPF_Deprecated )
	struct FName                                       SkelControlName;                                  		// 0x0058 (0x0008) [0x0000000020000000]              ( CPF_Deprecated )
	unsigned char                                      OnBecomeRelevantBehavior;                         		// 0x0060 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      OnCeaseRelevantBehavior;                          		// 0x0061 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	float                                              OnBecomeRelevantStrength;                         		// 0x0064 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              OnCeaseRelevantStrength;                          		// 0x0068 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1586 );

		return pClassPointer;
	};

};

UClass* UTgAnimMetaData_SkelControl_BoneScale_KeyFrame::pClassPointer = NULL;

// Class TgGame.TgAnimNodeAdditiveBlending
// 0x0034 (0x0124 - 0x00F0)
class UTgAnimNodeAdditiveBlending : public UAnimNodeAdditiveBlending
{
public:
	unsigned long                                      m_bSetStrengthFromAnimNode : 1;                   		// 0x00F0 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_bInvertStrengthFromAnimNode : 1;                		// 0x00F0 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_bInitializedCachedNodeList : 1;                 		// 0x00F0 (0x0004) [0x0000000000002000] [0x00000004] ( CPF_Transient )
	TArray< struct FName >                             m_StrengthAnimNodeNameList;                       		// 0x00F4 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< unsigned char >                            m_StrengthEmoteList;                              		// 0x0100 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< class UAnimNode* >                         m_CachedNodeList;                                 		// 0x010C (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	TArray< class UTgAnimNodeEmoteSequence* >          m_CachedEmoteSequences;                           		// 0x0118 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1587 );

		return pClassPointer;
	};

};

UClass* UTgAnimNodeAdditiveBlending::pClassPointer = NULL;

// Class TgGame.TgAnimNodeAimOffset
// 0x005D (0x0181 - 0x0124)
class UTgAnimNodeAimOffset : public UAnimNodeAimOffset
{
public:
	class ATgPawn*                                     Owner;                                            		// 0x0124 (0x0004) [0x0000000000002002]              ( CPF_Const | CPF_Transient )
	TArray< class UAnimNode* >                         m_CachedNodeList;                                 		// 0x0128 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	unsigned long                                      m_bInitializedCachedNodeList : 1;                 		// 0x0134 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	unsigned long                                      m_bDisableVerticalAiming : 1;                     		// 0x0134 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      bInterpolating : 1;                               		// 0x0134 (0x0004) [0x0000000000002002] [0x00000004] ( CPF_Const | CPF_Transient )
	unsigned long                                      m_bBakeAllProfileOffsetsFromAnimations : 1;       		// 0x0134 (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )
	unsigned long                                      m_bPopulateAnimNamesWithPrefixes : 1;             		// 0x0134 (0x0004) [0x0000000000000001] [0x00000010] ( CPF_Edit )
	unsigned long                                      m_bRandomAimPointsEnabled : 1;                    		// 0x0134 (0x0004) [0x0000000000000001] [0x00000020] ( CPF_Edit )
	unsigned long                                      m_bOverrideAim : 1;                               		// 0x0134 (0x0004) [0x0000000000000001] [0x00000040] ( CPF_Edit )
	unsigned long                                      m_bAimAtTarget : 1;                               		// 0x0134 (0x0004) [0x0000000000000001] [0x00000080] ( CPF_Edit )
	unsigned long                                      m_bUseDeviceOffset : 1;                           		// 0x0134 (0x0004) [0x0000000000000001] [0x00000100] ( CPF_Edit )
	unsigned long                                      m_bUseOwnerIfNoTarget : 1;                        		// 0x0134 (0x0004) [0x0000000000000001] [0x00000200] ( CPF_Edit )
	unsigned long                                      m_bFacingBackwards : 1;                           		// 0x0134 (0x0004) [0x0000000000000001] [0x00000400] ( CPF_Edit )
	float                                              TurnInPlaceOffset;                                		// 0x0138 (0x0004) [0x0000000000002003]              ( CPF_Edit | CPF_Const | CPF_Transient )
	float                                              LastAimX;                                         		// 0x013C (0x0004) [0x0000000000002002]              ( CPF_Const | CPF_Transient )
	float                                              InterpSpeed;                                      		// 0x0140 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FVector2D                                   m_AimOffsetPct;                                   		// 0x0144 (0x0008) [0x0000000000002002]              ( CPF_Const | CPF_Transient )
	struct FVector2D                                   m_RandomAimPointsRangeX;                          		// 0x014C (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FVector2D                                   m_RandomAimPointsRangeY;                          		// 0x0154 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fRandomAimPointsInterpRate;                     		// 0x015C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fRandomAimPointsIntervalMin;                    		// 0x0160 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fRandomAimPointsIntervalMax;                    		// 0x0164 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fCurrentRandomAimPointsInterval;                		// 0x0168 (0x0004) [0x0000000000000000]              
	struct FVector2D                                   m_TargetRandomAimLocation;                        		// 0x016C (0x0008) [0x0000000000000000]              
	float                                              m_fDeltaTime;                                     		// 0x0174 (0x0004) [0x0000000000000000]              
	struct FVector2D                                   m_OverriddenAim;                                  		// 0x0178 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_eDeviceEquipPoint;                              		// 0x0180 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1588 );

		return pClassPointer;
	};

};

UClass* UTgAnimNodeAimOffset::pClassPointer = NULL;

// Class TgGame.TgAnimNodeAimOffset_Charge
// 0x001F (0x01A0 - 0x0181)
class UTgAnimNodeAimOffset_Charge : public UTgAnimNodeAimOffset
{
public:
	unsigned long                                      m_bInterpToCurrentTurnRate : 1;                   		// 0x0184 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	float                                              m_fInterpSpeed;                                   		// 0x0188 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fMaxYawRate;                                    		// 0x018C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fAimYawOffset;                                  		// 0x0190 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FRotator                                    m_rCachedOwnerRotator;                            		// 0x0194 (0x000C) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1589 );

		return pClassPointer;
	};

};

UClass* UTgAnimNodeAimOffset_Charge::pClassPointer = NULL;

// Class TgGame.TgAnimNodeBlend_Bacchus_Inebriation
// 0x0004 (0x00F0 - 0x00EC)
class UTgAnimNodeBlend_Bacchus_Inebriation : public UAnimNodeBlend
{
public:
	class ATgPawn_Bacchus*                             OwningBacchusPawn;                                		// 0x00EC (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1590 );

		return pClassPointer;
	};

};

UClass* UTgAnimNodeBlend_Bacchus_Inebriation::pClassPointer = NULL;

// Class TgGame.TgAnimNodeBlendAnimsByDirection
// 0x0034 (0x0194 - 0x0160)
class UTgAnimNodeBlendAnimsByDirection : public UAnimNodeSequenceBlendBase
{
public:
	float                                              m_BlendSpeed;                                     		// 0x0160 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_bUsePlayRateByDirection : 1;                    		// 0x0164 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_bIncludeStandingAnim : 1;                       		// 0x0164 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_bForceStanding : 1;                             		// 0x0164 (0x0004) [0x0000000000002000] [0x00000004] ( CPF_Transient )
	unsigned long                                      m_bInterpolateWeights : 1;                        		// 0x0164 (0x0004) [0x0000000000002002] [0x00000008] ( CPF_Const | CPF_Transient )
	unsigned long                                      m_bMirrorDirectionsWhenPawnMirrored : 1;          		// 0x0164 (0x0004) [0x0000000000000001] [0x00000010] ( CPF_Edit )
	unsigned long                                      m_bForwardLeftCorrection : 1;                     		// 0x0164 (0x0004) [0x0000000000000001] [0x00000020] ( CPF_Edit )
	float                                              m_PlayRateByDirection[ 0x8 ];                     		// 0x0168 (0x0020) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_PlayRateStanding;                               		// 0x0188 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_DirAngle;                                       		// 0x018C (0x0004) [0x0000000000000000]              
	float                                              m_LastRelevantTime;                               		// 0x0190 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1591 );

		return pClassPointer;
	};

};

UClass* UTgAnimNodeBlendAnimsByDirection::pClassPointer = NULL;

// Class TgGame.TgAnimNodeBlendByBlink
// 0x0034 (0x0148 - 0x0114)
class UTgAnimNodeBlendByBlink : public UAnimNodeBlendPerBone
{
public:
	class ATgPawn*                                     m_TgPawn;                                         		// 0x0114 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class USkeletalMeshComponent*                      m_SkelMesh;                                       		// 0x0118 (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )
	float                                              m_fBlinkAnimRate;                                 		// 0x011C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FVector2D                                   m_vTimeBetweenBlinks;                             		// 0x0120 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fTimeTillNextBlink;                             		// 0x0128 (0x0004) [0x0000000000000000]              
	TArray< struct FName >                             m_DisableBlinkingAnimNodeNameList;                		// 0x012C (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< class UAnimNode* >                         m_CachedNodeList;                                 		// 0x0138 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	unsigned long                                      m_bInitializedCachedNodeList : 1;                 		// 0x0144 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1592 );

		return pClassPointer;
	};

};

UClass* UTgAnimNodeBlendByBlink::pClassPointer = NULL;

// Class TgGame.TgAnimNodeBlendByPhysics
// 0x002C (0x0124 - 0x00F8)
class UTgAnimNodeBlendByPhysics : public UAnimNodeBlendList
{
public:
	class ATgPawn*                                     m_TgPawn;                                         		// 0x00F8 (0x0004) [0x0000000000000000]              
	unsigned char                                      m_LastPhysics;                                    		// 0x00FC (0x0001) [0x0000000000000000]              
	unsigned char                                      m_CurrentPhysics;                                 		// 0x00FD (0x0001) [0x0000000000000000]              
	int                                                m_CurrentPhysicsChildIndex;                       		// 0x0100 (0x0004) [0x0000000000000000]              
	TArray< unsigned char >                            m_PhysicsChildren;                                		// 0x0104 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	unsigned long                                      m_bDirectUnspecifiedPhysicsThroughChild0 : 1;     		// 0x0110 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	float                                              DefaultBlendTime;                                 		// 0x0114 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	TArray< struct FChildrenBlendInfo >                m_ChildrenBlendInfo;                              		// 0x0118 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1593 );

		return pClassPointer;
	};

};

UClass* UTgAnimNodeBlendByPhysics::pClassPointer = NULL;

// Class TgGame.TgAnimNodeBlendByStrafe
// 0x0008 (0x00F4 - 0x00EC)
class UTgAnimNodeBlendByStrafe : public UAnimNodeBlend
{
public:
	class ATgPawn*                                     m_TgPawn;                                         		// 0x00EC (0x0004) [0x0000000000000000]              
	float                                              m_fBlendTime;                                     		// 0x00F0 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1594 );

		return pClassPointer;
	};

};

UClass* UTgAnimNodeBlendByStrafe::pClassPointer = NULL;

// Class TgGame.TgAnimNodeBlendList
// 0x0024 (0x011C - 0x00F8)
class UTgAnimNodeBlendList : public UAnimNodeBlendList
{
public:
	float                                              DefaultBlendTime;                                 		// 0x00F8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	TArray< float >                                    ChildBlendTimes;                                  		// 0x00FC (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	int                                                DesiredChildIndex;                                		// 0x0108 (0x0004) [0x0000000000000000]              
	unsigned long                                      DesiredChildWaitsForCurrentChildCompletion : 1;   		// 0x010C (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	TArray< struct FChildBlendParam >                  SpecificChildBlendTimes;                          		// 0x0110 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1595 );

		return pClassPointer;
	};

	float GetBlendTime ( int ChildIndex );
};

UClass* UTgAnimNodeBlendList::pClassPointer = NULL;

// Class TgGame.TgAnimBlendByAoKuangAttack
// 0x0004 (0x0120 - 0x011C)
class UTgAnimBlendByAoKuangAttack : public UTgAnimNodeBlendList
{
public:
	class ATgPawn_AoKuang*                             m_CachedAoKuang;                                  		// 0x011C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1596 );

		return pClassPointer;
	};

	void ReplayAnim ( );
	void PlayAnim ( unsigned long bLoop, float Rate, float StartTime );
};

UClass* UTgAnimBlendByAoKuangAttack::pClassPointer = NULL;

// Class TgGame.TgAnimBlendByAoKuangDragon
// 0x0004 (0x0120 - 0x011C)
class UTgAnimBlendByAoKuangDragon : public UTgAnimNodeBlendList
{
public:
	unsigned long                                      m_bKeepPlaying : 1;                               		// 0x011C (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1597 );

		return pClassPointer;
	};

	void ContinueToSky ( );
};

UClass* UTgAnimBlendByAoKuangDragon::pClassPointer = NULL;

// Class TgGame.TgAnimBlendByApolloPassive
// 0x0010 (0x012C - 0x011C)
class UTgAnimBlendByApolloPassive : public UTgAnimNodeBlendList
{
public:
	unsigned long                                      bControllingNode : 1;                             		// 0x011C (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_bEnablePassive : 1;                             		// 0x011C (0x0004) [0x0000000000000000] [0x00000002] 
	TArray< struct FName >                             FiringAnimNames;                                  		// 0x0120 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1598 );

		return pClassPointer;
	};

	void TogglePassive ( unsigned long bEnable );
};

UClass* UTgAnimBlendByApolloPassive::pClassPointer = NULL;

// Class TgGame.TgAnimBlendByArachneGrasp
// 0x0010 (0x012C - 0x011C)
class UTgAnimBlendByArachneGrasp : public UTgAnimNodeBlendList
{
public:
	class ATgPawn_Arachne*                             m_TgPawn;                                         		// 0x011C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_MaxSize;                                        		// 0x0120 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_MinSize;                                        		// 0x0124 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_bUseHeight : 1;                                 		// 0x0128 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1599 );

		return pClassPointer;
	};

};

UClass* UTgAnimBlendByArachneGrasp::pClassPointer = NULL;

// Class TgGame.TgAnimBlendByArachneInHand
// 0x0004 (0x0120 - 0x011C)
class UTgAnimBlendByArachneInHand : public UTgAnimNodeBlendList
{
public:
	class ATgPawn_ArachneV2*                           m_CachedArachne;                                  		// 0x011C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1600 );

		return pClassPointer;
	};

	void ReplayAnim ( );
	void PlayAnim ( unsigned long bLoop, float Rate, float StartTime );
};

UClass* UTgAnimBlendByArachneInHand::pClassPointer = NULL;

// Class TgGame.TgAnimBlendByAwilixMount
// 0x0008 (0x0124 - 0x011C)
class UTgAnimBlendByAwilixMount : public UTgAnimNodeBlendList
{
public:
	class ATgPawn_Awilix*                              m_TgPawn;                                         		// 0x011C (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bWasMounted : 1;                                		// 0x0120 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1601 );

		return pClassPointer;
	};

};

UClass* UTgAnimBlendByAwilixMount::pClassPointer = NULL;

// Class TgGame.TgAnimBlendByAwilixUlt
// 0x0004 (0x0120 - 0x011C)
class UTgAnimBlendByAwilixUlt : public UTgAnimNodeBlendList
{
public:
	unsigned long                                      bFirstInit : 1;                                   		// 0x011C (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1602 );

		return pClassPointer;
	};

	void WithPull ( );
};

UClass* UTgAnimBlendByAwilixUlt::pClassPointer = NULL;

// Class TgGame.TgAnimBlendByBakasuraInHand
// 0x0004 (0x0120 - 0x011C)
class UTgAnimBlendByBakasuraInHand : public UTgAnimNodeBlendList
{
public:
	class ATgPawn_Bakasura*                            m_CachedBakasura;                                 		// 0x011C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1603 );

		return pClassPointer;
	};

	void ReplayAnim ( );
	void PlayAnim ( unsigned long bLoop, float Rate, float StartTime );
};

UClass* UTgAnimBlendByBakasuraInHand::pClassPointer = NULL;

// Class TgGame.TgAnimBlendByBellonaWeaponSetIdle
// 0x0006 (0x0122 - 0x011C)
class UTgAnimBlendByBellonaWeaponSetIdle : public UTgAnimNodeBlendList
{
public:
	unsigned long                                      m_bCurrentlyBlockingWeaponSwap : 1;               		// 0x011C (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned char                                      m_PendingWeaponSet;                               		// 0x0120 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_ActiveWeaponSet;                                		// 0x0121 (0x0001) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1604 );

		return pClassPointer;
	};

	void StartChangeWeaponSet ( unsigned char NewSet, unsigned long bInstant );
};

UClass* UTgAnimBlendByBellonaWeaponSetIdle::pClassPointer = NULL;

// Class TgGame.TgAnimBlendByBuffMonsterIntro
// 0x0010 (0x012C - 0x011C)
class UTgAnimBlendByBuffMonsterIntro : public UTgAnimNodeBlendList
{
public:
	unsigned long                                      m_bEndIntroStateEarly : 1;                        		// 0x011C (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_bIntroHasBeenSetup : 1;                         		// 0x011C (0x0004) [0x0000000000000000] [0x00000002] 
	float                                              m_fIntroTimeHittableAt;                           		// 0x0120 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fTimeToStartIntroAnim;                          		// 0x0124 (0x0004) [0x0000000000000000]              
	class ATgPawn*                                     m_CachedPawn;                                     		// 0x0128 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1605 );

		return pClassPointer;
	};

	void SetupIntro ( float fTotalIntroTime, float fIntroOffset );
};

UClass* UTgAnimBlendByBuffMonsterIntro::pClassPointer = NULL;

// Class TgGame.TgAnimBlendByCharge
// 0x0008 (0x0124 - 0x011C)
class UTgAnimBlendByCharge : public UTgAnimNodeBlendList
{
public:
	unsigned char                                      ChargeEquipSlot;                                  		// 0x011C (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_bActivelyCharging : 1;                          		// 0x0120 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1606 );

		return pClassPointer;
	};

	void InterruptCharge ( );
	bool EndCharge ( unsigned long bHitTarget );
	void BeginCharge ( );
};

UClass* UTgAnimBlendByCharge::pClassPointer = NULL;

// Class TgGame.TgAnimBlendByChronosHasten
// 0x0000 (0x011C - 0x011C)
class UTgAnimBlendByChronosHasten : public UTgAnimNodeBlendList
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1607 );

		return pClassPointer;
	};

	void OnOtherDeviceFire ( );
	void ToggleHasten ( unsigned long bEnable, unsigned long bSkipTransition );
};

UClass* UTgAnimBlendByChronosHasten::pClassPointer = NULL;

// Class TgGame.TgAnimBlendByDirection
// 0x000C (0x0128 - 0x011C)
class UTgAnimBlendByDirection : public UTgAnimNodeBlendList
{
public:
	class ATgPawn*                                     m_TgPawn;                                         		// 0x011C (0x0004) [0x0000000000000000]              
	unsigned char                                      m_SpeedType;                                      		// 0x0120 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      LastDirection;                                    		// 0x0121 (0x0001) [0x0000000000000002]              ( CPF_Const )
	unsigned long                                      bAdjustRateByVelocity : 1;                        		// 0x0124 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      bNoDirectionIsEnabled : 1;                        		// 0x0124 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      bResetLooping : 1;                                		// 0x0124 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      m_bDelayBlendOutToPlayAnim : 1;                   		// 0x0124 (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )
	unsigned long                                      m_bIsAllowedToBlendOut : 1;                       		// 0x0124 (0x0004) [0x0000000000000000] [0x00000010] 
	unsigned long                                      m_bMirrorDirectionsWhenPawnMirrored : 1;          		// 0x0124 (0x0004) [0x0000000000000001] [0x00000020] ( CPF_Edit )
	unsigned long                                      m_bStopChildrenOnCeaseRelevant : 1;               		// 0x0124 (0x0004) [0x0000000000000001] [0x00000040] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1608 );

		return pClassPointer;
	};

};

UClass* UTgAnimBlendByDirection::pClassPointer = NULL;

// Class TgGame.TgAnimBlendByEmote
// 0x0040 (0x015C - 0x011C)
class UTgAnimBlendByEmote : public UTgAnimNodeBlendList
{
public:
	struct FName                                       nmEmotePrefix;                                    		// 0x011C (0x0008) [0x0000000000000000]              
	struct FName                                       mnEmoteMovingSuffix;                              		// 0x0124 (0x0008) [0x0000000000000000]              
	struct FName                                       nmEmoteFullMovingSuffix;                          		// 0x012C (0x0008) [0x0000000000000000]              
	unsigned long                                      bForceTreatAsMovingEmoteNode : 1;                 		// 0x0134 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	TArray< class UTgAnimNodeEmoteSequence* >          EmoteSequenceChildren;                            		// 0x0138 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UAnimNodeBlendPerBone* >             PerBoneChildren;                                  		// 0x0144 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UAnimNodeBlendList* >                FullMovingBlendLists;                             		// 0x0150 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1609 );

		return pClassPointer;
	};

	bool IsFullBody ( );
	void CancelEmote ( unsigned long bNoBlend );
	float PlayEmote ( unsigned char Emote );
};

UClass* UTgAnimBlendByEmote::pClassPointer = NULL;

// Class TgGame.TgAnimBlendByFall
// 0x0030 (0x014C - 0x011C)
class UTgAnimBlendByFall : public UTgAnimNodeBlendList
{
public:
	unsigned char                                      FallState;                                        		// 0x011C (0x0001) [0x0000000000000002]              ( CPF_Const )
	unsigned char                                      m_PreviousTickPhysics;                            		// 0x011D (0x0001) [0x0000000000000000]              
	float                                              LastFallingVelocity;                              		// 0x0120 (0x0004) [0x0000000000000002]              ( CPF_Const )
	class ATgPawn*                                     pOwner;                                           		// 0x0124 (0x0004) [0x0000000000000000]              
	float                                              m_fPrelandDistance;                               		// 0x0128 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_bDebugMeasureJumpUp : 1;                        		// 0x012C (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_bDebugMeasureJumpDownToLand : 1;                		// 0x012C (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_bMeasuring : 1;                                 		// 0x012C (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_bForceToIdleOnAttack : 1;                       		// 0x012C (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )
	struct FVector                                     m_StartMeasureJump;                               		// 0x0130 (0x000C) [0x0000000000000000]              
	float                                              m_fMeasureTime;                                   		// 0x013C (0x0004) [0x0000000000000000]              
	float                                              m_fLandingMovementPlayRate;                       		// 0x0140 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_nmNameLandingSynchGroup;                        		// 0x0144 (0x0008) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1610 );

		return pClassPointer;
	};

	void OnBasicOrOffhandAttack ( );
};

UClass* UTgAnimBlendByFall::pClassPointer = NULL;

// Class TgGame.TgAnimBlendByFire
// 0x0068 (0x0184 - 0x011C)
class UTgAnimBlendByFire : public UTgAnimNodeBlendList
{
public:
	unsigned long                                      m_bSetToIdleOnCeaseRelevant : 1;                  		// 0x011C (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_bShouldReplayIfAlreadyActive : 1;               		// 0x011C (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_bFirstInit : 1;                                 		// 0x011C (0x0004) [0x0000000000002000] [0x00000004] ( CPF_Transient )
	struct FDeviceParameters                           m_InHandDeviceParameters;                         		// 0x0120 (0x0010) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	struct FDeviceParameters                           m_OffHand1DeviceParameters;                       		// 0x0130 (0x0010) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	struct FDeviceParameters                           m_OffHand2DeviceParameters;                       		// 0x0140 (0x0010) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	struct FDeviceParameters                           m_OffHand3DeviceParameters;                       		// 0x0150 (0x0010) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	struct FDeviceParameters                           m_OffHand4DeviceParameters;                       		// 0x0160 (0x0010) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	struct FDeviceParameters                           m_RecallDeviceParameters;                         		// 0x0170 (0x0010) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	class ATgPawn*                                     m_OwningPawn;                                     		// 0x0180 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1611 );

		return pClassPointer;
	};

	void OnDeviceFormInterruptFire ( class UTgDeviceForm* DeviceForm );
	void OnDeviceFormStopFire ( class UTgDeviceForm* DeviceForm );
	void OnDeviceFormStartFire ( class UTgDeviceForm* DeviceForm, float FireDuration );
	void OnDeviceFormBuildup ( class UTgDeviceForm* DeviceForm, float BuildupTime );
};

UClass* UTgAnimBlendByFire::pClassPointer = NULL;

// Class TgGame.TgAnimBlendByFire_ZhongKui
// 0x0031 (0x01B5 - 0x0184)
class UTgAnimBlendByFire_ZhongKui : public UTgAnimBlendByFire
{
public:
	unsigned long                                      m_bForceScrollChargedAnimToAlwaysPlay : 1;        		// 0x0184 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_bCanManipulateControlStrength : 1;              		// 0x0184 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_bActivateControlOnScrollCharged : 1;            		// 0x0184 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      m_bCanManipulateControlBoneScale : 1;             		// 0x0184 (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )
	unsigned long                                      m_bHideMeshWhenDischarged : 1;                    		// 0x0184 (0x0004) [0x0000000000000001] [0x00000010] ( CPF_Edit )
	unsigned long                                      m_bInHandIsFiring : 1;                            		// 0x0184 (0x0004) [0x0000000000002000] [0x00000020] ( CPF_Transient )
	TArray< struct FName >                             m_ScrollScaleControlNames;                        		// 0x0188 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< class USkelControlBase* >                  m_ScrollScaleControls;                            		// 0x0194 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	float                                              m_bScrollChargeTime;                              		// 0x01A0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_bScrollDischargeTime;                           		// 0x01A4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_bDesiredChargedBoneScale;                       		// 0x01A8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_bDesiredDischargedBoneScale;                    		// 0x01AC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_nScrollDischargeDeviceEqpSlot;                  		// 0x01B0 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	unsigned char                                      m_bScrollState;                                   		// 0x01B4 (0x0001) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1612 );

		return pClassPointer;
	};

	void SetScrollCharged ( unsigned long bCharged );
	void OnDeviceFormStopFire ( class UTgDeviceForm* DeviceForm );
	void OnDeviceFormStartFire ( class UTgDeviceForm* DeviceForm, float FireDuration );
	void OnDeviceFormBuildup ( class UTgDeviceForm* DeviceForm, float BuildupTime );
};

UClass* UTgAnimBlendByFire_ZhongKui::pClassPointer = NULL;

// Class TgGame.TgAnimBlendByFireRatatoskr
// 0x0010 (0x0194 - 0x0184)
class UTgAnimBlendByFireRatatoskr : public UTgAnimBlendByFire
{
public:
	struct FDeviceParameters                           m_PassiveDeviceParameters;                        		// 0x0184 (0x0010) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1613 );

		return pClassPointer;
	};

};

UClass* UTgAnimBlendByFireRatatoskr::pClassPointer = NULL;

// Class TgGame.TgAnimBlendByFireGiantChest
// 0x0000 (0x011C - 0x011C)
class UTgAnimBlendByFireGiantChest : public UTgAnimNodeBlendList
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1614 );

		return pClassPointer;
	};

	void SetOpened ( unsigned long bForced );
	void OpenChest ( float StartOffset );
	void ForceClosed ( );
};

UClass* UTgAnimBlendByFireGiantChest::pClassPointer = NULL;

// Class TgGame.TgAnimBlendByFlying
// 0x002C (0x0148 - 0x011C)
class UTgAnimBlendByFlying : public UTgAnimNodeBlendList
{
public:
	unsigned long                                      bAdjustRateByVelocity : 1;                        		// 0x011C (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_bAdjustRateByAcceleration : 1;                  		// 0x011C (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_bPreviewJetpackPerBoneBlend : 1;                		// 0x011C (0x0004) [0x0000000000002001] [0x00000004] ( CPF_Edit | CPF_Transient )
	unsigned long                                      m_bIsUsingHandsFreeJetpack : 1;                   		// 0x011C (0x0004) [0x0000000000000000] [0x00000008] 
	float                                              m_fUpLoopStartTime;                               		// 0x0120 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      LastDirection;                                    		// 0x0124 (0x0001) [0x0000000000000002]              ( CPF_Const )
	struct FName                                       m_nmHandsFreeJetpackPerBoneBlendNodeName;         		// 0x0128 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	class UAnimNodeBlendPerBone*                       m_HandsFreeJetpackPerBoneBlendNode;               		// 0x0130 (0x0004) [0x0000000000000000]              
	float                                              m_fHandsFreeJetpackBlendBias;                     		// 0x0134 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_nmHandsFreeJetpackBiasBlendNodeName;            		// 0x0138 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	class UAnimNodeBlend*                              m_HandsFreeJetpackBiasBlendNode;                  		// 0x0140 (0x0004) [0x0000000000000000]              
	class ATgPawn*                                     m_TgPawn;                                         		// 0x0144 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1615 );

		return pClassPointer;
	};

};

UClass* UTgAnimBlendByFlying::pClassPointer = NULL;

// Class TgGame.TgAnimBlendByFreyaInHand
// 0x0001 (0x011D - 0x011C)
class UTgAnimBlendByFreyaInHand : public UTgAnimNodeBlendList
{
public:
	unsigned char                                      m_InHandLastAnim;                                 		// 0x011C (0x0001) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1616 );

		return pClassPointer;
	};

	void PrepareInHandAttack ( unsigned char NextAttackType );
};

UClass* UTgAnimBlendByFreyaInHand::pClassPointer = NULL;

// Class TgGame.TgAnimBlendByGuanYuV2Ult
// 0x0008 (0x0124 - 0x011C)
class UTgAnimBlendByGuanYuV2Ult : public UTgAnimNodeBlendList
{
public:
	class ATgPawn_GuanYuV2*                            m_GuanYuPawn;                                     		// 0x011C (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bAlternateFireAnim : 1;                         		// 0x0120 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1617 );

		return pClassPointer;
	};

	void PlayMountAnim ( );
	void PlayDismountAnim ( );
	void PlayFireAnim ( );
};

UClass* UTgAnimBlendByGuanYuV2Ult::pClassPointer = NULL;

// Class TgGame.TgAnimBlendByKhepriCrawlBack
// 0x0004 (0x0120 - 0x011C)
class UTgAnimBlendByKhepriCrawlBack : public UTgAnimNodeBlendList
{
public:
	unsigned long                                      m_bCrawlBackActive : 1;                           		// 0x011C (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1618 );

		return pClassPointer;
	};

	void EndCrawlBack ( );
	void ReplayAnim ( );
	void PlayAnim ( unsigned long bLoop, float Rate, float StartTime );
};

UClass* UTgAnimBlendByKhepriCrawlBack::pClassPointer = NULL;

// Class TgGame.TgAnimBlendByNeithUltimate
// 0x0000 (0x011C - 0x011C)
class UTgAnimBlendByNeithUltimate : public UTgAnimNodeBlendList
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1619 );

		return pClassPointer;
	};

	void Fire ( );
};

UClass* UTgAnimBlendByNeithUltimate::pClassPointer = NULL;

// Class TgGame.TgAnimBlendByNikeDivineValor
// 0x0008 (0x0124 - 0x011C)
class UTgAnimBlendByNikeDivineValor : public UTgAnimNodeBlendList
{
public:
	class ATgPawn_Nike*                                m_TgPawn;                                         		// 0x011C (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bWasBuffed : 1;                                 		// 0x0120 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1620 );

		return pClassPointer;
	};

};

UClass* UTgAnimBlendByNikeDivineValor::pClassPointer = NULL;

// Class TgGame.TgAnimBlendByPhase
// 0x001C (0x0138 - 0x011C)
class UTgAnimBlendByPhase : public UTgAnimNodeBlendList
{
public:
	class ATgPawn*                                     m_TgPawn;                                         		// 0x011C (0x0004) [0x0000000000000000]              
	int                                                m_LastPhase;                                      		// 0x0120 (0x0004) [0x0000000000000000]              
	int                                                m_CurrentPhase;                                   		// 0x0124 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bEnableTransitionAnims : 1;                     		// 0x0128 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	TArray< struct Fm_PhaseProfile >                   m_PhaseProfiles;                                  		// 0x012C (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1621 );

		return pClassPointer;
	};

};

UClass* UTgAnimBlendByPhase::pClassPointer = NULL;

// Class TgGame.TgAnimBlendByPhysics
// 0x003C (0x0158 - 0x011C)
class UTgAnimBlendByPhysics : public UTgAnimNodeBlendList
{
public:
	int                                                PhysicsMap[ 0xE ];                                		// 0x011C (0x0038) [0x0000000000000001]              ( CPF_Edit )
	int                                                LastPhysics;                                      		// 0x0154 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1622 );

		return pClassPointer;
	};

};

UClass* UTgAnimBlendByPhysics::pClassPointer = NULL;

// Class TgGame.TgAnimBlendByPosture
// 0x0030 (0x014C - 0x011C)
class UTgAnimBlendByPosture : public UTgAnimNodeBlendList
{
public:
	class ATgPawn*                                     m_TgPawn;                                         		// 0x011C (0x0004) [0x0000000000000000]              
	class ATgSkeletalMeshActor_Posture*                m_TgPostureMesh;                                  		// 0x0120 (0x0004) [0x0000000000000000]              
	unsigned char                                      m_LastPosture;                                    		// 0x0124 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_CurrentPosture;                                 		// 0x0125 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_TransitionFromPosture;                          		// 0x0126 (0x0001) [0x0000000000000000]              
	unsigned long                                      m_bEnableTransitionAnims : 1;                     		// 0x0128 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_bSkipTransitionAnimOnCeaseRelevant : 1;         		// 0x0128 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	int                                                m_CurrentPostureChildIndex;                       		// 0x012C (0x0004) [0x0000000000000000]              
	TArray< struct FPostureTransitionOverride >        m_QueuedTransitionOverrides;                      		// 0x0130 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< struct Fm_PostureProfile >                 m_PostureProfiles;                                		// 0x013C (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	class UAnimNodeSequence*                           m_TransitionAnimNodeSeq;                          		// 0x0148 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1623 );

		return pClassPointer;
	};

	bool ForcePostureChange ( unsigned long bAllowTransitionAnims );
	void OverrideTransition ( struct FName AnimName, float BlendTime, unsigned char StartPosture, unsigned char EndPosture );
};

UClass* UTgAnimBlendByPosture::pClassPointer = NULL;

// Class TgGame.TgAnimBlendBySerqetUltimate
// 0x0004 (0x0120 - 0x011C)
class UTgAnimBlendBySerqetUltimate : public UTgAnimNodeBlendList
{
public:
	unsigned long                                      m_bWasInterrupted : 1;                            		// 0x011C (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1624 );

		return pClassPointer;
	};

	void LosingFocus ( );
	void UltimateInterrupted ( );
	void BeginBackflip ( );
	void BeginGrab ( );
	bool EndLeap ( );
	void BeginLeap ( );
};

UClass* UTgAnimBlendBySerqetUltimate::pClassPointer = NULL;

// Class TgGame.TgAnimBlendByStartingPosture
// 0x000C (0x0128 - 0x011C)
class UTgAnimBlendByStartingPosture : public UTgAnimNodeBlendList
{
public:
	class ATgPawn*                                     m_TgPawn;                                         		// 0x011C (0x0004) [0x0000000000000000]              
	unsigned char                                      m_StartingPosture;                                		// 0x0120 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_bExpired : 1;                                   		// 0x0124 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1625 );

		return pClassPointer;
	};

};

UClass* UTgAnimBlendByStartingPosture::pClassPointer = NULL;

// Class TgGame.TgAnimBlendBySusanoDev2Stage
// 0x0008 (0x0124 - 0x011C)
class UTgAnimBlendBySusanoDev2Stage : public UTgAnimNodeBlendList
{
public:
	class ATgPawn_Susano*                              m_Susano;                                         		// 0x011C (0x0004) [0x0000000000000000]              
	int                                                m_LastStage;                                      		// 0x0120 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1626 );

		return pClassPointer;
	};

};

UClass* UTgAnimBlendBySusanoDev2Stage::pClassPointer = NULL;

// Class TgGame.TgAnimBlendByWukongCharge
// 0x0004 (0x0120 - 0x011C)
class UTgAnimBlendByWukongCharge : public UTgAnimNodeBlendList
{
public:
	class ATgPawn_SunWukong*                           m_CachedWukong;                                   		// 0x011C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1627 );

		return pClassPointer;
	};

};

UClass* UTgAnimBlendByWukongCharge::pClassPointer = NULL;

// Class TgGame.TgAnimBlendByZeusShieldRecover
// 0x0000 (0x011C - 0x011C)
class UTgAnimBlendByZeusShieldRecover : public UTgAnimNodeBlendList
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1628 );

		return pClassPointer;
	};

	bool Recover ( );
};

UClass* UTgAnimBlendByZeusShieldRecover::pClassPointer = NULL;

// Class TgGame.TgAnimBlendByZhongKuiExorcism
// 0x0010 (0x012C - 0x011C)
class UTgAnimBlendByZhongKuiExorcism : public UTgAnimNodeBlendList
{
public:
	struct FName                                       ScrollScaleSkelControlName;                       		// 0x011C (0x0008) [0x0000000000000001]              ( CPF_Edit )
	class USkelControlBase*                            SkelControl_ScrollScale;                          		// 0x0124 (0x0004) [0x0000000000000000]              
	int                                                m_nDesiredActiveChild;                            		// 0x0128 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1629 );

		return pClassPointer;
	};

	void SetExorcismCharged ( unsigned long bCharged );
};

UClass* UTgAnimBlendByZhongKuiExorcism::pClassPointer = NULL;

// Class TgGame.TgAnimBlendOnlyWhenRelevant
// 0x0001 (0x011D - 0x011C)
class UTgAnimBlendOnlyWhenRelevant : public UTgAnimNodeBlendList
{
public:
	unsigned char                                      m_eCurrentPosture;                                		// 0x011C (0x0001) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1630 );

		return pClassPointer;
	};

	void ReplayAnim ( );
	void PlayAnim ( unsigned long bLoop, float Rate, float StartTime );
};

UClass* UTgAnimBlendOnlyWhenRelevant::pClassPointer = NULL;

// Class TgGame.TgAnimNodeBlendByAFK
// 0x0004 (0x0120 - 0x011C)
class UTgAnimNodeBlendByAFK : public UTgAnimNodeBlendList
{
public:
	class ATgPawn*                                     PawnOwner;                                        		// 0x011C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1631 );

		return pClassPointer;
	};

};

UClass* UTgAnimNodeBlendByAFK::pClassPointer = NULL;

// Class TgGame.TgAnimNodeBlendByCamazotzUltimate
// 0x0004 (0x0120 - 0x011C)
class UTgAnimNodeBlendByCamazotzUltimate : public UTgAnimNodeBlendList
{
public:
	unsigned long                                      m_bOutroNextTick : 1;                             		// 0x011C (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	unsigned long                                      m_bFireNextTick : 1;                              		// 0x011C (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	unsigned long                                      m_bLastFireNextTick : 1;                          		// 0x011C (0x0004) [0x0000000000002000] [0x00000004] ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1632 );

		return pClassPointer;
	};

	void ResetChain ( );
	void Outro ( );
	void LastFire ( );
	void Fire ( );
};

UClass* UTgAnimNodeBlendByCamazotzUltimate::pClassPointer = NULL;

// Class TgGame.TgAnimNodeBlendByCombatWariness
// 0x000C (0x0128 - 0x011C)
class UTgAnimNodeBlendByCombatWariness : public UTgAnimNodeBlendList
{
public:
	float                                              CombatWarinessDuration;                           		// 0x011C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      AllowIdleAnimToComplete : 1;                      		// 0x0120 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      AllowWaryAnimToComplete : 1;                      		// 0x0120 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      IsWary : 1;                                       		// 0x0120 (0x0004) [0x0000000000002000] [0x00000004] ( CPF_Transient )
	float                                              WaryTime;                                         		// 0x0124 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1633 );

		return pClassPointer;
	};

	void BecomeWary ( );
	bool ShouldBeWary ( );
};

UClass* UTgAnimNodeBlendByCombatWariness::pClassPointer = NULL;

// Class TgGame.TgAnimBlendByAoKuangWariness
// 0x0000 (0x0128 - 0x0128)
class UTgAnimBlendByAoKuangWariness : public UTgAnimNodeBlendByCombatWariness
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1634 );

		return pClassPointer;
	};

	bool ShouldBeWary ( );
};

UClass* UTgAnimBlendByAoKuangWariness::pClassPointer = NULL;

// Class TgGame.TgAnimBlendByNuWaWariness
// 0x0008 (0x0130 - 0x0128)
class UTgAnimBlendByNuWaWariness : public UTgAnimNodeBlendByCombatWariness
{
public:
	float                                              fSnakeTransitionToNormalTime;                     		// 0x0128 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      bInSnakeForm : 1;                                 		// 0x012C (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1635 );

		return pClassPointer;
	};

	void ToggleSnakeForm ( unsigned long bEnable );
};

UClass* UTgAnimBlendByNuWaWariness::pClassPointer = NULL;

// Class TgGame.TgAnimNodeBlendByFreyaUltimate
// 0x0004 (0x0120 - 0x011C)
class UTgAnimNodeBlendByFreyaUltimate : public UTgAnimNodeBlendList
{
public:
	unsigned long                                      m_bOutroNextTick : 1;                             		// 0x011C (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	unsigned long                                      m_bFireNextTick : 1;                              		// 0x011C (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1636 );

		return pClassPointer;
	};

	void ResetChain ( );
	void Outro ( );
	void Fire ( );
};

UClass* UTgAnimNodeBlendByFreyaUltimate::pClassPointer = NULL;

// Class TgGame.TgAnimNodeBlendByGameState
// 0x0004 (0x0120 - 0x011C)
class UTgAnimNodeBlendByGameState : public UTgAnimNodeBlendList
{
public:
	class ATgPawn*                                     PawnOwner;                                        		// 0x011C (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1637 );

		return pClassPointer;
	};

};

UClass* UTgAnimNodeBlendByGameState::pClassPointer = NULL;

// Class TgGame.TgAnimNodeBlendByHealth
// 0x0010 (0x012C - 0x011C)
class UTgAnimNodeBlendByHealth : public UTgAnimNodeBlendList
{
public:
	TArray< float >                                    m_HealthChildren;                                 		// 0x011C (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	class ATgPawn*                                     m_TgPawn;                                         		// 0x0128 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1638 );

		return pClassPointer;
	};

};

UClass* UTgAnimNodeBlendByHealth::pClassPointer = NULL;

// Class TgGame.TgAnimNodeBlendByHitReaction
// 0x0000 (0x011C - 0x011C)
class UTgAnimNodeBlendByHitReaction : public UTgAnimNodeBlendList
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1639 );

		return pClassPointer;
	};

	void OnMajorHit ( struct FVector DirectionFromHit );
	void OnMinorHit ( struct FVector DirectionFromHit );
};

UClass* UTgAnimNodeBlendByHitReaction::pClassPointer = NULL;

// Class TgGame.TgAnimNodeBlendByIntroduction
// 0x0004 (0x0120 - 0x011C)
class UTgAnimNodeBlendByIntroduction : public UTgAnimNodeBlendList
{
public:
	unsigned long                                      m_bIsRelevant : 1;                                		// 0x011C (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1640 );

		return pClassPointer;
	};

	void PlayIntroduction ( );
	void PrepareIntroduction ( );
};

UClass* UTgAnimNodeBlendByIntroduction::pClassPointer = NULL;

// Class TgGame.TgAnimNodeBlendByKnockdown
// 0x0030 (0x014C - 0x011C)
class UTgAnimNodeBlendByKnockdown : public UTgAnimNodeBlendList
{
public:
	unsigned long                                      m_bAdjustPlayRateByVelocity : 1;                  		// 0x011C (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	float                                              m_fVelocityMultiplier;                            		// 0x0120 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_PreviewVelocity;                                		// 0x0124 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class ATgPawn*                                     m_TgPawn;                                         		// 0x0128 (0x0004) [0x0000000000000000]              
	struct FName                                       m_FaceDownAnimName;                               		// 0x012C (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_FaceUpAnimName;                                 		// 0x0134 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_FaceDownRecoverAnimName;                        		// 0x013C (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_FaceUpRecoverAnimName;                          		// 0x0144 (0x0008) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1641 );

		return pClassPointer;
	};

	void SetDownStateAnim ( unsigned long bFaceDown );
};

UClass* UTgAnimNodeBlendByKnockdown::pClassPointer = NULL;

// Class TgGame.TgAnimNodeBlendByNeZhaArmillarySash
// 0x0000 (0x011C - 0x011C)
class UTgAnimNodeBlendByNeZhaArmillarySash : public UTgAnimNodeBlendList
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1642 );

		return pClassPointer;
	};

	void SashMiss ( );
	void SashHit ( );
};

UClass* UTgAnimNodeBlendByNeZhaArmillarySash::pClassPointer = NULL;

// Class TgGame.TgAnimNodeBlendByTowerSideHealth
// 0x0014 (0x0130 - 0x011C)
class UTgAnimNodeBlendByTowerSideHealth : public UTgAnimNodeBlendList
{
public:
	int                                                m_nTowerSideIndex;                                		// 0x011C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	TArray< float >                                    m_HealthChildren;                                 		// 0x0120 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	class ATgPawn_Tower*                               m_TgPawn;                                         		// 0x012C (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1643 );

		return pClassPointer;
	};

};

UClass* UTgAnimNodeBlendByTowerSideHealth::pClassPointer = NULL;

// Class TgGame.TgAnimNodeBlendByUllrStance
// 0x0004 (0x0120 - 0x011C)
class UTgAnimNodeBlendByUllrStance : public UTgAnimNodeBlendList
{
public:
	class ATgPawn_Ullr*                                m_TgUllrPawn;                                     		// 0x011C (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1644 );

		return pClassPointer;
	};

};

UClass* UTgAnimNodeBlendByUllrStance::pClassPointer = NULL;

// Class TgGame.TgAnimNodeBlendList_Bacchus_Inebriation
// 0x0010 (0x012C - 0x011C)
class UTgAnimNodeBlendList_Bacchus_Inebriation : public UTgAnimNodeBlendList
{
public:
	class ATgPawn_Bacchus*                             OwningBacchusPawn;                                		// 0x011C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	TArray< struct FInebriationLevelInfo >             InebriationLevels;                                		// 0x0120 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1645 );

		return pClassPointer;
	};

};

UClass* UTgAnimNodeBlendList_Bacchus_Inebriation::pClassPointer = NULL;

// Class TgGame.TgAnimNodeBlendList_EquipScreen
// 0x0000 (0x011C - 0x011C)
class UTgAnimNodeBlendList_EquipScreen : public UTgAnimNodeBlendList
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1646 );

		return pClassPointer;
	};

	void PlayIdleAnim ( );
	void PlayBackpackReaction ( );
	void PlaySuitReaction ( );
	void PlayHelmetReaction ( );
	void PlayWeaponReaction ( );
};

UClass* UTgAnimNodeBlendList_EquipScreen::pClassPointer = NULL;

// Class TgGame.TgAnimNodeBlendList_G72_Ult
// 0x0000 (0x011C - 0x011C)
class UTgAnimNodeBlendList_G72_Ult : public UTgAnimNodeBlendList
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1647 );

		return pClassPointer;
	};

	void PlayAnim ( unsigned long bLoop, float Rate, float StartTime );
	void SetActiveAnimationIndex ( );
};

UClass* UTgAnimNodeBlendList_G72_Ult::pClassPointer = NULL;

// Class TgGame.TgAnimNodeBlendList_JingWei_KnockupSource
// 0x0000 (0x011C - 0x011C)
class UTgAnimNodeBlendList_JingWei_KnockupSource : public UTgAnimNodeBlendList
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1648 );

		return pClassPointer;
	};

	void eventSetActiveAnimationIndex ( int ChildIndex );
};

UClass* UTgAnimNodeBlendList_JingWei_KnockupSource::pClassPointer = NULL;

// Class TgGame.TgAnimNodeBlendList_Loki_Assassinate
// 0x0004 (0x0120 - 0x011C)
class UTgAnimNodeBlendList_Loki_Assassinate : public UTgAnimNodeBlendList
{
public:
	class ATgPawn_Loki*                                OwningLokiPawn;                                   		// 0x011C (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1649 );

		return pClassPointer;
	};

};

UClass* UTgAnimNodeBlendList_Loki_Assassinate::pClassPointer = NULL;

// Class TgGame.TgAnimNodeBlendList_Loki_BackStab
// 0x0004 (0x0120 - 0x011C)
class UTgAnimNodeBlendList_Loki_BackStab : public UTgAnimNodeBlendList
{
public:
	class ATgPawn_Loki*                                OwningLokiPawn;                                   		// 0x011C (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1650 );

		return pClassPointer;
	};

	void ReplayAnim ( );
};

UClass* UTgAnimNodeBlendList_Loki_BackStab::pClassPointer = NULL;

// Class TgGame.TgAnimNodeBlendList_Nox_Candles
// 0x0008 (0x0124 - 0x011C)
class UTgAnimNodeBlendList_Nox_Candles : public UTgAnimNodeBlendList
{
public:
	class ATgPawn_Nox*                                 OwningNoxPawn;                                    		// 0x011C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                CandleCount;                                      		// 0x0120 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1651 );

		return pClassPointer;
	};

};

UClass* UTgAnimNodeBlendList_Nox_Candles::pClassPointer = NULL;

// Class TgGame.TgAnimNodeBlendList_Skadi_Dev2
// 0x0004 (0x0120 - 0x011C)
class UTgAnimNodeBlendList_Skadi_Dev2 : public UTgAnimNodeBlendList
{
public:
	class ATgPawn_Skadi*                               OwningSkadiPawn;                                  		// 0x011C (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1652 );

		return pClassPointer;
	};

	void ReplayAnim ( );
};

UClass* UTgAnimNodeBlendList_Skadi_Dev2::pClassPointer = NULL;

// Class TgGame.TgAnimNodeBlendList_Sol_Dev2
// 0x0004 (0x0120 - 0x011C)
class UTgAnimNodeBlendList_Sol_Dev2 : public UTgAnimNodeBlendList
{
public:
	class ATgPawn_Sol*                                 OwningSolPawn;                                    		// 0x011C (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1653 );

		return pClassPointer;
	};

	void ReplayAnim ( );
};

UClass* UTgAnimNodeBlendList_Sol_Dev2::pClassPointer = NULL;

// Class TgGame.TgAnimNodeBlendList_Staging_Multi
// 0x0001 (0x011D - 0x011C)
class UTgAnimNodeBlendList_Staging_Multi : public UTgAnimNodeBlendList
{
public:
	unsigned char                                      EquipSlot;                                        		// 0x011C (0x0001) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1654 );

		return pClassPointer;
	};

	void SetActiveAnimationIndex ( int ChildIndex );
};

UClass* UTgAnimNodeBlendList_Staging_Multi::pClassPointer = NULL;

// Class TgGame.TgAnimNodeBlendList_Terra_CrushingShaleState
// 0x0008 (0x0124 - 0x011C)
class UTgAnimNodeBlendList_Terra_CrushingShaleState : public UTgAnimNodeBlendList
{
public:
	class ATgPawn_Terra*                               m_Terra;                                          		// 0x011C (0x0004) [0x0000000000000000]              
	unsigned long                                      m_PlayCrush : 1;                                  		// 0x0120 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1655 );

		return pClassPointer;
	};

};

UClass* UTgAnimNodeBlendList_Terra_CrushingShaleState::pClassPointer = NULL;

// Class TgGame.TgAnimNodeBlendList_Terra_ShaleDestruction
// 0x0000 (0x011C - 0x011C)
class UTgAnimNodeBlendList_Terra_ShaleDestruction : public UTgAnimNodeBlendList
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1656 );

		return pClassPointer;
	};

};

UClass* UTgAnimNodeBlendList_Terra_ShaleDestruction::pClassPointer = NULL;

// Class TgGame.TgAnimNodeBlendList_Thoth_Inhand
// 0x0000 (0x011C - 0x011C)
class UTgAnimNodeBlendList_Thoth_Inhand : public UTgAnimNodeBlendList
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1657 );

		return pClassPointer;
	};

	void SetInhandState ( unsigned char InhandState );
};

UClass* UTgAnimNodeBlendList_Thoth_Inhand::pClassPointer = NULL;

// Class TgGame.TgAnimNodeBlendList_XingTian_Spin
// 0x0000 (0x011C - 0x011C)
class UTgAnimNodeBlendList_XingTian_Spin : public UTgAnimNodeBlendList
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1658 );

		return pClassPointer;
	};

	void PlayAnim ( unsigned long bLoop, float Rate, float StartTime );
	void SetActiveAnimationIndex ( );
};

UClass* UTgAnimNodeBlendList_XingTian_Spin::pClassPointer = NULL;

// Class TgGame.TgAnimNodeBlentList_IntroLoopOutro
// 0x0000 (0x011C - 0x011C)
class UTgAnimNodeBlentList_IntroLoopOutro : public UTgAnimNodeBlendList
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1659 );

		return pClassPointer;
	};

	void PlayOutro ( );
	void PlayIntro ( );
};

UClass* UTgAnimNodeBlentList_IntroLoopOutro::pClassPointer = NULL;

// Class TgGame.TgAnimNodeBlentList_Thoth_Dash
// 0x0000 (0x011C - 0x011C)
class UTgAnimNodeBlentList_Thoth_Dash : public UTgAnimNodeBlendList
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1660 );

		return pClassPointer;
	};

	void SetIsDashing ( unsigned long IsDashing );
};

UClass* UTgAnimNodeBlentList_Thoth_Dash::pClassPointer = NULL;

// Class TgGame.TgAnimNodeEmoteSwitch
// 0x0000 (0x011C - 0x011C)
class UTgAnimNodeEmoteSwitch : public UTgAnimNodeBlendList
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1661 );

		return pClassPointer;
	};

	void PlayEmote ( unsigned char Emote );
};

UClass* UTgAnimNodeEmoteSwitch::pClassPointer = NULL;

// Class TgGame.TgAnimNodeFreyaCloak
// 0x0000 (0x011C - 0x011C)
class UTgAnimNodeFreyaCloak : public UTgAnimNodeBlendList
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1662 );

		return pClassPointer;
	};

	void eventOnDeath ( );
	void eventOnIntro ( );
	void eventOnFall ( );
	void eventOnFire ( );
	void eventOnLift ( );
};

UClass* UTgAnimNodeFreyaCloak::pClassPointer = NULL;

// Class TgGame.TgAnimNodeRandom
// 0x003C (0x0158 - 0x011C)
class UTgAnimNodeRandom : public UTgAnimNodeBlendList
{
public:
	int                                                m_iDefaultChildIndex;                             		// 0x011C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_bConsiderRelevancy : 1;                         		// 0x0120 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_bMasterOtherNodes : 1;                          		// 0x0120 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_bIsASlave : 1;                                  		// 0x0120 (0x0004) [0x0000000000002000] [0x00000004] ( CPF_Transient )
	unsigned long                                      m_bEnableTimer : 1;                               		// 0x0120 (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )
	unsigned long                                      m_TimeAllChildren : 1;                            		// 0x0120 (0x0004) [0x0000000000000001] [0x00000010] ( CPF_Edit )
	TArray< struct FName >                             m_SlaveNames;                                     		// 0x0124 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< class UTgAnimNodeRandom* >                 m_Slaves;                                         		// 0x0130 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	int                                                m_nPrimaryChild;                                  		// 0x013C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FVector2D                                   m_TimeRange;                                      		// 0x0140 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fRemainingTime;                                 		// 0x0148 (0x0004) [0x0000000000000000]              
	TArray< struct FTgRandomAnimInfo >                 RandomInfo;                                       		// 0x014C (0x000C) [0x0000000004400041]              ( CPF_Edit | CPF_EditConstArray | CPF_NeedCtorLink | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1663 );

		return pClassPointer;
	};

};

UClass* UTgAnimNodeRandom::pClassPointer = NULL;

// Class TgGame.TgAnimNodeSobekGrab
// 0x0000 (0x011C - 0x011C)
class UTgAnimNodeSobekGrab : public UTgAnimNodeBlendList
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1664 );

		return pClassPointer;
	};

};

UClass* UTgAnimNodeSobekGrab::pClassPointer = NULL;

// Class TgGame.TgAnimNodeSobekPool
// 0x0000 (0x011C - 0x011C)
class UTgAnimNodeSobekPool : public UTgAnimNodeBlendList
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1665 );

		return pClassPointer;
	};

};

UClass* UTgAnimNodeSobekPool::pClassPointer = NULL;

// Class TgGame.TgAnimNodeYmirShards
// 0x0000 (0x011C - 0x011C)
class UTgAnimNodeYmirShards : public UTgAnimNodeBlendList
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1666 );

		return pClassPointer;
	};

};

UClass* UTgAnimNodeYmirShards::pClassPointer = NULL;

// Class TgGame.TgAnimSequenceChain
// 0x0004 (0x0120 - 0x011C)
class UTgAnimSequenceChain : public UTgAnimNodeBlendList
{
public:
	unsigned long                                      m_bLoopChain : 1;                                 		// 0x011C (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_bResetOnRelevant : 1;                           		// 0x011C (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_bDelayBlendOutToPlayAnim : 1;                   		// 0x011C (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      m_bAdvanceOnReplay : 1;                           		// 0x011C (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )
	unsigned long                                      m_bAdvanceOnAnimEnd : 1;                          		// 0x011C (0x0004) [0x0000000000000001] [0x00000010] ( CPF_Edit )
	unsigned long                                      m_bIsAllowedToBlendOut : 1;                       		// 0x011C (0x0004) [0x0000000000000000] [0x00000020] 
	unsigned long                                      m_ReplayedThisFrame : 1;                          		// 0x011C (0x0004) [0x0000000000000000] [0x00000040] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1667 );

		return pClassPointer;
	};

};

UClass* UTgAnimSequenceChain::pClassPointer = NULL;

// Class TgGame.TgAnimNodeBlendNuWa
// 0x0000 (0x00EC - 0x00EC)
class UTgAnimNodeBlendNuWa : public UAnimNodeBlend
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1668 );

		return pClassPointer;
	};

};

UClass* UTgAnimNodeBlendNuWa::pClassPointer = NULL;

// Class TgGame.TgAnimNodeBlendPerBone_Bakasura_ConsumeMinion
// 0x0008 (0x011C - 0x0114)
class UTgAnimNodeBlendPerBone_Bakasura_ConsumeMinion : public UAnimNodeBlendPerBone
{
public:
	class ATgPawn_Bakasura*                            c_OwningBakasuraPawn;                             		// 0x0114 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class ATgPawn*                                     c_CachedConsumedPawn;                             		// 0x0118 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1669 );

		return pClassPointer;
	};

};

UClass* UTgAnimNodeBlendPerBone_Bakasura_ConsumeMinion::pClassPointer = NULL;

// Class TgGame.TgAnimNodeEmoteCustomAnim
// 0x0004 (0x00F8 - 0x00F4)
class UTgAnimNodeEmoteCustomAnim : public UAnimNodePlayCustomAnim
{
public:
	unsigned long                                      c_bIsInHandDeviceMeshInvisible : 1;               		// 0x00F4 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      c_bHasReachedFullWeight : 1;                      		// 0x00F4 (0x0004) [0x0000000000000000] [0x00000002] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1670 );

		return pClassPointer;
	};

};

UClass* UTgAnimNodeEmoteCustomAnim::pClassPointer = NULL;

// Class TgGame.TgAnimNodeEmoteSequence
// 0x000C (0x016C - 0x0160)
class UTgAnimNodeEmoteSequence : public UAnimNodeSequenceBlendBase
{
public:
	unsigned char                                      ActiveEmote;                                      		// 0x0160 (0x0001) [0x0000000000000000]              
	float                                              BlendSpeed;                                       		// 0x0164 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      InterpWeights : 1;                                		// 0x0168 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1671 );

		return pClassPointer;
	};

	bool SetActiveEmote ( struct FName FullBody, struct FName Moving, unsigned char Emote, unsigned long bResetSynchGroup );
};

UClass* UTgAnimNodeEmoteSequence::pClassPointer = NULL;

// Class TgGame.TgAnimNodeEmoteSequence_WithPAC
// 0x000C (0x0178 - 0x016C)
class UTgAnimNodeEmoteSequence_WithPAC : public UTgAnimNodeEmoteSequence
{
public:
	TArray< struct FEMOTE_PAC_INFO >                   m_Emote_PAC_Map;                                  		// 0x016C (0x000C) [0x0000000000480001]              ( CPF_Edit | CPF_Component | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1672 );

		return pClassPointer;
	};

	void DeactivateEmotePAC ( int PACIndex );
	void ActivateEmotePAC ( int PACIndex );
	bool SetActiveEmote ( struct FName FullBody, struct FName Moving, unsigned char Emote, unsigned long bResetSynchGroup );
};

UClass* UTgAnimNodeEmoteSequence_WithPAC::pClassPointer = NULL;

// Class TgGame.TgAnimNodeFidget
// 0x0024 (0x011C - 0x00F8)
class UTgAnimNodeFidget : public UAnimNodeBlendList
{
public:
	float                                              m_SelectedIdleTimeBeforeFidgeting;                		// 0x00F8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_CurrentIdleTime;                                		// 0x00FC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              BlendToFidgetDuration;                            		// 0x0100 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              BlendFromFidgetDuration;                          		// 0x0104 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      FidgetType;                                       		// 0x0108 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	float                                              MinimumIdleTimeBeforeFidgeting;                   		// 0x010C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              MaximumIdleTimeBeforeFidgeting;                   		// 0x0110 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      AllowIdleAnimToComplete : 1;                      		// 0x0114 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	float                                              ChanceToFidgetWhenIdleCompletes;                  		// 0x0118 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1673 );

		return pClassPointer;
	};

};

UClass* UTgAnimNodeFidget::pClassPointer = NULL;

// Class TgGame.TgAnimNodeFitToDuration
// 0x0017 (0x00F0 - 0x00D9)
class UTgAnimNodeFitToDuration : public UAnimNodeBlendBase
{
public:
	float                                              Duration;                                         		// 0x00DC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              OverrideDuration;                                 		// 0x00E0 (0x0004) [0x0000000000000000]              
	unsigned long                                      bAllowIncreasedPlayRate : 1;                      		// 0x00E4 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      bAllowDecreasedPlayRate : 1;                      		// 0x00E4 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      bClampDuration : 1;                               		// 0x00E4 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	float                                              ClampedMinDuration;                               		// 0x00E8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              ClampedMaxDuration;                               		// 0x00EC (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1674 );

		return pClassPointer;
	};

};

UClass* UTgAnimNodeFitToDuration::pClassPointer = NULL;

// Class TgGame.TgAnimNodeJumpLeanOffset
// 0x002C (0x0150 - 0x0124)
class UTgAnimNodeJumpLeanOffset : public UAnimNodeAimOffset
{
public:
	float                                              JumpLeanStrength;                                 		// 0x0124 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              MaxLeanChangeSpeed;                               		// 0x0128 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      bMultiplyByZVelocity : 1;                         		// 0x012C (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	class UAnimNodeAimOffset*                          CachedAimNode;                                    		// 0x0130 (0x0004) [0x0000000000000000]              
	struct FName                                       OldAimProfileName;                                		// 0x0134 (0x0008) [0x0000000000000000]              
	struct FVector2D                                   PreBlendAim;                                      		// 0x013C (0x0008) [0x0000000000000000]              
	float                                              LeanWeight;                                       		// 0x0144 (0x0004) [0x0000000000000000]              
	float                                              LeanWeightTarget;                                 		// 0x0148 (0x0004) [0x0000000000000000]              
	float                                              BlendTimeToGo;                                    		// 0x014C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1675 );

		return pClassPointer;
	};

	void SetLeanWeight ( float WeightTarget, float BlendTime );
};

UClass* UTgAnimNodeJumpLeanOffset::pClassPointer = NULL;

// Class TgGame.TgAnimNodeSequence_ZhongKui_Exorcism
// 0x0000 (0x015C - 0x015C)
class UTgAnimNodeSequence_ZhongKui_Exorcism : public UTgAnimNodeSequence
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1676 );

		return pClassPointer;
	};

};

UClass* UTgAnimNodeSequence_ZhongKui_Exorcism::pClassPointer = NULL;

// Class TgGame.TgAnimNodeSimpleTransitioner
// 0x0020 (0x0118 - 0x00F8)
class UTgAnimNodeSimpleTransitioner : public UAnimNodeBlendList
{
public:
	int                                                m_nDeviceId;                                      		// 0x00F8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_bConfigureBasedOnDevice : 1;                    		// 0x00FC (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_bIgnoreFireMode : 1;                            		// 0x00FC (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	int                                                m_nNumberOfStances;                               		// 0x0100 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_StanceBaseName;                                 		// 0x0104 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_TransitionBaseName;                             		// 0x010C (0x0008) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_BlendTransitionDuration;                        		// 0x0114 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1677 );

		return pClassPointer;
	};

	bool Fire ( int nMode );
	bool SetStance ( int nStance, unsigned long bNoBlend );
	void ReplayAnim ( );
	void PlayAnim ( unsigned long bLoop, float InRate, float StartTime );
};

UClass* UTgAnimNodeSimpleTransitioner::pClassPointer = NULL;

// Class TgGame.TgAnimNodeSlot
// 0x0030 (0x012C - 0x00FC)
class UTgAnimNodeSlot : public UAnimNodeSlot
{
public:
	class ATgPawn*                                     m_TgPawn;                                         		// 0x00FC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned long                                      m_bBlendOutIfVelocityIsGreaterThanZero : 1;       		// 0x0100 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	unsigned long                                      m_bIsTransitionAnim : 1;                          		// 0x0100 (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	unsigned long                                      m_bNotifyActorOnChildAnimEnd : 1;                 		// 0x0100 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	struct FName                                       m_nmHackingTransitionAnimName;                    		// 0x0104 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_nmHackingLoopingAnimName;                       		// 0x010C (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_nmAFKTransitionAnimName;                        		// 0x0114 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_nmAFKLoopingAnimName;                           		// 0x011C (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_nmQueuedAnim;                                   		// 0x0124 (0x0008) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1678 );

		return pClassPointer;
	};

	void StopCustomAnim ( float BlendOutTime );
	void StopHacking ( );
	void PlayHacking ( );
	void StopAFK ( );
	void PlayAFK ( );
	float PlayLoopingCustomAnimWithTransition ( struct FName TransitionAnimName, struct FName LoopingAnimName, float Rate, float BlendInTime, float BlendOutTime );
};

UClass* UTgAnimNodeSlot::pClassPointer = NULL;

// Class TgGame.TgAnimNodeStance
// 0x0004 (0x00FC - 0x00F8)
class UTgAnimNodeStance : public UAnimNodeBlendList
{
public:
	int                                                m_Stance;                                         		// 0x00F8 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1679 );

		return pClassPointer;
	};

};

UClass* UTgAnimNodeStance::pClassPointer = NULL;

// Class TgGame.TgAnimNodeStanceTransition
// 0x0008 (0x0100 - 0x00F8)
class UTgAnimNodeStanceTransition : public UAnimNodeBlendList
{
public:
	int                                                m_SourceStance;                                   		// 0x00F8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_DestinationStance;                              		// 0x00FC (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1680 );

		return pClassPointer;
	};

};

UClass* UTgAnimNodeStanceTransition::pClassPointer = NULL;

// Class TgGame.TgAnimNodeStanceTransitioner
// 0x0028 (0x0120 - 0x00F8)
class UTgAnimNodeStanceTransitioner : public UAnimNodeBlendList
{
public:
	int                                                m_DefaultStance;                                  		// 0x00F8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_CurrentStance;                                  		// 0x00FC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_bIsPlayingTransition : 1;                       		// 0x0100 (0x0004) [0x0000000000000000] [0x00000001] 
	float                                              m_BlendTransitionDuration;                        		// 0x0104 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	TArray< struct FCachedTgAnimNodeStanceInfo >       m_StanceNodeInfos;                                		// 0x0108 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< struct FCachedTgAnimNodeStanceTransitionInfo > m_TransitionNodeInfos;                            		// 0x0114 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1681 );

		return pClassPointer;
	};

	bool BlendToStance ( int DestinationStance );
	bool TransitionToStance ( int DestinationStance );
	void GetTransitionableStances ( int SourceStance, TArray< int >* DestinationStances );
	bool SetStance ( int Stance );
	void ReplayAnim ( );
	void PlayAnim ( unsigned long bLoop, float InRate, float StartTime );
	void eventGetStances ( TArray< int >* Stances );
	int eventGetCurrentStance ( );
};

UClass* UTgAnimNodeStanceTransitioner::pClassPointer = NULL;

// Class TgGame.TgAnimNodeTiltTowardsVelocity
// 0x001F (0x00F8 - 0x00D9)
class UTgAnimNodeTiltTowardsVelocity : public UAnimNodeBlendBase
{
public:
	struct FVector2D                                   m_MaximumVelocity;                                		// 0x00DC (0x0008) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_PitchOffset;                                    		// 0x00E4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_MaximumPitchOffset;                             		// 0x00E8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_RollOffset;                                     		// 0x00EC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_MaximumRollOffset;                              		// 0x00F0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class ATgPawn*                                     m_Pawn;                                           		// 0x00F4 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1682 );

		return pClassPointer;
	};

};

UClass* UTgAnimNodeTiltTowardsVelocity::pClassPointer = NULL;

// Class TgGame.TgAnimNotify_ApplyRigidBodyPhysics
// 0x0023 (0x0064 - 0x0041)
class UTgAnimNotify_ApplyRigidBodyPhysics : public UAnimNotify
{
public:
	unsigned long                                      ShouldAttachToBone : 1;                           		// 0x0044 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	struct FName                                       BoneName;                                         		// 0x0048 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FVector                                     ImpulseLocation;                                  		// 0x0050 (0x000C) [0x0000000000000001]              ( CPF_Edit )
	float                                              ImpulseRadius;                                    		// 0x005C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              ImpulseStrength;                                  		// 0x0060 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1683 );

		return pClassPointer;
	};

};

UClass* UTgAnimNotify_ApplyRigidBodyPhysics::pClassPointer = NULL;

// Class TgGame.TgAnimNotify_AudioGroup
// 0x0010 (0x0051 - 0x0041)
class UTgAnimNotify_AudioGroup : public UAnimNotify
{
public:
	class USoundCue*                                   c_PreviewSound;                                   		// 0x0044 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       c_SoundCueName;                                   		// 0x0048 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      c_eMeshSource;                                    		// 0x0050 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1684 );

		return pClassPointer;
	};

};

UClass* UTgAnimNotify_AudioGroup::pClassPointer = NULL;

// Class TgGame.TgAnimNotify_InterpolateMorphTargetWeight
// 0x001B (0x005C - 0x0041)
class UTgAnimNotify_InterpolateMorphTargetWeight : public UAnimNotify
{
public:
	struct FName                                       MorphNodePoseName;                                		// 0x0044 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	float                                              MorphTargetWeight;                                		// 0x004C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      OnInterruptBehavior;                              		// 0x0050 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	float                                              InterruptMorphTargetWeight;                       		// 0x0054 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              InitialMorphTargetWeight;                         		// 0x0058 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1685 );

		return pClassPointer;
	};

	void eventOnAnimNodeSequenceCeaseRelevant ( class UAnimNodeSequence* OwningNode );
};

UClass* UTgAnimNotify_InterpolateMorphTargetWeight::pClassPointer = NULL;

// Class TgGame.TgAnimNotify_PlayParticleEffect_Skinned
// 0x0010 (0x007C - 0x006C)
class UTgAnimNotify_PlayParticleEffect_Skinned : public UAnimNotify_PlayParticleEffect
{
public:
	TArray< struct FPPE_Skin >                         m_SkinOverrideList;                               		// 0x006C (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	unsigned long                                      m_bApplyTeamColor : 1;                            		// 0x0078 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1686 );

		return pClassPointer;
	};

	struct FParticleChannelContainer GetParticleChannels ( class USkeletalMeshComponent* skel );
	class UParticleSystem* GetParticleSystemToPlay ( class USkeletalMeshComponent* skel );
};

UClass* UTgAnimNotify_PlayParticleEffect_Skinned::pClassPointer = NULL;

// Class TgGame.TgAnimNotify_PlayParticleEffect_NuWaBasicAttack
// 0x0020 (0x009C - 0x007C)
class UTgAnimNotify_PlayParticleEffect_NuWaBasicAttack : public UTgAnimNotify_PlayParticleEffect_Skinned
{
public:
	class UParticleSystem*                             m_DefaultAOETemplate;                             		// 0x007C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	TArray< struct FPPE_Skin >                         m_AOESkinOverrideList;                            		// 0x0080 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	class UParticleSystem*                             m_DefaultSnakeTemplate;                           		// 0x008C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	TArray< struct FPPE_Skin >                         m_SnakeSkinOverrideList;                          		// 0x0090 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1687 );

		return pClassPointer;
	};

	class UParticleSystem* GetParticleSystemToPlay ( class USkeletalMeshComponent* skel );
};

UClass* UTgAnimNotify_PlayParticleEffect_NuWaBasicAttack::pClassPointer = NULL;

// Class TgGame.TgAnimNotify_PlayPetAnim
// 0x000B (0x004C - 0x0041)
class UTgAnimNotify_PlayPetAnim : public UAnimNotify
{
public:
	struct FName                                       m_ChildSeqName;                                   		// 0x0044 (0x0008) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1688 );

		return pClassPointer;
	};

};

UClass* UTgAnimNotify_PlayPetAnim::pClassPointer = NULL;

// Class TgGame.TgAnimNotify_Sound
// 0x000C (0x006C - 0x0060)
class UTgAnimNotify_Sound : public UAnimNotify_Sound
{
public:
	TArray< struct FPSE_Skin >                         m_SkinOverrideList;                               		// 0x0060 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1689 );

		return pClassPointer;
	};

	class USoundCue* GetSoundCueToPlay ( class USkeletalMeshComponent* skel );
};

UClass* UTgAnimNotify_Sound::pClassPointer = NULL;

// Class TgGame.TgAnimNotify_Sound_NikeUltSounds
// 0x0018 (0x0084 - 0x006C)
class UTgAnimNotify_Sound_NikeUltSounds : public UTgAnimNotify_Sound
{
public:
	TArray< struct FPSE_Skin_Nike >                    m_NikeSkinOverrideList;                           		// 0x006C (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< class USoundCue* >                         m_NikeSoundCues;                                  		// 0x0078 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1690 );

		return pClassPointer;
	};

	class USoundCue* GetSoundCueToPlay ( class USkeletalMeshComponent* skel );
};

UClass* UTgAnimNotify_Sound_NikeUltSounds::pClassPointer = NULL;

// Class TgGame.TgAnimNotify_ToggleInvisibleWall
// 0x003B (0x007C - 0x0041)
class UTgAnimNotify_ToggleInvisibleWall : public UAnimNotify
{
public:
	unsigned long                                      TurnWallOn : 1;                                   		// 0x0044 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      TurnOffOnCeaseRelevant : 1;                       		// 0x0044 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	int                                                WallIndex;                                        		// 0x0048 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FVector                                     WallPosition;                                     		// 0x004C (0x000C) [0x0000000000000001]              ( CPF_Edit )
	struct FVector                                     WallNormal;                                       		// 0x0058 (0x000C) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       WallEnableBaseName;                               		// 0x0064 (0x0008) [0x0000000000000002]              ( CPF_Const )
	struct FName                                       WallPositionBaseName;                             		// 0x006C (0x0008) [0x0000000000000002]              ( CPF_Const )
	struct FName                                       WallNormalBaseName;                               		// 0x0074 (0x0008) [0x0000000000000002]              ( CPF_Const )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1691 );

		return pClassPointer;
	};

	void eventOnAnimNodeSequenceCeaseRelevant ( class UAnimNodeSequence* OwningNode );
};

UClass* UTgAnimNotify_ToggleInvisibleWall::pClassPointer = NULL;

// Class TgGame.TgAnimNotify_ToggleRigidBodies
// 0x0010 (0x0051 - 0x0041)
class UTgAnimNotify_ToggleRigidBodies : public UAnimNotify
{
public:
	TArray< struct FName >                             BoneNames;                                        		// 0x0044 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	unsigned char                                      Effect;                                           		// 0x0050 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1692 );

		return pClassPointer;
	};

	void eventOnAnimNodeSequenceBecomeRelevant ( class UAnimNodeSequence* OwningNode );
	void eventOnAnimNodeSequenceCeaseRelevant ( class UAnimNodeSequence* OwningNode );
};

UClass* UTgAnimNotify_ToggleRigidBodies::pClassPointer = NULL;

// Class TgGame.TgAnimNotify_ToggleSocketSpecialFX
// 0x0013 (0x0054 - 0x0041)
class UTgAnimNotify_ToggleSocketSpecialFX : public UAnimNotify
{
public:
	struct FName                                       m_DisplayGroupName;                               		// 0x0044 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_EquipSlot;                                      		// 0x004C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_bActivateFxGroup : 1;                           		// 0x0050 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1693 );

		return pClassPointer;
	};

};

UClass* UTgAnimNotify_ToggleSocketSpecialFX::pClassPointer = NULL;

// Class TgGame.TgAnimNotify_ViewShake
// 0x000C (0x00A0 - 0x0094)
class UTgAnimNotify_ViewShake : public UAnimNotify_ViewShake
{
public:
	float                                              m_fShakeRadius;                                   		// 0x0094 (0x0004) [0x0000000000020000]              ( CPF_EditConst )
	float                                              m_fDuration;                                      		// 0x0098 (0x0004) [0x0000000000020000]              ( CPF_EditConst )
	float                                              m_fAmplitude;                                     		// 0x009C (0x0004) [0x0000000000020000]              ( CPF_EditConst )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1694 );

		return pClassPointer;
	};

};

UClass* UTgAnimNotify_ViewShake::pClassPointer = NULL;

// Class TgGame.TgAnimNotifySkinData
// 0x001C (0x0058 - 0x003C)
class UTgAnimNotifySkinData : public UObject
{
public:
	struct FString                                     OwningNotify;                                     		// 0x003C (0x000C) [0x0000000000500000]              ( CPF_NeedCtorLink )
	class USoundCue*                                   SoundCueTemplate;                                 		// 0x0048 (0x0004) [0x0000000000000000]              
	class UParticleSystem*                             ParticleSystemTemplate;                           		// 0x004C (0x0004) [0x0000000000000000]              
	int                                                nSkinId;                                          		// 0x0050 (0x0004) [0x0000000000000000]              
	int                                                nSkinLevel;                                       		// 0x0054 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1695 );

		return pClassPointer;
	};

};

UClass* UTgAnimNotifySkinData::pClassPointer = NULL;

// Class TgGame.TgAnimTurnInPlace
// 0x0078 (0x0164 - 0x00EC)
class UTgAnimTurnInPlace : public UAnimNodeBlend
{
public:
	unsigned long                                      bInitialized : 1;                                 		// 0x00EC (0x0004) [0x0000000000002002] [0x00000001] ( CPF_Const | CPF_Transient )
	unsigned long                                      bRootRotInitialized : 1;                          		// 0x00EC (0x0004) [0x0000000000002002] [0x00000002] ( CPF_Const | CPF_Transient )
	unsigned long                                      m_bDisableRotation : 1;                           		// 0x00EC (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      bDelayBlendOutToPlayAnim : 1;                     		// 0x00EC (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )
	unsigned long                                      bPlayingTurnTransition : 1;                       		// 0x00EC (0x0004) [0x0000000000000002] [0x00000010] ( CPF_Const )
	unsigned long                                      m_bCanChooseNewTransition : 1;                    		// 0x00EC (0x0004) [0x0000000000000001] [0x00000020] ( CPF_Edit )
	unsigned long                                      m_bOverrideInterpolationTime : 1;                 		// 0x00EC (0x0004) [0x0000000000000001] [0x00000040] ( CPF_Edit )
	unsigned long                                      m_bMirrorOffsetWhenPawnMirrored : 1;              		// 0x00EC (0x0004) [0x0000000000000001] [0x00000080] ( CPF_Edit )
	unsigned long                                      m_bAlwaysUpdateYawOffset : 1;                     		// 0x00EC (0x0004) [0x0000000000000001] [0x00000100] ( CPF_Edit )
	unsigned long                                      m_bIgnoreTransitionAnimations : 1;                		// 0x00EC (0x0004) [0x0000000000000001] [0x00000200] ( CPF_Edit )
	unsigned long                                      m_bOnlyUpdateRotationWhenMoving : 1;              		// 0x00EC (0x0004) [0x0000000000000001] [0x00000400] ( CPF_Edit )
	unsigned long                                      m_bTurnTowardsVelocity : 1;                       		// 0x00EC (0x0004) [0x0000000000000001] [0x00000800] ( CPF_Edit )
	unsigned long                                      m_bUsePawnRotationAtZeroVelocity : 1;             		// 0x00EC (0x0004) [0x0000000000000001] [0x00001000] ( CPF_Edit )
	unsigned long                                      m_bUse180ShortestRoute : 1;                       		// 0x00EC (0x0004) [0x0000000000000001] [0x00002000] ( CPF_Edit )
	unsigned long                                      m_bConstrictIdleYawOffset : 1;                    		// 0x00EC (0x0004) [0x0000000000000001] [0x00004000] ( CPF_Edit )
	unsigned long                                      m_bDisableAllTurning : 1;                         		// 0x00EC (0x0004) [0x0000000000000001] [0x00008000] ( CPF_Edit )
	unsigned long                                      m_bJustBecameRelevant : 1;                        		// 0x00EC (0x0004) [0x0000000000000000] [0x00010000] 
	int                                                LastPawnYaw;                                      		// 0x00F0 (0x0004) [0x0000000000002002]              ( CPF_Const | CPF_Transient )
	int                                                LastPawnPitch;                                    		// 0x00F4 (0x0004) [0x0000000000002002]              ( CPF_Const | CPF_Transient )
	float                                              PawnRotationRate;                                 		// 0x00F8 (0x0004) [0x0000000000002002]              ( CPF_Const | CPF_Transient )
	int                                                LastRootBoneYaw;                                  		// 0x00FC (0x0004) [0x0000000000002002]              ( CPF_Const | CPF_Transient )
	int                                                YawOffset;                                        		// 0x0100 (0x0004) [0x0000000000002003]              ( CPF_Edit | CPF_Const | CPF_Transient )
	int                                                PitchOffset;                                      		// 0x0104 (0x0004) [0x0000000000002003]              ( CPF_Edit | CPF_Const | CPF_Transient )
	float                                              RelativeOffset;                                   		// 0x0108 (0x0004) [0x0000000000002002]              ( CPF_Const | CPF_Transient )
	class ATgPawn*                                     m_TgPawn;                                         		// 0x010C (0x0004) [0x0000000000002002]              ( CPF_Const | CPF_Transient )
	TArray< class UTgAnimNodeAimOffset* >              OffsetNodes2;                                     		// 0x0110 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< struct FRotTransitionInfo >                RotTransitions;                                   		// 0x011C (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	float                                              TransitionBlendTime;                              		// 0x0128 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                CurrentTransitionIndex;                           		// 0x012C (0x0004) [0x0000000000000002]              ( CPF_Const )
	float                                              TransitionThresholdAngle;                         		// 0x0130 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_ForcedTransitionAngle;                          		// 0x0134 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fChooseNewTransitionPercent;                    		// 0x0138 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fInterpolationTime;                             		// 0x013C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_RemainingInterpolationTime;                     		// 0x0140 (0x0004) [0x0000000000000000]              
	TArray< class UTgAnimTurnInPlace_Player* >         PlayerNodes;                                      		// 0x0144 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	float                                              m_fIgnoredTransitionTime;                         		// 0x0150 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fTurnInterpTime;                                		// 0x0154 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FRotator                                    m_InterpRotation;                                 		// 0x0158 (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1696 );

		return pClassPointer;
	};

	void OverrideYawOffset ( float Value );
};

UClass* UTgAnimTurnInPlace::pClassPointer = NULL;

// Class TgGame.TgAnimTurnInPlace_Player
// 0x000C (0x0160 - 0x0154)
class UTgAnimTurnInPlace_Player : public UAnimNodeSequence
{
public:
	TArray< struct FTIP_Transition >                   TIP_Transitions;                                  		// 0x0154 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1697 );

		return pClassPointer;
	};

};

UClass* UTgAnimTurnInPlace_Player::pClassPointer = NULL;

// Class TgGame.TgAnimTurnInPlace_Rotator
// 0x0013 (0x00EC - 0x00D9)
class UTgAnimTurnInPlace_Rotator : public UAnimNodeBlendBase
{
public:
	TArray< class UTgAnimTurnInPlace* >                c_TurnInPlaceNodes;                               		// 0x00DC (0x000C) [0x0000000000400002]              ( CPF_Const | CPF_NeedCtorLink )
	class ATgPawn*                                     m_TgPawn;                                         		// 0x00E8 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1698 );

		return pClassPointer;
	};

};

UClass* UTgAnimTurnInPlace_Rotator::pClassPointer = NULL;

// Class TgGame.TgMorphNode_ZhongKui_DemonBag
// 0x001C (0x0078 - 0x005C)
class UTgMorphNode_ZhongKui_DemonBag : public UMorphNodePose
{
public:
	struct FInterpCurveFloat                           MorphWeightCurve;                                 		// 0x005C (0x0010) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	unsigned long                                      bPlaying : 1;                                     		// 0x006C (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      bLooping : 1;                                     		// 0x006C (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      bDoNotResetIfPlaying : 1;                         		// 0x006C (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	float                                              CurrentTime;                                      		// 0x0070 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              Rate;                                             		// 0x0074 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1699 );

		return pClassPointer;
	};

	void StopMorph ( );
	void ReplayMorph ( );
	void PlayMorph ( unsigned long bLoop, float InRate, float StartTime );
};

UClass* UTgMorphNode_ZhongKui_DemonBag::pClassPointer = NULL;

// Class TgGame.TgSkelCon_Ares_ChainTether
// 0x0000 (0x00E4 - 0x00E4)
class UTgSkelCon_Ares_ChainTether : public USkelControl_CCD_IK
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1700 );

		return pClassPointer;
	};

};

UClass* UTgSkelCon_Ares_ChainTether::pClassPointer = NULL;

// Class TgGame.TgSkelCon_BakasuraHead
// 0x0004 (0x00D0 - 0x00CC)
class UTgSkelCon_BakasuraHead : public USkelControlSingleBone
{
public:
	class ATgPawn_BakasuraV1*                          m_OwningPawn;                                     		// 0x00CC (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1701 );

		return pClassPointer;
	};

};

UClass* UTgSkelCon_BakasuraHead::pClassPointer = NULL;

// Class TgGame.TgSkelCon_CCD_IK_FootPlacement
// 0x0060 (0x00FC - 0x009C)
class UTgSkelCon_CCD_IK_FootPlacement : public USkelControlBase
{
public:
	int                                                NumBones;                                         		// 0x009C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                MaxPerBoneIterations;                             		// 0x00A0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                IterationsCount;                                  		// 0x00A4 (0x0004) [0x0000000000000002]              ( CPF_Const )
	float                                              Precision;                                        		// 0x00A8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      bStartFromTail : 1;                               		// 0x00AC (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      bNoTurnOptimization : 1;                          		// 0x00AC (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      bAllowStretching : 1;                             		// 0x00AC (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      bInvertFootUpAxis : 1;                            		// 0x00AC (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )
	unsigned long                                      bOrientFootToGround : 1;                          		// 0x00AC (0x0004) [0x0000000000000001] [0x00000010] ( CPF_Edit )
	unsigned long                                      bOnlyEnableForUpAdjustment : 1;                   		// 0x00AC (0x0004) [0x0000000000000001] [0x00000020] ( CPF_Edit )
	unsigned long                                      m_bUseCachedFootOffset : 1;                       		// 0x00AC (0x0004) [0x0000000000000000] [0x00000040] 
	TArray< struct FJointConstraintInformation >       JointConstraints;                                 		// 0x00B0 (0x000C) [0x0000000000400003]              ( CPF_Edit | CPF_Const | CPF_NeedCtorLink )
	float                                              MaxAngleSteps;                                    		// 0x00BC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              MaxStretchSteps;                                  		// 0x00C0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              FootOffset;                                       		// 0x00C4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      FootUpAxis;                                       		// 0x00C8 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	struct FRotator                                    FootRotOffset;                                    		// 0x00CC (0x000C) [0x0000000000000001]              ( CPF_Edit )
	float                                              MaxUpAdjustment;                                  		// 0x00D8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              MaxDownAdjustment;                                		// 0x00DC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              MaxFootOrientAdjust;                              		// 0x00E0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FVector                                     EffectorLocation;                                 		// 0x00E4 (0x000C) [0x0000000000000000]              
	struct FVector                                     m_vCachedFootOffset;                              		// 0x00F0 (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1702 );

		return pClassPointer;
	};

};

UClass* UTgSkelCon_CCD_IK_FootPlacement::pClassPointer = NULL;

// Class TgGame.TgSkelCon_CCD_IK_TargetLocation
// 0x0014 (0x00F8 - 0x00E4)
class UTgSkelCon_CCD_IK_TargetLocation : public USkelControl_CCD_IK
{
public:
	unsigned long                                      bAimAtFeet : 1;                                   		// 0x00E4 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_bHadTargetLastTick : 1;                         		// 0x00E4 (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	float                                              fInterpSpeed;                                     		// 0x00E8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              fEnableInterpSpeed;                               		// 0x00EC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class ATgPawn*                                     m_Owner;                                          		// 0x00F0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              fEnabledAlpha;                                    		// 0x00F4 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1703 );

		return pClassPointer;
	};

};

UClass* UTgSkelCon_CCD_IK_TargetLocation::pClassPointer = NULL;

// Class TgGame.TgSkelCon_ClockworkSpinner
// 0x0044 (0x0110 - 0x00CC)
class UTgSkelCon_ClockworkSpinner : public USkelControlSingleBone
{
public:
	float                                              m_fInterpTime;                                    		// 0x00CC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fRemainingInterpTime;                           		// 0x00D0 (0x0004) [0x0000000000000000]              
	float                                              m_fPauseTime;                                     		// 0x00D4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fRemainingPauseTime;                            		// 0x00D8 (0x0004) [0x0000000000000000]              
	unsigned char                                      RotationAxis;                                     		// 0x00DC (0x0001) [0x0000000000000001]              ( CPF_Edit )
	int                                                DeltaRotation;                                    		// 0x00E0 (0x0004) [0x0000000000000000]              
	float                                              m_fInterpRotation;                                		// 0x00E4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      bLimitedRotation : 1;                             		// 0x00E8 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      bForward : 1;                                     		// 0x00E8 (0x0004) [0x0000000000000000] [0x00000002] 
	float                                              m_fRotationMin;                                   		// 0x00EC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fRotationMax;                                   		// 0x00F0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fResetInterpTime;                               		// 0x00F4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fResetPauseTime;                                		// 0x00F8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fResetRotation;                                 		// 0x00FC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fRotatorMin;                                    		// 0x0100 (0x0004) [0x0000000000000000]              
	float                                              m_fRotatorMax;                                    		// 0x0104 (0x0004) [0x0000000000000000]              
	float                                              RotationsPerSecond;                               		// 0x0108 (0x0004) [0x0000000000000000]              
	float                                              ResetRotationsPerSecond;                          		// 0x010C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1704 );

		return pClassPointer;
	};

};

UClass* UTgSkelCon_ClockworkSpinner::pClassPointer = NULL;

// Class TgGame.TgSkelCon_Cupid_HeartMineField
// 0x0004 (0x00D0 - 0x00CC)
class UTgSkelCon_Cupid_HeartMineField : public USkelControlSingleBone
{
public:
	class ATgDeployable_Cupid_HeartMineField*          m_OwningDeployable;                               		// 0x00CC (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1705 );

		return pClassPointer;
	};

};

UClass* UTgSkelCon_Cupid_HeartMineField::pClassPointer = NULL;

// Class TgGame.TgSkelCon_FootPlacement
// 0x0004 (0x0128 - 0x0124)
class UTgSkelCon_FootPlacement : public USkelControlFootPlacement
{
public:
	unsigned long                                      bShouldUseWorldDown : 1;                          		// 0x0124 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1706 );

		return pClassPointer;
	};

};

UClass* UTgSkelCon_FootPlacement::pClassPointer = NULL;

// Class TgGame.TgSkelCon_HitReaction
// 0x03A0 (0x04D4 - 0x0134)
class UTgSkelCon_HitReaction : public UGameSkelCtrl_Recoil
{
public:
	unsigned char                                      m_CurrentRecoilDir;                               		// 0x0134 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_MoveType;                                       		// 0x0135 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	struct FRecoilInfo                                 m_RecoilFromFront;                                		// 0x0138 (0x00E0) [0x0000000000000001]              ( CPF_Edit )
	struct FRecoilInfo                                 m_RecoilFromBack;                                 		// 0x0218 (0x00E0) [0x0000000000000001]              ( CPF_Edit )
	struct FRecoilInfo                                 m_RecoilFromLeft;                                 		// 0x02F8 (0x00E0) [0x0000000000000001]              ( CPF_Edit )
	struct FRecoilInfo                                 m_RecoilFromRight;                                		// 0x03D8 (0x00E0) [0x0000000000000001]              ( CPF_Edit )
	TArray< struct FName >                             m_SlaveSkelControlNames;                          		// 0x04B8 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< class USkelControlBase* >                  m_SlaveSkelControls;                              		// 0x04C4 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	unsigned long                                      m_bInitialized : 1;                               		// 0x04D0 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1707 );

		return pClassPointer;
	};

	struct FRecoilDef GenRecoil ( struct FRecoilInfo RecoilParam );
	struct FVector VRandRange ( struct FVector v1, struct FVector v2 );
	void eventSetRecoilParam ( );
	void SetRecoilDir ( unsigned char NewDir );
};

UClass* UTgSkelCon_HitReaction::pClassPointer = NULL;

// Class TgGame.TgSkelCon_LookAt
// 0x0008 (0x0140 - 0x0138)
class UTgSkelCon_LookAt : public USkelControlLookAt
{
public:
	class ATgPawn*                                     m_Owner;                                          		// 0x0138 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bAimAtEnemyTarget : 1;                          		// 0x013C (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_AlwaysInterpolateTarget : 1;                    		// 0x013C (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_bAimAtOwner : 1;                                		// 0x013C (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      m_bHadTargetLastTick : 1;                         		// 0x013C (0x0004) [0x0000000000000000] [0x00000008] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1708 );

		return pClassPointer;
	};

};

UClass* UTgSkelCon_LookAt::pClassPointer = NULL;

// Class TgGame.TgSkelCon_OscillateBoneScale
// 0x0010 (0x00DC - 0x00CC)
class UTgSkelCon_OscillateBoneScale : public USkelControlSingleBone
{
public:
	float                                              OscillationAmplitude;                             		// 0x00CC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              OscillationFrequency;                             		// 0x00D0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              OscillationBaseScale;                             		// 0x00D4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              Theta;                                            		// 0x00D8 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1709 );

		return pClassPointer;
	};

};

UClass* UTgSkelCon_OscillateBoneScale::pClassPointer = NULL;

// Class TgGame.TgSkelCon_OscillateRotation
// 0x0024 (0x00F0 - 0x00CC)
class UTgSkelCon_OscillateRotation : public USkelControlSingleBone
{
public:
	float                                              OscillationAmplitude;                             		// 0x00CC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              OscillationFrequency;                             		// 0x00D0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FVector                                     OscillationAxis;                                  		// 0x00D4 (0x000C) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      OscillationAxisSpace;                             		// 0x00E0 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       OscillationAxisSpaceBoneName;                     		// 0x00E4 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	float                                              Theta;                                            		// 0x00EC (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1710 );

		return pClassPointer;
	};

};

UClass* UTgSkelCon_OscillateRotation::pClassPointer = NULL;

// Class TgGame.TgSkelCon_OscillateTranslation
// 0x0024 (0x00F0 - 0x00CC)
class UTgSkelCon_OscillateTranslation : public USkelControlSingleBone
{
public:
	float                                              OscillationAmplitude;                             		// 0x00CC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              OscillationFrequency;                             		// 0x00D0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FVector                                     OscillationAxis;                                  		// 0x00D4 (0x000C) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      OscillationAxisSpace;                             		// 0x00E0 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       OscillationAxisSpaceBoneName;                     		// 0x00E4 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	float                                              Theta;                                            		// 0x00EC (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1711 );

		return pClassPointer;
	};

};

UClass* UTgSkelCon_OscillateTranslation::pClassPointer = NULL;

// Class TgGame.TgSkelCon_Spinner
// 0x000C (0x00D8 - 0x00CC)
class UTgSkelCon_Spinner : public USkelControlSingleBone
{
public:
	unsigned char                                      RotationAxis;                                     		// 0x00CC (0x0001) [0x0000000000000001]              ( CPF_Edit )
	float                                              RotationsPerSecond;                               		// 0x00D0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                DeltaRotation;                                    		// 0x00D4 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1712 );

		return pClassPointer;
	};

};

UClass* UTgSkelCon_Spinner::pClassPointer = NULL;

// Class TgGame.TgSkelCon_Spinner_Skinned
// 0x0014 (0x00EC - 0x00D8)
class UTgSkelCon_Spinner_Skinned : public UTgSkelCon_Spinner
{
public:
	TArray< struct FSkinnedSpinData >                  m_SkinOverrides;                                  		// 0x00D8 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	float                                              fEditorRotationsPerSecond;                        		// 0x00E4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_bInitializedSpin : 1;                           		// 0x00E8 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1713 );

		return pClassPointer;
	};

};

UClass* UTgSkelCon_Spinner_Skinned::pClassPointer = NULL;

// Class TgGame.TgSkelCon_ZhongKui_BagGrowth
// 0x0054 (0x0120 - 0x00CC)
class UTgSkelCon_ZhongKui_BagGrowth : public USkelControlSingleBone
{
public:
	struct FBagGrowthDef                               m_BagGrowth;                                      		// 0x00CC (0x0030) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_NumDemonsInBag;                                 		// 0x00FC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_fUnclampedScale;                                		// 0x0100 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_fScaleVelocity;                                 		// 0x0104 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_fDesiredScale;                                  		// 0x0108 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_fNextGrowthImpulse;                             		// 0x010C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_fNextShrinkImpulse;                             		// 0x0110 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned long                                      m_bResetImpulseTimerActive : 1;                   		// 0x0114 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	unsigned long                                      m_bInitialized : 1;                               		// 0x0114 (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	float                                              m_fTimeUntilResetImpulse;                         		// 0x0118 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_fResetImpulseTime;                              		// 0x011C (0x0004) [0x0000000000000002]              ( CPF_Const )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1714 );

		return pClassPointer;
	};

	void ShrinkBag ( int NumDemons );
	void GrowBag ( int NumDemons );
	void SetBagGrowthDef ( struct FBagGrowthDef BagGrowth );
};

UClass* UTgSkelCon_ZhongKui_BagGrowth::pClassPointer = NULL;

// Class TgGame.TgSkelControlSingleBone
// 0x0018 (0x00E4 - 0x00CC)
class UTgSkelControlSingleBone : public USkelControlSingleBone
{
public:
	TArray< unsigned char >                            StrengthEmoteList;                                		// 0x00CC (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< class UTgAnimNodeEmoteSequence* >          CachedEmoteSequences;                             		// 0x00D8 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1715 );

		return pClassPointer;
	};

};

UClass* UTgSkelControlSingleBone::pClassPointer = NULL;

// Class TgGame.TgSkelControlSingleBone_DisplayGroup
// 0x000C (0x00F0 - 0x00E4)
class UTgSkelControlSingleBone_DisplayGroup : public UTgSkelControlSingleBone
{
public:
	TArray< struct FDisplayGroupInfo >                 DisplayGroupInfos;                                		// 0x00E4 (0x000C) [0x0000000004400009]              ( CPF_Edit | CPF_ExportObject | CPF_NeedCtorLink | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1716 );

		return pClassPointer;
	};

};

UClass* UTgSkelControlSingleBone_DisplayGroup::pClassPointer = NULL;

// Class TgGame.TgSkelControlSingleBone_ScalarMICParam
// 0x000C (0x00F0 - 0x00E4)
class UTgSkelControlSingleBone_ScalarMICParam : public UTgSkelControlSingleBone
{
public:
	TArray< struct FScalarMICParamInfo >               ScalarMICParamInfos;                              		// 0x00E4 (0x000C) [0x0000000004400009]              ( CPF_Edit | CPF_ExportObject | CPF_NeedCtorLink | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1717 );

		return pClassPointer;
	};

};

UClass* UTgSkelControlSingleBone_ScalarMICParam::pClassPointer = NULL;

// Class TgGame.TgSkelControlSingleBone_Skinned
// 0x0018 (0x00FC - 0x00E4)
class UTgSkelControlSingleBone_Skinned : public UTgSkelControlSingleBone
{
public:
	float                                              DefaultStrength;                                  		// 0x00E4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	TArray< struct FSkinStrengthOverride >             SkinOverrides;                                    		// 0x00E8 (0x000C) [0x0000000004400009]              ( CPF_Edit | CPF_ExportObject | CPF_NeedCtorLink | CPF_EditInline )
	unsigned long                                      bInitializedStrength : 1;                         		// 0x00F4 (0x0004) [0x0000000000000000] [0x00000001] 
	float                                              fSkinStrength;                                    		// 0x00F8 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1718 );

		return pClassPointer;
	};

};

UClass* UTgSkelControlSingleBone_Skinned::pClassPointer = NULL;

// Class TgGame.TgCharmComponent_Serqet
// 0x0033 (0x0088 - 0x0055)
class UTgCharmComponent_Serqet : public UActorComponent
{
public:
	class UTgDeviceFire*                               m_DeviceModeMelee;                                		// 0x0058 (0x0004) [0x0000000000000000]              
	class UTgDeviceFire*                               m_DeviceModeProjectile;                           		// 0x005C (0x0004) [0x0000000000000000]              
	class ATgPawn*                                     m_Instigator;                                     		// 0x0060 (0x0004) [0x0000000000000000]              
	class ATgPawn*                                     m_PawnOwner;                                      		// 0x0064 (0x0004) [0x0000000000000000]              
	class ATgDevice*                                   m_SimulatedDevice;                                		// 0x0068 (0x0004) [0x0000000000000000]              
	float                                              m_fAttackSpeed;                                   		// 0x006C (0x0004) [0x0000000000000000]              
	TArray< struct FFireChainInfo >                    m_CachedFireChainInfos;                           		// 0x0070 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	unsigned char                                      m_eCurrentFiringState;                            		// 0x007C (0x0001) [0x0000000000000000]              
	int                                                m_nCurrentFiringChain;                            		// 0x0080 (0x0004) [0x0000000000000000]              
	float                                              m_fFiringTimer;                                   		// 0x0084 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1719 );

		return pClassPointer;
	};

};

UClass* UTgCharmComponent_Serqet::pClassPointer = NULL;

// Class TgGame.TgDevice
// 0x0140 (0x0380 - 0x0240)
class ATgDevice : public AWeapon
{
public:
	int                                                r_nDeviceId;                                      		// 0x0240 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nDeviceInstanceId;                              		// 0x0244 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nInstanceCount;                                 		// 0x0248 (0x0004) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      r_eEquippedAt;                                    		// 0x024C (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      CurrentFireMode;                                  		// 0x024D (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      m_PendingFireMode;                                		// 0x024E (0x0001) [0x0000000000000000]              
	unsigned char                                      c_eTargetingModeStatus;                           		// 0x024F (0x0001) [0x0000000000000000]              
	unsigned char                                      m_eCachedDeviceFailType;                          		// 0x0250 (0x0001) [0x0000000000000000]              
	unsigned char                                      s_nCurrentFiringInstance;                         		// 0x0251 (0x0001) [0x0000000000000000]              
	int                                                r_nPointsAllocated;                               		// 0x0254 (0x0004) [0x0000000000000020]              ( CPF_Net )
	unsigned long                                      m_bIsTrained : 1;                                 		// 0x0258 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bSocketMaxCalculated : 1;                       		// 0x0258 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_bReplicateParentDevice : 1;                     		// 0x0258 (0x0004) [0x0000000000000002] [0x00000004] ( CPF_Const )
	unsigned long                                      r_bParentDeviceOwnedByOffhand : 1;                		// 0x0258 (0x0004) [0x0000000000000020] [0x00000008] ( CPF_Net )
	unsigned long                                      bPendingFire : 1;                                 		// 0x0258 (0x0004) [0x0000000000000000] [0x00000010] 
	unsigned long                                      m_IsPendingSetFireMode : 1;                       		// 0x0258 (0x0004) [0x0000000000000000] [0x00000020] 
	unsigned long                                      m_bEquipEffectsApplied : 1;                       		// 0x0258 (0x0004) [0x0000000000000000] [0x00000040] 
	unsigned long                                      r_OverrideUsesTargetingModeAsFalse : 1;           		// 0x0258 (0x0004) [0x0000000000000020] [0x00000080] ( CPF_Net )
	unsigned long                                      m_bOverrideIsToggledAsTrue : 1;                   		// 0x0258 (0x0004) [0x0000000000000000] [0x00000100] 
	unsigned long                                      s_bIgnoreReceivedAim : 1;                         		// 0x0258 (0x0004) [0x0000000000000000] [0x00000200] 
	unsigned long                                      m_bAlignEndTraceWithCamera : 1;                   		// 0x0258 (0x0004) [0x0000000000000002] [0x00000400] ( CPF_Const )
	unsigned long                                      m_bHandDevice : 1;                                		// 0x0258 (0x0004) [0x0000000000000000] [0x00000800] 
	unsigned long                                      m_bLockInputDuringFire : 1;                       		// 0x0258 (0x0004) [0x0000000000000000] [0x00001000] 
	unsigned long                                      m_bLockCameraDuringFire : 1;                      		// 0x0258 (0x0004) [0x0000000000000000] [0x00002000] 
	unsigned long                                      m_bShouldCacheAim : 1;                            		// 0x0258 (0x0004) [0x0000000000000000] [0x00004000] 
	unsigned long                                      m_bEffectsOnlyInHand : 1;                         		// 0x0258 (0x0004) [0x0000000000000000] [0x00008000] 
	unsigned long                                      r_bConsumedOnUse : 1;                             		// 0x0258 (0x0004) [0x0000000000000020] [0x00010000] ( CPF_Net )
	unsigned long                                      r_bConsumedOnDeath : 1;                           		// 0x0258 (0x0004) [0x0000000000000020] [0x00020000] ( CPF_Net )
	unsigned long                                      m_bConsumableContainer : 1;                       		// 0x0258 (0x0004) [0x0000000000000000] [0x00040000] 
	unsigned long                                      c_bCustomLeftClickBehavior : 1;                   		// 0x0258 (0x0004) [0x0000000000000000] [0x00080000] 
	unsigned long                                      c_bCustomLeftClickBehaviorLoaded : 1;             		// 0x0258 (0x0004) [0x0000000000000000] [0x00100000] 
	unsigned long                                      m_bSimulateStartFire : 1;                         		// 0x0258 (0x0004) [0x0000000000000000] [0x00200000] 
	unsigned long                                      m_bInterruptOnMove : 1;                           		// 0x0258 (0x0004) [0x0000000000000000] [0x00400000] 
	unsigned long                                      m_bCachedDeviceCanFire : 1;                       		// 0x0258 (0x0004) [0x0000000000000000] [0x00800000] 
	unsigned long                                      m_bConsumePowerPoolOnStartFire : 1;               		// 0x0258 (0x0004) [0x0000000000000000] [0x01000000] 
	unsigned long                                      m_bAlwaysStartCooldown : 1;                       		// 0x0258 (0x0004) [0x0000000000000000] [0x02000000] 
	unsigned long                                      m_bInTargetingMode : 1;                           		// 0x0258 (0x0004) [0x0000000000000000] [0x04000000] 
	unsigned long                                      m_IsBeingInterrupted : 1;                         		// 0x0258 (0x0004) [0x0000000000000000] [0x08000000] 
	unsigned long                                      HasAlreadyFiredOnce : 1;                          		// 0x0258 (0x0004) [0x0000000000000000] [0x10000000] 
	unsigned long                                      m_bShouldUseInstigatorsTimeDilation : 1;          		// 0x0258 (0x0004) [0x0000000000000000] [0x20000000] 
	unsigned long                                      r_bDeviceUnavailable : 1;                         		// 0x0258 (0x0004) [0x0000000000000020] [0x40000000] ( CPF_Net )
	unsigned long                                      m_bFireInstanceLocksProcs : 1;                    		// 0x0258 (0x0004) [0x0000000000000000] [0x80000000] 
	unsigned long                                      m_bDamages : 1;                                   		// 0x025C (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bStuns : 1;                                     		// 0x025C (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_bSlows : 1;                                     		// 0x025C (0x0004) [0x0000000000000000] [0x00000004] 
	int                                                m_nSocketIndex;                                   		// 0x0260 (0x0004) [0x0000000000000000]              
	int                                                m_nSocketMax;                                     		// 0x0264 (0x0004) [0x0000000000000000]              
	class ATgDevice*                                   r_ParentDevice;                                   		// 0x0268 (0x0004) [0x0000000000000020]              ( CPF_Net )
	TArray< class UTgDeviceFire* >                     m_FireMode;                                       		// 0x026C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                r_nMeleeComboSeed;                                		// 0x0278 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class UTgDeviceForm*                               c_DeviceForm;                                     		// 0x027C (0x0004) [0x0000000000000000]              
	class UTgTimerManager*                             m_CooldownTimers;                                 		// 0x0280 (0x0004) [0x0000000000000000]              
	TArray< struct FImpactInfo >                       PendingImpactList;                                		// 0x0284 (0x000C) [0x0000000000480000]              ( CPF_Component | CPF_NeedCtorLink )
	struct FAimData                                    c_TargetingAim;                                   		// 0x0290 (0x002C) [0x0000000000000000]              
	struct FAimData                                    m_CachedAim;                                      		// 0x02BC (0x002C) [0x0000000000000000]              
	float                                              m_fCachedFirePostHitDelay;                        		// 0x02E8 (0x0004) [0x0000000000000000]              
	struct FAimData                                    s_ReceivedAim;                                    		// 0x02EC (0x002C) [0x0000000000000000]              
	int                                                m_nCalcGroundTargetPlaceFlags;                    		// 0x0318 (0x0004) [0x0000000000000002]              ( CPF_Const )
	float                                              s_fRangeTolerance;                                		// 0x031C (0x0004) [0x0000000000000002]              ( CPF_Const )
	struct FPointer                                    m_pwzDeviceName;                                  		// 0x0320 (0x0004) [0x0000000000001000]              ( CPF_Native )
	int                                                m_nDeviceType;                                    		// 0x0324 (0x0004) [0x0000000000000000]              
	float                                              EquipTime;                                        		// 0x0328 (0x0004) [0x0000000000000000]              
	float                                              PutDownTime;                                      		// 0x032C (0x0004) [0x0000000000000000]              
	float                                              WeaponRange;                                      		// 0x0330 (0x0004) [0x0000000000000000]              
	class UTgInventoryObject_Device*                   s_InventoryObject;                                		// 0x0334 (0x0004) [0x0000000000000000]              
	int                                                m_nSkillId;                                       		// 0x0338 (0x0004) [0x0000000000000000]              
	int                                                m_nContainerRefill;                               		// 0x033C (0x0004) [0x0000000000000000]              
	int                                                m_nRightClickBehaviorType;                        		// 0x0340 (0x0004) [0x0000000000000000]              
	int                                                r_nInventoryId;                                   		// 0x0344 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                m_nRequiredLevel;                                 		// 0x0348 (0x0004) [0x0000000000000000]              
	float                                              m_fLastDeviceCanFireTimeStamp;                    		// 0x034C (0x0004) [0x0000000000000000]              
	struct FVector                                     m_vCachedWeaponStartTraceLocation;                		// 0x0350 (0x000C) [0x0000000000000000]              
	float                                              m_fLastWeaponTraceLocTimeStamp;                   		// 0x035C (0x0004) [0x0000000000000000]              
	float                                              m_fClientBuildUpTime;                             		// 0x0360 (0x0004) [0x0000000000000000]              
	float                                              m_EndOfLastFireTimeStamp;                         		// 0x0364 (0x0004) [0x0000000000000000]              
	float                                              m_fFiringTimer;                                   		// 0x0368 (0x0004) [0x0000000000000000]              
	float                                              m_fTimeAccountedFor;                              		// 0x036C (0x0004) [0x0000000000000000]              
	float                                              m_fTimeStampAccountedFor;                         		// 0x0370 (0x0004) [0x0000000000000000]              
	float                                              m_IndividualOffhandCooldownTime;                  		// 0x0374 (0x0004) [0x0000000000000000]              
	float                                              c_fCachedManaAtStartFire;                         		// 0x0378 (0x0004) [0x0000000000000000]              
	class UTgDeviceFire*                               s_WhileFiringDeviceMode;                          		// 0x037C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1720 );

		return pClassPointer;
	};

	void StopFiringLogic ( );
	void eventClientReconnected ( );
	void AdjustForNewDilation ( float fPrevDilation, float fNewDilation );
	bool eventHasRemoteOwner ( );
	bool eventIsToggleDevice ( );
	bool eventApplyGlobalOffhandCooldown ( );
	struct FVector GetStartTraceLocation ( );
	void CacheStartTraceLocation ( struct FVector vLoc );
	void eventDestroyed ( );
	void UpdateIndex ( );
	void HandleDeviceFormStartFire ( int nDeviceModeNum, float fRefireTime, struct FAimData* Aim );
	void HandleDeviceFormBuildup ( int nDeviceModeNum, float fBuildupTime );
	bool ShouldRefire ( class UTgDeviceFire* FireMode, struct FAimData* Aim );
	void RestartFireLoop ( unsigned long bRefire );
	void FirePostHitDelay ( );
	void FirePreHitDelay ( );
	void RefireCheckTimer ( );
	void PauseFiringInHandWeapon ( );
	void OnProjectileShutdown ( class ATgProjectile* Proj );
	void OnTeleportNotify ( class AActor* TeleportingActor );
	void OnTeleportToBaseNotify ( class AActor* TeleportingActor );
	void eventNotifySwitchMode ( );
	void NotifyPutAway ( );
	void eventClientEndCooldown ( );
	void eventClientResetCooldown ( int nMode, float fCooldownTime );
	void eventClientStartCooldown ( int nMode, float fCooldownTime );
	void eventEndCooldown ( );
	void eventResetCooldown ( int nMode, float fCooldownTimeOverride );
	void eventStartCooldown ( int nMode, float fCooldownTimeOverride );
	void ClientCooldownTimerExpired ( int nTimerId, unsigned char eEvent );
	void CooldownTimerExpired ( int nTimerId, unsigned char eEvent );
	float eventGetCooldownRemaining ( );
	void FireAmmunition ( );
	void TrackDeviceModeFired ( class ATgPawn* PawnFiring );
	class AActor* GetTrackingTarget ( int nFireIndex );
	bool eventUsesTrackingTarget ( );
	struct FVector GetPhysicalFireStartLoc ( struct FVector AimDir );
	int GetProjectileIDOverride ( int ProjectileIndex );
	void CustomProjectileInit ( class AProjectile* Proj, int ProjIndex, struct FAimData BaseAim );
	class AProjectile* ProjectileFire ( int ProjectileIndex );
	void CustomFire ( );
	void AOEArcingFlash ( TArray< struct FImpactInfo > ImpactList, struct FVector StartLocation );
	void ArcingFire ( );
	void eventInstantFire ( );
	void eventMeleeFire ( );
	class ATgPawn* eventAcquireMeleeTarget ( int* bExactTarget );
	float LinePointDist ( struct FVector A, struct FVector B, struct FVector Pt );
	bool eventShouldApplyHitSpecial ( );
	void eventDeliverQueuedPendingHits ( );
	struct FImpactInfo CalcWeaponFire ( struct FAimData Aim, TArray< struct FImpactInfo >* ImpactList );
	void ServerForceStopFire ( );
	void eventForceStopFire ( );
	void ServerStopFire ( );
	void eventServerStopFireAsEvent ( );
	void eventStopFireAsEvent ( );
	void StopFire ( );
	void ServerStartFire ( struct FAimData ClientAim, float EndTraceX, float EndTraceY, int nCompressedRot );
	void eventServerStartFireAsEvent ( );
	void FireLockComplete ( );
	void GlobalOffhandCooldownCompleteClient ( );
	void GlobalOffhandCooldownCompleteServer ( );
	void SetFireLock ( );
	bool eventStartFire ( );
	bool ShouldSwitchBackToBasicAttackTargeting ( unsigned char CastMode );
	bool ShouldConsumePowerPoolAfterFire ( );
	bool ShouldConsumePowerPoolOnStartFire ( );
	bool eventShouldCooldownAfterFire ( );
	bool AllowFireFromStunTaunt ( class ATgPawn* P );
	bool eventSimulateStartFire ( );
	bool eventUse ( );
	bool CheckCustomStartFire ( );
	bool NeedCustomLeftClickBehavior ( );
	bool eventCanDeviceStartFiringNow ( unsigned char FireModeNum, struct FAimData Aim, unsigned long bDebugRelevant, unsigned char* failType );
	void CacheDeviceCanFire ( unsigned long bDeviceCanFire, unsigned char failType );
	bool eventCanFireWhileDead ( );
	bool eventCustomCanDeviceFireNow ( unsigned char FireModeNum, struct FAimData Aim, unsigned long bDeviceFailLog, unsigned char* failType );
	bool eventCanDeviceFireNow ( unsigned char FireModeNum, struct FAimData Aim, unsigned long bDeviceFailLog, unsigned long bSkipStunCheck, unsigned char* failType );
	void InterruptRecall ( );
	bool eventShouldLockFiring ( class ATgDevice* Current );
	bool CanLockFiringAegisAmulet ( );
	bool eventIsGreaterAegisAmulet ( );
	bool eventIsPurificationBeads ( );
	bool eventIsAegisAmulet ( );
	float GetLockoutExtensionTime ( );
	float eventAmountCurrentlyOffOfTargetAccuracy ( unsigned char FireModeNum );
	bool CanFireWhileFalling ( );
	bool CanFireWhileHanging ( );
	bool CanFireWhileDoingRoutineTasks ( int FireModeNum );
	void eventTriggerRefill ( );
	void eventOnPurchased ( );
	void eventConsumeDevice ( );
	bool UsesEnergy ( );
	bool UsesMana ( );
	bool UsesHealth ( );
	void eventDeviceConsumePowerPool ( unsigned char FireModeNum );
	void PlayClientOffhandFx ( struct FAimData Aim, int nSocketIndex );
	void PlayClientFireFx ( struct FVector HitLocation, int nSocketIndex, unsigned long bSuccessfulHit, float fRefireTime );
	bool ShouldCancelStealth ( );
	void HandleFiringRejection ( );
	void ClientInterrupt ( );
	void eventInterruptFiring ( );
	void DeviceRestart ( );
	void DeviceShutDown ( unsigned long bDeactiveMode, unsigned long bResetCooldowns );
	void ServerDoRemoteDetonation ( int nFireMode );
	void eventSetActiveState ( );
	void eventGetAdjustedAim ( int nShotIndex, struct FAimData* Aim );
	struct FRotator AddSpread ( struct FRotator BaseAim, float fAccuracy );
	bool CanFireIfLeftMouseDown ( );
	bool eventShouldInterruptInhand ( );
	bool eventCanBeInterrupted ( );
	bool eventCancelledByJumping ( );
	bool eventCanJumpWhileFiring ( );
	bool eventCanBeFiredWhileTweening ( );
	bool eventCanBeCanceledByRightMouse ( );
	bool eventCanBeCanceled ( );
	float GetEffectiveRange ( );
	float GetRange ( );
	bool eventShouldTriggerCastReactionItemsOnFire ( );
	bool eventShouldTriggerCastReactionItems ( );
	bool eventIsEquipping ( );
	bool NativeIsFiring ( );
	void eventForceCooldownIfFiring ( );
	int GetRestrictType ( );
	void DisplayMessage ( struct FString sMessage );
	void DisplayDebug ( class AHUD* HUD, float* out_YL, float* out_YPos );
	void WeaponLog ( struct FString msg, struct FString FuncStr );
	void eventReplicatedEvent ( struct FName VarName );
	void OnUnequipAsEffectListener ( );
	void OnEquipAsEffectListener ( );
	unsigned char GetCurrentFiringInstance ( );
	unsigned char IncrementFiringInstance ( );
	void SetFireMode ( int nFireModeNum, unsigned long ForceSet );
	bool ShouldRevealFromStealth ( );
	void SetInstanceCount ( int nInstanceCount );
	void SetPointsAllocated ( int nPoints );
	void ClientPtsAllocatedUpdated ( );
	bool HasBeenTrained ( );
	bool AllocateDevicePoint ( );
	int GetAllocatedDevicePoints ( );
	int GetTotalDevicePoints ( );
	void ExitTargetingMode ( );
	void EnterTargetingMode ( );
	bool IsInTargetingMode ( );
	bool IsTargetingModeReady ( unsigned char* failType );
	void UpdateAimWhileFiring ( struct FAimData* Aim );
	bool CanLockOnToTarget ( class AActor* Target );
	void GetPawnSelectTargetAim ( struct FAimData* Aim );
	void GetWorldMapLockOnTargetAim ( struct FAimData* Aim );
	void GetWorldMapTargetAim ( struct FAimData* Aim );
	void GetSpawnPointTargetAim ( struct FAimData* Aim );
	void GetLockOnTargetAim ( struct FAimData* Aim );
	void GetDeployAim ( struct FAimData* Aim );
	void GetGroundTargetAim ( struct FAimData* Aim );
	void GetLinearTargetAim ( struct FAimData* Aim );
	void GetSelfTargetAim ( struct FAimData* Aim );
	void GetAOETargetAim ( struct FAimData* Aim );
	void GetConeTargetAim ( struct FAimData* Aim );
	void GetMeleeTargetAim ( struct FAimData* Aim );
	void GetReticleTargetAim ( struct FAimData* Aim );
	void GetTargetingAim ( struct FAimData* Aim );
	unsigned char GetCannotFireTargetingStatus ( );
	void UpdateTargetingModeStatus ( struct FAimData* Aim );
	struct FAimData CacheAim ( );
	void GetCachedAim ( struct FAimData* Aim );
	bool UsesCachedAim ( );
	bool ForceDefaultCastMode ( );
	bool UsesTargetingMode ( );
	unsigned char GetTargetingMode ( );
	float GetCachedFiringPostHitDelay ( );
	float CacheFiringPostHitDelay ( );
	float GetFiringPostHitDelay ( int nMode );
	float GetFiringPreHitDelay ( int nMode );
	float GetRefireTime ( int nMode );
	float GetBuildupTime ( int nMode );
	void GetCombatLogEventLocation ( int* LocationX, int* LocationY );
	void SendCombatLogEvent ( unsigned char Type );
	void SendDeviceChangeEvent ( unsigned char Event );
	bool IsToggledOn ( );
	bool IsLockedDown ( );
	bool ShowUICanFire ( );
	void CheckAndUpdateCooldown ( );
	class UTgTimerManager* GetCooldownTimerManager ( );
	bool IsDeviceRefiring ( );
	bool IsInCooldownGracePeriod ( );
	bool IsDeviceCoolingDown ( );
	bool HasEnoughPowerPool ( unsigned char FireModeNum );
	bool IsDeviceLimited ( );
	bool IsTutorialFiringDisabled ( );
	float GetConePullbackDistance ( );
	bool AllowFireFromGrab ( class ATgPawn* P );
	bool CanBeGrabbed ( );
	bool CanBeCrippled ( );
	bool CanBeDisarmed ( );
	bool CanBeSilenced ( );
	bool CanBeStunned ( );
	bool IsPurchasedAbility ( );
	bool IsOwnedByOffhand ( );
	bool IsOffhand ( );
	bool IsMeleeAttack ( );
	bool IsRangedAttack ( );
	int GetModeRange ( int nMode );
	bool CheckModeRange ( int nMode, struct FVector vDelta );
	void RemoveEquipEffects ( );
	void ApplyEquipEffects ( );
	bool ShouldApplyModeEquipEffects ( );
	class UTgDeviceFire* GetDeviceFire ( int nMode );
	class UTgDeviceFire* GetCurrentFire ( );
	void UpdateManaUseVitals ( class ATgPlayerController* PC );
	void TickTargetingMode ( float DeltaSeconds );
	void ClearInstigatorEquippedDevices ( );
	void PopulateInstigatorEquippedDevices ( );
	bool NeedServerDetonate ( int nFireMode );
	bool ServerDetonate ( int nFireMode );
	bool LogDebugInfo ( );
	void RemoveConsumableFromOwnerInventory ( );
	struct FString GetDeviceName ( );
	void CalcFireSocketIndexMax ( );
	struct FName GetFireSocketName ( );
	struct FName QueryDeployableClass ( int nMode );
	struct FName QueryProjectileClass ( int nMode );
	bool ApplyDeviceSetup ( );
};

UClass* ATgDevice::pClassPointer = NULL;

// Class TgGame.TgDevice_AoKuang_NewUltimate
// 0x0098 (0x0418 - 0x0380)
class ATgDevice_AoKuang_NewUltimate : public ATgDevice
{
public:
	int                                                m_nDelayedKnockupSituationalType;                 		// 0x0380 (0x0004) [0x0000000000000000]              
	int                                                m_nDelayedMegaKillSituationalType;                		// 0x0384 (0x0004) [0x0000000000000000]              
	int                                                m_nDelayedMegaKillProtectionSitType;              		// 0x0388 (0x0004) [0x0000000000000000]              
	float                                              m_fMegaKillStunDelay;                             		// 0x038C (0x0004) [0x0000000000000000]              
	unsigned char                                      m_MegaKillTweenType;                              		// 0x0390 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_MegaKillDeathReason;                            		// 0x0391 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_NormalKnockUpTween;                             		// 0x0392 (0x0001) [0x0000000000000000]              
	struct FImpactInfo                                 s_DelayedActionImpact;                            		// 0x0394 (0x0060) [0x0000000000080000]              ( CPF_Component )
	struct FVector                                     s_vFallBackLocation;                              		// 0x03F4 (0x000C) [0x0000000000000000]              
	unsigned long                                      s_bPerformedMegaKill : 1;                         		// 0x0400 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      s_bTargetLost : 1;                                		// 0x0400 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_bUsePassive : 1;                                		// 0x0400 (0x0004) [0x0000000000000000] [0x00000004] 
	TArray< struct FValidTargetInfo >                  s_ValidTargets;                                   		// 0x0404 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                s_nTargetingSituationalType;                      		// 0x0410 (0x0004) [0x0000000000000000]              
	float                                              s_fTargetingHighlightRange;                       		// 0x0414 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1721 );

		return pClassPointer;
	};

	void DeviceShutDown ( unsigned long bDeactivateMode, unsigned long bResetCooldowns );
	struct FImpactInfo CalcWeaponFire ( struct FAimData Aim, TArray< struct FImpactInfo >* ImpactList );
	void eventStartCooldown ( int nMode, float fCooldownTimeOverride );
	void eventDeliverQueuedPendingHits ( );
	void InstantFire ( );
	void FireAmmunition ( );
	void ClientForceFireAmmunition ( );
	void TargetLost ( );
	void FreeAllDelayedActionTargets ( );
	void eventCancelDelayedAction ( );
	void EndDelayedAction ( );
	void eventBeginDelayedKnockUpTween ( struct FImpactInfo Impact, class UTgDeviceFire* FireMode, unsigned long bEndDelayedAction );
	bool BeginDelayedKnockUp ( struct FImpactInfo Impact, class UTgDeviceFire* FireMode );
	void DoMegaKill ( );
	void eventBeginDelayedMegaKillTween ( struct FImpactInfo Impact, class UTgDeviceFire* FireMode );
	void StartDragon ( );
	void eventMegaKillTargetDied ( float fTimeRemaining, class AActor* Target );
	bool BeginDelayedMegaKill ( struct FImpactInfo Impact, class UTgDeviceFire* FireMode, int nMode );
	void eventInterruptFiring ( );
	bool eventCanBeInterrupted ( );
	void ClientToggleOn ( unsigned long bOn );
	void ToggleOn ( unsigned long bOn );
	bool ShouldConsumePowerPoolAfterFire ( );
	bool eventShouldCooldownAfterFire ( );
	bool eventShouldLockFiring ( class ATgDevice* Current );
	void FixFailedMegaKillFallLocation ( class ATgPawn* Target );
	bool ShouldForceMegaKill ( class AActor* Target );
	void ClearValidTargets ( );
	void SpawnDeployable ( class UTgDeviceFire* DeviceMode );
	bool CanMegaKill ( class AActor* A, class UTgDeviceFire* DeviceMode, unsigned long bPredicting );
	void SetFireMode ( int nFireModeNum, unsigned long ForceSet );
	void SetPointsAllocated ( int nPoints );
};

UClass* ATgDevice_AoKuang_NewUltimate::pClassPointer = NULL;

// Class TgGame.TgDevice_AoKuang_Ultimate
// 0x0008 (0x0388 - 0x0380)
class ATgDevice_AoKuang_Ultimate : public ATgDevice
{
public:
	float                                              m_fKillDelay;                                     		// 0x0380 (0x0004) [0x0000000000000000]              
	unsigned long                                      s_bPerformedMegaKill : 1;                         		// 0x0384 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bTransformOnStopFire : 1;                       		// 0x0384 (0x0004) [0x0000000000000000] [0x00000002] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1722 );

		return pClassPointer;
	};

	void eventStartCooldown ( int nMode, float fCooldownTimeOverride );
	void eventDeliverQueuedPendingHits ( );
	bool IsDeadGod ( class AActor* A );
	void FireAmmunition ( );
	void ClientForceFireAmmunition ( );
	bool DoMegaKill ( struct FImpactInfo Impact, class UTgDeviceFire* FireMode, int nMode );
	bool CanMegaKill ( class AActor* A );
	void ClientTransformOnStopFire ( );
	void TransformOnStopFire ( );
	void ClientToggleOn ( unsigned long bOn );
	void ToggleOn ( unsigned long bOn );
	bool eventShouldCooldownAfterFire ( );
	bool eventShouldLockFiring ( class ATgDevice* Current );
	void SetFireMode ( int nFireModeNum, unsigned long ForceSet );
	void SetPointsAllocated ( int nPoints );
};

UClass* ATgDevice_AoKuang_Ultimate::pClassPointer = NULL;

// Class TgGame.TgDevice_Apep_Strike
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_Apep_Strike : public ATgDevice
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1723 );

		return pClassPointer;
	};

};

UClass* ATgDevice_Apep_Strike::pClassPointer = NULL;

// Class TgGame.TgDevice_Aphrodite_GetAway
// 0x004C (0x03CC - 0x0380)
class ATgDevice_Aphrodite_GetAway : public ATgDevice
{
public:
	unsigned long                                      m_bCachedUseSoulMateDeviceMode : 1;               		// 0x0380 (0x0004) [0x0000000000000000] [0x00000001] 
	class ATgPawn*                                     m_CachedSoulMate;                                 		// 0x0384 (0x0004) [0x0000000000000000]              
	struct FAimData                                    m_CachedSoulMateAim;                              		// 0x0388 (0x002C) [0x0000000000000000]              
	TArray< struct FImpactInfo >                       PendingSoulMateImpact;                            		// 0x03B4 (0x000C) [0x0000000000480000]              ( CPF_Component | CPF_NeedCtorLink )
	TArray< class UTgDeviceFire* >                     m_SoulMateFireMode;                               		// 0x03C0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1724 );

		return pClassPointer;
	};

	void FireAmmunition ( );
	void eventDeliverQueuedPendingHits ( );
	struct FImpactInfo CalcWeaponFire ( struct FAimData Aim, TArray< struct FImpactInfo >* ImpactList );
	void PerformKnockback ( struct FImpactInfo Impact, class AActor* DamageInstigator );
	void GetSoulMateAim ( struct FAimData* Aim );
	class UTgDeviceFire* GetCurrentSoulMateFire ( );
	struct FAimData CacheAim ( );
	void GetCachedSoulMateAim ( struct FAimData* Aim );
	class ATgPawn* GetSoulMate ( );
	bool UseSoulMateFireMode ( );
	bool ValidSoulMate ( class ATgPawn* SoulMate );
	void TickTargetingMode ( float DeltaSeconds );
	void GetTargetingAim ( struct FAimData* Aim );
};

UClass* ATgDevice_Aphrodite_GetAway::pClassPointer = NULL;

// Class TgGame.TgDevice_Aphrodite_SoulMates
// 0x0004 (0x0384 - 0x0380)
class ATgDevice_Aphrodite_SoulMates : public ATgDevice
{
public:
	unsigned long                                      m_bDisableCooldown : 1;                           		// 0x0380 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1725 );

		return pClassPointer;
	};

	void eventStartCooldown ( int nMode, float fCooldownTimeOverride );
	class AActor* GetTrackingTarget ( int nFireIndex );
	void FireAmmunition ( );
	void GetReticleTargetAim ( struct FAimData* Aim );
	void GetTargetingAim ( struct FAimData* Aim );
};

UClass* ATgDevice_Aphrodite_SoulMates::pClassPointer = NULL;

// Class TgGame.TgDevice_Aphrodite_SoulMates_PVE
// 0x0000 (0x0384 - 0x0384)
class ATgDevice_Aphrodite_SoulMates_PVE : public ATgDevice_Aphrodite_SoulMates
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1726 );

		return pClassPointer;
	};

	class AActor* GetTrackingTarget ( int nFireIndex );
};

UClass* ATgDevice_Aphrodite_SoulMates_PVE::pClassPointer = NULL;

// Class TgGame.TgDevice_Apollo_SoBeautiful
// 0x0004 (0x0384 - 0x0380)
class ATgDevice_Apollo_SoBeautiful : public ATgDevice
{
public:
	class ATgProj_SimulatedPassThrough*                m_SoBeautifulProj;                                		// 0x0380 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1727 );

		return pClassPointer;
	};

	void OnProjectileShutdown ( class ATgProjectile* Proj );
	void CustomProjectileInit ( class AProjectile* Proj, int ProjIndex, struct FAimData BaseAim );
};

UClass* ATgDevice_Apollo_SoBeautiful::pClassPointer = NULL;

// Class TgGame.TgDevice_ArcingBeam
// 0x0018 (0x0398 - 0x0380)
class ATgDevice_ArcingBeam : public ATgDevice
{
public:
	class AActor*                                      s_PreviousArcTarget;                              		// 0x0380 (0x0004) [0x0000000000000000]              
	TArray< class AActor* >                            s_PreviousTargets;                                		// 0x0384 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class UTgDeviceFire_ArcingBeam*                    s_ArcFiremode;                                    		// 0x0390 (0x0004) [0x0000000000000000]              
	int                                                s_nJumpsRemaining;                                		// 0x0394 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1728 );

		return pClassPointer;
	};

	void TriggerArc ( );
	void EndArcing ( );
	void BeginArcing ( class AActor* initialTarget, class UTgDeviceFire_ArcingBeam* FireMode );
	class AActor* DetermineNextTarget ( );
};

UClass* ATgDevice_ArcingBeam::pClassPointer = NULL;

// Class TgGame.TgDevice_Zeus_ChainLightning
// 0x0000 (0x0398 - 0x0398)
class ATgDevice_Zeus_ChainLightning : public ATgDevice_ArcingBeam
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1729 );

		return pClassPointer;
	};

	void UpdateTargetingModeStatus ( struct FAimData* Aim );
};

UClass* ATgDevice_Zeus_ChainLightning::pClassPointer = NULL;

// Class TgGame.TgDevice_Ares_Shackles
// 0x0010 (0x0390 - 0x0380)
class ATgDevice_Ares_Shackles : public ATgDevice
{
public:
	int                                                m_ShackleComboCount;                              		// 0x0380 (0x0004) [0x0000000000000000]              
	unsigned long                                      r_CanComboShot : 1;                               		// 0x0384 (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )
	unsigned long                                      m_bHitOccured : 1;                                		// 0x0384 (0x0004) [0x0000000000000000] [0x00000002] 
	int                                                m_MaxShackleCount;                                		// 0x0388 (0x0004) [0x0000000000000000]              
	float                                              m_fComboTimeLimit;                                		// 0x038C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1730 );

		return pClassPointer;
	};

	void DeviceConsumePowerPool ( unsigned char FireModeNum );
	bool HasEnoughPowerPool ( unsigned char FireModeNum );
	void OnReshackleTimerExpired ( );
	void FireAmmunition ( );
	void eventOnHit ( struct FImpactInfo Impact );
	void CooldownTimerExpired ( int nTimerId, unsigned char eEvent );
	bool IsDeviceCoolingDown ( );
	void SetCanComboShot ( unsigned long bCanComboShot );
	void ReplicatedEvent ( struct FName VarName );
	void UpdateManaUseVitals ( class ATgPlayerController* PC );
};

UClass* ATgDevice_Ares_Shackles::pClassPointer = NULL;

// Class TgGame.TgDevice_Aura
// 0x0018 (0x0398 - 0x0380)
class ATgDevice_Aura : public ATgDevice
{
public:
	class ATgCollisionProxy*                           s_CollisionProxy;                                 		// 0x0380 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	TArray< class AActor* >                            s_AppliedList;                                    		// 0x0384 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	class AActor*                                      s_AppliedToBaseActor;                             		// 0x0390 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned long                                      s_bApplyToOwner : 1;                              		// 0x0394 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1731 );

		return pClassPointer;
	};

	bool eventCanJumpWhileFiring ( );
	void DeviceShutDown ( unsigned long bDeactiveMode, unsigned long bResetCooldowns );
	void eventDestroyed ( );
	void eventEndAura ( );
	void eventBeginAura ( );
	void eventRemoveFromAllHitAura ( );
	void eventApplyToAllHitAura ( );
	bool RemoveHitAura ( class AActor* Other, unsigned long bRemoveFromList );
	void eventProxyUnTouch ( class AActor* Other );
	void ApplyHitAura ( class AActor* Other );
	bool ShouldApplyAura ( );
	void eventProxyTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void eventTick ( float DeltaTime );
	void eventUpdateCollisionProxyDelegates ( );
	bool eventIsAuraActive ( );
	void SetFireMode ( int nFireModeNum, unsigned long ForceSet );
};

UClass* ATgDevice_Aura::pClassPointer = NULL;

// Class TgGame.TgDevice_ActiveAura
// 0x0000 (0x0398 - 0x0398)
class ATgDevice_ActiveAura : public ATgDevice_Aura
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1732 );

		return pClassPointer;
	};

	bool eventShouldLockFiring ( class ATgDevice* Current );
	bool eventIsAuraActive ( );
	bool eventCanBeCanceled ( );
};

UClass* ATgDevice_ActiveAura::pClassPointer = NULL;

// Class TgGame.TgDevice_Kaldr_Dev4
// 0x0000 (0x0398 - 0x0398)
class ATgDevice_Kaldr_Dev4 : public ATgDevice_ActiveAura
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1733 );

		return pClassPointer;
	};

	bool eventCanDeviceFireNow ( unsigned char FireModeNum, struct FAimData Aim, unsigned long bDeviceFailLog, unsigned long bSkipStunCheck, unsigned char* failType );
	bool eventCanBeFiredWhileTweening ( );
	bool eventShouldLockFiring ( class ATgDevice* Current );
	bool eventApplyGlobalOffhandCooldown ( );
	bool AllocateDevicePoint ( );
};

UClass* ATgDevice_Kaldr_Dev4::pClassPointer = NULL;

// Class TgGame.TgDevice_Skadi_Dev4
// 0x0010 (0x03A8 - 0x0398)
class ATgDevice_Skadi_Dev4 : public ATgDevice_ActiveAura
{
public:
	class ATgDevice*                                   s_MatchedDevice;                                  		// 0x0398 (0x0004) [0x0000000000000000]              
	TArray< class AActor* >                            m_ValidAOETargets;                                		// 0x039C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1734 );

		return pClassPointer;
	};

	bool eventCanBeInterrupted ( );
	void eventBeginAura ( );
	bool eventGetMatchedDevice ( );
	void FireAmmunition ( );
	int eventMatchedKaldrDeviceEQPoint ( );
	void TickTargetingMode ( float DeltaSeconds );
	bool AllocateDevicePoint ( );
};

UClass* ATgDevice_Skadi_Dev4::pClassPointer = NULL;

// Class TgGame.TgDevice_Ares_AuraShield
// 0x0004 (0x039C - 0x0398)
class ATgDevice_Ares_AuraShield : public ATgDevice_Aura
{
public:
	int                                                m_ShackleStackCount;                              		// 0x0398 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1735 );

		return pClassPointer;
	};

	void DeviceShutDown ( unsigned long bDeactiveMode, unsigned long bResetCooldowns );
	void FireAmmunition ( );
	void eventRemoveExtraBuff ( class AActor* Other );
	void eventUpdateExtraBuff ( class AActor* Other );
	void eventApplyExtraBuff ( class AActor* Other );
	bool RemoveHitAura ( class AActor* Other, unsigned long bRemoveFromList );
	void ApplyHitAura ( class AActor* Other );
	void eventTick ( float DeltaTime );
	bool eventIsAuraActive ( );
};

UClass* ATgDevice_Ares_AuraShield::pClassPointer = NULL;

// Class TgGame.TgDevice_AuraToggle
// 0x0000 (0x0398 - 0x0398)
class ATgDevice_AuraToggle : public ATgDevice_Aura
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1736 );

		return pClassPointer;
	};

	bool ShouldInterruptReload ( );
	bool eventIsToggleDevice ( );
	bool eventStartFire ( );
	bool CanDeviceFireInTargetingMode ( );
	bool eventIsAuraActive ( );
	bool IsToggledOn ( );
	void UpdateUIToggleState ( );
};

UClass* ATgDevice_AuraToggle::pClassPointer = NULL;

// Class TgGame.TgDevice_CooldownAura
// 0x0000 (0x0398 - 0x0398)
class ATgDevice_CooldownAura : public ATgDevice_Aura
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1737 );

		return pClassPointer;
	};

	void DeviceRestart ( );
	void eventStartCooldown ( int nMode, float fCooldownTimeOverride );
	void CooldownTimerExpired ( int nTimerId, unsigned char eEvent );
	bool eventIsAuraActive ( );
};

UClass* ATgDevice_CooldownAura::pClassPointer = NULL;

// Class TgGame.TgDevice_Osiris_AuraReformation
// 0x0004 (0x039C - 0x0398)
class ATgDevice_Osiris_AuraReformation : public ATgDevice_Aura
{
public:
	int                                                m_PartsStackCount;                                		// 0x0398 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1738 );

		return pClassPointer;
	};

	void DeviceShutDown ( unsigned long bDeactiveMode, unsigned long bResetCooldowns );
	void eventEndAura ( );
	void FireAmmunition ( );
	void eventRemoveExtraBuff ( class AActor* Other );
	bool eventStartFire ( );
	void eventApplyExtraBuff ( class AActor* Other );
	bool RemoveHitAura ( class AActor* Other, unsigned long bRemoveFromList );
	void ApplyHitAura ( class AActor* Other );
	bool eventIsAuraActive ( );
};

UClass* ATgDevice_Osiris_AuraReformation::pClassPointer = NULL;

// Class TgGame.TgDevice_PassiveAura
// 0x0000 (0x0398 - 0x0398)
class ATgDevice_PassiveAura : public ATgDevice_Aura
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1739 );

		return pClassPointer;
	};

	void eventEndAura ( );
	void eventBeginAura ( );
	void DeviceRestart ( );
	bool eventIsAuraActive ( );
	void RemoveEquipEffects ( );
	void ApplyEquipEffects ( );
};

UClass* ATgDevice_PassiveAura::pClassPointer = NULL;

// Class TgGame.TgDevice_G72_Dev1
// 0x0001 (0x0399 - 0x0398)
class ATgDevice_G72_Dev1 : public ATgDevice_PassiveAura
{
public:
	unsigned char                                      r_eAuraType;                                      		// 0x0398 (0x0001) [0x0000000000000020]              ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1740 );

		return pClassPointer;
	};

	void eventBeginAura ( );
	void eventSwapAuraType ( );
	void FireAmmunition ( );
	bool eventIsAuraActive ( );
	bool AllocateDevicePoint ( );
};

UClass* ATgDevice_G72_Dev1::pClassPointer = NULL;

// Class TgGame.TgDevice_HelV3_SwitchStance
// 0x0000 (0x0398 - 0x0398)
class ATgDevice_HelV3_SwitchStance : public ATgDevice_PassiveAura
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1741 );

		return pClassPointer;
	};

	bool ShouldApplyAura ( );
	bool ShouldApplyModeEquipEffects ( );
	bool HasBeenTrained ( );
};

UClass* ATgDevice_HelV3_SwitchStance::pClassPointer = NULL;

// Class TgGame.TgDevice_Isis_FuneralRites
// 0x0004 (0x039C - 0x0398)
class ATgDevice_Isis_FuneralRites : public ATgDevice_PassiveAura
{
public:
	class ATgCollisionProxy_PawnListener*              CollisionProxyListener;                           		// 0x0398 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1742 );

		return pClassPointer;
	};

	void eventDestroyed ( );
	void eventApplyDispelMagic ( class UTgDeviceFire* FireMode, int StackCount );
	bool RemoveHitAura ( class AActor* Other, unsigned long bRemoveFromList );
	void ApplyHitAura ( class AActor* Other );
	void ReapplyHitAuraWithStack ( int StackCount );
	void CollisionProxyOnPawnDied ( class ATgPawn* Other );
	void eventUpdateCollisionProxyDelegates ( );
};

UClass* ATgDevice_Isis_FuneralRites::pClassPointer = NULL;

// Class TgGame.TgDevice_Nox_PassiveListener
// 0x0008 (0x03A0 - 0x0398)
class ATgDevice_Nox_PassiveListener : public ATgDevice_PassiveAura
{
public:
	class ATgCollisionProxy_PawnListener*              CollisionProxyListener;                           		// 0x0398 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              s_fSecondsBetweenAbilityProcs;                    		// 0x039C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1743 );

		return pClassPointer;
	};

	void eventDestroyed ( );
	void CollisionProxyDeviceOnStartFire ( class ATgPawn* Other, class ATgDevice* OtherDevice );
	void eventUpdateCollisionProxyDelegates ( );
};

UClass* ATgDevice_Nox_PassiveListener::pClassPointer = NULL;

// Class TgGame.TgDevice_NuWa_Passive
// 0x01F8 (0x0590 - 0x0398)
class ATgDevice_NuWa_Passive : public ATgDevice_PassiveAura
{
public:
	struct FCrystalInfo                                m_Crystals[ 0x19 ];                               		// 0x0398 (0x01F4) [0x0000000000000000]              
	float                                              m_fCrystalDefaultLifeTime;                        		// 0x058C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1744 );

		return pClassPointer;
	};

	void eventEndAura ( );
	void eventBeginAura ( );
	bool RemoveHitAura ( class AActor* Other, unsigned long bRemoveFromList );
	void ApplyHitAura ( class AActor* Other );
	int NumCrystalsActive ( );
	void AdjustAllActiveCrystals ( float fNewLifetime );
	void ReactivateCrystals ( );
	void DeactivateAllCrystals ( unsigned long bWillReapply );
	void DeactivateCrystal ( unsigned char eqp, unsigned long bWillReapply );
	void ActivateCrystal ( unsigned char eqp, float fLifeTime );
	void SetCrystalFireMode ( unsigned char eqp, class UTgDeviceFire* DeviceMode );
	void SetFireMode ( int nFireModeNum, unsigned long ForceSet );
};

UClass* ATgDevice_NuWa_Passive::pClassPointer = NULL;

// Class TgGame.TgDevice_PassiveAura_EffectListener
// 0x0000 (0x0398 - 0x0398)
class ATgDevice_PassiveAura_EffectListener : public ATgDevice_PassiveAura
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1745 );

		return pClassPointer;
	};

	bool ShouldApplyAura ( );
	void OnUnequipAsEffectListener ( );
	void OnEquipAsEffectListener ( );
};

UClass* ATgDevice_PassiveAura_EffectListener::pClassPointer = NULL;

// Class TgGame.TgDevice_Serqet_Passive
// 0x0014 (0x03AC - 0x0398)
class ATgDevice_Serqet_Passive : public ATgDevice_PassiveAura
{
public:
	float                                              s_fTimeUntilStealth;                              		// 0x0398 (0x0004) [0x0000000000000000]              
	unsigned long                                      r_bPassiveActive : 1;                             		// 0x039C (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )
	unsigned long                                      s_bStealthOn : 1;                                 		// 0x039C (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      s_bDeviceSwapped : 1;                             		// 0x039C (0x0004) [0x0000000000000000] [0x00000004] 
	int                                                m_nJumpDeviceId;                                  		// 0x03A0 (0x0004) [0x0000000000000000]              
	class ATgDevice*                                   r_JumpDevice;                                     		// 0x03A4 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgDevice*                                   s_CachedInHand;                                   		// 0x03A8 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1746 );

		return pClassPointer;
	};

	void Tick ( float DeltaTime );
	void EquipJumpDevice ( unsigned long bEquip, unsigned long bForce );
	void SetStealth ( unsigned long bOn );
	void eventUpdatePassiveState ( float DeltaSeconds, unsigned long bForceOff, unsigned long bJumpStartFire );
	void eventRemoveFromAllHitAura ( );
	bool RemoveHitAura ( class AActor* Other, unsigned long bRemoveFromList );
	void ApplyHitAura ( class AActor* Other );
	void eventInterruptFiring ( );
	bool eventCanBeInterrupted ( );
	void ApplyEquipEffects ( );
};

UClass* ATgDevice_Serqet_Passive::pClassPointer = NULL;

// Class TgGame.TgDevice_ThorPassive
// 0x0004 (0x039C - 0x0398)
class ATgDevice_ThorPassive : public ATgDevice_PassiveAura
{
public:
	int                                                m_nNumInRange;                                    		// 0x0398 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1747 );

		return pClassPointer;
	};

	bool RemoveHitAura ( class AActor* Other, unsigned long bRemoveFromList );
	void ApplyHitAura ( class AActor* Other );
};

UClass* ATgDevice_ThorPassive::pClassPointer = NULL;

// Class TgGame.TgDevice_Awilix_Moonlight
// 0x0004 (0x0384 - 0x0380)
class ATgDevice_Awilix_Moonlight : public ATgDevice
{
public:
	class UTgDeviceFire*                               m_BuffFireMode;                                   		// 0x0380 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1748 );

		return pClassPointer;
	};

	void DeviceShutDown ( unsigned long bDeactiveMode, unsigned long bResetCooldowns );
	void HandleDeviceFormStartFire ( int nDeviceModeNum, float fRefireTime, struct FAimData* Aim );
	struct FImpactInfo eventGetPullTarget ( );
	void ApplyMoonlightBuff ( );
	void TriggerDelayReset ( );
	void eventStartMoonlightBuff ( unsigned long bApplyImmediately );
};

UClass* ATgDevice_Awilix_Moonlight::pClassPointer = NULL;

// Class TgGame.TgDevice_Awilix_Reposition
// 0x0008 (0x0388 - 0x0380)
class ATgDevice_Awilix_Reposition : public ATgDevice
{
public:
	int                                                m_nPounceDistance;                                		// 0x0380 (0x0004) [0x0000000000000000]              
	int                                                m_nMaxTargetDistance;                             		// 0x0384 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1749 );

		return pClassPointer;
	};

	struct FImpactInfo CalcWeaponFire ( struct FAimData Aim, TArray< struct FImpactInfo >* ImpactList );
	bool eventCanDeviceStartFiringNow ( unsigned char FireModeNum, struct FAimData Aim, unsigned long bDebugRelevant, unsigned char* failType );
	bool eventCanBeCanceled ( );
	bool CanLockOnToTarget ( class AActor* Target );
	void GetTargetingAim ( struct FAimData* Aim );
	bool IsLockedDown ( );
	bool UsesCachedAim ( );
};

UClass* ATgDevice_Awilix_Reposition::pClassPointer = NULL;

// Class TgGame.TgDevice_Awilix_StarlightLance
// 0x0004 (0x0384 - 0x0380)
class ATgDevice_Awilix_StarlightLance : public ATgDevice
{
public:
	unsigned long                                      m_bApplyHitSpecial : 1;                           		// 0x0380 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1750 );

		return pClassPointer;
	};

	bool eventShouldApplyHitSpecial ( );
	bool IsFacingAway ( class AActor* TargetActor );
	void HandleDeviceFormStartFire ( int nDeviceModeNum, float fRefireTime, struct FAimData* Aim );
	void UpdateTargetingModeStatus ( struct FAimData* Aim );
};

UClass* ATgDevice_Awilix_StarlightLance::pClassPointer = NULL;

// Class TgGame.TgDevice_Bacchus_Intoxicate
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_Bacchus_Intoxicate : public ATgDevice
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1751 );

		return pClassPointer;
	};

	struct FImpactInfo CalcWeaponFire ( struct FAimData Aim, TArray< struct FImpactInfo >* ImpactList );
	int GetFxID ( );
};

UClass* ATgDevice_Bacchus_Intoxicate::pClassPointer = NULL;

// Class TgGame.TgDevice_BakasuraSpitMinion
// 0x0004 (0x0384 - 0x0380)
class ATgDevice_BakasuraSpitMinion : public ATgDevice
{
public:
	int                                                m_nAmmoCount;                                     		// 0x0380 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1752 );

		return pClassPointer;
	};

	class AProjectile* ProjectileFire ( int ProjectileIndex );
	bool eventReplenishMinionAmmunition ( class ATgPawn* KilledPawn );
};

UClass* ATgDevice_BakasuraSpitMinion::pClassPointer = NULL;

// Class TgGame.TgDevice_BastetCatCall
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_BastetCatCall : public ATgDevice
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1753 );

		return pClassPointer;
	};

	void GetTargetingAim ( struct FAimData* Aim );
};

UClass* ATgDevice_BastetCatCall::pClassPointer = NULL;

// Class TgGame.TgDevice_BastetPounce
// 0x0030 (0x03B0 - 0x0380)
class ATgDevice_BastetPounce : public ATgDevice
{
public:
	unsigned char                                      m_ePounceState;                                   		// 0x0380 (0x0001) [0x0000000000000000]              
	unsigned long                                      m_ShouldPounceBack : 1;                           		// 0x0384 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_IsPouncingBack : 1;                             		// 0x0384 (0x0004) [0x0000000000000000] [0x00000002] 
	struct FVector                                     m_PrePounceLocation;                              		// 0x0388 (0x000C) [0x0000000000000000]              
	struct FVector                                     m_PounceLocation;                                 		// 0x0394 (0x000C) [0x0000000000000000]              
	float                                              m_PounceDuration;                                 		// 0x03A0 (0x0004) [0x0000000000000000]              
	class ASkeletalMeshActor*                          m_PounceBackPreviewActor;                         		// 0x03A4 (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                m_PounceBackPreviewSpecialEffect;                 		// 0x03A8 (0x0004) [0x0000000000000000]              
	class UTgDeviceFire*                               s_ForwardPounceMode;                              		// 0x03AC (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1754 );

		return pClassPointer;
	};

	bool eventShouldTriggerCastReactionItems ( );
	void eventInterruptFiring ( );
	void FireAmmunition ( );
	void KillPounceBackPreview ( );
	void StopPounceBackwardLogic ( unsigned long bNoCooldown );
	void StartPounceBackwardLogic ( );
	void PounceBackTimerExpired ( );
	void StartPounceForwardCooldown ( );
	void StopPounceForwardLogic ( );
	void StartPounceForwardLogic ( );
	bool ServerPounceBackward ( );
	bool PounceBackward ( );
	bool ServerPounceForward ( struct FAimData ClientAim, float EndTraceX, float EndTraceY );
	bool PounceForward ( );
	bool eventUse ( );
	void ClientSetPounceState ( unsigned char NewState );
	void eventSetPounceState ( unsigned char NewState, unsigned long bNoCooldown );
	bool eventCanBeCanceled ( );
	void GetTargetingAim ( struct FAimData* Aim );
	bool HasEnoughPowerPool ( unsigned char FireModeNum );
	void SpawnPounceBackPreview ( );
	float GetRefireTime ( int nMode );
	float GetFiringPreHitDelay ( int nMode );
};

UClass* ATgDevice_BastetPounce::pClassPointer = NULL;

// Class TgGame.TgDevice_Blink
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_Blink : public ATgDevice
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1755 );

		return pClassPointer;
	};

	bool eventCanDeviceStartFiringNow ( unsigned char FireModeNum, struct FAimData Aim, unsigned long bDebugRelevant, unsigned char* failType );
	void eventTimerDeviceAvailable ( );
	bool IsLockedDown ( );
	bool ShowUICanFire ( );
	bool IsTargetingModeReady ( unsigned char* failType );
};

UClass* ATgDevice_Blink::pClassPointer = NULL;

// Class TgGame.TgDevice_Camazotz_Screech
// 0x0010 (0x0390 - 0x0380)
class ATgDevice_Camazotz_Screech : public ATgDevice
{
public:
	unsigned long                                      m_bShouldUpgradeEcho : 1;                         		// 0x0380 (0x0004) [0x0000000000000000] [0x00000001] 
	TArray< class ATgProj_Camazotz_ScreechEcho* >      m_echoProjectiles;                                		// 0x0384 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1756 );

		return pClassPointer;
	};

	void eventDestroyAllEchoes ( );
	void SetPointsAllocated ( int nPoints );
	bool AllocateDevicePoint ( );
};

UClass* ATgDevice_Camazotz_Screech::pClassPointer = NULL;

// Class TgGame.TgDevice_ChainedMelee
// 0x0040 (0x03C0 - 0x0380)
class ATgDevice_ChainedMelee : public ATgDevice
{
public:
	int                                                m_nAttackCounter;                                 		// 0x0380 (0x0004) [0x0000000000000000]              
	TArray< struct FAttackModeInfo >                   c_AttackHistory;                                  		// 0x0384 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< struct FAttackModeInfo >                   c_AttackFuture;                                   		// 0x0390 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                m_nMaxNumFireModes;                               		// 0x039C (0x0004) [0x0000000000000000]              
	int                                                m_nNextChainedFireMode;                           		// 0x03A0 (0x0004) [0x0000000000000000]              
	int                                                m_nSelectedFireMode;                              		// 0x03A4 (0x0004) [0x0000000000000000]              
	float                                              m_fAttackPercentRemaining;                        		// 0x03A8 (0x0004) [0x0000000000000000]              
	float                                              m_fAttackTimeRemaining;                           		// 0x03AC (0x0004) [0x0000000000000000]              
	float                                              m_fPreHitTimeRemaining;                           		// 0x03B0 (0x0004) [0x0000000000000000]              
	float                                              m_fAttackTimeElapsed;                             		// 0x03B4 (0x0004) [0x0000000000000000]              
	float                                              m_fCachedRefireTime;                              		// 0x03B8 (0x0004) [0x0000000000000000]              
	float                                              m_fCachedFirePreHitDelay;                         		// 0x03BC (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1757 );

		return pClassPointer;
	};

	void FixAttack ( int DesiredFireMode, float fDesiredRefireTime, float fAttackTimeDifferential );
	void ClientGoToNextChainAttack ( int AttackNumber, unsigned char DesiredFireMode, float fRefireTime );
	void GoToNextChainAttack ( int nMode );
	void eventInterruptFiring ( );
	void ClientResetChainedAttack ( );
	void eventResetChainedAttack ( );
	int eventCalculateNextMode ( int CurrentMode );
	int eventGetBaseMode ( );
	bool eventCanBeInterrupted ( );
	bool eventCanBeCanceled ( );
	float GetFiringPreHitDelay ( int nMode );
	float GetRefireTime ( int nMode );
};

UClass* ATgDevice_ChainedMelee::pClassPointer = NULL;

// Class TgGame.TgDevice_ActiveMode
// 0x0010 (0x03D0 - 0x03C0)
class ATgDevice_ActiveMode : public ATgDevice_ChainedMelee
{
public:
	int                                                m_nActiveMode;                                    		// 0x03C0 (0x0004) [0x0000000000000000]              
	TArray< struct FActiveModeInfo >                   c_NextActiveModes;                                		// 0x03C4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1758 );

		return pClassPointer;
	};

	void ClientResetChainedAttack ( );
	int CalculateNextMode ( int CurrentMode );
	int GetBaseMode ( );
	void ClientChangeActiveMode ( unsigned char NewMode, int FirstAttackNumber );
	void eventChangeActiveMode ( unsigned char NewMode );
};

UClass* ATgDevice_ActiveMode::pClassPointer = NULL;

// Class TgGame.TgDevice_ErlangShen_Dog_Basic
// 0x0000 (0x03D0 - 0x03D0)
class ATgDevice_ErlangShen_Dog_Basic : public ATgDevice_ActiveMode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1759 );

		return pClassPointer;
	};

};

UClass* ATgDevice_ErlangShen_Dog_Basic::pClassPointer = NULL;

// Class TgGame.TgDevice_Izanami_Inhand
// 0x0004 (0x03D4 - 0x03D0)
class ATgDevice_Izanami_Inhand : public ATgDevice_ActiveMode
{
public:
	class ATgPawn_Izanami*                             IzanamiPawn;                                      		// 0x03D0 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1760 );

		return pClassPointer;
	};

	int CalculateNextMode ( int CurrentMode );
};

UClass* ATgDevice_Izanami_Inhand::pClassPointer = NULL;

// Class TgGame.TgDevice_Sol_BasicAttack
// 0x0000 (0x03D0 - 0x03D0)
class ATgDevice_Sol_BasicAttack : public ATgDevice_ActiveMode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1761 );

		return pClassPointer;
	};

	void eventToggleInstability ( unsigned char NewState );
};

UClass* ATgDevice_Sol_BasicAttack::pClassPointer = NULL;

// Class TgGame.TgDevice_G84_Inhand
// 0x0000 (0x03C0 - 0x03C0)
class ATgDevice_G84_Inhand : public ATgDevice_ChainedMelee
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1762 );

		return pClassPointer;
	};

	void UpdateTargetingModeStatus ( struct FAimData* Aim );
};

UClass* ATgDevice_G84_Inhand::pClassPointer = NULL;

// Class TgGame.TgDevice_Charge
// 0x0030 (0x03B0 - 0x0380)
class ATgDevice_Charge : public ATgDevice
{
public:
	unsigned char                                      m_eChargeState;                                   		// 0x0380 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_bStopOnHitType;                                 		// 0x0381 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_ChargeTimingType;                               		// 0x0382 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_CurrentChargeEndState;                          		// 0x0383 (0x0001) [0x0000000000002000]              ( CPF_Transient )
	class ATgCollisionProxy_Cylinder*                  m_HitProxy;                                       		// 0x0384 (0x0004) [0x0000000000000000]              
	struct FVector                                     m_vHitProxyOffset;                                		// 0x0388 (0x000C) [0x0000000000000000]              
	unsigned long                                      m_bIgnoreHumanoids : 1;                           		// 0x0394 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bHitOnce : 1;                                   		// 0x0394 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_bApplyHitOnTouch : 1;                           		// 0x0394 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_bApplyHitSpecialOnTouch : 1;                    		// 0x0394 (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      m_bIgnoreRange : 1;                               		// 0x0394 (0x0004) [0x0000000000000000] [0x00000010] 
	unsigned long                                      m_bCharging : 1;                                  		// 0x0394 (0x0004) [0x0000000000000000] [0x00000020] 
	unsigned long                                      m_bInterruptDeviceIfChargeEnds : 1;               		// 0x0394 (0x0004) [0x0000000000000000] [0x00000040] 
	unsigned long                                      m_bUseDirectHitSpecial : 1;                       		// 0x0394 (0x0004) [0x0000000000000000] [0x00000080] 
	unsigned long                                      m_bDoNotCompensateForTimerError : 1;              		// 0x0394 (0x0004) [0x0000000000000000] [0x00000100] 
	TArray< class AActor* >                            s_AppliedList;                                    		// 0x0398 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class AActor* >                            s_HitActors;                                      		// 0x03A4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1763 );

		return pClassPointer;
	};

	void EndChargePhysics ( unsigned long bInterrupted );
	void StartChargePhysics ( );
	void OnChargeEnd ( );
	void OnChargeStart ( );
	bool VerifyChargeHit ( struct FVector HitLocation, struct FVector HitNormal, struct FVector TargetLocation, class AActor* Other );
	bool eventPredictChargeHit ( struct FVector ChargeDir, struct FVector ChargeStart, float fChargeRange, struct FVector HitLocation, struct FVector HitNormal, struct FVector TargetLocation, class AActor* Other );
	void OnStoppedChargeOnHit ( class AActor* Other );
	void OnValidTargetTouched ( class AActor* Other );
	void ApplyDamageReduction ( struct FImpactInfo* Impact );
	bool ShouldApplyHitSpecialOnTouch ( class AActor* Target );
	bool ShouldStopOnThisHit ( class AActor* Other );
	float eventGetChargeTime ( );
	float eventGetChargeRange ( );
	bool eventCanBeInterrupted ( );
	bool eventCanBeCanceled ( );
	void ProcessChargeNumber ( int nChargeNumber );
	void ClientStoppingOnHit ( );
	unsigned char GetMaxChargeValue ( );
	unsigned char GetCurrentChargeValue ( );
	void eventEndCharge ( unsigned long bRestart );
	void eventStartCharge ( );
	void eventChargeUnTouch ( class AActor* Other );
	void eventChargeTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void GetTargetingAim ( struct FAimData* Aim );
	void SetFireMode ( int nFireModeNum, unsigned long ForceSet );
};

UClass* ATgDevice_Charge::pClassPointer = NULL;

// Class TgGame.TgDevice_Bellona_ShieldBash
// 0x003C (0x03EC - 0x03B0)
class ATgDevice_Bellona_ShieldBash : public ATgDevice_Charge
{
public:
	int                                                m_nCachedStackCount;                              		// 0x03B0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      m_eSwitchToSet;                                   		// 0x03B4 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_eDoingConeAttack;                               		// 0x03B5 (0x0001) [0x0000000000000000]              
	struct FAimData                                    m_ConeAttackCachedAim;                            		// 0x03B8 (0x002C) [0x0000000000000000]              
	class AActor*                                      s_FirstActorHit;                                  		// 0x03E4 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bRemoveHitActorFromConeDamage : 1;              		// 0x03E8 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1764 );

		return pClassPointer;
	};

	bool eventPredictChargeHit ( struct FVector ChargeDir, struct FVector ChargeStart, float fChargeRange, struct FVector HitLocation, struct FVector HitNormal, struct FVector TargetLocation, class AActor* Other );
	void eventDeviceConsumePowerPool ( unsigned char FireModeNum );
	void ApplyConeAttack ( );
	void DoConeAttack ( );
	void eventInterruptFiring ( );
	void HandleDeviceFormStartFire ( int nDeviceModeNum, float fRefireTime, struct FAimData* Aim );
	void ClientStartConeAttack ( );
	void StartConeAttack ( );
	void TickTargetingMode ( float DeltaSeconds );
	void GetTargetingAim ( struct FAimData* Aim );
	float GetFiringPreHitDelay ( int nMode );
	float GetRefireTime ( int nMode );
};

UClass* ATgDevice_Bellona_ShieldBash::pClassPointer = NULL;

// Class TgGame.TgDevice_XingTian_HeroicCharge
// 0x0004 (0x03F0 - 0x03EC)
class ATgDevice_XingTian_HeroicCharge : public ATgDevice_Bellona_ShieldBash
{
public:
	unsigned long                                      m_bWillHit : 1;                                   		// 0x03EC (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1765 );

		return pClassPointer;
	};

	bool eventPredictChargeHit ( struct FVector ChargeDir, struct FVector ChargeStart, float fChargeRange, struct FVector HitLocation, struct FVector HitNormal, struct FVector TargetLocation, class AActor* Other );
	void TickTargetingMode ( float DeltaSeconds );
};

UClass* ATgDevice_XingTian_HeroicCharge::pClassPointer = NULL;

// Class TgGame.TgDevice_Camazotz_Dev4Shooter
// 0x000C (0x03BC - 0x03B0)
class ATgDevice_Camazotz_Dev4Shooter : public ATgDevice_Charge
{
public:
	int                                                m_nAmmoCount;                                     		// 0x03B0 (0x0004) [0x0000000000000000]              
	int                                                m_nMaxAmmoCount;                                  		// 0x03B4 (0x0004) [0x0000000000000000]              
	int                                                m_nAmmoCountSituationalType;                      		// 0x03B8 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1766 );

		return pClassPointer;
	};

	void ClientSetAmmoCount ( int nAmmoCount );
	void eventSetAmmoCount ( int nAmmoCount, unsigned long bDoNotFowardToClient );
	void eventInterruptFiring ( );
	void eventDeviceConsumePowerPool ( unsigned char FireModeNum );
	int GetProjectileNum ( );
	bool HasEnoughPowerPool ( unsigned char FireModeNum );
	void RemoveEquipEffects ( );
	void ApplyEquipEffects ( );
};

UClass* ATgDevice_Camazotz_Dev4Shooter::pClassPointer = NULL;

// Class TgGame.TgDevice_Chiron_ChargeLong
// 0x0010 (0x03C0 - 0x03B0)
class ATgDevice_Chiron_ChargeLong : public ATgDevice_Charge
{
public:
	unsigned long                                      m_bDoNotNotifyOthers : 1;                         		// 0x03B0 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	unsigned long                                      m_bForceLockout : 1;                              		// 0x03B0 (0x0004) [0x0000000000000000] [0x00000002] 
	float                                              m_fForcedLockoutDuration;                         		// 0x03B4 (0x0004) [0x0000000000000000]              
	float                                              m_fChargeBuffExtendedDuration;                    		// 0x03B8 (0x0004) [0x0000000000000000]              
	class UTgDeviceFire*                               m_CachedFireMode;                                 		// 0x03BC (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1767 );

		return pClassPointer;
	};

	void EndChargeBuff ( );
	void StartChargeBuff ( );
	void EndForcedLockout ( );
	void StartForcedLockout ( );
	void InstantFire ( );
	bool eventCanBeCanceled ( );
	bool eventShouldLockFiring ( class ATgDevice* Current );
	void GetTargetingAim ( struct FAimData* Aim );
};

UClass* ATgDevice_Chiron_ChargeLong::pClassPointer = NULL;

// Class TgGame.TgDevice_DoubleCharge
// 0x000C (0x03BC - 0x03B0)
class ATgDevice_DoubleCharge : public ATgDevice_Charge
{
public:
	unsigned char                                      m_nTotalNumShots;                                 		// 0x03B0 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_nShotsFired;                                    		// 0x03B1 (0x0001) [0x0000000000000000]              
	float                                              m_fAimingTime;                                    		// 0x03B4 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bForceRefire : 1;                               		// 0x03B8 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bShowTargetingDuringFire : 1;                   		// 0x03B8 (0x0004) [0x0000000000000000] [0x00000002] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1768 );

		return pClassPointer;
	};

	void ClientStopFirstCharge ( unsigned char nChargeNumber );
	float eventGetAimTime ( );
	void DeviceConsumePowerPool ( unsigned char FireModeNum );
	bool ServerRefireTimer ( unsigned char nRefireIndex, struct FAimData ClientAim, float EndTraceX, float EndTraceY );
	bool RefireTimer ( unsigned char nRefireIndex );
	void HandleDeviceFormStartFire ( int nDeviceModeNum, float fRefireTime, struct FAimData* Aim );
	bool eventUse ( );
	bool eventCanBeCanceled ( );
	bool CanFireAgain ( );
	void ProcessChargeNumber ( int nChargeNumber );
	void UpdateTargetingModeStatus ( struct FAimData* Aim );
};

UClass* ATgDevice_DoubleCharge::pClassPointer = NULL;

// Class TgGame.TgDevice_Nemesis_Num1
// 0x0000 (0x03BC - 0x03BC)
class ATgDevice_Nemesis_Num1 : public ATgDevice_DoubleCharge
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1769 );

		return pClassPointer;
	};

	bool eventCanDeviceFireNow ( unsigned char FireModeNum, struct FAimData Aim, unsigned long bDeviceFailLog, unsigned long bSkipStunCheck, unsigned char* failType );
};

UClass* ATgDevice_Nemesis_Num1::pClassPointer = NULL;

// Class TgGame.TgDevice_XingTian_HeroicChargeV2
// 0x0058 (0x0414 - 0x03BC)
class ATgDevice_XingTian_HeroicChargeV2 : public ATgDevice_DoubleCharge
{
public:
	struct FAimData                                    m_CachedSecondaryAim;                             		// 0x03BC (0x002C) [0x0000000000000000]              
	struct FAimData                                    c_SecondaryTargetingAim;                          		// 0x03E8 (0x002C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1770 );

		return pClassPointer;
	};

	bool ShouldStopOnThisHit ( class AActor* Other );
	float eventGetAimTime ( );
	void TickTargetingMode ( float DeltaSeconds );
	void UpdateTargetingModeStatus ( struct FAimData* Aim );
	void UpdateAimWhileFiring ( struct FAimData* Aim );
	void GetCachedAim ( struct FAimData* Aim );
	struct FAimData CacheAim ( );
	bool UsesCachedAim ( );
	void GetSecondaryAim ( struct FAimData* Aim, struct FAimData* primaryAim );
	void GetLinearTargetAim ( struct FAimData* Aim );
	float GetFiringPreHitDelay ( int nMode );
	float GetBuildupTime ( int nMode );
};

UClass* ATgDevice_XingTian_HeroicChargeV2::pClassPointer = NULL;

// Class TgGame.TgDevice_ErlangShen_Dog_Dash
// 0x0000 (0x03B0 - 0x03B0)
class ATgDevice_ErlangShen_Dog_Dash : public ATgDevice_Charge
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1771 );

		return pClassPointer;
	};

};

UClass* ATgDevice_ErlangShen_Dog_Dash::pClassPointer = NULL;

// Class TgGame.TgDevice_ErlangShen_Transform
// 0x0014 (0x03C4 - 0x03B0)
class ATgDevice_ErlangShen_Transform : public ATgDevice_Charge
{
public:
	unsigned char                                      r_eTransformType;                                 		// 0x03B0 (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned long                                      m_bDoNotNotifyOthers : 1;                         		// 0x03B4 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	float                                              m_fTransformRanges[ 0x3 ];                        		// 0x03B8 (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1772 );

		return pClassPointer;
	};

	void InstantFire ( );
	void ParentInterruptFiring ( );
	void eventInterruptFiring ( );
	void eventResetCooldown ( int nMode, float fCooldownTimeOverride );
	void eventStartCooldown ( int nMode, float fCooldownTimeOverride );
	void TransformBack ( );
	void TransformTo ( );
	bool eventCanBeCanceled ( );
	unsigned char GetBestTransform ( struct FAimData Aim );
	void GetTargetingAim ( struct FAimData* Aim );
	void TickTargetingMode ( float DeltaSeconds );
	void SetPointsAllocated ( int nPoints );
	bool AllocateDevicePoint ( );
};

UClass* ATgDevice_ErlangShen_Transform::pClassPointer = NULL;

// Class TgGame.TgDevice_ErlangShen_TransformMink
// 0x0004 (0x03C8 - 0x03C4)
class ATgDevice_ErlangShen_TransformMink : public ATgDevice_ErlangShen_Transform
{
public:
	unsigned long                                      m_bTriggerPounce : 1;                             		// 0x03C4 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1773 );

		return pClassPointer;
	};

	void ClientTriggerPounce ( );
	void TriggerPounce ( );
	void eventInterruptFiring ( );
	void TransformBack ( );
};

UClass* ATgDevice_ErlangShen_TransformMink::pClassPointer = NULL;

// Class TgGame.TgDevice_ErlangShen_TransformTurtle
// 0x0000 (0x03C4 - 0x03C4)
class ATgDevice_ErlangShen_TransformTurtle : public ATgDevice_ErlangShen_Transform
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1774 );

		return pClassPointer;
	};

};

UClass* ATgDevice_ErlangShen_TransformTurtle::pClassPointer = NULL;

// Class TgGame.TgDevice_G72_Dev3
// 0x0000 (0x03B0 - 0x03B0)
class ATgDevice_G72_Dev3 : public ATgDevice_Charge
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1775 );

		return pClassPointer;
	};

	bool ShouldConsumePowerPoolAfterFire ( );
	bool ShouldConsumePowerPoolOnStartFire ( );
	void ProcessChargeNumber ( int nChargeNumber );
};

UClass* ATgDevice_G72_Dev3::pClassPointer = NULL;

// Class TgGame.TgDevice_HouYi_Dev3
// 0x0038 (0x03E8 - 0x03B0)
class ATgDevice_HouYi_Dev3 : public ATgDevice_Charge
{
public:
	unsigned long                                      m_bSentTriggerFunction : 1;                       		// 0x03B0 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bDoNotTurnCollisionBackOn : 1;                  		// 0x03B0 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_bLeapingOnStopFire : 1;                         		// 0x03B0 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned char                                      m_eLeapTweenState;                                		// 0x03B4 (0x0001) [0x0000000000000000]              
	class UTgDeviceFire*                               m_ExplosionMode;                                  		// 0x03B8 (0x0004) [0x0000000000000000]              
	struct FAimData                                    m_ExplosionAim;                                   		// 0x03BC (0x002C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1776 );

		return pClassPointer;
	};

	void CancelExplosion ( );
	void TriggerExplosion ( );
	void ClientLeapTriggerSuccess ( );
	void ClientLeapTriggerFailed ( );
	void ServerTriggerLeap ( struct FAimData ClientAim, float EndTraceX, float EndTraceY, int nCompressedRot );
	bool TriggerLeap ( );
	void EndSecondaryTargeting ( );
	void BeginSecondaryTargeting ( );
	void RestoreCollision ( );
	void DisableCollision ( );
	bool eventUse ( );
	bool eventCanTriggerLeap ( );
	void UpdateTargetingModeStatus ( struct FAimData* Aim );
	unsigned char GetTargetingMode ( );
	void GetTargetingAim ( struct FAimData* Aim );
};

UClass* ATgDevice_HouYi_Dev3::pClassPointer = NULL;

// Class TgGame.TgDevice_JingWei_Dev4_AirCharge
// 0x0000 (0x03B0 - 0x03B0)
class ATgDevice_JingWei_Dev4_AirCharge : public ATgDevice_Charge
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1777 );

		return pClassPointer;
	};

	void DeviceShutDown ( unsigned long bDeactiveMode, unsigned long bResetCooldowns );
	void OnChargeEnd ( );
	void OnChargeStart ( );
	bool eventCanBeInterrupted ( );
	bool eventCanBeCanceled ( );
	void SetFireMode ( int nFireModeNum, unsigned long ForceSet );
	bool AdjustCollisionProxyFX ( );
};

UClass* ATgDevice_JingWei_Dev4_AirCharge::pClassPointer = NULL;

// Class TgGame.TgDevice_Kaldr_Dev2
// 0x0000 (0x03B0 - 0x03B0)
class ATgDevice_Kaldr_Dev2 : public ATgDevice_Charge
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1778 );

		return pClassPointer;
	};

	bool ShouldStopOnThisHit ( class AActor* Other );
	bool eventCanBeFiredWhileTweening ( );
	bool eventShouldLockFiring ( class ATgDevice* Current );
	bool eventApplyGlobalOffhandCooldown ( );
	bool AllocateDevicePoint ( );
};

UClass* ATgDevice_Kaldr_Dev2::pClassPointer = NULL;

// Class TgGame.TgDevice_Khepri_Abduct
// 0x0008 (0x03B8 - 0x03B0)
class ATgDevice_Khepri_Abduct : public ATgDevice_Charge
{
public:
	unsigned char                                      m_TargetGrabState;                                		// 0x03B0 (0x0001) [0x0000000000000000]              
	unsigned long                                      m_bInterruptingGrab : 1;                          		// 0x03B4 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1779 );

		return pClassPointer;
	};

	void OnAbductionGrabDetach ( class ATgPawn* OtherPawn, unsigned long bInterrupted );
	void eventForceEarlyGrabDetach ( class AActor* Other );
	void ClientForceStopFire ( unsigned char EndState );
	void eventDestroyed ( );
	void ProcessChargeNumber ( int nChargeNumber );
	void eventInterruptFiring ( );
};

UClass* ATgDevice_Khepri_Abduct::pClassPointer = NULL;

// Class TgGame.TgDevice_Kumbhakarna_Num1
// 0x0014 (0x03C4 - 0x03B0)
class ATgDevice_Kumbhakarna_Num1 : public ATgDevice_Charge
{
public:
	class ATgCollisionProxy*                           m_CollisionProxy;                                 		// 0x03B0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class ATgPawn*                                     m_ThrownPawn;                                     		// 0x03B4 (0x0004) [0x0000000000000000]              
	TArray< class AActor* >                            m_VictimList;                                     		// 0x03B8 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1780 );

		return pClassPointer;
	};

	void eventProxyTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void TweenEndTimer ( );
	void ClientForcePostFire ( );
};

UClass* ATgDevice_Kumbhakarna_Num1::pClassPointer = NULL;

// Class TgGame.TgDevice_Nox_Dev3
// 0x0004 (0x03B4 - 0x03B0)
class ATgDevice_Nox_Dev3 : public ATgDevice_Charge
{
public:
	unsigned long                                      m_bFirstFire : 1;                                 		// 0x03B0 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bInterruptOnCharge : 1;                         		// 0x03B0 (0x0004) [0x0000000000000000] [0x00000002] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1781 );

		return pClassPointer;
	};

	void eventStartCooldown ( int nMode, float fCooldownTimeOverride );
	bool eventShouldAllowGrab ( class ATgPawn_Nox* OwnerPawn, class ATgPawn* OtherPawn );
	bool ShouldStopOnThisHit ( class AActor* Other );
	bool eventShouldCooldownAfterFire ( );
	void eventInterruptFiring ( );
	bool eventCanBeCanceled ( );
};

UClass* ATgDevice_Nox_Dev3::pClassPointer = NULL;

// Class TgGame.TgDevice_Ratatoskr_Dart
// 0x002C (0x03DC - 0x03B0)
class ATgDevice_Ratatoskr_Dart : public ATgDevice_Charge
{
public:
	TArray< class AActor* >                            s_AllHitActors;                                   		// 0x03B0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< struct FPreviousChargeInfo >               s_PreviousChargeInfos;                            		// 0x03BC (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	float                                              m_fPreviousHitTimeout;                            		// 0x03C8 (0x0004) [0x0000000000000000]              
	unsigned long                                      s_bNoCooldownThisFire : 1;                        		// 0x03CC (0x0004) [0x0000000000000000] [0x00000001] 
	int                                                s_nMaxDashCount;                                  		// 0x03D0 (0x0004) [0x0000000000000002]              ( CPF_Const )
	unsigned char                                      m_nLocalDashCounter;                              		// 0x03D4 (0x0001) [0x0000000000000000]              
	float                                              m_fLocalIndividualOffhandCooldown;                		// 0x03D8 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1782 );

		return pClassPointer;
	};

	bool eventCanDeviceStartFiringNow ( unsigned char FireModeNum, struct FAimData Aim, unsigned long bDebugRelevant, unsigned char* failType );
	void AttemptToNotGoOnCooldown ( class AActor* Other );
	void CustomFire ( );
	void eventInterruptFiring ( );
	void ClientRecoverDashCounter ( unsigned char nDashCounter );
	void ClientResetDashCounter ( );
	void ResetDashCounter ( );
	void ProcessChargeNumber ( int nChargeNumber );
	unsigned char GetMaxChargeValue ( );
	unsigned char GetCurrentChargeValue ( );
	unsigned char GetNextChargeNumber ( );
	void eventStartCooldown ( int nMode, float fCooldownTimeOverride );
	bool eventShouldCooldownAfterFire ( );
	void CalcOpalLightningImpactList ( class UTgDeviceFire* DeviceMode, class ATgPawn* DamageInstigator, struct FAimData Aim, float Range, float Radius, int nMaxCount, unsigned long bPredicting, struct FVector InstigatorLocation, TArray< struct FImpactInfo >* ImpactList );
	bool HasBeenPreviouslyHit ( class AActor* HitTarget );
	bool UpdatePreviousHitTargets ( unsigned long bDoNotSave, TArray< class AActor* >* HitActors );
	void SetFireMode ( int nFireModeNum, unsigned long ForceSet );
};

UClass* ATgDevice_Ratatoskr_Dart::pClassPointer = NULL;

// Class TgGame.TgDevice_Ratatoskr_DartV2
// 0x0000 (0x03B0 - 0x03B0)
class ATgDevice_Ratatoskr_DartV2 : public ATgDevice_Charge
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1783 );

		return pClassPointer;
	};

	void ReduceCooldown ( );
};

UClass* ATgDevice_Ratatoskr_DartV2::pClassPointer = NULL;

// Class TgGame.TgDevice_Serqet_Deathbane
// 0x004C (0x03FC - 0x03B0)
class ATgDevice_Serqet_Deathbane : public ATgDevice_Charge
{
public:
	struct FPointer                                    VfTable_ITgSplineDeviceInterface;                 		// 0x03B0 (0x0004) [0x0000000000801002]              ( CPF_Const | CPF_Native | CPF_NoExport )
	unsigned long                                      m_bStartDashRight : 1;                            		// 0x03B4 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bDoNotUseTargetingRangeConstraint : 1;          		// 0x03B4 (0x0004) [0x0000000000000000] [0x00000002] 
	struct FVector2D                                   m_fTargetPointOffsetFromCenter;                   		// 0x03B8 (0x0008) [0x0000000000000000]              
	TArray< struct FVector >                           m_CachedTargetPoints;                             		// 0x03C0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                m_nCurrentCacheAimIndex;                          		// 0x03CC (0x0004) [0x0000000000000000]              
	int                                                m_nNumTargetPoints;                               		// 0x03D0 (0x0004) [0x0000000000000000]              
	float                                              m_fCachedSpeed;                                   		// 0x03D4 (0x0004) [0x0000000000000000]              
	class UClass*                                      m_FiringCameraModuleClass;                        		// 0x03D8 (0x0004) [0x0000000000000000]              
	class UClass*                                      m_PreviousCameraModuleClass;                      		// 0x03DC (0x0004) [0x0000000000000000]              
	class UTgCameraModule*                             m_CachedCameraModule;                             		// 0x03E0 (0x0004) [0x0000000000000000]              
	float                                              m_fCameraTweenInTime;                             		// 0x03E4 (0x0004) [0x0000000000000000]              
	float                                              m_fCameraTweenOutTime;                            		// 0x03E8 (0x0004) [0x0000000000000000]              
	struct FInterpCurveVector                          c_TargetingSpline;                                		// 0x03EC (0x0010) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1784 );

		return pClassPointer;
	};

	bool VerifyChargeHit ( struct FVector HitLocation, struct FVector HitNormal, struct FVector TargetLocation, class AActor* Other );
	bool eventPredictChargeHit ( struct FVector ChargeDir, struct FVector ChargeStart, float fChargeRange, struct FVector HitLocation, struct FVector HitNormal, struct FVector TargetLocation, class AActor* Other );
	void TurnOffSpecialCamera ( );
	void TurnOnSpecialCamera ( );
	void eventInstantFire ( );
	void ProcessChargeNumber ( int nChargeNumber );
	unsigned char GetMaxChargeValue ( );
	unsigned char GetCurrentChargeValue ( );
	void eventGetAdjustedAimSpline ( int nShotIndex, struct FAimData* Aim );
	float GetRefireTime ( int nMode );
	float GetFiringPreHitDelay ( int nMode );
	void TickTargetingMode ( float DeltaSeconds );
	bool CalculateFlightPath ( int nIndex, class UTgDeviceFire* DeviceMode, struct FInterpCurveVector* Spline, struct FAimData* Aim );
	void GetCachedAim ( struct FAimData* Aim );
	struct FAimData CacheAim ( );
	bool UsesCachedAim ( );
	void GetTargetingAim ( struct FAimData* Aim );
	void SetFireMode ( int nFireModeNum, unsigned long ForceSet );
	bool HasEnoughPowerPool ( unsigned char FireModeNum );
};

UClass* ATgDevice_Serqet_Deathbane::pClassPointer = NULL;

// Class TgGame.TgDevice_SunWukong_Transform
// 0x0018 (0x03C8 - 0x03B0)
class ATgDevice_SunWukong_Transform : public ATgDevice_Charge
{
public:
	unsigned char                                      r_eTransformType;                                 		// 0x03B0 (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned long                                      m_bDoNotNotifyOthers : 1;                         		// 0x03B4 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	float                                              m_fTransformRanges[ 0x4 ];                        		// 0x03B8 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1785 );

		return pClassPointer;
	};

	void InstantFire ( );
	void ParentInterruptFiring ( );
	void eventInterruptFiring ( );
	void eventResetCooldown ( int nMode, float fCooldownTimeOverride );
	void eventStartCooldown ( int nMode, float fCooldownTimeOverride );
	void TransformBack ( );
	void TransformTo ( );
	bool eventCanBeCanceled ( );
	unsigned char GetBestTransform ( struct FAimData Aim );
	void GetTargetingAim ( struct FAimData* Aim );
	void TickTargetingMode ( float DeltaSeconds );
	void SetPointsAllocated ( int nPoints );
	bool AllocateDevicePoint ( );
	void SetFireMode ( int nFireModeNum, unsigned long ForceSet );
};

UClass* ATgDevice_SunWukong_Transform::pClassPointer = NULL;

// Class TgGame.TgDevice_Susano_Dev2_Part1
// 0x0004 (0x03B4 - 0x03B0)
class ATgDevice_Susano_Dev2_Part1 : public ATgDevice_Charge
{
public:
	unsigned long                                      r_IsToggledOn : 1;                                		// 0x03B0 (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1786 );

		return pClassPointer;
	};

	bool eventShouldTriggerCastReactionItems ( );
	bool eventShouldCooldownAfterFire ( );
	void ProcessChargeNumber ( int nChargeNumber );
	void eventReplicatedEvent ( struct FName VarName );
	bool IsToggledOn ( );
	void RemoveEquipEffects ( );
	void ApplyEquipEffects ( );
};

UClass* ATgDevice_Susano_Dev2_Part1::pClassPointer = NULL;

// Class TgGame.TgDevice_Terra_MegaPunch
// 0x0004 (0x03B4 - 0x03B0)
class ATgDevice_Terra_MegaPunch : public ATgDevice_Charge
{
public:
	unsigned long                                      r_IsBonusCharge : 1;                              		// 0x03B0 (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )
	unsigned long                                      r_HitWall : 1;                                    		// 0x03B0 (0x0004) [0x0000000000000020] [0x00000002] ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1787 );

		return pClassPointer;
	};

	bool eventShouldCooldownAfterFire ( );
	void DeviceConsumePowerPool ( unsigned char FireModeNum );
	void ProcessChargeNumber ( int nChargeNumber );
	bool IsNextUsageFree ( );
	bool IsTargetingModeReady ( unsigned char* failType );
	bool HasEnoughPowerPool ( unsigned char FireModeNum );
	void UpdateManaUseVitals ( class ATgPlayerController* PC );
};

UClass* ATgDevice_Terra_MegaPunch::pClassPointer = NULL;

// Class TgGame.TgDevice_Thoth_AutoCharge
// 0x0000 (0x03B0 - 0x03B0)
class ATgDevice_Thoth_AutoCharge : public ATgDevice_Charge
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1788 );

		return pClassPointer;
	};

	bool eventShouldLockFiring ( class ATgDevice* Current );
	void ProcessChargeNumber ( int nChargeNumber );
	void GetTargetingAim ( struct FAimData* Aim );
};

UClass* ATgDevice_Thoth_AutoCharge::pClassPointer = NULL;

// Class TgGame.TgDevice_Thoth_Dash
// 0x0000 (0x03B0 - 0x03B0)
class ATgDevice_Thoth_Dash : public ATgDevice_Charge
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1789 );

		return pClassPointer;
	};

	float eventGetChargeRange ( );
	void ProcessChargeNumber ( int nChargeNumber );
	void GetLinearTargetAim ( struct FAimData* Aim );
};

UClass* ATgDevice_Thoth_Dash::pClassPointer = NULL;

// Class TgGame.TgDevice_Chiron_Passive
// 0x0004 (0x0384 - 0x0380)
class ATgDevice_Chiron_Passive : public ATgDevice
{
public:
	class AActor*                                      r_CurrentTarget;                                  		// 0x0380 (0x0004) [0x0000000000000020]              ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1790 );

		return pClassPointer;
	};

	class AProjectile* ProjectileFire ( int ProjectileIndex );
	class AActor* GetTrackingTarget ( int nFireIndex );
	bool eventUsesTrackingTarget ( );
	void UpdateTarget ( );
};

UClass* ATgDevice_Chiron_Passive::pClassPointer = NULL;

// Class TgGame.TgDevice_Chiron_SpreadShotShooter
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_Chiron_SpreadShotShooter : public ATgDevice
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1791 );

		return pClassPointer;
	};

	bool eventUsesTrackingTarget ( );
	class AActor* GetTrackingTarget ( int nFireIndex );
	class AProjectile* ProjectileFire ( int ProjectileIndex );
	void eventGetAdjustedAim ( int nShotIndex, struct FAimData* Aim );
	void GetTargetingAim ( struct FAimData* Aim );
};

UClass* ATgDevice_Chiron_SpreadShotShooter::pClassPointer = NULL;

// Class TgGame.TgDevice_Chiron_UltimateShooter
// 0x0004 (0x0384 - 0x0380)
class ATgDevice_Chiron_UltimateShooter : public ATgDevice
{
public:
	unsigned long                                      r_IsFinalShot : 1;                                		// 0x0380 (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1792 );

		return pClassPointer;
	};

	float GetFiringPostHitDelay ( int nMode );
	void TickTargetingMode ( float DeltaSeconds );
};

UClass* ATgDevice_Chiron_UltimateShooter::pClassPointer = NULL;

// Class TgGame.TgDevice_Container
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_Container : public ATgDevice
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1793 );

		return pClassPointer;
	};

};

UClass* ATgDevice_Container::pClassPointer = NULL;

// Class TgGame.TgDevice_Deployable
// 0x0008 (0x0388 - 0x0380)
class ATgDevice_Deployable : public ATgDevice
{
public:
	class ATgDeployable*                               r_Deployable;                                     		// 0x0380 (0x0004) [0x0000000000000020]              ( CPF_Net )
	unsigned long                                      m_bUseMovingEffectVolumeAim : 1;                  		// 0x0384 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1794 );

		return pClassPointer;
	};

	void eventOnDeployableDeployComplete ( class ATgDeployable* deployable );
	void eventOnDeployableSpawned ( class ATgDeployable* deployable );
	void eventOnDeployableDestroyed ( class ATgDeployable* deployable );
	void GetTargetingAim ( struct FAimData* Aim );
};

UClass* ATgDevice_Deployable::pClassPointer = NULL;

// Class TgGame.TgDevice_AgniRainFire
// 0x000C (0x0394 - 0x0388)
class ATgDevice_AgniRainFire : public ATgDevice_Deployable
{
public:
	int                                                r_RainFireAmmunitionCount;                        		// 0x0388 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              m_ElapsedRechargeTime;                            		// 0x038C (0x0004) [0x0000000000000000]              
	float                                              m_LastTickCooldownUpdate;                         		// 0x0390 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1795 );

		return pClassPointer;
	};

	bool eventShouldTriggerCastReactionItems ( );
	void eventExpendRainFireAmmunition ( unsigned long bSkipDischargeTime );
	bool ShouldCooldownAfterFire ( );
	void eventReplenishRainFireAmmunition ( );
	void Tick ( float DeltaSeconds );
	bool UpdateAmmoRechargeTime ( float DeltaSeconds );
	void ClientReduceAmmoRechargeTime ( float fValue, unsigned long bFull );
	void eventReduceAmmoRechargeTime ( float fValue, unsigned long bPercentage );
	bool eventCanDeviceFireNow ( unsigned char FireModeNum, struct FAimData Aim, unsigned long bDeviceFailLog, unsigned long bSkipStunCheck, unsigned char* failType );
	bool ShouldSwitchBackToBasicAttackTargeting ( unsigned char CastMode );
	void RemoveEquipEffects ( );
	void ApplyEquipEffects ( );
	void SetFireMode ( int nFireMode, unsigned long ForceSet );
	bool AllocateDevicePoint ( );
	bool IsTargetingModeReady ( unsigned char* failType );
	bool ShowUICanFire ( );
	void UpdateTargetingModeStatus ( struct FAimData* Aim );
};

UClass* ATgDevice_AgniRainFire::pClassPointer = NULL;

// Class TgGame.TgDevice_AhMuzenCab_Hive
// 0x000C (0x0394 - 0x0388)
class ATgDevice_AhMuzenCab_Hive : public ATgDevice_Deployable
{
public:
	int                                                r_nCurrentAmmo;                                   		// 0x0388 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              m_fElapsedAddAmmoTime;                            		// 0x038C (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bUseAmmo : 1;                                   		// 0x0390 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1796 );

		return pClassPointer;
	};

	bool ShouldCooldownAfterFire ( );
	void eventAddAmmo ( int Amount );
	void Tick ( float DeltaSeconds );
	bool eventCanDeviceFireNow ( unsigned char FireModeNum, struct FAimData Aim, unsigned long bDeviceFailLog, unsigned long bSkipStunCheck, unsigned char* failType );
	bool IsTargetingModeReady ( unsigned char* failType );
	bool ShowUICanFire ( );
};

UClass* ATgDevice_AhMuzenCab_Hive::pClassPointer = NULL;

// Class TgGame.TgDevice_AhMuzenCab_Honey
// 0x0014 (0x039C - 0x0388)
class ATgDevice_AhMuzenCab_Honey : public ATgDevice_Deployable
{
public:
	int                                                m_nRemainingDeployables;                          		// 0x0388 (0x0004) [0x0000000000000000]              
	struct FVector                                     m_vLastDeployLocation;                            		// 0x038C (0x000C) [0x0000000000000000]              
	float                                              m_fDistanceBetweenDeployables;                    		// 0x0398 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1797 );

		return pClassPointer;
	};

	void eventOnDeployableSpawned ( class ATgDeployable* deployable );
	void CustomFire ( );
	void eventDeployNextHoney ( );
	bool eventStartFire ( );
};

UClass* ATgDevice_AhMuzenCab_Honey::pClassPointer = NULL;

// Class TgGame.TgDevice_Apep_AcidSpray
// 0x0020 (0x03A8 - 0x0388)
class ATgDevice_Apep_AcidSpray : public ATgDevice_Deployable
{
public:
	int                                                m_nRemainingDeployables;                          		// 0x0388 (0x0004) [0x0000000000000000]              
	struct FVector                                     m_vLastDeployLocation;                            		// 0x038C (0x000C) [0x0000000000000000]              
	float                                              m_fDistanceBetweenDeployables;                    		// 0x0398 (0x0004) [0x0000000000000000]              
	TArray< struct FDeployTouchStatus >                m_DeployRegistration;                             		// 0x039C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1798 );

		return pClassPointer;
	};

	void eventUnregisterDeployTouch ( class AActor* Other, class UTgDeviceFire* m_deployFireMode );
	void eventRegisterDeployTouch ( class AActor* Other, class UTgDeviceFire* m_deployFireMode );
	void eventOnDeployableSpawned ( class ATgDeployable* deployable );
	void CustomFire ( );
	void eventDeployNextAcidPool ( );
	bool eventStartFire ( );
};

UClass* ATgDevice_Apep_AcidSpray::pClassPointer = NULL;

// Class TgGame.TgDevice_Apollo_SkyJump
// 0x0000 (0x0388 - 0x0388)
class ATgDevice_Apollo_SkyJump : public ATgDevice_Deployable
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1799 );

		return pClassPointer;
	};

	void eventOnDeployableSpawned ( class ATgDeployable* deployable );
	void eventOnDeployableDestroyed ( class ATgDeployable* deployable );
	bool eventCanBeCanceled ( );
	bool eventApplyGlobalOffhandCooldown ( );
	void GetGroundTargetAim ( struct FAimData* Aim );
};

UClass* ATgDevice_Apollo_SkyJump::pClassPointer = NULL;

// Class TgGame.TgDevice_Arachne_ComplicatedWebWall
// 0x0010 (0x0398 - 0x0388)
class ATgDevice_Arachne_ComplicatedWebWall : public ATgDevice_Deployable
{
public:
	int                                                m_nTrailDeviceId;                                 		// 0x0388 (0x0004) [0x0000000000000000]              
	TArray< class UTgDeviceFire* >                     m_TrailSpawningModes;                             		// 0x038C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1800 );

		return pClassPointer;
	};

	void AttachTrailComponent ( class AActor* TrailTarget, class UTgDeviceFire* DeviceModeReference );
};

UClass* ATgDevice_Arachne_ComplicatedWebWall::pClassPointer = NULL;

// Class TgGame.TgDevice_Arachne_NewWeb
// 0x0000 (0x0398 - 0x0398)
class ATgDevice_Arachne_NewWeb : public ATgDevice_Arachne_ComplicatedWebWall
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1801 );

		return pClassPointer;
	};

	void CustomProjectileInit ( class AProjectile* Proj, int ProjIndex, struct FAimData BaseAim );
	void TickTargetingMode ( float DeltaSeconds );
	void GetTargetingAim ( struct FAimData* Aim );
};

UClass* ATgDevice_Arachne_NewWeb::pClassPointer = NULL;

// Class TgGame.TgDevice_AutoPortal
// 0x008C (0x0414 - 0x0388)
class ATgDevice_AutoPortal : public ATgDevice_Deployable
{
public:
	struct FAimData                                    m_SecondaryAim;                                   		// 0x0388 (0x002C) [0x0000000000000000]              
	struct FAimData                                    m_CachedSecondaryAim;                             		// 0x03B4 (0x002C) [0x0000000000000000]              
	struct FAimData                                    s_ReceivedSecondaryAim;                           		// 0x03E0 (0x002C) [0x0000000000000000]              
	unsigned long                                      m_bOutOfRange : 1;                                		// 0x040C (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bCachedOutOfRange : 1;                          		// 0x040C (0x0004) [0x0000000000000000] [0x00000002] 
	float                                              m_fMaxPortalRange;                                		// 0x0410 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1802 );

		return pClassPointer;
	};

	void ServerPortalStartFire ( float P1X, float P1Y, float P2X, float P2Y, int nCompressedRot, unsigned long bUseSecondaryAim );
	bool eventStartFire ( );
	void HandleDeviceFormStartFire ( int nDeviceModeNum, float fRefireTime, struct FAimData* Aim );
	void TickTargetingMode ( float DeltaSeconds );
	struct FAimData CacheAim ( );
	void GetTargetingAim ( struct FAimData* Aim );
	bool UsesCachedAim ( );
};

UClass* ATgDevice_AutoPortal::pClassPointer = NULL;

// Class TgGame.TgDevice_Camazotz_Essence
// 0x0008 (0x0390 - 0x0388)
class ATgDevice_Camazotz_Essence : public ATgDevice_Deployable
{
public:
	class ATgPawn*                                     s_SpawnerPawn;                                    		// 0x0388 (0x0004) [0x0000000000000000]              
	float                                              s_fSpawnTimeStamp;                                		// 0x038C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1803 );

		return pClassPointer;
	};

	void eventOnDeployableDestroyed ( class ATgDeployable* deployable );
	void eventOnDeployableSpawned ( class ATgDeployable* deployable );
};

UClass* ATgDevice_Camazotz_Essence::pClassPointer = NULL;

// Class TgGame.TgDevice_Chiron_TrainingExercise
// 0x0000 (0x0388 - 0x0388)
class ATgDevice_Chiron_TrainingExercise : public ATgDevice_Deployable
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1804 );

		return pClassPointer;
	};

	void FireAmmunition ( );
};

UClass* ATgDevice_Chiron_TrainingExercise::pClassPointer = NULL;

// Class TgGame.TgDevice_Fafnir_Dev4
// 0x0000 (0x0388 - 0x0388)
class ATgDevice_Fafnir_Dev4 : public ATgDevice_Deployable
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1805 );

		return pClassPointer;
	};

	void eventOnDeployableDeployComplete ( class ATgDeployable* deployable );
	bool eventCanDeviceFireNow ( unsigned char FireModeNum, struct FAimData Aim, unsigned long bDeviceFailLog, unsigned long bSkipStunCheck, unsigned char* failType );
	bool eventShouldCooldownAfterFire ( );
};

UClass* ATgDevice_Fafnir_Dev4::pClassPointer = NULL;

// Class TgGame.TgDevice_Fafnir_Dev4_D
// 0x0000 (0x0388 - 0x0388)
class ATgDevice_Fafnir_Dev4_D : public ATgDevice_Deployable
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1806 );

		return pClassPointer;
	};

	void eventOnDeployableDeployComplete ( class ATgDeployable* deployable );
	bool AllocateDevicePoint ( );
};

UClass* ATgDevice_Fafnir_Dev4_D::pClassPointer = NULL;

// Class TgGame.TgDevice_Khepri_ScarabsFlight
// 0x0018 (0x03A0 - 0x0388)
class ATgDevice_Khepri_ScarabsFlight : public ATgDevice_Deployable
{
public:
	class ATgDeployable*                               r_KhepriBasedScarab;                              		// 0x0388 (0x0004) [0x0000000000000020]              ( CPF_Net )
	TArray< class AActor* >                            alreadyTaken;                                     		// 0x038C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class UTgSpecialFx*                                m_RangedChargingFx;                               		// 0x0398 (0x0004) [0x0000000000000000]              
	unsigned long                                      r_bRangedScarabCharging : 1;                      		// 0x039C (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )
	unsigned long                                      r_bBasedScarabCharging : 1;                       		// 0x039C (0x0004) [0x0000000000000020] [0x00000002] ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1807 );

		return pClassPointer;
	};

	void Tick ( float DeltaTime );
	bool UseFlight ( class AActor* passenger );
	bool CanUseFlight ( class AActor* passenger );
	struct FVector GetFlightLocationFrom ( class ATgDeployable* launchPad );
	void eventOnDeployableSpawned ( class ATgDeployable* deployable );
	void UpdateBasedFx ( );
	void UpdateRangedFx ( );
	void eventReplicatedEvent ( struct FName VarName );
	void SpawnKhepriBasedScarab ( );
};

UClass* ATgDevice_Khepri_ScarabsFlight::pClassPointer = NULL;

// Class TgGame.TgDevice_Neith_BrokenWeave
// 0x0018 (0x03A0 - 0x0388)
class ATgDevice_Neith_BrokenWeave : public ATgDevice_Deployable
{
public:
	unsigned char                                      s_eNextWeaveSpawnType;                            		// 0x0388 (0x0001) [0x0000000000000000]              
	class ATgPawn*                                     s_NextSourcePawn;                                 		// 0x038C (0x0004) [0x0000000000000000]              
	class ATgDeployable_Neith_BrokenWeave*             s_BackflipWeave;                                  		// 0x0390 (0x0004) [0x0000000000000000]              
	TArray< struct FWeaveSpawnInfo >                   s_PawnDeathWeaves;                                		// 0x0394 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1808 );

		return pClassPointer;
	};

	void eventOnDeployableSpawned ( class ATgDeployable* deployable );
	void eventOnDeployableDestroyed ( class ATgDeployable* deployable );
};

UClass* ATgDevice_Neith_BrokenWeave::pClassPointer = NULL;

// Class TgGame.TgDevice_Nike_Dev4
// 0x0004 (0x038C - 0x0388)
class ATgDevice_Nike_Dev4 : public ATgDevice_Deployable
{
public:
	unsigned long                                      c_bWasDev2Active : 1;                             		// 0x0388 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1809 );

		return pClassPointer;
	};

};

UClass* ATgDevice_Nike_Dev4::pClassPointer = NULL;

// Class TgGame.TgDevice_NuWa_GlobalUltimate
// 0x0034 (0x03BC - 0x0388)
class ATgDevice_NuWa_GlobalUltimate : public ATgDevice_Deployable
{
public:
	class ATgPawn_NuWaV2*                              s_CachedNuWa;                                     		// 0x0388 (0x0004) [0x0000000000000000]              
	float                                              m_fChargeRange;                                   		// 0x038C (0x0004) [0x0000000000000000]              
	unsigned char                                      m_eChargeType;                                    		// 0x0390 (0x0001) [0x0000000000000000]              
	unsigned long                                      m_bCharging : 1;                                  		// 0x0394 (0x0004) [0x0000000000000000] [0x00000001] 
	TArray< class ATgDeployable* >                     s_ActiveDeployables;                              		// 0x0398 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class AActor* >                            s_ExemptActors;                                   		// 0x03A4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class AActor* >                            s_WarnedActors;                                   		// 0x03B0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1810 );

		return pClassPointer;
	};

	void RemoveWarningEffects ( unsigned long bInterrupted );
	void ApplyWarningEffects ( );
	void CustomFire ( );
	struct FImpactInfo CalcWeaponFire ( struct FAimData Aim, TArray< struct FImpactInfo >* ImpactList );
	class ATgRepInfo_TaskForce* GetEnemyTaskForce ( int* nIndex );
	bool eventCanBeCanceled ( );
	bool eventShouldLockFiring ( class ATgDevice* Current );
	void eventOnDeployableSpawned ( class ATgDeployable* deployable );
	void eventOnDeployableDestroyed ( class ATgDeployable* deployable );
	void SetFireMode ( int nFireModeNum, unsigned long ForceSet );
	bool UsesCachedAim ( );
};

UClass* ATgDevice_NuWa_GlobalUltimate::pClassPointer = NULL;

// Class TgGame.TgDevice_Scylla_Num3
// 0x0038 (0x03C0 - 0x0388)
class ATgDevice_Scylla_Num3 : public ATgDevice_Deployable
{
public:
	float                                              m_fTargetTime;                                    		// 0x0388 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bDeductCooldownTime : 1;                        		// 0x038C (0x0004) [0x0000000000000002] [0x00000001] ( CPF_Const )
	unsigned long                                      m_bCanFireWithoutTarget : 1;                      		// 0x038C (0x0004) [0x0000000000000000] [0x00000002] 
	float                                              m_fStopFireTimeStamp;                             		// 0x0390 (0x0004) [0x0000000000000000]              
	float                                              m_fCachedCooldownTime;                            		// 0x0394 (0x0004) [0x0000000000000000]              
	float                                              m_fCachedTweenTime;                               		// 0x0398 (0x0004) [0x0000000000000000]              
	class UTgDeviceFire*                               m_CachedFireMode;                                 		// 0x039C (0x0004) [0x0000000000000000]              
	unsigned char                                      m_eLocalState;                                    		// 0x03A0 (0x0001) [0x0000000000000000]              
	class ATgCollisionProxy_Cylinder*                  m_HitProxy;                                       		// 0x03A4 (0x0004) [0x0000000000000000]              
	struct FVector                                     m_TweenStartLocation;                             		// 0x03A8 (0x000C) [0x0000000000000000]              
	TArray< class AActor* >                            s_HitActors;                                      		// 0x03B4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1811 );

		return pClassPointer;
	};

	void eventTweenTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void DeviceShutDown ( unsigned long bDeactiveMode, unsigned long bResetCooldowns );
	struct FImpactInfo CalcWeaponFire ( struct FAimData Aim, TArray< struct FImpactInfo >* ImpactList );
	void InterruptFiring ( );
	void OnPreTeleport ( );
	void ClientSetState ( unsigned char NewState );
	void eventSetState ( unsigned char NewState, unsigned long bStartCooldown );
	void FireAmmunition ( );
	void ExpireTarget ( );
	void eventOnDeployableDestroyed ( class ATgDeployable* deployable );
	void EndToggledAction ( );
	bool ToggledAction ( float* fPreHitDelay );
	bool ServerDoToggledAction ( class AActor* Target );
	bool DoToggledAction ( );
	bool eventUse ( );
	bool eventShouldCooldownAfterFire ( );
	bool eventCanUseToggle ( );
	float GetFiringPostHitDelay ( int nMode );
	float GetFiringPreHitDelay ( int nMode );
	float GetBuildupTime ( int nMode );
	bool CanBeCrippled ( );
	void GetTargetingAim ( struct FAimData* Aim );
	void SetFireMode ( int nFireModeNum, unsigned long ForceSet );
	bool HasEnoughPowerPool ( unsigned char FireModeNum );
};

UClass* ATgDevice_Scylla_Num3::pClassPointer = NULL;

// Class TgGame.TgDevice_Skadi_Dev1
// 0x000C (0x0394 - 0x0388)
class ATgDevice_Skadi_Dev1 : public ATgDevice_Deployable
{
public:
	TArray< class AActor* >                            m_ValidAOETargets;                                		// 0x0388 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1812 );

		return pClassPointer;
	};

	void TickTargetingMode ( float DeltaSeconds );
	bool AllocateDevicePoint ( );
};

UClass* ATgDevice_Skadi_Dev1::pClassPointer = NULL;

// Class TgGame.TgDevice_Skadi_Dev3
// 0x0000 (0x0388 - 0x0388)
class ATgDevice_Skadi_Dev3 : public ATgDevice_Deployable
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1813 );

		return pClassPointer;
	};

};

UClass* ATgDevice_Skadi_Dev3::pClassPointer = NULL;

// Class TgGame.TgDevice_Sol_Dev1
// 0x0000 (0x0388 - 0x0388)
class ATgDevice_Sol_Dev1 : public ATgDevice_Deployable
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1814 );

		return pClassPointer;
	};

	bool eventCanBeCanceled ( );
	bool eventShouldInterruptInhand ( );
};

UClass* ATgDevice_Sol_Dev1::pClassPointer = NULL;

// Class TgGame.TgDevice_Sol_Dev2
// 0x0004 (0x038C - 0x0388)
class ATgDevice_Sol_Dev2 : public ATgDevice_Deployable
{
public:
	unsigned long                                      r_bIsToggledOn : 1;                               		// 0x0388 (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1815 );

		return pClassPointer;
	};

	void eventStartCooldown ( int nMode, float fCooldownTimeOverride );
	void eventInterruptFiring ( );
	bool eventCustomCanDeviceFireNow ( unsigned char FireModeNum, struct FAimData Aim, unsigned long bDeviceFailLog, unsigned char* failType );
	bool eventShouldCooldownAfterFire ( );
	void eventReplicatedEvent ( struct FName VarName );
	void StartShockwaveAt ( struct FVector SpawnLoc );
	bool IsToggledOn ( );
};

UClass* ATgDevice_Sol_Dev2::pClassPointer = NULL;

// Class TgGame.TgDevice_Sol_Trail
// 0x0004 (0x038C - 0x0388)
class ATgDevice_Sol_Trail : public ATgDevice_Deployable
{
public:
	unsigned long                                      r_bPassiveActive : 1;                             		// 0x0388 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1816 );

		return pClassPointer;
	};

	bool eventCustomCanDeviceFireNow ( unsigned char FireModeNum, struct FAimData Aim, unsigned long bDeviceFailLog, unsigned char* failType );
	bool eventShouldCooldownAfterFire ( );
	void Tick ( float DeltaTime );
	bool DeactivateTrail ( );
	bool ActivateTrail ( );
};

UClass* ATgDevice_Sol_Trail::pClassPointer = NULL;

// Class TgGame.TgDevice_Sol_Ult
// 0x0028 (0x03B0 - 0x0388)
class ATgDevice_Sol_Ult : public ATgDevice_Deployable
{
public:
	unsigned long                                      s_bSpecialFire : 1;                               		// 0x0388 (0x0004) [0x0000000000000000] [0x00000001] 
	int                                                m_nRemainingDeployables;                          		// 0x038C (0x0004) [0x0000000000000000]              
	struct FVector                                     m_vLastDeployLocation;                            		// 0x0390 (0x000C) [0x0000000000000000]              
	float                                              m_fDistanceBetweenDeployables;                    		// 0x039C (0x0004) [0x0000000000000000]              
	float                                              m_fNextDeployableDelay;                           		// 0x03A0 (0x0004) [0x0000000000000000]              
	TArray< class ATgPawn* >                           HitPawns;                                         		// 0x03A4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1817 );

		return pClassPointer;
	};

	void eventOnDeployableSpawned ( class ATgDeployable* deployable );
	void CustomFire ( );
	void eventDropNext ( );
	bool eventStartFire ( );
};

UClass* ATgDevice_Sol_Ult::pClassPointer = NULL;

// Class TgGame.TgDevice_Terra_CrushingShale
// 0x0044 (0x03CC - 0x0388)
class ATgDevice_Terra_CrushingShale : public ATgDevice_Deployable
{
public:
	unsigned char                                      r_CurrentState;                                   		// 0x0388 (0x0001) [0x0000000000000020]              ( CPF_Net )
	TArray< class ATgDeployable* >                     s_ActiveDeployables;                              		// 0x038C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class ATgDeployable_Terra_CrushingShale*           m_LastSpawned;                                    		// 0x0398 (0x0004) [0x0000000000000000]              
	class ATgDeployable_Terra_Trap*                    m_Trap;                                           		// 0x039C (0x0004) [0x0000000000000000]              
	struct FAimData                                    m_DeployAim;                                      		// 0x03A0 (0x002C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1818 );

		return pClassPointer;
	};

	void eventOnDeployableDestroyed ( class ATgDeployable* deployable );
	void eventOnDeployableDeployComplete ( class ATgDeployable* deployable );
	void eventOnDeployableSpawned ( class ATgDeployable* deployable );
	void eventTryTriggerCrush ( );
	void RefireTimerExpire ( );
	bool eventCustomCanDeviceFireNow ( unsigned char FireModeNum, struct FAimData Aim, unsigned long bDeviceFailLog, unsigned char* failType );
	bool eventShouldCooldownAfterFire ( );
	void UpdateCurrentState ( );
	void eventSetCurrentState ( unsigned char State );
	void SetNextAnimState ( unsigned long IsDetonating );
	void DeviceConsumePowerPool ( unsigned char FireModeNum );
	void eventReplicatedEvent ( struct FName VarName );
	unsigned char IncrementFiringInstance ( );
	void GetTargetingAim ( struct FAimData* Aim );
	float GetFiringPostHitDelay ( int nMode );
	float GetFiringPreHitDelay ( int nMode );
	void UpdateManaUseVitals ( class ATgPlayerController* PC );
	bool HasEnoughPowerPool ( unsigned char FireModeNum );
};

UClass* ATgDevice_Terra_CrushingShale::pClassPointer = NULL;

// Class TgGame.TgDevice_TogglableDeployable
// 0x0014 (0x039C - 0x0388)
class ATgDevice_TogglableDeployable : public ATgDevice_Deployable
{
public:
	unsigned char                                      m_eToggleState;                                   		// 0x0388 (0x0001) [0x0000000000000000]              
	unsigned long                                      m_bWaitForDeploy : 1;                             		// 0x038C (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bCanToggleOffWhenDead : 1;                      		// 0x038C (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_bDoCanDeviceFireCheckOnToggleOff : 1;           		// 0x038C (0x0004) [0x0000000000000000] [0x00000004] 
	TArray< class ATgProjectile* >                     s_DeployingProjectiles;                           		// 0x0390 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1819 );

		return pClassPointer;
	};

	void OnProjectileShutdown ( class ATgProjectile* Proj );
	class AProjectile* ProjectileFire ( int ProjectileIndex );
	void InterruptFiring ( );
	void eventOnDeployableSpawned ( class ATgDeployable* deployable );
	void ToggleOffConsumePowerPool ( class ATgDeployable* deployable );
	bool ServerToggleOff ( );
	void ServerToggleOn ( struct FAimData ClientAim, float EndTraceX, float EndTraceY, int nCompressedRot );
	bool ToggleOff ( );
	bool ToggleOn ( );
	bool Use ( );
	bool eventCanBeCanceled ( );
	bool eventShouldInterruptInhand ( );
	bool ShouldInterruptReload ( );
	bool eventIsToggleDevice ( );
	bool CanDeviceFireInTargetingMode ( );
	void ClientSetState ( unsigned char NewState );
	void eventSetState ( unsigned char NewState, unsigned long bStartCooldown );
	bool IsToggledOn ( );
	bool eventShouldCooldownAfterFire ( );
	void eventOnDeployableDestroyed ( class ATgDeployable* deployable );
	bool HasEnoughPowerPool ( unsigned char FireModeNum );
	bool ProjectileWillSpawnDeployable ( class ATgProjectile* Proj );
};

UClass* ATgDevice_TogglableDeployable::pClassPointer = NULL;

// Class TgGame.TgDevice_AoKuang_WaterIllusion
// 0x0000 (0x039C - 0x039C)
class ATgDevice_AoKuang_WaterIllusion : public ATgDevice_TogglableDeployable
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1820 );

		return pClassPointer;
	};

	void DeviceFormToggleOff ( );
	bool ServerToggleOff ( );
	bool ToggleOff ( );
	void ToggleOffConsumePowerPool ( class ATgDeployable* deployable );
	void eventDeviceConsumePowerPool ( unsigned char FireModeNum );
	unsigned char FindDeployableFireModeNum ( class ATgDeployable* deployable );
	bool HasEnoughPowerPool ( unsigned char FireModeNum );
};

UClass* ATgDevice_AoKuang_WaterIllusion::pClassPointer = NULL;

// Class TgGame.TgDevice_Isis_CircleOfProtection
// 0x0000 (0x039C - 0x039C)
class ATgDevice_Isis_CircleOfProtection : public ATgDevice_TogglableDeployable
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1821 );

		return pClassPointer;
	};

	void eventOnDeployableDestroyed ( class ATgDeployable* deployable );
	bool eventCanBeCanceled ( );
	bool CanBeGrabbed ( );
	bool CanBeDisarmed ( );
	bool CanBeSilenced ( );
	bool CanBeStunned ( );
};

UClass* ATgDevice_Isis_CircleOfProtection::pClassPointer = NULL;

// Class TgGame.TgDevice_PersistentCostTogglableDeployable
// 0x0004 (0x03A0 - 0x039C)
class ATgDevice_PersistentCostTogglableDeployable : public ATgDevice_TogglableDeployable
{
public:
	float                                              m_TimeSinceLastManaCostApplied;                   		// 0x039C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1822 );

		return pClassPointer;
	};

	void Tick ( float DeltaTime );
	void DeviceConsumePowerPool ( unsigned char FireModeNum );
};

UClass* ATgDevice_PersistentCostTogglableDeployable::pClassPointer = NULL;

// Class TgGame.TgDevice_Ward
// 0x0000 (0x0388 - 0x0388)
class ATgDevice_Ward : public ATgDevice_Deployable
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1823 );

		return pClassPointer;
	};

	void GetCombatLogEventLocation ( int* LocationX, int* LocationY );
	void PlayEmoteWardPlaced ( );
};

UClass* ATgDevice_Ward::pClassPointer = NULL;

// Class TgGame.TgDevice_EyeOfProvidenceS3
// 0x0000 (0x0388 - 0x0388)
class ATgDevice_EyeOfProvidenceS3 : public ATgDevice_Ward
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1824 );

		return pClassPointer;
	};

};

UClass* ATgDevice_EyeOfProvidenceS3::pClassPointer = NULL;

// Class TgGame.TgDevice_WardContainer
// 0x0000 (0x0388 - 0x0388)
class ATgDevice_WardContainer : public ATgDevice_Ward
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1825 );

		return pClassPointer;
	};

};

UClass* ATgDevice_WardContainer::pClassPointer = NULL;

// Class TgGame.TgDevice_ZhongKui_Exorcism
// 0x0000 (0x0388 - 0x0388)
class ATgDevice_ZhongKui_Exorcism : public ATgDevice_Deployable
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1826 );

		return pClassPointer;
	};

	void CooldownTimerExpired ( int nTimerId, unsigned char eEvent );
	void eventStartCooldown ( int nMode, float fCooldownTimeOverride );
	bool AllocateDevicePoint ( );
};

UClass* ATgDevice_ZhongKui_Exorcism::pClassPointer = NULL;

// Class TgGame.TgDevice_ErlangShen_SeeWeakness
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_ErlangShen_SeeWeakness : public ATgDevice
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1827 );

		return pClassPointer;
	};

	bool eventShouldInterruptInhand ( );
};

UClass* ATgDevice_ErlangShen_SeeWeakness::pClassPointer = NULL;

// Class TgGame.TgDevice_EyeOfRetaliation
// 0x0004 (0x0384 - 0x0380)
class ATgDevice_EyeOfRetaliation : public ATgDevice
{
public:
	float                                              m_fFlipPoint;                                     		// 0x0380 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1828 );

		return pClassPointer;
	};

	void Tick ( float DeltaTime );
	void DeviceRestart ( );
	void eventTestFlipPoint ( );
};

UClass* ATgDevice_EyeOfRetaliation::pClassPointer = NULL;

// Class TgGame.TgDevice_Fafnir_Basic_D
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_Fafnir_Basic_D : public ATgDevice
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1829 );

		return pClassPointer;
	};

	bool CanBeDisarmed ( );
	float GetRefireTime ( int nMode );
};

UClass* ATgDevice_Fafnir_Basic_D::pClassPointer = NULL;

// Class TgGame.TgDevice_G72_Dev2Stage
// 0x0008 (0x0388 - 0x0380)
class ATgDevice_G72_Dev2Stage : public ATgDevice
{
public:
	unsigned long                                      r_bWillSwapOnFire : 1;                            		// 0x0380 (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )
	int                                                c_nChargingPostureId;                             		// 0x0384 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1830 );

		return pClassPointer;
	};

	bool eventShouldInterruptInhand ( );
	void OnProjectileShutdown ( class ATgProjectile* Proj );
	void ResetDevice ( );
	bool eventCanBeInterrupted ( );
	void eventForceRefireOnTimeout ( );
	void ResetRefireTargeter ( );
	void AttachRefireTargeting ( );
	void eventShowRefireTargeter ( );
	void eventSetPosture ( );
	void CustomFire ( );
	bool eventApplyGlobalOffhandCooldown ( );
	bool eventShouldLockFiring ( class ATgDevice* Current );
	bool eventCanDeviceFireNow ( unsigned char FireModeNum, struct FAimData Aim, unsigned long bDeviceFailLog, unsigned long bSkipStunCheck, unsigned char* failType );
	bool eventShouldCooldownAfterFire ( );
	bool ShouldConsumePowerPoolAfterFire ( );
	bool ShouldConsumePowerPoolOnStartFire ( );
	void eventReplicatedEvent ( struct FName VarName );
	bool UsesTargetingMode ( );
	bool IsToggledOn ( );
	float GetRefireTime ( int nMode );
	float GetFiringPostHitDelay ( int nMode );
	float GetFiringPreHitDelay ( int nMode );
};

UClass* ATgDevice_G72_Dev2Stage::pClassPointer = NULL;

// Class TgGame.TgDevice_G72_Passive
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_G72_Passive : public ATgDevice
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1831 );

		return pClassPointer;
	};

	void eventPassiveAuraProxyOnUnTouch ( class AActor* Other );
	void eventPassiveAuraProxyOnTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
};

UClass* ATgDevice_G72_Passive::pClassPointer = NULL;

// Class TgGame.TgDevice_Grenade
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_Grenade : public ATgDevice
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1832 );

		return pClassPointer;
	};

};

UClass* ATgDevice_Grenade::pClassPointer = NULL;

// Class TgGame.TgDevice_GroundTarget_LockOn
// 0x0004 (0x0384 - 0x0380)
class ATgDevice_GroundTarget_LockOn : public ATgDevice
{
public:
	unsigned long                                      m_bCanFireWithoutTarget : 1;                      		// 0x0380 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bSelfTargetIfNone : 1;                          		// 0x0380 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_bOnlyTargetValidGrabSources : 1;                		// 0x0380 (0x0004) [0x0000000000000000] [0x00000004] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1833 );

		return pClassPointer;
	};

	bool CanLockOnToTarget ( class AActor* Target );
	void UpdateAimWhileFiring ( struct FAimData* Aim );
	void GetTargetingAim ( struct FAimData* Aim );
};

UClass* ATgDevice_GroundTarget_LockOn::pClassPointer = NULL;

// Class TgGame.TgDevice_Fafnir_Dev2
// 0x0000 (0x0384 - 0x0384)
class ATgDevice_Fafnir_Dev2 : public ATgDevice_GroundTarget_LockOn
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1834 );

		return pClassPointer;
	};

	void HandleDeviceFormStartFire ( int nDeviceModeNum, float fRefireTime, struct FAimData* Aim );
	bool eventUsesTrackingTarget ( );
};

UClass* ATgDevice_Fafnir_Dev2::pClassPointer = NULL;

// Class TgGame.TgDevice_Fafnir_Dev2_D
// 0x0000 (0x0384 - 0x0384)
class ATgDevice_Fafnir_Dev2_D : public ATgDevice_GroundTarget_LockOn
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1835 );

		return pClassPointer;
	};

	void GetTargetingAim ( struct FAimData* Aim );
	void SpawnWarningDeployable ( );
};

UClass* ATgDevice_Fafnir_Dev2_D::pClassPointer = NULL;

// Class TgGame.TgDevice_Kaldr_Dev3
// 0x0000 (0x0384 - 0x0384)
class ATgDevice_Kaldr_Dev3 : public ATgDevice_GroundTarget_LockOn
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1836 );

		return pClassPointer;
	};

	bool eventCanDeviceFireNow ( unsigned char FireModeNum, struct FAimData Aim, unsigned long bDeviceFailLog, unsigned long bSkipStunCheck, unsigned char* failType );
	bool eventCanBeFiredWhileTweening ( );
	bool eventShouldLockFiring ( class ATgDevice* Current );
	bool eventApplyGlobalOffhandCooldown ( );
	bool HasBeenTrained ( );
};

UClass* ATgDevice_Kaldr_Dev3::pClassPointer = NULL;

// Class TgGame.TgDevice_Khepri_ScarabBlessing
// 0x0000 (0x0384 - 0x0384)
class ATgDevice_Khepri_ScarabBlessing : public ATgDevice_GroundTarget_LockOn
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1837 );

		return pClassPointer;
	};

	bool eventShouldConsumePowerPoolAfterFire ( );
	bool eventShouldConsumePowerPoolOnStartFire ( );
	bool eventShouldCooldownAfterFire ( );
};

UClass* ATgDevice_Khepri_ScarabBlessing::pClassPointer = NULL;

// Class TgGame.TgDevice_Serqet_LastBreath
// 0x0054 (0x03D8 - 0x0384)
class ATgDevice_Serqet_LastBreath : public ATgDevice_GroundTarget_LockOn
{
public:
	unsigned char                                      m_eLeapTweenState;                                		// 0x0384 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_eStingerGrabState;                              		// 0x0385 (0x0001) [0x0000000000000000]              
	int                                                m_nStunSituationalType;                           		// 0x0388 (0x0004) [0x0000000000000000]              
	unsigned long                                      s_bStunApplied : 1;                               		// 0x038C (0x0004) [0x0000000000000000] [0x00000001] 
	class ATgDevice*                                   r_BackflipDevice;                                 		// 0x0390 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              m_fTimeToSting;                                   		// 0x0394 (0x0004) [0x0000000000000000]              
	class UTgDeviceFire*                               s_StingFireMode;                                  		// 0x0398 (0x0004) [0x0000000000000000]              
	struct FAimData                                    s_StingAim;                                       		// 0x039C (0x002C) [0x0000000000000000]              
	float                                              m_fExplosionDeplayTime;                           		// 0x03C8 (0x0004) [0x0000000000000000]              
	TArray< struct FLastBreathExplosionInfo >          m_ExplosionQueue;                                 		// 0x03CC (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1838 );

		return pClassPointer;
	};

	bool ShouldConsumePowerPoolAfterFire ( );
	bool ShouldConsumePowerPoolOnStartFire ( );
	bool eventShouldCooldownAfterFire ( );
	void FireAmmunition ( );
	void DoSting ( );
	void OnEndTween ( unsigned long bInterrupted );
	bool ClientDoBackflip ( );
	bool DoBackflip ( );
	void OnTeleportNotify ( class AActor* TeleportingActor );
	void Tick ( float DeltaTime );
	bool IsAttackValid ( struct FAimData* Aim );
	bool eventShouldLockFiring ( class ATgDevice* Current );
	bool eventCanBeInterrupted ( );
	bool eventCanBeCanceled ( );
	void QueueLastBreathExplosion ( struct FVector ExplosionLocation, class UTgDeviceFire* DeviceMode );
	bool DoKnockBack ( struct FAimData* Aim );
	void SetFireMode ( int nFireModeNum, unsigned long ForceSet );
	void SetPointsAllocated ( int nPoints );
	float GetRefireTime ( int nMode );
};

UClass* ATgDevice_Serqet_LastBreath::pClassPointer = NULL;

// Class TgGame.TgDevice_Skadi_Dev2
// 0x0004 (0x0388 - 0x0384)
class ATgDevice_Skadi_Dev2 : public ATgDevice_GroundTarget_LockOn
{
public:
	class ATgDevice*                                   s_MatchedDevice;                                  		// 0x0384 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1839 );

		return pClassPointer;
	};

	bool eventGetMatchedDevice ( );
	int eventMatchedKaldrDeviceEQPoint ( );
	void FireAmmunition ( );
	bool IsToggledOn ( );
	void GetTargetingAim ( struct FAimData* Aim );
	bool IsTargetingModeReady ( unsigned char* failType );
	bool UsesTargetingMode ( );
	bool HasBeenTrained ( );
	bool AllocateDevicePoint ( );
};

UClass* ATgDevice_Skadi_Dev2::pClassPointer = NULL;

// Class TgGame.TgDevice_Hel_SwitchStance
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_Hel_SwitchStance : public ATgDevice
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1840 );

		return pClassPointer;
	};

	bool HasBeenTrained ( );
};

UClass* ATgDevice_Hel_SwitchStance::pClassPointer = NULL;

// Class TgGame.TgDevice_Hercules_BoulderThrower
// 0x0004 (0x0384 - 0x0380)
class ATgDevice_Hercules_BoulderThrower : public ATgDevice
{
public:
	unsigned long                                      m_bFireTimerExpired : 1;                          		// 0x0380 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bOverrideStartLocation : 1;                     		// 0x0380 (0x0004) [0x0000000000000000] [0x00000002] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1841 );

		return pClassPointer;
	};

	void ClientSimulateStartFire ( );
	bool eventStartFireOnTimerExpired ( );
	void GetGroundTargetAim ( struct FAimData* Aim );
};

UClass* ATgDevice_Hercules_BoulderThrower::pClassPointer = NULL;

// Class TgGame.TgDevice_HitPulse
// 0x0008 (0x0388 - 0x0380)
class ATgDevice_HitPulse : public ATgDevice
{
public:
	unsigned long                                      s_ShouldPayCostPerPulse : 1;                      		// 0x0380 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      s_bCostPaid : 1;                                  		// 0x0380 (0x0004) [0x0000000000000000] [0x00000002] 
	int                                                m_CurrentPulseIndex;                              		// 0x0384 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1842 );

		return pClassPointer;
	};

	float GetLockoutExtensionTime ( );
	bool ShouldConsumePowerPoolAfterFire ( );
	bool ShouldConsumePowerPoolOnStartFire ( );
	void ClientInterrupt ( );
	void eventInterruptFiring ( );
	float eventGetPersistPulseHitTime ( int nMode );
	float eventGetPersistTime ( int nMode );
	void PulseHit ( );
	float eventGetRefireTime ( int nMode );
	void PersistTimer ( );
	bool ApplyGlobalOffhandCooldown ( );
};

UClass* ATgDevice_HitPulse::pClassPointer = NULL;

// Class TgGame.TgDevice_ArachneAttach
// 0x0000 (0x0388 - 0x0388)
class ATgDevice_ArachneAttach : public ATgDevice_HitPulse
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1843 );

		return pClassPointer;
	};

	void UpdateAimWhileFiring ( struct FAimData* Aim );
};

UClass* ATgDevice_ArachneAttach::pClassPointer = NULL;

// Class TgGame.TgDevice_Cabrakan_Dev3
// 0x0000 (0x0388 - 0x0388)
class ATgDevice_Cabrakan_Dev3 : public ATgDevice_HitPulse
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1844 );

		return pClassPointer;
	};

	void eventInterruptFiring ( );
	bool ShouldConsumePowerPoolAfterFire ( );
	bool eventCanBeCanceled ( );
	bool eventStartFire ( );
	bool IsToggledOn ( );
	void UpdateUIToggleState ( );
};

UClass* ATgDevice_Cabrakan_Dev3::pClassPointer = NULL;

// Class TgGame.TgDevice_Fenrir_Maul
// 0x0000 (0x0388 - 0x0388)
class ATgDevice_Fenrir_Maul : public ATgDevice_HitPulse
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1845 );

		return pClassPointer;
	};

	bool eventCanBeCanceled ( );
	bool CanLockOnToTarget ( class AActor* Target );
	void UpdateAimWhileFiring ( struct FAimData* Aim );
	void GetTargetingAim ( struct FAimData* Aim );
};

UClass* ATgDevice_Fenrir_Maul::pClassPointer = NULL;

// Class TgGame.TgDevice_G72_Dev4
// 0x0008 (0x0390 - 0x0388)
class ATgDevice_G72_Dev4 : public ATgDevice_HitPulse
{
public:
	int                                                r_nUltSwing;                                      		// 0x0388 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                s_nUltPulse;                                      		// 0x038C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1846 );

		return pClassPointer;
	};

	bool eventCanBeInterrupted ( );
	void eventDeliverQueuedPendingHits ( );
	void UpdatePawnAnim ( int SwingNum );
};

UClass* ATgDevice_G72_Dev4::pClassPointer = NULL;

// Class TgGame.TgDevice_Medusa_Dev4
// 0x0008 (0x0390 - 0x0388)
class ATgDevice_Medusa_Dev4 : public ATgDevice_HitPulse
{
public:
	unsigned long                                      r_bIsToggledOn : 1;                               		// 0x0388 (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )
	float                                              m_FacingTowardCos;                                		// 0x038C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1847 );

		return pClassPointer;
	};

	void eventStartCooldown ( int nMode, float fCooldownTimeOverride );
	bool eventStartFire ( );
	bool eventShouldLockFiring ( class ATgDevice* Current );
	bool eventCanBeCanceled ( );
	void eventReplicatedEvent ( struct FName VarName );
	bool IsToggledOn ( );
	void SetFireMode ( int nFireModeNum, unsigned long ForceSet );
};

UClass* ATgDevice_Medusa_Dev4::pClassPointer = NULL;

// Class TgGame.TgDevice_Nike_Dev1
// 0x0018 (0x03A0 - 0x0388)
class ATgDevice_Nike_Dev1 : public ATgDevice_HitPulse
{
public:
	TArray< class ATgPawn* >                           m_SingleHitGods;                                  		// 0x0388 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class ATgPawn* >                           m_DoubleHitGods;                                  		// 0x0394 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1848 );

		return pClassPointer;
	};

	void UpdateTargetingModeStatus ( struct FAimData* Aim );
	float eventGetPersistTime ( int nMode );
	bool eventCanBeCanceled ( );
	bool eventCanBeInterrupted ( );
};

UClass* ATgDevice_Nike_Dev1::pClassPointer = NULL;

// Class TgGame.TgDevice_Raijin_Dev1
// 0x0009 (0x0391 - 0x0388)
class ATgDevice_Raijin_Dev1 : public ATgDevice_HitPulse
{
public:
	float                                              m_fProjectileXOffset;                             		// 0x0388 (0x0004) [0x0000000000000000]              
	float                                              m_fProjectileYOffset;                             		// 0x038C (0x0004) [0x0000000000000000]              
	unsigned char                                      m_nCachedFireType;                                		// 0x0390 (0x0001) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1849 );

		return pClassPointer;
	};

	bool eventCanBeCanceled ( );
	bool eventCanBeInterrupted ( );
	void CustomFire ( );
	void FireAmmunition ( );
	void CustomProjectileInit ( class AProjectile* Proj, int ProjIndex, struct FAimData BaseAim );
	void eventGetAdjustedAim ( int nShotIndex, struct FAimData* Aim );
	void UpdateTargetingModeStatus ( struct FAimData* Aim );
};

UClass* ATgDevice_Raijin_Dev1::pClassPointer = NULL;

// Class TgGame.TgDevice_Raijin_Dev4
// 0x0034 (0x03BC - 0x0388)
class ATgDevice_Raijin_Dev4 : public ATgDevice_HitPulse
{
public:
	unsigned char                                      m_CachedBeatSelect;                               		// 0x0388 (0x0001) [0x0000000000000000]              
	TArray< class UTgDeviceFire* >                     m_Beat2FireModes;                                 		// 0x038C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UTgDeviceFire* >                     m_Beat3FireModes;                                 		// 0x0398 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class UClass*                                      m_DefaultCameraModuleClass;                       		// 0x03A4 (0x0004) [0x0000000000000000]              
	class UClass*                                      m_FiringCameraModuleClass;                        		// 0x03A8 (0x0004) [0x0000000000000000]              
	class UTgCameraModule*                             m_FiringCameraModule;                             		// 0x03AC (0x0004) [0x0000000000000000]              
	float                                              m_fCameraTweenInTime;                             		// 0x03B0 (0x0004) [0x0000000000000000]              
	float                                              m_fCameraTweenOutTime;                            		// 0x03B4 (0x0004) [0x0000000000000000]              
	float                                              m_fFiringCameraZOffset;                           		// 0x03B8 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1850 );

		return pClassPointer;
	};

	void TurnOffSpecialCamera ( );
	void TurnOnSpecialCamera ( );
	class AProjectile* ProjectileFire ( int ProjectileIndex );
	void TickTargetingMode ( float DeltaSeconds );
	void UpdateAimWhileFiring ( struct FAimData* Aim );
};

UClass* ATgDevice_Raijin_Dev4::pClassPointer = NULL;

// Class TgGame.TgDevice_Ratatoskr_TailSpin
// 0x0000 (0x0388 - 0x0388)
class ATgDevice_Ratatoskr_TailSpin : public ATgDevice_HitPulse
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1851 );

		return pClassPointer;
	};

	void eventGetAdjustedAim ( int nShotIndex, struct FAimData* Aim );
	bool eventCanBeInterrupted ( );
	bool UsesCachedAim ( );
	void UpdateAimWhileFiring ( struct FAimData* Aim );
};

UClass* ATgDevice_Ratatoskr_TailSpin::pClassPointer = NULL;

// Class TgGame.TgDevice_Serqet_Catalyst
// 0x0020 (0x03A8 - 0x0388)
class ATgDevice_Serqet_Catalyst : public ATgDevice_HitPulse
{
public:
	int                                                m_nCharmedMeleeDeviceId;                          		// 0x0388 (0x0004) [0x0000000000000000]              
	int                                                m_nCharmedProjectileDeviceId;                     		// 0x038C (0x0004) [0x0000000000000000]              
	TArray< class UTgDeviceFire* >                     m_CharmedMeleeFireMode;                           		// 0x0390 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UTgDeviceFire* >                     m_CharmedProjectileFireMode;                      		// 0x039C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1852 );

		return pClassPointer;
	};

	class UTgDeviceFire* GetCharmedProjectileMode ( int nMode );
	class UTgDeviceFire* GetCurrentCharmedProjectileMode ( );
	class UTgDeviceFire* GetCharmedMeleeMode ( int nMode );
	class UTgDeviceFire* GetCurrentCharmedMeleeMode ( );
	void UpdateTargetingModeStatus ( struct FAimData* Aim );
};

UClass* ATgDevice_Serqet_Catalyst::pClassPointer = NULL;

// Class TgGame.TgDevice_TogglableHitPulse
// 0x0000 (0x0388 - 0x0388)
class ATgDevice_TogglableHitPulse : public ATgDevice_HitPulse
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1853 );

		return pClassPointer;
	};

	bool ShouldInterruptReload ( );
	bool eventIsToggleDevice ( );
	bool eventStartFire ( );
	bool CanDeviceFireInTargetingMode ( );
	bool IsToggledOn ( );
	void UpdateUIToggleState ( );
};

UClass* ATgDevice_TogglableHitPulse::pClassPointer = NULL;

// Class TgGame.TgDevice_Vulcan_UltimateForge
// 0x0000 (0x0388 - 0x0388)
class ATgDevice_Vulcan_UltimateForge : public ATgDevice_HitPulse
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1854 );

		return pClassPointer;
	};

	bool ShouldInterruptReload ( );
	bool eventIsToggleDevice ( );
	void FireAmmunition ( );
	bool eventStartFire ( );
	bool CanDeviceFireInTargetingMode ( );
	bool IsToggledOn ( );
	void UpdateUIToggleState ( );
};

UClass* ATgDevice_Vulcan_UltimateForge::pClassPointer = NULL;

// Class TgGame.TgDevice_ZhongKui_RecallDemons
// 0x0044 (0x03CC - 0x0388)
class ATgDevice_ZhongKui_RecallDemons : public ATgDevice_HitPulse
{
public:
	int                                                m_nMaxTargets;                                    		// 0x0388 (0x0004) [0x0000000000000000]              
	int                                                m_nShotLimit;                                     		// 0x038C (0x0004) [0x0000000000000002]              ( CPF_Const )
	float                                              m_fShotDelay;                                     		// 0x0390 (0x0004) [0x0000000000000002]              ( CPF_Const )
	TArray< class AActor* >                            m_CurrentTargets;                                 		// 0x0394 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UTgDeviceFire* >                     m_EnemyProjectileFireModes;                       		// 0x03A0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UTgDeviceFire* >                     m_FriendlyProjectileFireModes;                    		// 0x03AC (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                m_nEnemyProjectileId;                             		// 0x03B8 (0x0004) [0x0000000000000000]              
	int                                                m_nFriendlyProjectileId;                          		// 0x03BC (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bWaveIsCharged : 1;                             		// 0x03C0 (0x0004) [0x0000000000000000] [0x00000001] 
	struct FPointer                                    m_pProjSetupEnemy;                                		// 0x03C4 (0x0004) [0x0000000000001000]              ( CPF_Native )
	struct FPointer                                    m_pProjSetupFriendly;                             		// 0x03C8 (0x0004) [0x0000000000001000]              ( CPF_Native )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1855 );

		return pClassPointer;
	};

	void CustomProjectileInit ( class AProjectile* Proj, int ProjIndex, struct FAimData BaseAim );
	class AProjectile* DemonProjectileFire ( int ProjectileIndex, struct FAimData* Aim );
	void CustomFire ( );
	void DeferredFire ( );
	bool eventShouldTriggerCastReactionItems ( );
	bool eventShouldTriggerCastReactionItemsOnFire ( );
	bool eventShouldLockFiring ( class ATgDevice* Current );
	bool eventCancelledByJumping ( );
	bool eventCanJumpWhileFiring ( );
	bool eventCanBeInterrupted ( );
	bool eventCanBeCanceled ( );
	void UpdateTargetList ( struct FAimData* Aim );
	void GetTargetingAim ( struct FAimData* Aim );
};

UClass* ATgDevice_ZhongKui_RecallDemons::pClassPointer = NULL;

// Class TgGame.TgDevice_Isis_SpiritBall
// 0x0008 (0x0388 - 0x0380)
class ATgDevice_Isis_SpiritBall : public ATgDevice
{
public:
	unsigned long                                      bHasPressed : 1;                                  		// 0x0380 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	unsigned long                                      r_bIsDeployed : 1;                                		// 0x0380 (0x0004) [0x0000000000002020] [0x00000002] ( CPF_Net | CPF_Transient )
	unsigned long                                      c_bWaitingForDeploy : 1;                          		// 0x0380 (0x0004) [0x0000000000002000] [0x00000004] ( CPF_Transient )
	unsigned long                                      c_bForceNoToggle : 1;                             		// 0x0380 (0x0004) [0x0000000000000000] [0x00000008] 
	class ATgProjectile*                               SpawnedProj;                                      		// 0x0384 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1856 );

		return pClassPointer;
	};

	void ClientTurnOffOverrides ( );
	void eventInterruptFiring ( );
	void OnProjectileDestroyed ( class AProjectile* Proj );
	void CustomProjectileInit ( class AProjectile* Proj, int ProjIndex, struct FAimData BaseAim );
	void ServerDoRemoteDetonation ( int FireMode );
	bool eventUse ( );
	bool eventCanBeCanceled ( );
	void eventReplicatedEvent ( struct FName VarName );
	bool HasEnoughPowerPool ( unsigned char FireModeNum );
	void GetTargetingAim ( struct FAimData* Aim );
};

UClass* ATgDevice_Isis_SpiritBall::pClassPointer = NULL;

// Class TgGame.TgDevice_Izanami_Dev1
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_Izanami_Dev1 : public ATgDevice
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1857 );

		return pClassPointer;
	};

	bool ShouldCancelStealth ( );
	bool eventStartFire ( );
	bool ShouldCooldownAfterFire ( );
};

UClass* ATgDevice_Izanami_Dev1::pClassPointer = NULL;

// Class TgGame.TgDevice_JingWei_Dev1
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_JingWei_Dev1 : public ATgDevice
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1858 );

		return pClassPointer;
	};

};

UClass* ATgDevice_JingWei_Dev1::pClassPointer = NULL;

// Class TgGame.TgDevice_JingWei_Dev2
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_JingWei_Dev2 : public ATgDevice
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1859 );

		return pClassPointer;
	};

	void SetFireMode ( int nFireModeNum, unsigned long ForceSet );
};

UClass* ATgDevice_JingWei_Dev2::pClassPointer = NULL;

// Class TgGame.TgDevice_JingWei_Dev3
// 0x0004 (0x0384 - 0x0380)
class ATgDevice_JingWei_Dev3 : public ATgDevice
{
public:
	unsigned long                                      m_bIsAirDash : 1;                                 		// 0x0380 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1860 );

		return pClassPointer;
	};

	void FireAmmunition ( );
	void eventApplyLeapBuff ( );
	void eventToggleSecondaryTargeting ( unsigned long bEnable );
	bool CanFireWhileFalling ( );
	bool eventCanBeInterrupted ( );
	bool eventCanBeCanceled ( );
	void CalculateLob ( );
	void GetLinearTargetAim ( struct FAimData* Aim );
	void GetTargetingAim ( struct FAimData* Aim );
	void TickTargetingMode ( float DeltaSeconds );
};

UClass* ATgDevice_JingWei_Dev3::pClassPointer = NULL;

// Class TgGame.TgDevice_JingWei_Dev4_Landing
// 0x0010 (0x0390 - 0x0380)
class ATgDevice_JingWei_Dev4_Landing : public ATgDevice
{
public:
	unsigned long                                      m_IsTimedOut : 1;                                 		// 0x0380 (0x0004) [0x0000000000000000] [0x00000001] 
	struct FVector                                     m_BackupLandingLocation;                          		// 0x0384 (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1861 );

		return pClassPointer;
	};

	void DeviceShutDown ( unsigned long bDeactiveMode, unsigned long bResetCooldowns );
	void Tick ( float DeltaTime );
	bool eventApplyGlobalOffhandCooldown ( );
	bool eventShouldInterruptInhand ( );
	bool eventCanBeInterrupted ( );
	bool eventCanBeCanceled ( );
	bool CanLockFiringAegisAmulet ( );
	bool eventTriggerTimeOutJump ( );
	void UpdateBackupLocation ( );
	void GetGroundTargetAim ( struct FAimData* Aim );
	bool IsValidLandingLocation ( struct FVector landLocation );
};

UClass* ATgDevice_JingWei_Dev4_Landing::pClassPointer = NULL;

// Class TgGame.TgDevice_JingWei_Passive
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_JingWei_Passive : public ATgDevice
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1862 );

		return pClassPointer;
	};

	void eventInterruptFiring ( );
	bool eventCanJumpWhileFiring ( );
	bool CanFireWhileFalling ( );
	bool eventCanBeCanceled ( );
	void SetFireMode ( int nFireModeNum, unsigned long ForceSet );
};

UClass* ATgDevice_JingWei_Passive::pClassPointer = NULL;

// Class TgGame.TgDevice_JingWei_SkyJumpAuto
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_JingWei_SkyJumpAuto : public ATgDevice
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1863 );

		return pClassPointer;
	};

	void GetGroundTargetAim ( struct FAimData* Aim );
};

UClass* ATgDevice_JingWei_SkyJumpAuto::pClassPointer = NULL;

// Class TgGame.TgDevice_Khepri_KheprisFortitude
// 0x0004 (0x0384 - 0x0380)
class ATgDevice_Khepri_KheprisFortitude : public ATgDevice
{
public:
	float                                              r_fPassiveTimer;                                  		// 0x0380 (0x0004) [0x0000000000000020]              ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1864 );

		return pClassPointer;
	};

	bool eventShouldInterruptInhand ( );
	bool eventApplyGlobalOffhandCooldown ( );
	bool eventShouldLockFiring ( class ATgDevice* Current );
	bool eventCanDeviceFireNow ( unsigned char FireModeNum, struct FAimData Aim, unsigned long bDeviceFailLog, unsigned long bSkipStunCheck, unsigned char* failType );
	bool CanFireWhileFalling ( );
	void eventDeliverQueuedPendingHits ( );
	void Tick ( float DeltaSeconds );
	float eventGetCurrentTickFrequency ( );
};

UClass* ATgDevice_Khepri_KheprisFortitude::pClassPointer = NULL;

// Class TgGame.TgDevice_Khepri_Sun
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_Khepri_Sun : public ATgDevice
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1865 );

		return pClassPointer;
	};

	bool UsesCachedAim ( );
};

UClass* ATgDevice_Khepri_Sun::pClassPointer = NULL;

// Class TgGame.TgDevice_LimitedDuration
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_LimitedDuration : public ATgDevice
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1866 );

		return pClassPointer;
	};

};

UClass* ATgDevice_LimitedDuration::pClassPointer = NULL;

// Class TgGame.TgDevice_LimitedGroundTarget
// 0x0010 (0x0390 - 0x0380)
class ATgDevice_LimitedGroundTarget : public ATgDevice
{
public:
	struct FVector                                     r_vLimitedGroundTargetOrigin;                     		// 0x0380 (0x000C) [0x0000000000000020]              ( CPF_Net )
	class ATgDeployable_LimitedGroundTarget*           m_TargetingBoundsDeployable;                      		// 0x038C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1867 );

		return pClassPointer;
	};

	struct FImpactInfo CalcWeaponFire ( struct FAimData Aim, TArray< struct FImpactInfo >* ImpactList );
	void eventSetLimitedAimLocation ( struct FVector Loc );
	void GetTargetingAim ( struct FAimData* Aim );
	void TickTargetingMode ( float DeltaSeconds );
	void GetLimitedTargetingAim ( struct FAimData* Aim );
};

UClass* ATgDevice_LimitedGroundTarget::pClassPointer = NULL;

// Class TgGame.TgDevice_LineTarget_LockOn
// 0x0004 (0x0384 - 0x0380)
class ATgDevice_LineTarget_LockOn : public ATgDevice
{
public:
	unsigned long                                      m_bCanFireWithoutTarget : 1;                      		// 0x0380 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1868 );

		return pClassPointer;
	};

	void GetReticleTargetAim ( struct FAimData* Aim );
};

UClass* ATgDevice_LineTarget_LockOn::pClassPointer = NULL;

// Class TgGame.TgDevice_LockOnShooter
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_LockOnShooter : public ATgDevice
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1869 );

		return pClassPointer;
	};

	void GetLockOnTargetAim ( struct FAimData* Aim );
	bool CanLockOnToTarget ( class AActor* Target );
};

UClass* ATgDevice_LockOnShooter::pClassPointer = NULL;

// Class TgGame.TgDevice_MapTargetLockOn
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_MapTargetLockOn : public ATgDevice
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1870 );

		return pClassPointer;
	};

	void GetWorldMapLockOnTargetAim ( struct FAimData* Aim );
	bool CanLockOnToTarget ( class AActor* Target );
	bool ShowUICanFire ( );
	bool IsTargetingModeReady ( unsigned char* failType );
	bool HasValidTargets ( );
	bool ForceDefaultCastMode ( );
};

UClass* ATgDevice_MapTargetLockOn::pClassPointer = NULL;

// Class TgGame.TgDevice_MapTargetTeleport
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_MapTargetTeleport : public ATgDevice_MapTargetLockOn
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1871 );

		return pClassPointer;
	};

	bool eventCanBeCanceled ( );
};

UClass* ATgDevice_MapTargetTeleport::pClassPointer = NULL;

// Class TgGame.TgDevice_MapTargetTeleportGod
// 0x002C (0x03AC - 0x0380)
class ATgDevice_MapTargetTeleportGod : public ATgDevice_MapTargetLockOn
{
public:
	struct FAimData                                    s_LastGoodAim;                                    		// 0x0380 (0x002C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1872 );

		return pClassPointer;
	};

	bool eventCanBeCanceled ( );
};

UClass* ATgDevice_MapTargetTeleportGod::pClassPointer = NULL;

// Class TgGame.TgDevice_RallyingRitual
// 0x0000 (0x03AC - 0x03AC)
class ATgDevice_RallyingRitual : public ATgDevice_MapTargetTeleportGod
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1873 );

		return pClassPointer;
	};

	void FireAmmunition ( );
	bool eventCanBeInterrupted ( );
};

UClass* ATgDevice_RallyingRitual::pClassPointer = NULL;

// Class TgGame.TgDevice_TeleportSiegeVariant
// 0x002C (0x03AC - 0x0380)
class ATgDevice_TeleportSiegeVariant : public ATgDevice_MapTargetLockOn
{
public:
	struct FAimData                                    s_LastGoodAim;                                    		// 0x0380 (0x002C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1874 );

		return pClassPointer;
	};

	void GetTargetingAim ( struct FAimData* Aim );
	bool HasValidTargets ( );
	bool CanBeCrippled ( );
};

UClass* ATgDevice_TeleportSiegeVariant::pClassPointer = NULL;

// Class TgGame.TgDevice_Medusa_Dev1
// 0x0004 (0x0384 - 0x0380)
class ATgDevice_Medusa_Dev1 : public ATgDevice
{
public:
	unsigned long                                      r_bIsToggledOn : 1;                               		// 0x0380 (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1875 );

		return pClassPointer;
	};

	void eventStartCooldown ( int nMode, float fCooldownTimeOverride );
	void eventInterruptFiring ( );
	bool eventCustomCanDeviceFireNow ( unsigned char FireModeNum, struct FAimData Aim, unsigned long bDeviceFailLog, unsigned char* failType );
	bool eventShouldCooldownAfterFire ( );
	void eventReplicatedEvent ( struct FName VarName );
	bool IsToggledOn ( );
};

UClass* ATgDevice_Medusa_Dev1::pClassPointer = NULL;

// Class TgGame.TgDevice_Melee
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_Melee : public ATgDevice
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1876 );

		return pClassPointer;
	};

	struct FImpactInfo MeleeMouseOver ( class AActor* TraceActor, struct FVector StartTrace, struct FVector EndTrace );
	class ATgPawn* eventAcquireMeleeTarget ( int* bExactTarget );
	bool eventStartFire ( );
	bool NativeIsFiring ( );
};

UClass* ATgDevice_Melee::pClassPointer = NULL;

// Class TgGame.TgDevice_Fenrir_Bite
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_Fenrir_Bite : public ATgDevice_Melee
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1877 );

		return pClassPointer;
	};

	void FireAmmunition ( );
	struct FImpactInfo CalcWeaponFire ( struct FAimData Aim, TArray< struct FImpactInfo >* ImpactList );
	struct FVector GetCylinderExtent ( class AActor* A );
	void GetTargetingAim ( struct FAimData* Aim );
	float GetRefireTime ( int nMode );
};

UClass* ATgDevice_Fenrir_Bite::pClassPointer = NULL;

// Class TgGame.TgDevice_Mercury_4Shooter
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_Mercury_4Shooter : public ATgDevice
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1878 );

		return pClassPointer;
	};

	bool eventShouldTriggerCastReactionItems ( );
	void TickTargetingMode ( float DeltaSeconds );
};

UClass* ATgDevice_Mercury_4Shooter::pClassPointer = NULL;

// Class TgGame.TgDevice_Neith_BrokenWeaveUser
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_Neith_BrokenWeaveUser : public ATgDevice
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1879 );

		return pClassPointer;
	};

	void TickTargetingMode ( float DeltaSeconds );
};

UClass* ATgDevice_Neith_BrokenWeaveUser::pClassPointer = NULL;

// Class TgGame.TgDevice_Neith_SpiritArrow
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_Neith_SpiritArrow : public ATgDevice_Neith_BrokenWeaveUser
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1880 );

		return pClassPointer;
	};

};

UClass* ATgDevice_Neith_SpiritArrow::pClassPointer = NULL;

// Class TgGame.TgDevice_Neith_WorldWeaver
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_Neith_WorldWeaver : public ATgDevice
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1881 );

		return pClassPointer;
	};

	bool eventShouldTriggerCastReactionItems ( );
	void GetReticleTargetAim ( struct FAimData* Aim );
	void GetTargetingAim ( struct FAimData* Aim );
};

UClass* ATgDevice_Neith_WorldWeaver::pClassPointer = NULL;

// Class TgGame.TgDevice_Nemesis_Num3
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_Nemesis_Num3 : public ATgDevice
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1882 );

		return pClassPointer;
	};

	void eventRestartFiringWithParry ( );
};

UClass* ATgDevice_Nemesis_Num3::pClassPointer = NULL;

// Class TgGame.TgDevice_NeZha_UltQte
// 0x0040 (0x03C0 - 0x0380)
class ATgDevice_NeZha_UltQte : public ATgDevice
{
public:
	float                                              r_CenterPoints[ 0x6 ];                            		// 0x0380 (0x0018) [0x0000000000002020]              ( CPF_Net | CPF_Transient )
	float                                              r_SmoothSpeeds[ 0x6 ];                            		// 0x0398 (0x0018) [0x0000000000002020]              ( CPF_Net | CPF_Transient )
	unsigned long                                      bHasReleased : 1;                                 		// 0x03B0 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	float                                              SmoothedEnergy;                                   		// 0x03B4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                CurrentHitTiming;                                 		// 0x03B8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                LastHitSubmitted;                                 		// 0x03BC (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1883 );

		return pClassPointer;
	};

	bool ServerPerformQuickTimeEvent ( float ClientEnergy, int ClientHit );
	void StopFire ( );
	bool eventUse ( );
	void PlayMissSound ( );
	void PlayHitSound ( );
	void ApplyEquipEffects ( );
};

UClass* ATgDevice_NeZha_UltQte::pClassPointer = NULL;

// Class TgGame.TgDevice_Nike_Dev2
// 0x0004 (0x0384 - 0x0380)
class ATgDevice_Nike_Dev2 : public ATgDevice
{
public:
	unsigned long                                      r_bIsActiveState : 1;                             		// 0x0380 (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1884 );

		return pClassPointer;
	};

	bool eventCanDeviceFireNow ( unsigned char FireModeNum, struct FAimData Aim, unsigned long bDeviceFailLog, unsigned long bSkipStunCheck, unsigned char* failType );
	void eventHandleActiveState ( );
	void eventStartCooldown ( int nMode, float fCooldownTimeOverride );
	bool eventShouldLockFiring ( class ATgDevice* Current );
	bool eventShouldCooldownAfterFire ( );
	void eventReplicatedEvent ( struct FName VarName );
	bool eventCanBeCanceled ( );
};

UClass* ATgDevice_Nike_Dev2::pClassPointer = NULL;

// Class TgGame.TgDevice_Nox_Dev1
// 0x0010 (0x0390 - 0x0380)
class ATgDevice_Nox_Dev1 : public ATgDevice
{
public:
	TArray< class ATgProjectile* >                     s_ActiveProjectiles;                              		// 0x0380 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	unsigned long                                      m_bLockOutFiring : 1;                             		// 0x038C (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      c_bPreventLockOut : 1;                            		// 0x038C (0x0004) [0x0000000000000000] [0x00000002] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1885 );

		return pClassPointer;
	};

	void SetLinkActor ( class AActor* Target );
	void OnProjectileShutdown ( class ATgProjectile* Proj );
	class AProjectile* ProjectileFire ( int ProjectileIndex );
	bool CustomCanDeviceFireNow ( unsigned char FireModeNum, struct FAimData Aim, unsigned long bDeviceFailLog, unsigned char* failType );
	void ClientSetLockOutFiringFlag ( unsigned long bLockOut );
	void SetLockOutFiringFlag ( unsigned long bLockOut );
	void ClearLockOutFlag ( );
	bool eventShouldLockFiring ( class ATgDevice* Current );
	bool eventShouldCooldownAfterFire ( );
	void eventInterruptFiring ( );
	bool eventCanBeCanceled ( );
	bool LinkedToTarget ( );
};

UClass* ATgDevice_Nox_Dev1::pClassPointer = NULL;

// Class TgGame.TgDevice_NuWa_FogSpawn
// 0x0004 (0x0384 - 0x0380)
class ATgDevice_NuWa_FogSpawn : public ATgDevice
{
public:
	class ATgPawn*                                     DeployableBase;                                   		// 0x0380 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1886 );

		return pClassPointer;
	};

	void GetCachedAim ( struct FAimData* Aim );
	void GetTargetingAim ( struct FAimData* Aim );
};

UClass* ATgDevice_NuWa_FogSpawn::pClassPointer = NULL;

// Class TgGame.TgDevice_NuWa_MinionSpawn
// 0x0004 (0x0384 - 0x0380)
class ATgDevice_NuWa_MinionSpawn : public ATgDevice
{
public:
	class UTgDeviceFire_NuWa_MinionSpawn*              m_CachedMode;                                     		// 0x0380 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1887 );

		return pClassPointer;
	};

	void FireAmmunition ( );
	void SpawnNext ( );
	void GetTargetingAim ( struct FAimData* Aim );
};

UClass* ATgDevice_NuWa_MinionSpawn::pClassPointer = NULL;

// Class TgGame.TgDevice_NuWa_ShiningMetal
// 0x000C (0x038C - 0x0380)
class ATgDevice_NuWa_ShiningMetal : public ATgDevice
{
public:
	TArray< class AActor* >                            m_TargetingExplosionActors;                       		// 0x0380 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1888 );

		return pClassPointer;
	};

	void TickTargetingMode ( float DeltaSeconds );
	bool CanLockOnToTarget ( class AActor* Target );
};

UClass* ATgDevice_NuWa_ShiningMetal::pClassPointer = NULL;

// Class TgGame.TgDevice_Odin_Lunge
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_Odin_Lunge : public ATgDevice
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1889 );

		return pClassPointer;
	};

	bool CanBeCrippled ( );
};

UClass* ATgDevice_Odin_Lunge::pClassPointer = NULL;

// Class TgGame.TgDevice_Odin_LungePVE
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_Odin_LungePVE : public ATgDevice_Odin_Lunge
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1890 );

		return pClassPointer;
	};

	void GetGroundTargetAim ( struct FAimData* Aim );
};

UClass* ATgDevice_Odin_LungePVE::pClassPointer = NULL;

// Class TgGame.TgDevice_Osiris_MummyWrap
// 0x0010 (0x0390 - 0x0380)
class ATgDevice_Osiris_MummyWrap : public ATgDevice
{
public:
	unsigned long                                      c_bOverrideToggleOn : 1;                          		// 0x0380 (0x0004) [0x0000000000000000] [0x00000001] 
	TArray< struct FImpactInfo >                       ImpactsOnFireStart;                               		// 0x0384 (0x000C) [0x0000000000480000]              ( CPF_Component | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1891 );

		return pClassPointer;
	};

	void Remove ( class ATgPawn* Pawn );
	bool eventCanJumpWhileFiring ( );
	bool eventShouldLockFiring ( class ATgDevice* Current );
	bool eventCanBeInterrupted ( );
	struct FImpactInfo CalcWeaponFire ( struct FAimData Aim, TArray< struct FImpactInfo >* ImpactList );
	void UpdateUIToggleState ( );
	bool IsToggledOn ( );
};

UClass* ATgDevice_Osiris_MummyWrap::pClassPointer = NULL;

// Class TgGame.TgDevice_Poseidon_TridentShot
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_Poseidon_TridentShot : public ATgDevice
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1892 );

		return pClassPointer;
	};

	void CustomProjectileInit ( class AProjectile* Proj, int ProjIndex, struct FAimData BaseAim );
	void eventGetAdjustedAim ( int nShotIndex, struct FAimData* Aim );
};

UClass* ATgDevice_Poseidon_TridentShot::pClassPointer = NULL;

// Class TgGame.TgDevice_RadialSweep
// 0x0018 (0x0398 - 0x0380)
class ATgDevice_RadialSweep : public ATgDevice
{
public:
	class ATgCollisionProxy_RadialSweep*               m_CollisionProxy;                                 		// 0x0380 (0x0004) [0x0000000000000000]              
	TArray< class AActor* >                            m_HitActors;                                      		// 0x0384 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class UTgDeviceFire*                               m_SweepFiremode;                                  		// 0x0390 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bForceEndSweepOnStopFire : 1;                   		// 0x0394 (0x0004) [0x0000000000000002] [0x00000001] ( CPF_Const )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1893 );

		return pClassPointer;
	};

	void eventDestroyed ( );
	void EndSweep ( );
	void StartSweep ( class UTgDeviceFire* FireMode, struct FRotator AimRotation, float fPersistTime );
	bool CanRadialSweep ( );
	bool IsSweepActive ( );
	float eventGetPersistTime ( int nMode );
	void OnApplyHitFromTouch ( class UTgDeviceFire* FireMode, struct FImpactInfo* Impact );
	void eventProxyEndSweep ( unsigned long bInterrupt );
	void eventProxyUnTouch ( class AActor* Other );
	void eventProxyTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void eventUpdateCollisionProxyDelegates ( );
};

UClass* ATgDevice_RadialSweep::pClassPointer = NULL;

// Class TgGame.TgDevice_Bellona_SpinToStrike
// 0x000C (0x03A4 - 0x0398)
class ATgDevice_Bellona_SpinToStrike : public ATgDevice_RadialSweep
{
public:
	unsigned char                                      m_eDoingStrikeAttack;                             		// 0x0398 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_eSwitchToSet;                                   		// 0x0399 (0x0001) [0x0000000000000000]              
	int                                                m_nHitGodCount;                                   		// 0x039C (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bDoingStrikeTargeting : 1;                      		// 0x03A0 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1894 );

		return pClassPointer;
	};

	void EndSecondaryTargeting ( );
	void BeginSecondaryTargeting ( );
	void OnApplyHitFromTouch ( class UTgDeviceFire* firmode, struct FImpactInfo* Impact );
	void eventProxyTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	bool CanRadialSweep ( );
	void HandleDeviceFormStartFire ( int nDeviceModeNum, float fRefireTime, struct FAimData* Aim );
	void DoStrikeAttack ( );
	void eventDeviceConsumePowerPool ( unsigned char FireModeNum );
	void eventInterruptFiring ( );
	bool eventCanBeInterrupted ( );
	void UpdateTargetingModeStatus ( struct FAimData* Aim );
	float GetFiringPreHitDelay ( int nMode );
	float GetRefireTime ( int nMode );
	void UpdateAimWhileFiring ( struct FAimData* Aim );
};

UClass* ATgDevice_Bellona_SpinToStrike::pClassPointer = NULL;

// Class TgGame.TgDevice_Chaac_Num2
// 0x0004 (0x039C - 0x0398)
class ATgDevice_Chaac_Num2 : public ATgDevice_RadialSweep
{
public:
	unsigned long                                      m_bTeleporting : 1;                               		// 0x0398 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1895 );

		return pClassPointer;
	};

	bool eventCanBeCanceled ( );
	bool ShouldConsumePowerPoolOnStartFire ( );
	bool eventShouldCooldownAfterFire ( );
	bool CanBeCrippled ( );
	float GetBuildupTime ( int nMode );
};

UClass* ATgDevice_Chaac_Num2::pClassPointer = NULL;

// Class TgGame.TgDevice_RadialSweep_MultiHit
// 0x0014 (0x03AC - 0x0398)
class ATgDevice_RadialSweep_MultiHit : public ATgDevice_RadialSweep
{
public:
	TArray< float >                                    m_fClearTimes;                                    		// 0x0398 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	float                                              m_fHitClearTime;                                  		// 0x03A4 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bLocksOtherDevices : 1;                         		// 0x03A8 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1896 );

		return pClassPointer;
	};

	bool eventShouldLockFiring ( class ATgDevice* Current );
	void Tick ( float DeltaSeconds );
	void eventProxyTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
};

UClass* ATgDevice_RadialSweep_MultiHit::pClassPointer = NULL;

// Class TgGame.TgDevice_Susano_Dev2_Part3
// 0x0004 (0x039C - 0x0398)
class ATgDevice_Susano_Dev2_Part3 : public ATgDevice_RadialSweep
{
public:
	unsigned long                                      r_IsToggledOn : 1;                                		// 0x0398 (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1897 );

		return pClassPointer;
	};

	bool eventShouldTriggerCastReactionItems ( );
	bool eventShouldCooldownAfterFire ( );
	void eventReplicatedEvent ( struct FName VarName );
	bool IsToggledOn ( );
	void RemoveEquipEffects ( );
	void ApplyEquipEffects ( );
};

UClass* ATgDevice_Susano_Dev2_Part3::pClassPointer = NULL;

// Class TgGame.TgDevice_XingTian_UltSweep
// 0x0011 (0x03A9 - 0x0398)
class ATgDevice_XingTian_UltSweep : public ATgDevice_RadialSweep
{
public:
	unsigned long                                      m_bHasEjected : 1;                                		// 0x0398 (0x0004) [0x0000000000000000] [0x00000001] 
	int                                                m_nHitsApplied;                                   		// 0x039C (0x0004) [0x0000000000000000]              
	float                                              m_fNumSpins;                                      		// 0x03A0 (0x0004) [0x0000000000000000]              
	float                                              m_fNextEjectPercent;                              		// 0x03A4 (0x0004) [0x0000000000000000]              
	unsigned char                                      m_eHitTargetGrabState;                            		// 0x03A8 (0x0001) [0x0000000000000002]              ( CPF_Const )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1898 );

		return pClassPointer;
	};

	void RehitAll ( );
	bool eventShouldRehit ( float currentPercent );
	bool eventShouldEject ( );
	void TossAllHit ( );
	void eventProxyEndSweep ( unsigned long bInterrupted );
	void Tick ( float DeltaSeconds );
	void OnGrabDetach ( class ATgPawn* Target );
	void OnApplyHitFromTouch ( class UTgDeviceFire* FireMode, struct FImpactInfo* Impact );
	void eventInterruptFiring ( );
	bool eventCanBeInterrupted ( );
	float GetCurrentSweepPercent ( );
};

UClass* ATgDevice_XingTian_UltSweep::pClassPointer = NULL;

// Class TgGame.TgDevice_Raijin_Dev3
// 0x0008 (0x0388 - 0x0380)
class ATgDevice_Raijin_Dev3 : public ATgDevice
{
public:
	float                                              m_fMinTweenTime;                                  		// 0x0380 (0x0004) [0x0000000000000000]              
	float                                              m_fFixedVelocity;                                 		// 0x0384 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1899 );

		return pClassPointer;
	};

	void BeginThunder ( );
	void eventInstantFire ( );
	bool eventCanBeCanceled ( );
	float GetFiringPreHitDelay ( int nMode );
};

UClass* ATgDevice_Raijin_Dev3::pClassPointer = NULL;

// Class TgGame.TgDevice_Raijin_KotoDrums
// 0x0018 (0x0398 - 0x0380)
class ATgDevice_Raijin_KotoDrums : public ATgDevice
{
public:
	unsigned char                                      m_CachedBeatSelect;                               		// 0x0380 (0x0001) [0x0000000000000000]              
	class ATgDevice*                                   c_BeatDevice;                                     		// 0x0384 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bForcingPostFire : 1;                           		// 0x0388 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bReadyToFire : 1;                               		// 0x0388 (0x0004) [0x0000000000000000] [0x00000002] 
	float                                              m_fForcedPostFireDuration;                        		// 0x038C (0x0004) [0x0000000000000000]              
	int                                                m_nMaxBeatFireCount;                              		// 0x0390 (0x0004) [0x0000000000000000]              
	int                                                m_nBeatFireCount;                                 		// 0x0394 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1900 );

		return pClassPointer;
	};

	void EndForcedPostFire ( );
	void StartForcedPostFire ( );
	void eventBeatStopFire ( );
	void eventBeatAmmunitionFired ( );
	bool eventCanBeCanceled ( );
	bool eventCanBeInterrupted ( );
	bool eventShouldLockFiring ( class ATgDevice* Current );
	void UpdateTargetingModeStatus ( struct FAimData* Aim );
	void SetFireMode ( int nFireModeNum, unsigned long ForceSet );
	void SetPointsAllocated ( int nPoints );
	void UpdateAimWhileFiring ( struct FAimData* Aim );
};

UClass* ATgDevice_Raijin_KotoDrums::pClassPointer = NULL;

// Class TgGame.TgDevice_Raijin_KotoDrums_Beat
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_Raijin_KotoDrums_Beat : public ATgDevice
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1901 );

		return pClassPointer;
	};

	bool eventCanDeviceStartFiringNow ( unsigned char FireModeNum, struct FAimData Aim, unsigned long bDebugRelevant, unsigned char* failType );
	bool ShouldSwitchBackToBasicAttackTargeting ( unsigned char CastMode );
	void UpdateTargetingModeStatus ( struct FAimData* Aim );
};

UClass* ATgDevice_Raijin_KotoDrums_Beat::pClassPointer = NULL;

// Class TgGame.TgDevice_Ram_AimTowardsMovement
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_Ram_AimTowardsMovement : public ATgDevice
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1902 );

		return pClassPointer;
	};

	void GetTargetingAim ( struct FAimData* Aim );
	void GetLinearTargetAim ( struct FAimData* Aim );
	bool eventCanBeInterrupted ( );
	bool eventCanBeCanceled ( );
};

UClass* ATgDevice_Ram_AimTowardsMovement::pClassPointer = NULL;

// Class TgGame.TgDevice_Range
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_Range : public ATgDevice
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1903 );

		return pClassPointer;
	};

};

UClass* ATgDevice_Range::pClassPointer = NULL;

// Class TgGame.TgDevice_Apep_BasicAttack
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_Apep_BasicAttack : public ATgDevice_Range
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1904 );

		return pClassPointer;
	};

	void OnProjectileShutdown ( class ATgProjectile* Proj );
	void StartShockwaveAt ( class UTgDeviceFire* DeviceFire, struct FVector SpawnLoc );
};

UClass* ATgDevice_Apep_BasicAttack::pClassPointer = NULL;

// Class TgGame.TgDevice_Camazotz_VampireBats
// 0x0004 (0x0384 - 0x0380)
class ATgDevice_Camazotz_VampireBats : public ATgDevice_Range
{
public:
	unsigned long                                      m_bShouldUpgradeBatsHeal : 1;                     		// 0x0380 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1905 );

		return pClassPointer;
	};

	void SetPointsAllocated ( int nPoints );
	bool AllocateDevicePoint ( );
};

UClass* ATgDevice_Camazotz_VampireBats::pClassPointer = NULL;

// Class TgGame.TgDevice_ErlangShen_NineTurnsBlessing
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_ErlangShen_NineTurnsBlessing : public ATgDevice_Range
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1906 );

		return pClassPointer;
	};

	float GetConePullbackDistance ( );
};

UClass* ATgDevice_ErlangShen_NineTurnsBlessing::pClassPointer = NULL;

// Class TgGame.TgDevice_Fafnir_Dev1
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_Fafnir_Dev1 : public ATgDevice_Range
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1907 );

		return pClassPointer;
	};

	void OnProjectileShutdown ( class ATgProjectile* Proj );
	void StartShockwaveAt ( class UTgDeviceFire* DeviceFire, struct FVector SpawnLoc );
};

UClass* ATgDevice_Fafnir_Dev1::pClassPointer = NULL;

// Class TgGame.TgDevice_Izanami_IcyGrasp
// 0x0050 (0x03D0 - 0x0380)
class ATgDevice_Izanami_IcyGrasp : public ATgDevice_Range
{
public:
	unsigned char                                      UnknownData00[ 0x3C ];                            		// 0x0380 (0x003C) UNKNOWN PROPERTY: MapProperty TgGame.TgDevice_Izanami_IcyGrasp.m_HitTargets
	TArray< class ATgProj_Simulated* >                 m_ActiveContagions;                               		// 0x03BC (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	float                                              m_LastProjectileCheckTime;                        		// 0x03C8 (0x0004) [0x0000000000000000]              
	float                                              m_CheckProjectileTime;                            		// 0x03CC (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1908 );

		return pClassPointer;
	};

	bool eventCanFireWhileDead ( );
	void AddContagionProjectile ( class ATgProj_Simulated* Contagion );
	void RemoveContagionChain ( int FiringInstance );
	void AddContagion ( int FiringInstance, class ATgPawn* Victim );
};

UClass* ATgDevice_Izanami_IcyGrasp::pClassPointer = NULL;

// Class TgGame.TgDevice_Janus_Ultimate
// 0x000C (0x038C - 0x0380)
class ATgDevice_Janus_Ultimate : public ATgDevice_Range
{
public:
	TArray< class ATgProjectile* >                     s_ActiveProjectiles;                              		// 0x0380 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1909 );

		return pClassPointer;
	};

	void OnProjectileShutdown ( class ATgProjectile* Proj );
	void CustomProjectileInit ( class AProjectile* Proj, int ProjIndex, struct FAimData BaseAim );
	void SetPassiveStatus ( unsigned long bOn );
};

UClass* ATgDevice_Janus_Ultimate::pClassPointer = NULL;

// Class TgGame.TgDevice_Kaldr_Dev1
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_Kaldr_Dev1 : public ATgDevice_Range
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1910 );

		return pClassPointer;
	};

	bool eventCanBeFiredWhileTweening ( );
	bool eventShouldLockFiring ( class ATgDevice* Current );
	bool eventApplyGlobalOffhandCooldown ( );
	bool AllocateDevicePoint ( );
	void GetTargetingAim ( struct FAimData* Aim );
	void UpdateAimWhileFiring ( struct FAimData* Aim );
	struct FAimData CacheAim ( );
};

UClass* ATgDevice_Kaldr_Dev1::pClassPointer = NULL;

// Class TgGame.TgDevice_ManticoreScorpion
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_ManticoreScorpion : public ATgDevice_Range
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1911 );

		return pClassPointer;
	};

	void eventGetAdjustedAim ( int nShotIndex, struct FAimData* Aim );
};

UClass* ATgDevice_ManticoreScorpion::pClassPointer = NULL;

// Class TgGame.TgDevice_Medusa_Dev2
// 0x0004 (0x0384 - 0x0380)
class ATgDevice_Medusa_Dev2 : public ATgDevice_Range
{
public:
	unsigned long                                      c_bWillExplode : 1;                               		// 0x0380 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1912 );

		return pClassPointer;
	};

	void TickTargetingMode ( float DeltaSeconds );
	void GetTargetingAim ( struct FAimData* Aim );
};

UClass* ATgDevice_Medusa_Dev2::pClassPointer = NULL;

// Class TgGame.TgDevice_Nox_InHand
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_Nox_InHand : public ATgDevice_Range
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1913 );

		return pClassPointer;
	};

	void UpdateTargetingModeStatus ( struct FAimData* Aim );
};

UClass* ATgDevice_Nox_InHand::pClassPointer = NULL;

// Class TgGame.TgDevice_Obelisk_Dev1
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_Obelisk_Dev1 : public ATgDevice_Range
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1914 );

		return pClassPointer;
	};

};

UClass* ATgDevice_Obelisk_Dev1::pClassPointer = NULL;

// Class TgGame.TgDevice_ProjectileTeleport
// 0x0004 (0x0384 - 0x0380)
class ATgDevice_ProjectileTeleport : public ATgDevice_Range
{
public:
	unsigned long                                      m_bShutdownProjOnTeleport : 1;                    		// 0x0380 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1915 );

		return pClassPointer;
	};

	class ATgProjectile* eventGetProjectile ( );
	bool DoTeleport ( struct FVector vLocation, struct FVector vClientLocation );
	bool ServerTeleportToProjectile ( struct FVector vClientLocation );
	bool TeleportToProjectile ( );
	bool eventUse ( );
	bool HasEnoughPowerPool ( unsigned char FireModeNum );
};

UClass* ATgDevice_ProjectileTeleport::pClassPointer = NULL;

// Class TgGame.TgDevice_Monkey_FuriousMonkey
// 0x0011 (0x0395 - 0x0384)
class ATgDevice_Monkey_FuriousMonkey : public ATgDevice_ProjectileTeleport
{
public:
	class ATgPawn*                                     r_LastHitPawn;                                    		// 0x0384 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgPawn*                                     c_FxPawn;                                         		// 0x0388 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UTgSpecialFx*                                c_TargetingDirectionFx;                           		// 0x038C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UTgSpecialFx*                                c_TargetingPawnFx;                                		// 0x0390 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      m_eMonkeyState;                                   		// 0x0394 (0x0001) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1916 );

		return pClassPointer;
	};

	void UpdateTargetFxs ( );
	void ClearTargetingFxs ( );
	void DeviceShutDown ( unsigned long bDeactiveMode, unsigned long bResetCooldowns );
	void ToggleTeleportTimer ( unsigned long bEnable );
	void TeleportExpire ( );
	void ClientSetMonkeyState ( unsigned char NewState );
	void SetMonkeyState ( unsigned char NewState, class ATgPawn* Target, unsigned long bNoCooldown );
	bool ServerTeleportToLastTarget ( );
	bool TeleportToLastTarget ( );
	class ATgProjectile* GetProjectile ( );
	bool DoTeleport ( struct FVector vLocation, struct FVector vClientLocation );
	bool eventUse ( );
	bool eventShouldCooldownAfterFire ( );
	void eventPostDemoRewind ( );
	void eventPreDemoRewind ( );
	void Tick ( float DeltaTime );
	void eventReplicatedEvent ( struct FName VarName );
	bool HasEnoughPowerPool ( unsigned char FireModeNum );
};

UClass* ATgDevice_Monkey_FuriousMonkey::pClassPointer = NULL;

// Class TgGame.TgDevice_Raijin_RaijuuBouncing
// 0x0014 (0x0398 - 0x0384)
class ATgDevice_Raijin_RaijuuBouncing : public ATgDevice_ProjectileTeleport
{
public:
	class ATgProj_Raijin_RaijuuBouncing*               m_Raijuu;                                         		// 0x0384 (0x0004) [0x0000000000000000]              
	class ATgPawn*                                     r_LastHitPawn;                                    		// 0x0388 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgPawn*                                     c_FxPawn;                                         		// 0x038C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UTgSpecialFx*                                c_TargetingDirectionFx;                           		// 0x0390 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UTgSpecialFx*                                c_TargetingPawnFx;                                		// 0x0394 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1917 );

		return pClassPointer;
	};

	void UpdateTargetFxs ( );
	void ClearTargetingFxs ( );
	class ATgProjectile* GetProjectile ( );
	void eventPostDemoRewind ( );
	void eventPreDemoRewind ( );
	void Tick ( float DeltaTime );
	void eventReplicatedEvent ( struct FName VarName );
};

UClass* ATgDevice_Raijin_RaijuuBouncing::pClassPointer = NULL;

// Class TgGame.TgDevice_ThorTeleportHammer
// 0x0000 (0x0384 - 0x0384)
class ATgDevice_ThorTeleportHammer : public ATgDevice_ProjectileTeleport
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1918 );

		return pClassPointer;
	};

	bool DoTeleport ( struct FVector vLocation, struct FVector vClientLocation );
	class ATgProjectile* GetProjectile ( );
};

UClass* ATgDevice_ThorTeleportHammer::pClassPointer = NULL;

// Class TgGame.TgDevice_Raijin_Dev2
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_Raijin_Dev2 : public ATgDevice_Range
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1919 );

		return pClassPointer;
	};

	void eventGetAdjustedAim ( int nShotIndex, struct FAimData* Aim );
	void GetTargetingAim ( struct FAimData* Aim );
	unsigned char GetTargetingMode ( );
};

UClass* ATgDevice_Raijin_Dev2::pClassPointer = NULL;

// Class TgGame.TgDevice_Susano_Dev2_Part2
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_Susano_Dev2_Part2 : public ATgDevice_Range
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1920 );

		return pClassPointer;
	};

	bool eventShouldCooldownAfterFire ( );
	float GetConePullbackDistance ( );
	void RemoveEquipEffects ( );
};

UClass* ATgDevice_Susano_Dev2_Part2::pClassPointer = NULL;

// Class TgGame.TgDevice_Susano_Dev3
// 0x0028 (0x03A8 - 0x0380)
class ATgDevice_Susano_Dev3 : public ATgDevice_Range
{
public:
	unsigned char                                      r_CurrentState;                                   		// 0x0380 (0x0001) [0x0000000000000020]              ( CPF_Net )
	class AActor*                                      r_TeleportTarget;                                 		// 0x0384 (0x0004) [0x0000000000000020]              ( CPF_Net )
	TArray< class ATgDeployable* >                     m_WindDeployables;                                		// 0x0388 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class AProjectile*                                 m_LastFiredProjectile;                            		// 0x0394 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class AActor*                                      m_FxTarget;                                       		// 0x0398 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UTgSpecialFx*                                c_DirectionFx;                                    		// 0x039C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UTgSpecialFx*                                c_TimerFx;                                        		// 0x03A0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned long                                      c_QueueTeleport : 1;                              		// 0x03A4 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1921 );

		return pClassPointer;
	};

	void eventOnProjectileHit ( class AProjectile* Proj, class AActor* HitActor );
	void OnProjectileShutdown ( class ATgProjectile* Proj );
	class AProjectile* ProjectileFire ( int ProjectileIndex );
	void TeleportExpire ( );
	void DeviceShutDown ( unsigned long bDeactiveMode, unsigned long bResetCooldowns );
	bool ExecuteTeleportToTarget ( class ATgPawn* caster, struct FVector EndLocation, struct FRotator ToTarget );
	bool TryTeleportToDeployableTarget ( class ATgPawn* caster );
	bool TryTeleportToPawnTarget ( class ATgPawn* caster );
	bool ServerTeleportToLastTarget ( );
	bool TeleportToLastTarget ( );
	bool eventUse ( );
	bool eventCustomCanDeviceFireNow ( unsigned char FireModeNum, struct FAimData Aim, unsigned long bDeviceFailLog, unsigned char* failType );
	bool eventShouldCooldownAfterFire ( );
	void eventPostDemoRewind ( );
	void eventPreDemoRewind ( );
	void Tick ( float DeltaTime );
	void ClearTargetingFX ( );
	void CreateAndAttachFXToTarget ( class ATgPawn_Susano* Susano, class AActor* Target, int FxId, class UTgSpecialFx** Fx );
	void UpdateTargetingFX ( );
	void UpdateCurrentState ( );
	void SetCurrentTeleportTarget ( class AActor* Target );
	void SetCurrentState ( unsigned char State );
	void eventReplicatedEvent ( struct FName VarName );
	class ATgDeployable* SpawnDeployable ( class ATgProjectile* Projectile );
	bool HasEnoughPowerPool ( unsigned char FireModeNum );
};

UClass* ATgDevice_Susano_Dev3::pClassPointer = NULL;

// Class TgGame.TgDevice_TeamDevice
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_TeamDevice : public ATgDevice_Range
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1922 );

		return pClassPointer;
	};

	void TeamFlashCooldown ( unsigned char nMode );
	void TeamGotoState ( struct FName NewState );
	void TeamCooldownEnd ( );
	void TeamCooldownReset ( int nMode, float fCooldownTime );
	void TeamCooldownStart ( int nMode, float fCooldownTime );
	void TeamCooldownTimerExpired ( int nTimerId, unsigned char eEvent );
	void eventEndCooldown ( );
	void eventResetCooldown ( int nMode, float fCooldownTimeOverride );
	void eventStartCooldown ( int nMode, float fCooldownTimeOverride );
	void eventToggleCooldownEffects ( unsigned long bOnCooldown );
	void FlashCooldown ( unsigned char nMode );
	void CheckAndUpdateCooldown ( );
	class ATgRepInfo_TaskForce* GetTaskForce ( );
	class UTgTimerManager* GetCooldownTimerManager ( );
};

UClass* ATgDevice_TeamDevice::pClassPointer = NULL;

// Class TgGame.TgDevice_Ullr_Arrow
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_Ullr_Arrow : public ATgDevice_Range
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1923 );

		return pClassPointer;
	};

	void eventGetAdjustedAim ( int nShotIndex, struct FAimData* Aim );
};

UClass* ATgDevice_Ullr_Arrow::pClassPointer = NULL;

// Class TgGame.TgDevice_Zeus_SuperLightningBolt
// 0x0001 (0x0381 - 0x0380)
class ATgDevice_Zeus_SuperLightningBolt : public ATgDevice_Range
{
public:
	unsigned char                                      m_eBoltState;                                     		// 0x0380 (0x0001) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1924 );

		return pClassPointer;
	};

	bool eventCanDeviceFireNow ( unsigned char FireModeNum, struct FAimData Aim, unsigned long bDeviceFailLog, unsigned long bSkipStunCheck, unsigned char* failType );
	void ClientSetBoltState ( unsigned char NewState );
	void SetBoltState ( unsigned char NewState, class ATgPawn* Target, unsigned long bNoCooldown );
	class ATgProjectile* eventGetProjectile ( );
	bool eventShouldCooldownAfterFire ( );
};

UClass* ATgDevice_Zeus_SuperLightningBolt::pClassPointer = NULL;

// Class TgGame.TgDevice_Ratatoskr_AcornThrow
// 0x0014 (0x0394 - 0x0380)
class ATgDevice_Ratatoskr_AcornThrow : public ATgDevice
{
public:
	int                                                m_nProjectileOverridesSapphire[ 0x5 ];            		// 0x0380 (0x0014) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1925 );

		return pClassPointer;
	};

	int GetProjectileIDOverride ( int ProjectileIndex );
	void eventGetAdjustedAim ( int nShotIndex, struct FAimData* Aim );
};

UClass* ATgDevice_Ratatoskr_AcornThrow::pClassPointer = NULL;

// Class TgGame.TgDevice_Ravana_Dev4
// 0x0005 (0x0385 - 0x0380)
class ATgDevice_Ravana_Dev4 : public ATgDevice
{
public:
	class ATgCollisionProxy_Cylinder*                  m_DashCollision;                                  		// 0x0380 (0x0004) [0x0000000000000000]              
	unsigned char                                      m_eDashTweenType;                                 		// 0x0384 (0x0001) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1926 );

		return pClassPointer;
	};

	struct FImpactInfo CalcWeaponFire ( struct FAimData Aim, TArray< struct FImpactInfo >* ImpactList );
	bool eventCanBeCanceled ( );
	bool eventCanBeInterrupted ( );
	void eventProxyOnTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void TurnOffDashCollision ( );
	void TurnOnDashCollision ( );
};

UClass* ATgDevice_Ravana_Dev4::pClassPointer = NULL;

// Class TgGame.TgDevice_ReverseCone
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_ReverseCone : public ATgDevice
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1927 );

		return pClassPointer;
	};

	void GetConeTargetAim ( struct FAimData* Aim );
};

UClass* ATgDevice_ReverseCone::pClassPointer = NULL;

// Class TgGame.TgDevice_Sequenced
// 0x001C (0x039C - 0x0380)
class ATgDevice_Sequenced : public ATgDevice
{
public:
	int                                                r_NextDeviceId;                                   		// 0x0380 (0x0004) [0x0000000000000020]              ( CPF_Net )
	TArray< class ATgDevice_Sequenced* >               m_Sequence;                                       		// 0x0384 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class ATgDevice_Sequenced*                         m_RootDevice;                                     		// 0x0390 (0x0004) [0x0000000000000000]              
	float                                              r_RetriggerTimeLimit;                             		// 0x0394 (0x0004) [0x0000000000000020]              ( CPF_Net )
	unsigned long                                      m_ForceNoFire : 1;                                		// 0x0398 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      r_IsAnActiveSequence : 1;                         		// 0x0398 (0x0004) [0x0000000000000020] [0x00000002] ( CPF_Net )
	unsigned long                                      r_TriggerComboAtEnd : 1;                          		// 0x0398 (0x0004) [0x0000000000000020] [0x00000004] ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1928 );

		return pClassPointer;
	};

	class ATgDevice_Sequenced* GetNextChildInSequence ( );
	void PushNextDevice ( );
	void PopToRootDevice ( );
	void RetriggerTimeExpired ( );
	void DeinitializeInSequence ( );
	void InitializeInSequence ( class ATgDevice_Sequenced* rootDevice );
	bool AllowNextDeviceInSequence ( );
	bool eventShouldCooldownAfterFire ( );
	void DeviceConsumePowerPool ( unsigned char FireModeNum );
	bool eventCustomCanDeviceFireNow ( unsigned char FireModeNum, struct FAimData Aim, unsigned long bDeviceFailLog, unsigned char* failType );
	void eventHandleComboTrigger ( );
	void eventReplicatedEvent ( struct FName VarName );
	void SetFireMode ( int FireModeNum, unsigned long ForceSet );
	void SetPointsAllocated ( int Points );
	bool IsDeviceCoolingDown ( );
	bool HasEnoughPowerPool ( unsigned char FireModeNum );
	void UpdateManaUseVitals ( class ATgPlayerController* PC );
	bool IsRootDevice ( );
};

UClass* ATgDevice_Sequenced::pClassPointer = NULL;

// Class TgGame.TgDevice_Sequenced_RadialSweep
// 0x0018 (0x03B4 - 0x039C)
class ATgDevice_Sequenced_RadialSweep : public ATgDevice_Sequenced
{
public:
	class ATgCollisionProxy_RadialSweep*               m_CollisionProxy;                                 		// 0x039C (0x0004) [0x0000000000000000]              
	TArray< class AActor* >                            m_HitActors;                                      		// 0x03A0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class UTgDeviceFire*                               m_SweepFiremode;                                  		// 0x03AC (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bForceEndSweepOnStopFire : 1;                   		// 0x03B0 (0x0004) [0x0000000000000002] [0x00000001] ( CPF_Const )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1929 );

		return pClassPointer;
	};

	void eventDestroyed ( );
	bool CanRadialSweep ( );
	bool IsSweepActive ( );
	float eventGetPersistTime ( int nMode );
	void OnApplyHitFromTouch ( class UTgDeviceFire* FireMode, struct FImpactInfo* Impact );
	void eventProxyEndSweep ( unsigned long bInterrupt );
	void eventProxyUnTouch ( class AActor* Other );
	void eventProxyTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void eventUpdateCollisionProxyDelegates ( );
};

UClass* ATgDevice_Sequenced_RadialSweep::pClassPointer = NULL;

// Class TgGame.TgDevice_ShieldedRecall
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_ShieldedRecall : public ATgDevice
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1930 );

		return pClassPointer;
	};

	bool eventShouldLockFiring ( class ATgDevice* Current );
	bool eventCanBeInterrupted ( );
	bool eventCanBeCanceled ( );
};

UClass* ATgDevice_ShieldedRecall::pClassPointer = NULL;

// Class TgGame.TgDevice_Skadi_Passive
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_Skadi_Passive : public ATgDevice
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1931 );

		return pClassPointer;
	};

};

UClass* ATgDevice_Skadi_Passive::pClassPointer = NULL;

// Class TgGame.TgDevice_SobekPool
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_SobekPool : public ATgDevice
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1932 );

		return pClassPointer;
	};

	bool eventCanBeInterrupted ( );
	bool eventCanBeCanceled ( );
	void StopFire ( );
	bool eventShouldLockFiring ( class ATgDevice* Current );
	bool eventIsToggleDevice ( );
	bool CanBeGrabbed ( );
	bool CanBeDisarmed ( );
	bool CanBeSilenced ( );
	bool CanBeStunned ( );
};

UClass* ATgDevice_SobekPool::pClassPointer = NULL;

// Class TgGame.TgDevice_Sol_2Basic
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_Sol_2Basic : public ATgDevice
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1933 );

		return pClassPointer;
	};

	void OnProjectileShutdown ( class ATgProjectile* Proj );
};

UClass* ATgDevice_Sol_2Basic::pClassPointer = NULL;

// Class TgGame.TgDevice_Spline
// 0x0004 (0x0384 - 0x0380)
class ATgDevice_Spline : public ATgDevice
{
public:
	struct FPointer                                    VfTable_ITgSplineDeviceInterface;                 		// 0x0380 (0x0004) [0x0000000000801002]              ( CPF_Const | CPF_Native | CPF_NoExport )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1934 );

		return pClassPointer;
	};

	void eventGetAdjustedAimSpline ( int nShotIndex, struct FAimData* Aim );
	void TickTargetingMode ( float DeltaSeconds );
	bool CalculateFlightPath ( int nIndex, class UTgDeviceFire* DeviceMode, struct FInterpCurveVector* Spline, struct FAimData* Aim );
};

UClass* ATgDevice_Spline::pClassPointer = NULL;

// Class TgGame.TgDevice_HouYi_Dev1_Shooter
// 0x0004 (0x0388 - 0x0384)
class ATgDevice_HouYi_Dev1_Shooter : public ATgDevice_Spline
{
public:
	int                                                m_nMaxTargetingBounces;                           		// 0x0384 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1935 );

		return pClassPointer;
	};

	class AProjectile* ProjectileFire ( int ProjectileIndex );
	bool eventCanBeCanceled ( );
	bool CalculateFlightPath ( int nIndex, class UTgDeviceFire* DeviceMode, struct FInterpCurveVector* Spline, struct FAimData* Aim );
};

UClass* ATgDevice_HouYi_Dev1_Shooter::pClassPointer = NULL;

// Class TgGame.TgDevice_Janus_DeathGate
// 0x001C (0x03A0 - 0x0384)
class ATgDevice_Janus_DeathGate : public ATgDevice_Spline
{
public:
	float                                              m_fSamplesPerPeriod;                              		// 0x0384 (0x0004) [0x0000000000000002]              ( CPF_Const )
	TArray< class ATgProjectile* >                     s_ActiveProjectiles;                              		// 0x0388 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< struct FDeathGateHitInfo >                 s_ActiveTargets;                                  		// 0x0394 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1936 );

		return pClassPointer;
	};

	void OnProjectileShutdown ( class ATgProjectile* Proj );
	void CustomProjectileInit ( class AProjectile* Proj, int ProjIndex, struct FAimData BaseAim );
	int GetProjectileIDOverride ( int ProjectileIndex );
	void eventGetAdjustedAim ( int nShotIndex, struct FAimData* Aim );
	void SetPassiveStatus ( unsigned long bOn );
	bool CalculateFlightPath ( int nIndex, class UTgDeviceFire* DeviceMode, struct FInterpCurveVector* Spline, struct FAimData* Aim );
};

UClass* ATgDevice_Janus_DeathGate::pClassPointer = NULL;

// Class TgGame.TgDevice_Kali_Lash
// 0x0000 (0x0384 - 0x0384)
class ATgDevice_Kali_Lash : public ATgDevice_Spline
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1937 );

		return pClassPointer;
	};

	int GetProjectileIDOverride ( int ProjectileIndex );
	void eventGetAdjustedAim ( int nShotIndex, struct FAimData* Aim );
	bool CalculateFlightPath ( int nIndex, class UTgDeviceFire* DeviceMode, struct FInterpCurveVector* Spline, struct FAimData* Aim );
};

UClass* ATgDevice_Kali_Lash::pClassPointer = NULL;

// Class TgGame.TgDevice_Staging
// 0x002C (0x03AC - 0x0380)
class ATgDevice_Staging : public ATgDevice
{
public:
	TArray< int >                                      m_LockOutExceptionList;                           		// 0x0380 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	unsigned char                                      m_eBlockAegis;                                    		// 0x038C (0x0001) [0x0000000000000002]              ( CPF_Const )
	unsigned char                                      m_eBlockNonTargetingPurchaseables;                		// 0x038D (0x0001) [0x0000000000000002]              ( CPF_Const )
	unsigned long                                      m_bCanBeGrabSource : 1;                           		// 0x0390 (0x0004) [0x0000000000000002] [0x00000001] ( CPF_Const )
	unsigned long                                      s_bShouldFireStageShooterOnEndStage : 1;          		// 0x0390 (0x0004) [0x0000000000000002] [0x00000002] ( CPF_Const )
	unsigned long                                      s_bReplicateFireOnEndStageToClient : 1;           		// 0x0390 (0x0004) [0x0000000000000002] [0x00000004] ( CPF_Const )
	unsigned long                                      m_bStageShooterFired : 1;                         		// 0x0390 (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      m_bAllowStageShooterToFire : 1;                   		// 0x0390 (0x0004) [0x0000000000002000] [0x00000010] ( CPF_Transient )
	unsigned long                                      m_bSwapInHandOnShooterStopFire : 1;               		// 0x0390 (0x0004) [0x0000000000000000] [0x00000020] 
	unsigned long                                      c_bLockStageShooterFiring : 1;                    		// 0x0390 (0x0004) [0x0000000000000000] [0x00000040] 
	unsigned long                                      m_bStartStagingDuringFireAmmunition : 1;          		// 0x0390 (0x0004) [0x0000000000000000] [0x00000080] 
	class ATgDevice*                                   r_StageShooter;                                   		// 0x0394 (0x0004) [0x0000000000002020]              ( CPF_Net | CPF_Transient )
	int                                                m_nStageShooterId;                                		// 0x0398 (0x0004) [0x0000000000000002]              ( CPF_Const )
	class ATgDevice*                                   s_StoredInHand;                                   		// 0x039C (0x0004) [0x0000000000000000]              
	struct FVector                                     m_vInHandFiringOffset;                            		// 0x03A0 (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1938 );

		return pClassPointer;
	};

	bool eventInStage ( );
	bool eventInPreStage ( );
	void DeviceShutDown ( unsigned long bDeactiveMode, unsigned long bResetCooldowns );
	void ChangeInHandFiringOffset ( unsigned long bUsingStageShooter );
	void ClientSwapOutShooter ( );
	void eventSwapOutShooter ( );
	void ClientSwapInShooter ( );
	void SwapInShooter ( );
	bool StartStage ( );
	void FireAmmunition ( );
	void eventOnStageShooterStopFire ( unsigned long bInterrupted );
	bool ShouldSwapInHandOnShooterStopFire ( );
	void eventOnStageShooterFire ( );
	void eventOnStageShooterStartFire ( );
	void eventOnStageShooterStopBuildup ( unsigned long bInterrupted );
	void eventOnStageShooterStartBuildup ( );
	bool ShouldSetStageShooterFired ( );
	bool ClientFireOnEndStage ( );
	bool FireEndStageDevice ( );
	void ClientLockStageShooterFiring ( unsigned long bLock );
	bool LockStageShooterFiring ( );
	bool eventShouldLockFiring ( class ATgDevice* Current );
	bool eventCanBeCanceled ( );
	void SetFireMode ( int nFireModeNum, unsigned long ForceSet );
	void SetPointsAllocated ( int nPoints );
};

UClass* ATgDevice_Staging::pClassPointer = NULL;

// Class TgGame.TgDevice_Awilix_JungleMount
// 0x0004 (0x03B0 - 0x03AC)
class ATgDevice_Awilix_JungleMount : public ATgDevice_Staging
{
public:
	unsigned long                                      m_bInStageInterruption : 1;                       		// 0x03AC (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bWasInterrupted : 1;                            		// 0x03AC (0x0004) [0x0000000000000000] [0x00000002] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1939 );

		return pClassPointer;
	};

	void eventStartCooldown ( int nMode, float fCooldownTimeOverride );
	bool eventSimulateStartFire ( );
	void eventOnStageShooterStartBuildup ( );
	void eventInterruptFiring ( );
	bool eventShouldTriggerCastReactionItems ( );
	bool eventCanJumpWhileFiring ( );
	bool eventCanBeInterrupted ( );
	bool eventCanBeCanceled ( );
	bool eventShouldLockFiring ( class ATgDevice* Current );
};

UClass* ATgDevice_Awilix_JungleMount::pClassPointer = NULL;

// Class TgGame.TgDevice_Camazotz_Dev4Staging
// 0x0004 (0x03B0 - 0x03AC)
class ATgDevice_Camazotz_Dev4Staging : public ATgDevice_Staging
{
public:
	class ATgPawn_Camazotz*                            s_CachedCamazotz;                                 		// 0x03AC (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1940 );

		return pClassPointer;
	};

	bool ClientFireOnEndStage ( );
	void eventOnStageShooterStopFire ( unsigned long bInterrupted );
	void eventOnStageShooterStartBuildup ( );
	bool LockStageShooterFiring ( );
	bool eventCanJumpWhileFiring ( );
	bool eventCanBeCanceled ( );
};

UClass* ATgDevice_Camazotz_Dev4Staging::pClassPointer = NULL;

// Class TgGame.TgDevice_Chiron_Ultimate
// 0x0028 (0x03D4 - 0x03AC)
class ATgDevice_Chiron_Ultimate : public ATgDevice_Staging
{
public:
	unsigned long                                      r_bShooterFired : 1;                              		// 0x03AC (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )
	unsigned long                                      m_bForcingPostFire : 1;                           		// 0x03AC (0x0004) [0x0000000000000000] [0x00000002] 
	int                                                m_nAmmoRemaining;                                 		// 0x03B0 (0x0004) [0x0000000000000000]              
	int                                                m_nMaxAmmo;                                       		// 0x03B4 (0x0004) [0x0000000000000000]              
	float                                              m_fForcedPostFireDuration;                        		// 0x03B8 (0x0004) [0x0000000000000000]              
	class UClass*                                      m_DefaultCameraModuleClass;                       		// 0x03BC (0x0004) [0x0000000000000000]              
	class UClass*                                      m_FiringCameraModuleClass;                        		// 0x03C0 (0x0004) [0x0000000000000000]              
	class UTgCameraModule*                             m_FiringCameraModule;                             		// 0x03C4 (0x0004) [0x0000000000000000]              
	float                                              m_fCameraTweenInTime;                             		// 0x03C8 (0x0004) [0x0000000000000000]              
	float                                              m_fCameraTweenOutTime;                            		// 0x03CC (0x0004) [0x0000000000000000]              
	float                                              m_fFiringCameraZOffset;                           		// 0x03D0 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1941 );

		return pClassPointer;
	};

	void TurnOffSpecialCamera ( );
	void TurnOnSpecialCamera ( );
	void EndForcedPostFire ( );
	void eventOnStageShooterStopFire ( unsigned long bInterrupted );
	void eventOnStageShooterStartBuildup ( );
	bool LockStageShooterFiring ( );
	bool eventCanJumpWhileFiring ( );
	bool eventCanBeCanceled ( );
	bool eventShouldLockFiring ( class ATgDevice* Current );
	bool eventShouldTriggerCastReactionItems ( );
	bool eventShouldInterruptInhand ( );
	bool ShouldConsumePowerPoolAfterFire ( );
	bool ShouldConsumePowerPoolOnStartFire ( );
	bool ShouldCooldownAfterFire ( );
};

UClass* ATgDevice_Chiron_Ultimate::pClassPointer = NULL;

// Class TgGame.TgDevice_Kumbhakarna_Num2
// 0x0004 (0x03B0 - 0x03AC)
class ATgDevice_Kumbhakarna_Num2 : public ATgDevice_Staging
{
public:
	unsigned long                                      m_bIsToggle : 1;                                  		// 0x03AC (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1942 );

		return pClassPointer;
	};

	bool ShouldInterruptReload ( );
	bool eventIsToggleDevice ( );
	bool eventStartFire ( );
	bool eventShouldCooldownAfterFire ( );
	bool CanDeviceFireInTargetingMode ( );
	bool eventCanBeCanceled ( );
	bool IsToggledOn ( );
	void UpdateUIToggleState ( );
};

UClass* ATgDevice_Kumbhakarna_Num2::pClassPointer = NULL;

// Class TgGame.TgDevice_NuWa_Ultimate
// 0x0010 (0x03BC - 0x03AC)
class ATgDevice_NuWa_Ultimate : public ATgDevice_Staging
{
public:
	class ATgPawn_NuWaV2*                              s_CachedNuWa;                                     		// 0x03AC (0x0004) [0x0000000000000000]              
	float                                              m_fChargeRange;                                   		// 0x03B0 (0x0004) [0x0000000000000000]              
	unsigned char                                      m_eChargeType;                                    		// 0x03B4 (0x0001) [0x0000000000000000]              
	unsigned long                                      m_bCharging : 1;                                  		// 0x03B8 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1943 );

		return pClassPointer;
	};

	void eventOnStageShooterStopFire ( unsigned long bInterrupted );
	void eventOnStageShooterStartBuildup ( );
	bool LockStageShooterFiring ( );
	bool eventCanJumpWhileFiring ( );
	bool eventCanBeCanceled ( );
	void SetFireMode ( int nFireModeNum, unsigned long ForceSet );
};

UClass* ATgDevice_NuWa_Ultimate::pClassPointer = NULL;

// Class TgGame.TgDevice_Ram_AstralArrow
// 0x0004 (0x03B0 - 0x03AC)
class ATgDevice_Ram_AstralArrow : public ATgDevice_Staging
{
public:
	class ATgPawn_Ram*                                 s_CachedRam;                                      		// 0x03AC (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1944 );

		return pClassPointer;
	};

	void eventOnStageShooterStopFire ( unsigned long bInterrupted );
	void eventOnStageShooterStartBuildup ( );
	bool LockStageShooterFiring ( );
	bool eventCanJumpWhileFiring ( );
	bool eventCanBeCanceled ( );
};

UClass* ATgDevice_Ram_AstralArrow::pClassPointer = NULL;

// Class TgGame.TgDevice_Serqet_Ambush
// 0x0016 (0x03C2 - 0x03AC)
class ATgDevice_Serqet_Ambush : public ATgDevice_Staging
{
public:
	unsigned long                                      s_bStealthActive : 1;                             		// 0x03AC (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      r_bCanCancel : 1;                                 		// 0x03AC (0x0004) [0x0000000000000020] [0x00000002] ( CPF_Net )
	class ATgCollisionProxy*                           m_HitProxy;                                       		// 0x03B0 (0x0004) [0x0000000000000000]              
	TArray< class AActor* >                            s_PreventStealthList;                             		// 0x03B4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	unsigned char                                      m_eStealthOnState;                                		// 0x03C0 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_eStealthOffState;                               		// 0x03C1 (0x0001) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1945 );

		return pClassPointer;
	};

	void eventAuraUnTouch ( class AActor* Other );
	void eventAuraTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void ToggleStealth ( unsigned long bOn );
	bool ShouldCancelStealth ( );
	bool eventCanBeInterrupted ( );
	bool eventCanBeCanceled ( );
	void SetFireMode ( int nFireModeNum, unsigned long ForceSet );
	bool ShouldRevealFromStealth ( );
};

UClass* ATgDevice_Serqet_Ambush::pClassPointer = NULL;

// Class TgGame.TgDevice_Sol_Dev4_Staging
// 0x0000 (0x03AC - 0x03AC)
class ATgDevice_Sol_Dev4_Staging : public ATgDevice_Staging
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1946 );

		return pClassPointer;
	};

	bool FireEndStageDevice ( );
	void ClientInterrupt ( );
	bool eventCanBeInterrupted ( );
};

UClass* ATgDevice_Sol_Dev4_Staging::pClassPointer = NULL;

// Class TgGame.TgDevice_StagingRefresh
// 0x0004 (0x03B0 - 0x03AC)
class ATgDevice_StagingRefresh : public ATgDevice_Staging
{
public:
	float                                              s_fCachedPostHitTime;                             		// 0x03AC (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1947 );

		return pClassPointer;
	};

	void eventOnStageShooterStopFire ( unsigned long bInterrupted );
	float GetRefreshTime ( );
	bool CanRefreshPostHitDelay ( );
	void eventOnStageShooterStartBuildup ( );
	void ClientLockStageShooterFiring ( unsigned long bLock );
	bool LockStageShooterFiring ( );
	void ClientInterrupt ( );
	void ClientResumePostHitDelay ( float fTimeRemaining );
	void ClientPausePostHitDelay ( );
	bool ResumePostHitDelay ( float fTimeRemaining );
	bool PausePostHitDelay ( float* fTimeRemaining );
};

UClass* ATgDevice_StagingRefresh::pClassPointer = NULL;

// Class TgGame.TgDevice_Scylla_Ultimate
// 0x0014 (0x03C4 - 0x03B0)
class ATgDevice_Scylla_Ultimate : public ATgDevice_StagingRefresh
{
public:
	class ATgPawn_Scylla*                              s_CachedScylla;                                   		// 0x03B0 (0x0004) [0x0000000000000000]              
	int                                                m_nShooterFireCount;                              		// 0x03B4 (0x0004) [0x0000000000000000]              
	int                                                m_nCachedFireCountMax;                            		// 0x03B8 (0x0004) [0x0000000000000000]              
	int                                                m_nShooterFireCountMax;                           		// 0x03BC (0x0004) [0x0000000000000000]              
	unsigned long                                      s_bFirstCast : 1;                                 		// 0x03C0 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      s_bGodKilled : 1;                                 		// 0x03C0 (0x0004) [0x0000000000000000] [0x00000002] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1948 );

		return pClassPointer;
	};

	void eventOnStageShooterStopFire ( unsigned long bInterrupted );
	bool CanRefreshPostHitDelay ( );
	bool eventCanJumpWhileFiring ( );
	bool eventCanBeCanceled ( );
	void SetFireMode ( int nFireModeNum, unsigned long ForceSet );
};

UClass* ATgDevice_Scylla_Ultimate::pClassPointer = NULL;

// Class TgGame.TgDevice_Staging_MultiBase
// 0x0044 (0x03C4 - 0x0380)
class ATgDevice_Staging_MultiBase : public ATgDevice
{
public:
	TArray< int >                                      m_LockOutExceptionList;                           		// 0x0380 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	unsigned char                                      m_eBlockAegis;                                    		// 0x038C (0x0001) [0x0000000000000002]              ( CPF_Const )
	unsigned char                                      m_eBlockNonTargetingPurchaseables;                		// 0x038D (0x0001) [0x0000000000000002]              ( CPF_Const )
	unsigned long                                      m_bCanBeGrabSource : 1;                           		// 0x0390 (0x0004) [0x0000000000000002] [0x00000001] ( CPF_Const )
	unsigned long                                      r_bAnyShooterHasFired : 1;                        		// 0x0390 (0x0004) [0x0000000000000020] [0x00000002] ( CPF_Net )
	unsigned long                                      m_bAllowShooterToFire : 1;                        		// 0x0390 (0x0004) [0x0000000000002000] [0x00000004] ( CPF_Transient )
	unsigned long                                      c_bLockShooterFiring : 1;                         		// 0x0390 (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      m_bBlockPreStagingAnim : 1;                       		// 0x0390 (0x0004) [0x0000000000000000] [0x00000010] 
	unsigned long                                      m_bBlockPostStagingAnim : 1;                      		// 0x0390 (0x0004) [0x0000000000000000] [0x00000020] 
	unsigned long                                      m_bDeferAimToShooters : 1;                        		// 0x0390 (0x0004) [0x0000000000000000] [0x00000040] 
	unsigned long                                      m_bForceFirstShooterWhenReady : 1;                		// 0x0390 (0x0004) [0x0000000000000000] [0x00000080] 
	class ATgDevice*                                   r_FirstShooter;                                   		// 0x0394 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgDevice*                                   r_CurrentShooter;                                 		// 0x0398 (0x0004) [0x0000000000002020]              ( CPF_Net | CPF_Transient )
	int                                                r_nCurrentShooterIndex;                           		// 0x039C (0x0004) [0x0000000000000020]              ( CPF_Net )
	TArray< class ATgDevice* >                         r_Shooters;                                       		// 0x03A0 (0x000C) [0x0000000000500000]              ( CPF_NeedCtorLink )
	TArray< int >                                      m_nShooterIds;                                    		// 0x03AC (0x000C) [0x0000000000400002]              ( CPF_Const | CPF_NeedCtorLink )
	TArray< unsigned long >                            m_bShooterFired;                                  		// 0x03B8 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1949 );

		return pClassPointer;
	};

	bool ShouldConsumePowerPoolAfterFire ( );
	bool ShouldConsumePowerPoolOnStartFire ( );
	bool ShouldCooldownAfterFire ( );
	void ClientSwapOutCurrentShooter ( );
	void eventSwapOutCurrentShooter ( );
	void ClientSwapInNextShooter ( );
	void SwapInNextShooter ( );
	void EndPostStage ( unsigned long bInterrupted );
	bool eventInPostStage ( );
	void StartPostStage ( );
	bool EndStage ( unsigned long bInterrupted );
	bool eventInStage ( );
	bool StartStage ( );
	void EndPreStage ( unsigned long bInterrupted );
	bool eventInPreStage ( );
	void StartPreStage ( );
	void DeviceShutDown ( unsigned long bDeactiveMode, unsigned long bResetCooldowns );
	void eventInterruptAllShooters ( );
	void eventInterruptFiring ( );
	void StopFire ( );
	void eventStopAllAnim ( );
	void eventStartPostStagingAnim ( );
	void eventStartShooterPostFireAnim ( class ATgDevice* Dev );
	void eventStartShooterFireAnim ( class ATgDevice* Dev );
	void eventStartShooterPreFireAnim ( class ATgDevice* Dev );
	void eventStartPreStagingAnim ( );
	void eventSetActiveAnimChild ( int nChild );
	void eventOnShooterStopFire ( unsigned long bInterrupted );
	void eventOnShooterFire ( );
	void eventOnShooterStartFire ( );
	void eventOnShooterStopBuildup ( unsigned long bInterrupted );
	void eventOnShooterStartBuildup ( );
	void SetAllShootersFired ( unsigned long bFired );
	void SetShooterFired ( class ATgDevice* Dev, unsigned long bFired );
	bool ShouldSetShooterFired ( class ATgDevice* Dev );
	bool eventAnyShooterHasFired ( );
	bool ShooterHasFired ( class ATgDevice* Dev );
	class ATgDevice* GetNextShooter ( class ATgDevice* Dev );
	class ATgDevice* eventGetFirstShooter ( );
	int GetShooterIndex ( class ATgDevice* Dev );
	void ClientLockShooterFiring ( unsigned long bLock );
	bool LockShooterFiring ( );
	float GetLockoutExtensionTime ( );
	bool eventShouldLockFiring ( class ATgDevice* Current );
	bool eventCanStagingBeInterrupted ( );
	bool eventCanBeInterrupted ( );
	bool eventCanStagingBeCanceled ( );
	bool eventCanBeCanceled ( );
	bool eventForceFirstShooter ( );
	void eventReplicatedEvent ( struct FName VarName );
	void SetFireMode ( int nFireModeNum, unsigned long ForceSet );
	void SetPointsAllocated ( int nPoints );
};

UClass* ATgDevice_Staging_MultiBase::pClassPointer = NULL;

// Class TgGame.TgDevice_JingWei_Dev4_Staging
// 0x0008 (0x03CC - 0x03C4)
class ATgDevice_JingWei_Dev4_Staging : public ATgDevice_Staging_MultiBase
{
public:
	float                                              m_ForceLandingTime;                               		// 0x03C4 (0x0004) [0x0000000000000000]              
	unsigned long                                      r_bWillCooldown : 1;                              		// 0x03C8 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1950 );

		return pClassPointer;
	};

	void DeviceShutDown ( unsigned long bDeactiveMode, unsigned long bResetCooldowns );
	void eventSetActiveAnimChild ( int nChild );
	void eventForceLanding ( );
	void eventOnShooterStopFire ( unsigned long bInterrupted );
	void ForceClientCooldown ( int nMode );
	void eventOnShooterStartFire ( );
	void eventOnShooterStartBuildup ( );
	void eventForceSelfCollisions ( unsigned long bEnable );
	void eventForceSelfRoot ( unsigned long bEnable );
	bool eventIsFiring ( );
	bool eventCanStagingBeCanceled ( );
	bool ShouldCooldownAfterFire ( );
	bool eventApplyGlobalOffhandCooldown ( );
	bool HasEnoughPowerPool ( unsigned char FireModeNum );
};

UClass* ATgDevice_JingWei_Dev4_Staging::pClassPointer = NULL;

// Class TgGame.TgDevice_SunWukong_SomersaultCloud
// 0x0008 (0x0388 - 0x0380)
class ATgDevice_SunWukong_SomersaultCloud : public ATgDevice
{
public:
	class ATgPawn_SunWukong*                           s_CachedWukong;                                   		// 0x0380 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bCalcBotPlacementAim : 1;                       		// 0x0384 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1951 );

		return pClassPointer;
	};

	void CustomFire ( );
	void InstantFire ( );
	bool ShouldCancelStealth ( );
	bool eventCanBeCanceled ( );
	void UpdateTargetingModeStatus ( struct FAimData* Aim );
	void GetTargetingAim ( struct FAimData* Aim );
};

UClass* ATgDevice_SunWukong_SomersaultCloud::pClassPointer = NULL;

// Class TgGame.TgDevice_Sylvanus_HealingWisp
// 0x0034 (0x03B4 - 0x0380)
class ATgDevice_Sylvanus_HealingWisp : public ATgDevice
{
public:
	TArray< class AActor* >                            m_CurrentTargets;                                 		// 0x0380 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UTgDeviceFire* >                     m_EnemyProjectileFireModes;                       		// 0x038C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UTgDeviceFire* >                     m_FriendlyProjectileFireModes;                    		// 0x0398 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                m_nEnemyProjectileId;                             		// 0x03A4 (0x0004) [0x0000000000000000]              
	int                                                m_nFriendlyProjectileId;                          		// 0x03A8 (0x0004) [0x0000000000000000]              
	struct FPointer                                    m_pProjSetupEnemy;                                		// 0x03AC (0x0004) [0x0000000000001000]              ( CPF_Native )
	struct FPointer                                    m_pProjSetupFriendly;                             		// 0x03B0 (0x0004) [0x0000000000001000]              ( CPF_Native )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1952 );

		return pClassPointer;
	};

	class AProjectile* FireWisp ( class AActor* Target, struct FAimData Aim );
	class AProjectile* ProjectileFire ( int ProjectileIndex );
	void UpdateTargetList ( struct FAimData* Aim );
	void GetTargetingAim ( struct FAimData* Aim );
};

UClass* ATgDevice_Sylvanus_HealingWisp::pClassPointer = NULL;

// Class TgGame.TgDevice_Terra_MotherEarth
// 0x0004 (0x0384 - 0x0380)
class ATgDevice_Terra_MotherEarth : public ATgDevice
{
public:
	unsigned long                                      r_IsEffectActive : 1;                             		// 0x0380 (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1953 );

		return pClassPointer;
	};

	struct FImpactInfo CalcWeaponFire ( struct FAimData Aim, TArray< struct FImpactInfo >* ImpactList );
	class ATgRepInfo_TaskForce* GetInstigatorTeam ( );
	void eventOnEffectEndOnSelf ( );
	void eventOnEffectPlacedOnSelf ( float Duration );
	bool eventCustomCanDeviceFireNow ( unsigned char FireModeNum, struct FAimData Aim, unsigned long bDeviceFailLog, unsigned char* failType );
	bool eventShouldTriggerCastReactionItemsOnFire ( );
	bool eventShouldTriggerCastReactionItems ( );
	bool eventShouldCooldownAfterFire ( );
	void eventReplicatedEvent ( struct FName VarName );
};

UClass* ATgDevice_Terra_MotherEarth::pClassPointer = NULL;

// Class TgGame.TgDevice_Thoth_Dev1
// 0x0004 (0x0384 - 0x0380)
class ATgDevice_Thoth_Dev1 : public ATgDevice
{
public:
	unsigned long                                      r_bIsToggledOn : 1;                               		// 0x0380 (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1954 );

		return pClassPointer;
	};

	void eventStartCooldown ( int nMode, float fCooldownTimeOverride );
	void FireAmmunition ( );
	bool eventShouldCooldownAfterFire ( );
	void eventReplicatedEvent ( struct FName VarName );
	bool IsToggledOn ( );
};

UClass* ATgDevice_Thoth_Dev1::pClassPointer = NULL;

// Class TgGame.TgDevice_Thoth_RangeExtension
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_Thoth_RangeExtension : public ATgDevice
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1955 );

		return pClassPointer;
	};

};

UClass* ATgDevice_Thoth_RangeExtension::pClassPointer = NULL;

// Class TgGame.TgDevice_Thoth_Dev1_Shooter
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_Thoth_Dev1_Shooter : public ATgDevice_Thoth_RangeExtension
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1956 );

		return pClassPointer;
	};

	bool CanBeDisarmed ( );
	void UpdateTargetingModeStatus ( struct FAimData* Aim );
	unsigned char GetCurrentFiringInstance ( );
};

UClass* ATgDevice_Thoth_Dev1_Shooter::pClassPointer = NULL;

// Class TgGame.TgDevice_Thoth_Dev2Shooter
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_Thoth_Dev2Shooter : public ATgDevice_Thoth_RangeExtension
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1957 );

		return pClassPointer;
	};

	bool CanBeDisarmed ( );
};

UClass* ATgDevice_Thoth_Dev2Shooter::pClassPointer = NULL;

// Class TgGame.TgDevice_TimerFromParent
// 0x0006 (0x0386 - 0x0380)
class ATgDevice_TimerFromParent : public ATgDevice
{
public:
	unsigned long                                      m_bUsesDistanceScaleTimer : 1;                    		// 0x0380 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned char                                      m_eStartTimerCheckpoint;                          		// 0x0384 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_eStopTimerCheckpoint;                           		// 0x0385 (0x0001) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1958 );

		return pClassPointer;
	};

};

UClass* ATgDevice_TimerFromParent::pClassPointer = NULL;

// Class TgGame.TgDevice_AnvilSlamBase
// 0x0012 (0x0398 - 0x0386)
class ATgDevice_AnvilSlamBase : public ATgDevice_TimerFromParent
{
public:
	unsigned long                                      m_bDoTimeOutJump : 1;                             		// 0x0388 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bUseBackupLocation : 1;                         		// 0x0388 (0x0004) [0x0000000000000000] [0x00000002] 
	struct FVector                                     m_vBackupLocation;                                		// 0x038C (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1959 );

		return pClassPointer;
	};

	bool eventCanBeCanceled ( );
	bool eventApplyGlobalOffhandCooldown ( );
	bool eventShouldInterruptInhand ( );
	bool eventTriggerTimeOutJump ( );
	bool CanLockFiringAegisAmulet ( );
	void UpdateBackupLocation ( struct FVector vLoc );
	void GetGroundTargetAim ( struct FAimData* Aim );
};

UClass* ATgDevice_AnvilSlamBase::pClassPointer = NULL;

// Class TgGame.TgDevice_AoKuang_UltimateJumpDown
// 0x0004 (0x039C - 0x0398)
class ATgDevice_AoKuang_UltimateJumpDown : public ATgDevice_AnvilSlamBase
{
public:
	int                                                s_nSwordChargesConsumed;                          		// 0x0398 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1960 );

		return pClassPointer;
	};

	void SpawnWarningDeployable ( );
};

UClass* ATgDevice_AoKuang_UltimateJumpDown::pClassPointer = NULL;

// Class TgGame.TgDevice_HouYi_DivebombShooter
// 0x0008 (0x03A0 - 0x0398)
class ATgDevice_HouYi_DivebombShooter : public ATgDevice_AnvilSlamBase
{
public:
	unsigned char                                      m_eDiveBombTweenState;                            		// 0x0398 (0x0001) [0x0000000000000000]              
	unsigned long                                      s_bDisableOnTweenEnd : 1;                         		// 0x039C (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bFixedTweenTime : 1;                            		// 0x039C (0x0004) [0x0000000000000000] [0x00000002] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1961 );

		return pClassPointer;
	};

	void FireAmmunition ( );
	void OnTweenEnd ( unsigned long bInterrupted );
	struct FVector eventGetTweenLocation ( struct FAimData* Aim );
	float GetTweenTime ( );
	void ClientInterrupt ( );
	void eventDestroyed ( );
};

UClass* ATgDevice_HouYi_DivebombShooter::pClassPointer = NULL;

// Class TgGame.TgDevice_Sol_Dev4
// 0x0004 (0x039C - 0x0398)
class ATgDevice_Sol_Dev4 : public ATgDevice_AnvilSlamBase
{
public:
	unsigned long                                      s_bDisableOnTweenEnd : 1;                         		// 0x0398 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1962 );

		return pClassPointer;
	};

	void OnTweenEnd ( unsigned long bInterrupted );
	void FireAmmunition ( );
	float GetTweenTime ( );
	struct FVector eventGetTweenLocation ( struct FAimData* Aim );
	void ClientInterrupt ( );
};

UClass* ATgDevice_Sol_Dev4::pClassPointer = NULL;

// Class TgGame.TgDevice_ThorAnvilSlam
// 0x0000 (0x0398 - 0x0398)
class ATgDevice_ThorAnvilSlam : public ATgDevice_AnvilSlamBase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1963 );

		return pClassPointer;
	};

	bool eventSimulateStartFire ( );
	void SpawnWarningDeployable ( );
};

UClass* ATgDevice_ThorAnvilSlam::pClassPointer = NULL;

// Class TgGame.TgDevice_Ram_AstralArrowShooter
// 0x001A (0x03A0 - 0x0386)
class ATgDevice_Ram_AstralArrowShooter : public ATgDevice_TimerFromParent
{
public:
	int                                                m_nAmmoCount;                                     		// 0x0388 (0x0004) [0x0000000000000000]              
	int                                                m_nMaxAmmoCount;                                  		// 0x038C (0x0004) [0x0000000000000000]              
	int                                                m_nAmmoCountSituationalType;                      		// 0x0390 (0x0004) [0x0000000000000000]              
	TArray< int >                                      m_nProjectileIds;                                 		// 0x0394 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1964 );

		return pClassPointer;
	};

	void ClientSetAmmoCount ( int nAmmoCount );
	void eventSetAmmoCount ( int nAmmoCount, unsigned long bDoNotFowardToClient );
	void eventInterruptFiring ( );
	int GetProjectileIDOverride ( int ProjectileIndex );
	void CustomProjectileInit ( class AProjectile* Proj, int ProjIndex, struct FAimData BaseAim );
	void eventDeviceConsumePowerPool ( unsigned char FireModeNum );
	bool eventApplyGlobalOffhandCooldown ( );
	bool eventShouldInterruptInhand ( );
	int GetProjectileNum ( );
	bool HasEnoughPowerPool ( unsigned char FireModeNum );
	void RemoveEquipEffects ( );
	void ApplyEquipEffects ( );
	void TickTargetingMode ( float DeltaSeconds );
	void UpdateTargetingModeStatus ( struct FAimData* Aim );
};

UClass* ATgDevice_Ram_AstralArrowShooter::pClassPointer = NULL;

// Class TgGame.TgDevice_Scylla_UltimateShooter
// 0x0006 (0x038C - 0x0386)
class ATgDevice_Scylla_UltimateShooter : public ATgDevice_TimerFromParent
{
public:
	float                                              m_fCachedDistanceScale;                           		// 0x0388 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1965 );

		return pClassPointer;
	};

	bool eventApplyGlobalOffhandCooldown ( );
	bool eventShouldInterruptInhand ( );
};

UClass* ATgDevice_Scylla_UltimateShooter::pClassPointer = NULL;

// Class TgGame.TgDevice_Thanatos_HoveringDeathStrike
// 0x0002 (0x0388 - 0x0386)
class ATgDevice_Thanatos_HoveringDeathStrike : public ATgDevice_TimerFromParent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1966 );

		return pClassPointer;
	};

	bool eventCanBeCanceled ( );
	bool eventApplyGlobalOffhandCooldown ( );
	void GetGroundTargetAim ( struct FAimData* Aim );
};

UClass* ATgDevice_Thanatos_HoveringDeathStrike::pClassPointer = NULL;

// Class TgGame.TgDevice_Toggle
// 0x0004 (0x0384 - 0x0380)
class ATgDevice_Toggle : public ATgDevice
{
public:
	unsigned long                                      m_bIsToggle : 1;                                  		// 0x0380 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1967 );

		return pClassPointer;
	};

	bool ShouldInterruptReload ( );
	bool eventCanBeInterrupted ( );
	bool eventIsToggleDevice ( );
	void eventInterruptFiring ( );
	bool eventStartFire ( );
	bool CanDeviceFireInTargetingMode ( );
	bool IsToggledOn ( );
	void UpdateUIToggleState ( );
};

UClass* ATgDevice_Toggle::pClassPointer = NULL;

// Class TgGame.TgDevice_Ram_Offhand1
// 0x0008 (0x038C - 0x0384)
class ATgDevice_Ram_Offhand1 : public ATgDevice_Toggle
{
public:
	float                                              m_ElapsedRechargeTime;                            		// 0x0384 (0x0004) [0x0000000000000000]              
	float                                              m_LastTickCooldownUpdate;                         		// 0x0388 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1968 );

		return pClassPointer;
	};

	bool eventCanDeviceFireNow ( unsigned char FireModeNum, struct FAimData Aim, unsigned long bDeviceFailLog, unsigned long bSkipStunCheck, unsigned char* failType );
	void Tick ( float DeltaSeconds );
	bool eventCanBeCanceled ( );
	bool eventCanBeCanceledByRightMouse ( );
	bool eventShouldTriggerCastReactionItems ( );
	void DeviceConsumePowerPool ( unsigned char FireModeNum );
	bool IsTargetingModeReady ( unsigned char* failType );
	bool ShowUICanFire ( );
	bool HasEnoughPowerPool ( unsigned char FireModeNum );
	void SetFireMode ( int nFireModeNum, unsigned long ForceSet );
};

UClass* ATgDevice_Ram_Offhand1::pClassPointer = NULL;

// Class TgGame.TgDevice_Xbalanque_Splitting_Projectile_Stim
// 0x0000 (0x0384 - 0x0384)
class ATgDevice_Xbalanque_Splitting_Projectile_Stim : public ATgDevice_Toggle
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1969 );

		return pClassPointer;
	};

	bool eventCanBeCanceledByRightMouse ( );
	bool eventShouldTriggerCastReactionItems ( );
	void DeviceConsumePowerPool ( unsigned char FireModeNum );
	bool eventCanBeInterrupted ( );
	bool HasEnoughPowerPool ( unsigned char FireModeNum );
	void SetFireMode ( int nFireModeNum, unsigned long ForceSet );
};

UClass* ATgDevice_Xbalanque_Splitting_Projectile_Stim::pClassPointer = NULL;

// Class TgGame.TgDevice_TriggerItemsOnFire
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_TriggerItemsOnFire : public ATgDevice
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1970 );

		return pClassPointer;
	};

	bool eventShouldTriggerCastReactionItemsOnFire ( );
};

UClass* ATgDevice_TriggerItemsOnFire::pClassPointer = NULL;

// Class TgGame.TgDevice_TweenBase
// 0x0008 (0x0388 - 0x0380)
class ATgDevice_TweenBase : public ATgDevice
{
public:
	unsigned char                                      m_eTweenState;                                    		// 0x0380 (0x0001) [0x0000000000000000]              
	unsigned long                                      m_bFixedTweenTime : 1;                            		// 0x0384 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1971 );

		return pClassPointer;
	};

	void OnTweenEnd ( unsigned long bInterrupted );
	void OnTweenStart ( );
	struct FVector eventGetTweenLocation ( struct FAimData* Aim );
	float GetTweenTime ( );
	void GetGroundTargetAim ( struct FAimData* Aim );
};

UClass* ATgDevice_TweenBase::pClassPointer = NULL;

// Class TgGame.TgDevice_Bellona_VeniVidiVici
// 0x0004 (0x038C - 0x0388)
class ATgDevice_Bellona_VeniVidiVici : public ATgDevice_TweenBase
{
public:
	float                                              m_fFlagOffsetX;                                   		// 0x0388 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1972 );

		return pClassPointer;
	};

	struct FVector eventGetTweenLocation ( struct FAimData* Aim );
};

UClass* ATgDevice_Bellona_VeniVidiVici::pClassPointer = NULL;

// Class TgGame.TgDevice_Fafnir_Dev3
// 0x0000 (0x0388 - 0x0388)
class ATgDevice_Fafnir_Dev3 : public ATgDevice_TweenBase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1973 );

		return pClassPointer;
	};

	bool eventCanBeCanceled ( );
	int GetLeapMode ( float fAimDist );
	void HandleDeviceFormStartFire ( int nDeviceModeNum, float fRefireTime, struct FAimData* Aim );
	void HandleDeviceFormBuildup ( int nDeviceModeNum, float fBuildupTime );
	void eventDeliverQueuedPendingHits ( );
	float GetTweenTime ( );
};

UClass* ATgDevice_Fafnir_Dev3::pClassPointer = NULL;

// Class TgGame.TgDevice_Izanami_InvisibleEscape
// 0x0000 (0x0388 - 0x0388)
class ATgDevice_Izanami_InvisibleEscape : public ATgDevice_TweenBase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1974 );

		return pClassPointer;
	};

	bool eventCanBeCanceled ( );
};

UClass* ATgDevice_Izanami_InvisibleEscape::pClassPointer = NULL;

// Class TgGame.TgDevice_Nike_Dev3
// 0x0000 (0x0388 - 0x0388)
class ATgDevice_Nike_Dev3 : public ATgDevice_TweenBase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1975 );

		return pClassPointer;
	};

	bool eventCanBeCanceled ( );
	float GetRefireTime ( int nMode );
	float GetFiringPreHitDelay ( int nMode );
};

UClass* ATgDevice_Nike_Dev3::pClassPointer = NULL;

// Class TgGame.TgDevice_XingTian_SkyCuttingAxe
// 0x000C (0x0394 - 0x0388)
class ATgDevice_XingTian_SkyCuttingAxe : public ATgDevice_TweenBase
{
public:
	int                                                r_nCurrentLeapCount;                              		// 0x0388 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nMaxLeapCount;                                  		// 0x038C (0x0004) [0x0000000000000020]              ( CPF_Net )
	unsigned long                                      s_bDisableOnTweenEnd : 1;                         		// 0x0390 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1976 );

		return pClassPointer;
	};

	void LeapExpire ( );
	bool eventShouldCooldownAfterFire ( );
	void StartLeapTimer ( int Time );
	bool eventCustomCanDeviceFireNow ( unsigned char FireModeNum, struct FAimData Aim, unsigned long bDeviceFailLog, unsigned char* failType );
	bool ShouldConsumePowerPoolAfterFire ( );
	bool ShouldConsumePowerPoolOnStartFire ( );
	bool eventCanBeInterrupted ( );
	bool eventShouldTriggerCastReactionItems ( );
	void UpdateManaUseVitals ( class ATgPlayerController* PC );
	bool HasEnoughPowerPool ( unsigned char FireModeNum );
};

UClass* ATgDevice_XingTian_SkyCuttingAxe::pClassPointer = NULL;

// Class TgGame.TgDevice_TwoPhase
// 0x0014 (0x0394 - 0x0380)
class ATgDevice_TwoPhase : public ATgDevice
{
public:
	unsigned char                                      m_eLocalState;                                    		// 0x0380 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_eCustomValueType;                               		// 0x0381 (0x0001) [0x0000000000000002]              ( CPF_Const )
	unsigned long                                      m_bDeductCooldownTime : 1;                        		// 0x0384 (0x0004) [0x0000000000000002] [0x00000001] ( CPF_Const )
	unsigned long                                      m_bCacheCooldownInfoOnStopFire : 1;               		// 0x0384 (0x0004) [0x0000000000000000] [0x00000002] 
	float                                              m_fStopFireTimeStamp;                             		// 0x0388 (0x0004) [0x0000000000000000]              
	float                                              m_fCachedCooldownTime;                            		// 0x038C (0x0004) [0x0000000000000000]              
	class UTgDeviceFire*                               m_CachedFireMode;                                 		// 0x0390 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1977 );

		return pClassPointer;
	};

	void DeviceShutDown ( unsigned long bDeactiveMode, unsigned long bResetCooldowns );
	bool CustomCanDeviceFireNow ( unsigned char FireModeNum, struct FAimData Aim, unsigned long bDeviceFailLog, unsigned char* failType );
	void FireAmmunition ( );
	void SetAltFireReady ( );
	void HandleDeviceFormStartFire ( int nDeviceModeNum, float fRefireTime, struct FAimData* Aim );
	void HandleFiringRejection ( );
	void eventInterruptFiring ( );
	void ClientSetState ( unsigned char NewState );
	void eventSetState ( unsigned char NewState, unsigned long bStartCooldown );
	void OnStateSet ( unsigned char PrevState, unsigned char CurrentState );
	void SelectStopFiringState ( );
	void eventExpireTarget ( );
	bool eventShouldCooldownAfterFire ( );
	bool eventCanUseToggle ( );
	unsigned char IncrementFiringInstance ( );
	float GetToggleMaxTime ( int nMode );
	float GetFiringPreHitDelay ( int nMode );
	float GetBuildupTime ( int nMode );
};

UClass* ATgDevice_TwoPhase::pClassPointer = NULL;

// Class TgGame.TgDevice_AhPuch_Dev1
// 0x000C (0x03A0 - 0x0394)
class ATgDevice_AhPuch_Dev1 : public ATgDevice_TwoPhase
{
public:
	TArray< class ATgProjectile* >                     s_ActiveProjectiles;                              		// 0x0394 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1978 );

		return pClassPointer;
	};

	bool eventShouldTriggerCastReactionItemsOnFire ( );
	void OnProjectileShutdown ( class ATgProjectile* Proj );
	class AProjectile* ProjectileFire ( int ProjectileIndex );
	void FireAmmunition ( );
	void OnStateSet ( unsigned char PrevState, unsigned char CurrentState );
	void SetAltFireReady ( );
	void GetTargetingAim ( struct FAimData* Aim );
	void TickTargetingMode ( float DeltaSeconds );
};

UClass* ATgDevice_AhPuch_Dev1::pClassPointer = NULL;

// Class TgGame.TgDevice_AhPuch_EmptyTheCrypts
// 0x0020 (0x03B4 - 0x0394)
class ATgDevice_AhPuch_EmptyTheCrypts : public ATgDevice_TwoPhase
{
public:
	TArray< int >                                      m_StunsPerRank;                                   		// 0x0394 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< int >                                      m_CorpsesPerRank;                                 		// 0x03A0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                m_nStunsLeft;                                     		// 0x03AC (0x0004) [0x0000000000000000]              
	float                                              m_fCorpseOffset;                                  		// 0x03B0 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1979 );

		return pClassPointer;
	};

	bool ShouldSwitchBackToBasicAttackTargeting ( unsigned char CastMode );
	void SelectStopFiringState ( );
	void OnStateSet ( unsigned char PrevState, unsigned char CurrentState );
	void ClientFixStunsLeft ( int nStunsLeft );
	struct FImpactInfo CalcWeaponFire ( struct FAimData Aim, TArray< struct FImpactInfo >* ImpactList );
	void FireAmmunition ( );
	bool eventCanUseToggle ( );
	void SpawnZombieCorpses ( int nNumCorpses, struct FVector vLocation, struct FVector vForward );
	float GetToggleMaxTime ( int nMode );
};

UClass* ATgDevice_AhPuch_EmptyTheCrypts::pClassPointer = NULL;

// Class TgGame.TgDevice_AoKuang_DragonCall
// 0x0040 (0x03D4 - 0x0394)
class ATgDevice_AoKuang_DragonCall : public ATgDevice_TwoPhase
{
public:
	class UTgDeviceFire*                               m_BuffFireMode;                                   		// 0x0394 (0x0004) [0x0000000000000000]              
	int                                                m_nMaxDragonDeploys;                              		// 0x0398 (0x0004) [0x0000000000000002]              ( CPF_Const )
	int                                                m_nRemainingDragonDeploys;                        		// 0x039C (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bUseMiniProjectile : 1;                         		// 0x03A0 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bUsePassive : 1;                                		// 0x03A0 (0x0004) [0x0000000000000000] [0x00000002] 
	int                                                m_nMiniProjectileId;                              		// 0x03A4 (0x0004) [0x0000000000000000]              
	struct FAimData                                    m_MiniProjAim;                                    		// 0x03A8 (0x002C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1980 );

		return pClassPointer;
	};

	bool eventShouldTriggerCastReactionItems ( );
	bool ShouldCancelStealth ( );
	void OnStateSet ( unsigned char PrevState, unsigned char CurrentState );
	void DeviceShutDown ( unsigned long bDeactiveMode, unsigned long bResetCooldowns );
	void CustomProjectileInit ( class AProjectile* Proj, int ProjIndex, struct FAimData BaseAim );
	void FireAmmunition ( );
	void eventExpireTarget ( );
	void eventRemoveBuff ( );
	bool ApplyBuff ( );
	bool eventUsesTrackingTarget ( );
	void eventFireMiniProjectile ( class AActor* Target, class UTgDeviceFire* FireMode );
	int GetProjectileIDOverride ( int ProjectileIndex );
	void GetCachedAim ( struct FAimData* Aim );
	float GetToggleMaxTime ( int nMode );
};

UClass* ATgDevice_AoKuang_DragonCall::pClassPointer = NULL;

// Class TgGame.TgDevice_Gateway
// 0x0014 (0x03A8 - 0x0394)
class ATgDevice_Gateway : public ATgDevice_TwoPhase
{
public:
	class ATgDeployable_GatewayEntrance*               m_gatewayEntrance;                                		// 0x0394 (0x0004) [0x0000000000000000]              
	class ATgDeployable_GatewayExit*                   m_gatewayExit;                                    		// 0x0398 (0x0004) [0x0000000000000000]              
	struct FVector                                     r_vEntranceLocation;                              		// 0x039C (0x000C) [0x0000000000000020]              ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1981 );

		return pClassPointer;
	};

	int eventGetDeployableId ( );
	void GetTargetingAim ( struct FAimData* Aim );
	float GetToggleMaxTime ( int nMode );
};

UClass* ATgDevice_Gateway::pClassPointer = NULL;

// Class TgGame.TgDevice_JingWei_Dev4
// 0x0020 (0x03B4 - 0x0394)
class ATgDevice_JingWei_Dev4 : public ATgDevice_TwoPhase
{
public:
	int                                                m_nLeapCount;                                     		// 0x0394 (0x0004) [0x0000000000000000]              
	int                                                m_nMaxLeapCount;                                  		// 0x0398 (0x0004) [0x0000000000000002]              ( CPF_Const )
	unsigned char                                      m_ePrimaryTweenState;                             		// 0x039C (0x0001) [0x0000000000000000]              
	unsigned char                                      m_eSecondaryTweenState;                           		// 0x039D (0x0001) [0x0000000000000000]              
	unsigned long                                      m_bFixedTweenTime : 1;                            		// 0x03A0 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bForceToNormalState : 1;                        		// 0x03A0 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      s_bDisableOnTweenEnd : 1;                         		// 0x03A0 (0x0004) [0x0000000000000000] [0x00000004] 
	TArray< class AActor* >                            m_HitActors;                                      		// 0x03A4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class ATgCollisionProxy_JingWei_Dev4*              m_CollisionProxy;                                 		// 0x03B0 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1982 );

		return pClassPointer;
	};

	void eventForceSelfRoot ( unsigned long bEnable );
	void SelectStopFiringState ( );
	struct FVector eventGetTweenLocation ( struct FAimData* Aim );
	float GetTweenTime ( );
	void FireAmmunition ( );
	void ClientFixLeapCount ( int bRecoverLeapCount );
	void HandleFiringRejection ( );
	void eventInterruptFiring ( );
	bool eventShouldCooldownAfterFire ( );
	void eventForceToNormalState ( );
	void ServerForceToNormalState ( );
	bool eventCanBeInterrupted ( );
	bool eventCanBeCanceled ( );
	bool eventCanJumpWhileFiring ( );
	void eventExpireTarget ( );
	void OnStateSet ( unsigned char PrevState, unsigned char CurrentState );
	bool ShouldSwitchBackToBasicAttackTargeting ( unsigned char CastMode );
	bool eventShouldTriggerCastReactionItems ( );
	float GetToggleMaxTime ( int nMode );
};

UClass* ATgDevice_JingWei_Dev4::pClassPointer = NULL;

// Class TgGame.TgDevice_Ratatoskr_UltimateShooter
// 0x004C (0x03E0 - 0x0394)
class ATgDevice_Ratatoskr_UltimateShooter : public ATgDevice_TwoPhase
{
public:
	class ATgDeployable*                               s_ActiveTreeDeployable;                           		// 0x0394 (0x0004) [0x0000000000000000]              
	struct FVector                                     s_vTreeDeloyOffset;                               		// 0x0398 (0x000C) [0x0000000000000000]              
	int                                                m_nLeapCount;                                     		// 0x03A4 (0x0004) [0x0000000000000000]              
	unsigned char                                      m_eLeapTweenState;                                		// 0x03A8 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_eSlamTweenType;                                 		// 0x03A9 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_eStartTimerCheckpoint;                          		// 0x03AA (0x0001) [0x0000000000000000]              
	unsigned char                                      m_eStopTimerCheckpoint;                           		// 0x03AB (0x0001) [0x0000000000000000]              
	unsigned long                                      m_bFixedTweenTime : 1;                            		// 0x03AC (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bForceCast : 1;                                 		// 0x03AC (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      s_bForceStraightDown : 1;                         		// 0x03AC (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      s_bDisableOnTweenEnd : 1;                         		// 0x03AC (0x0004) [0x0000000000000000] [0x00000008] 
	float                                              m_fCachedDistanceScale;                           		// 0x03B0 (0x0004) [0x0000000000000000]              
	struct FAimData                                    s_LastValidAim;                                   		// 0x03B4 (0x002C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1983 );

		return pClassPointer;
	};

	void OnTweenEnd ( unsigned long bInterrupted );
	void eventInstantFire ( );
	struct FVector eventGetTweenLocation ( struct FAimData* Aim );
	float GetTweenTime ( );
	void FireAmmunition ( );
	bool CustomCanDeviceFireNow ( unsigned char FireModeNum, struct FAimData Aim, unsigned long bDeviceFailLog, unsigned char* failType );
	void ClientForceFireCharge ( float EndX, float EndY );
	bool ForceFireCharge ( unsigned long bForceStraightDown );
	void ClientFixRatatoskrUltState ( int bRecoverLeapCount );
	void HandleFiringRejection ( );
	void eventInterruptFiring ( );
	void OnStateSet ( unsigned char PrevState, unsigned char CurrentState );
	void DestroyTree ( );
	void NextTree ( struct FAimData Aim );
	bool eventCanUseToggle ( );
	void DestroyTreeEarly ( class ATgDeployable* Tree );
	class ATgDeployable* SpawnTreeDeployable ( struct FAimData Aim, class UTgDeviceFire* DeviceMode );
	void GetTargetingAim ( struct FAimData* Aim );
};

UClass* ATgDevice_Ratatoskr_UltimateShooter::pClassPointer = NULL;

// Class TgGame.TgDevice_XingTian_HeroicLeap
// 0x0010 (0x03A4 - 0x0394)
class ATgDevice_XingTian_HeroicLeap : public ATgDevice_TwoPhase
{
public:
	int                                                m_nLeapCount;                                     		// 0x0394 (0x0004) [0x0000000000000000]              
	int                                                m_nMaxLeapCount;                                  		// 0x0398 (0x0004) [0x0000000000000002]              ( CPF_Const )
	unsigned char                                      m_eLeapTweenState;                                		// 0x039C (0x0001) [0x0000000000000000]              
	unsigned char                                      m_eSlamTweenType;                                 		// 0x039D (0x0001) [0x0000000000000000]              
	unsigned long                                      m_bFixedTweenTime : 1;                            		// 0x03A0 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bForceToNormalState : 1;                        		// 0x03A0 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      s_bDisableOnTweenEnd : 1;                         		// 0x03A0 (0x0004) [0x0000000000000000] [0x00000004] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1984 );

		return pClassPointer;
	};

	void SelectStopFiringState ( );
	void OnTweenEnd ( unsigned long bInterrupted );
	struct FVector eventGetTweenLocation ( struct FAimData* Aim );
	float GetTweenTime ( );
	void FireAmmunition ( );
	void ClientFixLeapCount ( int bRecoverLeapCount );
	void HandleFiringRejection ( );
	void eventInterruptFiring ( );
	bool eventShouldCooldownAfterFire ( );
	void eventForceToNormalState ( );
	void ServerForceToNormalState ( );
	bool eventCanBeInterrupted ( );
	bool eventCanBeCanceled ( );
	void OnStateSet ( unsigned char PrevState, unsigned char CurrentState );
	bool ShouldSwitchBackToBasicAttackTargeting ( unsigned char CastMode );
	bool eventShouldTriggerCastReactionItems ( );
	float GetToggleMaxTime ( int nMode );
};

UClass* ATgDevice_XingTian_HeroicLeap::pClassPointer = NULL;

// Class TgGame.TgDevice_Zeus_Shield
// 0x0000 (0x0394 - 0x0394)
class ATgDevice_Zeus_Shield : public ATgDevice_TwoPhase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1985 );

		return pClassPointer;
	};

	bool eventShouldCooldownAfterFire ( );
	void FireAmmunition ( );
	bool eventCustomCanDeviceFireNow ( unsigned char FireModeNum, struct FAimData Aim, unsigned long bDeviceFailLog, unsigned char* failType );
	void ClientInterrupt ( );
	void OnStateSet ( unsigned char PrevState, unsigned char CurrentState );
	float GetToggleMaxTime ( int nMode );
};

UClass* ATgDevice_Zeus_Shield::pClassPointer = NULL;

// Class TgGame.TgDevice_Tyr_ChangeStance
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_Tyr_ChangeStance : public ATgDevice
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1986 );

		return pClassPointer;
	};

	bool ShouldApplyModeEquipEffects ( );
	bool HasBeenTrained ( );
};

UClass* ATgDevice_Tyr_ChangeStance::pClassPointer = NULL;

// Class TgGame.TgDevice_Ullr_Num4
// 0x0004 (0x0384 - 0x0380)
class ATgDevice_Ullr_Num4 : public ATgDevice
{
public:
	float                                              m_TimeSinceLastManaCostApplied;                   		// 0x0380 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1987 );

		return pClassPointer;
	};

	void ServerEndStance ( );
	void Tick ( float DeltaTime );
	void DeviceConsumePowerPool ( unsigned char FireModeNum );
	bool ShouldApplyModeEquipEffects ( );
	bool HasBeenTrained ( );
};

UClass* ATgDevice_Ullr_Num4::pClassPointer = NULL;

// Class TgGame.TgDevice_Vulcan_ForgeCharge
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_Vulcan_ForgeCharge : public ATgDevice
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1988 );

		return pClassPointer;
	};

	void DeviceConsumePowerPool ( unsigned char FireModeNum );
};

UClass* ATgDevice_Vulcan_ForgeCharge::pClassPointer = NULL;

// Class TgGame.TgDevice_WarningDeployable
// 0x0020 (0x03A0 - 0x0380)
class ATgDevice_WarningDeployable : public ATgDevice
{
public:
	int                                                m_nWarningDeployableId;                           		// 0x0380 (0x0004) [0x0000000000000002]              ( CPF_Const )
	struct FPointer                                    m_pWarningDeployableSetup;                        		// 0x0384 (0x0004) [0x0000000000001000]              ( CPF_Native )
	class ATgDeployable*                               m_LastWarningDeployable;                          		// 0x0388 (0x0004) [0x0000000000000000]              
	TArray< struct FWarningDeployableInfo >            m_WarningDeployableInfos;                         		// 0x038C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	unsigned char                                      m_eDeployTiming;                                  		// 0x0398 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_eDestroyTiming;                                 		// 0x0399 (0x0001) [0x0000000000000000]              
	unsigned long                                      m_bCachedValidSetup : 1;                          		// 0x039C (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1989 );

		return pClassPointer;
	};

	void OnProjectileShutdown ( class ATgProjectile* Proj );
	class AProjectile* ProjectileFire ( int nProjectileIndex );
	void FireAmmunition ( );
	void DestroyWarningDeployable ( class ATgProjectile* Proj );
	void SpawnWarningDeployable ( );
	void SetFireMode ( int nFireModeNum, unsigned long ForceSet );
};

UClass* ATgDevice_WarningDeployable::pClassPointer = NULL;

// Class TgGame.TgDevice_WithAmmo
// 0x0010 (0x0390 - 0x0380)
class ATgDevice_WithAmmo : public ATgDevice
{
public:
	int                                                m_nAmmoCount;                                     		// 0x0380 (0x0004) [0x0000000000000000]              
	int                                                m_nMaxAmmoCount;                                  		// 0x0384 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bReplenishAmmoOnEndCooldown : 1;                		// 0x0388 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bLoadAmmoOnInit : 1;                            		// 0x0388 (0x0004) [0x0000000000000000] [0x00000002] 
	float                                              m_fForceCooldownTime;                             		// 0x038C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1990 );

		return pClassPointer;
	};

	void ClientSetAmmoCount ( int nAmmoCount );
	void eventSetAmmoCount ( int nAmmoCount, unsigned long bDoNotFowardToClient );
	void eventInterruptFiring ( );
	void eventDeviceConsumePowerPool ( unsigned char FireModeNum );
	void DeviceShutDown ( unsigned long bDeactiveMode, unsigned long bResetCooldowns );
	void CooldownTimerExpired ( int nTimerId, unsigned char eEvent );
	void eventResetCooldown ( int nMode, float fCooldownTimeOverride );
	void eventStartCooldown ( int nMode, float fCooldownTimeOverride );
	bool CustomCanDeviceFireNow ( unsigned char FireModeNum, struct FAimData Aim, unsigned long bDeviceFailLog, unsigned char* failType );
	bool eventShouldCooldownAfterFire ( );
	bool eventApplyGlobalOffhandCooldown ( );
	void ForceIntoCooldown ( );
	void eventConsumeAllAmmo ( );
	void eventReplenishAllAmmo ( );
};

UClass* ATgDevice_WithAmmo::pClassPointer = NULL;

// Class TgGame.TgDevice_Painting
// 0x0014 (0x03A4 - 0x0390)
class ATgDevice_Painting : public ATgDevice_WithAmmo
{
public:
	struct FVector                                     m_vLastDeployLocation;                            		// 0x0390 (0x000C) [0x0000000000000000]              
	float                                              m_fDistanceBetweenDeployables;                    		// 0x039C (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bDeployHoneyFromTargetingChange : 1;            		// 0x03A0 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1991 );

		return pClassPointer;
	};

	void CustomFire ( );
	void eventDeployNextHoney ( );
	void eventDeviceConsumePowerPool ( unsigned char FireModeNum );
	bool eventShouldCooldownAfterFire ( );
	bool eventApplyGlobalOffhandCooldown ( );
	void SetFireMode ( int nFireModeNum, unsigned long ForceSet );
};

UClass* ATgDevice_Painting::pClassPointer = NULL;

// Class TgGame.TgDevice_NuWa_UltimateShooter
// 0x0000 (0x03A4 - 0x03A4)
class ATgDevice_NuWa_UltimateShooter : public ATgDevice_Painting
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1992 );

		return pClassPointer;
	};

	bool eventApplyGlobalOffhandCooldown ( );
	bool eventShouldInterruptInhand ( );
	void RemoveEquipEffects ( );
	void ApplyEquipEffects ( );
};

UClass* ATgDevice_NuWa_UltimateShooter::pClassPointer = NULL;

// Class TgGame.TgDevice_Xbalanque_DashAndJump
// 0x0004 (0x0384 - 0x0380)
class ATgDevice_Xbalanque_DashAndJump : public ATgDevice
{
public:
	unsigned long                                      m_IsUpdatingAimWhileFiring : 1;                   		// 0x0380 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1993 );

		return pClassPointer;
	};

	bool eventCanBeInterrupted ( );
	void UpdateAimWhileFiring ( struct FAimData* Aim );
};

UClass* ATgDevice_Xbalanque_DashAndJump::pClassPointer = NULL;

// Class TgGame.TgDevice_XingTian_AxeSweepShieldBash
// 0x0002 (0x0382 - 0x0380)
class ATgDevice_XingTian_AxeSweepShieldBash : public ATgDevice
{
public:
	unsigned char                                      m_eBashTweenState;                                		// 0x0380 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_eXingAttackState;                               		// 0x0381 (0x0001) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1994 );

		return pClassPointer;
	};

	void EndSecondaryTargeting ( );
	void BeginSecondaryTargeting ( );
	void eventDeviceConsumePowerPool ( unsigned char FireModeNum );
	void HandleDeviceFormStartFire ( int nDeviceModeNum, float fRefireTime, struct FAimData* Aim );
	bool eventCanBeInterrupted ( );
	void UpdateAimWhileFiring ( struct FAimData* Aim );
	void TickTargetingMode ( float DeltaSeconds );
	void UpdateTargetingModeStatus ( struct FAimData* Aim );
	float GetFiringPreHitDelay ( int nMode );
	float GetRefireTime ( int nMode );
};

UClass* ATgDevice_XingTian_AxeSweepShieldBash::pClassPointer = NULL;

// Class TgGame.TgDevice_XingTian_Battlecry
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_XingTian_Battlecry : public ATgDevice
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1995 );

		return pClassPointer;
	};

	void CustomProjectileInit ( class AProjectile* Proj, int ProjIndex, struct FAimData BaseAim );
	struct FImpactInfo CalcWeaponFire ( struct FAimData Aim, TArray< struct FImpactInfo >* ImpactList );
	void CalcLinearFire ( struct FAimData Aim, unsigned long bPredicting, TArray< struct FImpactInfo >* ImpactList );
};

UClass* ATgDevice_XingTian_Battlecry::pClassPointer = NULL;

// Class TgGame.TgDevice_Ymir_Explosion
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_Ymir_Explosion : public ATgDevice
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1996 );

		return pClassPointer;
	};

	bool eventCanBeInterrupted ( );
	bool eventCanBeCanceled ( );
	void StopFire ( );
	bool eventShouldLockFiring ( class ATgDevice* Current );
	bool eventIsToggleDevice ( );
	bool CanBeGrabbed ( );
	bool CanBeDisarmed ( );
	bool CanBeSilenced ( );
	bool CanBeStunned ( );
};

UClass* ATgDevice_Ymir_Explosion::pClassPointer = NULL;

// Class TgGame.TgDevice_Zeus_ForkedLightning
// 0x0010 (0x0390 - 0x0380)
class ATgDevice_Zeus_ForkedLightning : public ATgDevice
{
public:
	TArray< struct FArcingInfo >                       m_ArcingList;                                     		// 0x0380 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                m_nLastImpactIndex;                               		// 0x038C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1997 );

		return pClassPointer;
	};

	void TriggerArc ( int Index );
	float GetArcDamageMultiplier ( float previousDamageMultiplier );
	void EndArcing ( int Index );
	void BeginArcing ( class AActor* initialTarget, class UTgDeviceFire_Zeus_ForkedLightning* FireMode );
	void Tick ( float DeltaTime );
	void DeviceAdjustDamage ( int nPropertyId, struct FImpactInfo* Impact, float* fDamage );
	class AActor* DetermineNextTarget ( int Index );
};

UClass* ATgDevice_Zeus_ForkedLightning::pClassPointer = NULL;

// Class TgGame.TgDeviceFire
// 0x013C (0x0178 - 0x003C)
class UTgDeviceFire : public UObject
{
public:
	class AActor*                                      m_Owner;                                          		// 0x003C (0x0004) [0x0000000000000000]              
	unsigned char                                      m_nFireType;                                      		// 0x0040 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_eTargetingMode;                                 		// 0x0041 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_eTargeterType;                                  		// 0x0042 (0x0001) [0x0000000000000000]              
	unsigned long                                      m_bIsAOE : 1;                                     		// 0x0044 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bIsCone : 1;                                    		// 0x0044 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_bIsLinear : 1;                                  		// 0x0044 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_bApplyInitialHit : 1;                           		// 0x0044 (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      m_bContinuousFire : 1;                            		// 0x0044 (0x0004) [0x0000000000000000] [0x00000010] 
	unsigned long                                      m_bRequireLOS : 1;                                		// 0x0044 (0x0004) [0x0000000000000000] [0x00000020] 
	unsigned long                                      m_bDoNotPauseAIDuringBuildup : 1;                 		// 0x0044 (0x0004) [0x0000000000000000] [0x00000040] 
	unsigned long                                      m_bVerifyTargetPlacement : 1;                     		// 0x0044 (0x0004) [0x0000000000000000] [0x00000080] 
	unsigned long                                      m_bAllowPetDomination : 1;                        		// 0x0044 (0x0004) [0x0000000000000000] [0x00000100] 
	unsigned long                                      m_bUseTargetingEncroachmentActor : 1;             		// 0x0044 (0x0004) [0x0000000000000002] [0x00000200] ( CPF_Const )
	TArray< class UTgEffectGroup* >                    s_EffectGroupList;                                		// 0x0048 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UTgProperty* >                       m_Properties;                                     		// 0x0054 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< struct FTGDFM_ANIM_SEQUENCE >              s_AnimSeqArrayRightSide;                          		// 0x0060 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< struct FTGDFM_ANIM_SEQUENCE >              s_AnimSeqArrayLeftSide;                           		// 0x006C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FPointer                                    m_pAmSetup;                                       		// 0x0078 (0x0004) [0x0000000000001000]              ( CPF_Native )
	struct FPointer                                    m_pFireModeSetup;                                 		// 0x007C (0x0004) [0x0000000000001000]              ( CPF_Native )
	int                                                m_nId;                                            		// 0x0080 (0x0004) [0x0000000000000000]              
	struct FPointer                                    m_pwzDeviceFireName;                              		// 0x0084 (0x0004) [0x0000000000001000]              ( CPF_Native )
	int                                                m_nAttackType;                                    		// 0x0088 (0x0004) [0x0000000000000000]              
	int                                                m_nMovementType;                                  		// 0x008C (0x0004) [0x0000000000000000]              
	struct FName                                       m_nmOffhandAnimationType;                         		// 0x0090 (0x0008) [0x0000000000000000]              
	int                                                m_nTargetAffectsType;                             		// 0x0098 (0x0004) [0x0000000000000000]              
	struct FName                                       c_nmZoomScopeMaterial;                            		// 0x009C (0x0008) [0x0000000000000000]              
	int                                                m_nAllowUseWhileFlags;                            		// 0x00A4 (0x0004) [0x0000000000000000]              
	int                                                m_nDamageType;                                    		// 0x00A8 (0x0004) [0x0000000000000000]              
	int                                                m_nArcingJumps;                                   		// 0x00AC (0x0004) [0x0000000000000000]              
	int                                                m_nVisionRangeIndex;                              		// 0x00B0 (0x0004) [0x0000000000000000]              
	int                                                m_nProximityDistanceIndex;                        		// 0x00B4 (0x0004) [0x0000000000000000]              
	int                                                m_nRangeIndex;                                    		// 0x00B8 (0x0004) [0x0000000000000000]              
	int                                                m_nMinRangeIndex;                                 		// 0x00BC (0x0004) [0x0000000000000000]              
	int                                                m_nConeAttackAngleIndex;                          		// 0x00C0 (0x0004) [0x0000000000000000]              
	int                                                m_nDamageRadiusIndex;                             		// 0x00C4 (0x0004) [0x0000000000000000]              
	int                                                m_nAccuracyIndex;                                 		// 0x00C8 (0x0004) [0x0000000000000000]              
	int                                                m_nAccuracyCrouchIndex;                           		// 0x00CC (0x0004) [0x0000000000000000]              
	int                                                m_nAccuracySprintIndex;                           		// 0x00D0 (0x0004) [0x0000000000000000]              
	int                                                m_nAccuracyWalkIndex;                             		// 0x00D4 (0x0004) [0x0000000000000000]              
	int                                                m_nAccuracyLossMaxIndex;                          		// 0x00D8 (0x0004) [0x0000000000000000]              
	int                                                m_nEffectiveRangeIndex;                           		// 0x00DC (0x0004) [0x0000000000000000]              
	int                                                m_nInterruptChanceIndex;                          		// 0x00E0 (0x0004) [0x0000000000000000]              
	int                                                s_nMaxDeployableIndex;                            		// 0x00E4 (0x0004) [0x0000000000000000]              
	int                                                m_nCoolDownTimeIndex;                             		// 0x00E8 (0x0004) [0x0000000000000000]              
	int                                                m_nActivationTimeIndex;                           		// 0x00EC (0x0004) [0x0000000000000000]              
	int                                                m_nEffectiveRadiusIndex;                          		// 0x00F0 (0x0004) [0x0000000000000000]              
	int                                                m_nMinimumRadiusIndex;                            		// 0x00F4 (0x0004) [0x0000000000000000]              
	int                                                s_nPetLifeSpanIndex;                              		// 0x00F8 (0x0004) [0x0000000000000000]              
	int                                                s_nProjectileSpeedIndex;                          		// 0x00FC (0x0004) [0x0000000000000000]              
	int                                                m_nCustomValue1Index;                             		// 0x0100 (0x0004) [0x0000000000000000]              
	int                                                m_nCustomValue2Index;                             		// 0x0104 (0x0004) [0x0000000000000000]              
	int                                                m_nCustomValue3Index;                             		// 0x0108 (0x0004) [0x0000000000000000]              
	int                                                m_nCustomValue4Index;                             		// 0x010C (0x0004) [0x0000000000000000]              
	int                                                m_nCustomValue5Index;                             		// 0x0110 (0x0004) [0x0000000000000000]              
	int                                                m_nAIDeviceRangeIndex;                            		// 0x0114 (0x0004) [0x0000000000000000]              
	int                                                m_nAIDeviceRadiusIndex;                           		// 0x0118 (0x0004) [0x0000000000000000]              
	int                                                m_nAIDamageBaseIndex;                             		// 0x011C (0x0004) [0x0000000000000000]              
	int                                                m_nAIDamageScalingIndex;                          		// 0x0120 (0x0004) [0x0000000000000000]              
	float                                              m_fHealthCost;                                    		// 0x0124 (0x0004) [0x0000000000000000]              
	float                                              m_fManaCost;                                      		// 0x0128 (0x0004) [0x0000000000000000]              
	float                                              m_fEnergyCost;                                    		// 0x012C (0x0004) [0x0000000000000000]              
	float                                              m_fFireTime;                                      		// 0x0130 (0x0004) [0x0000000000000000]              
	float                                              m_fEquipTime;                                     		// 0x0134 (0x0004) [0x0000000000000000]              
	float                                              m_fBuildupTime;                                   		// 0x0138 (0x0004) [0x0000000000000000]              
	float                                              m_fFirePreHitDelay;                               		// 0x013C (0x0004) [0x0000000000000000]              
	float                                              m_fFirePostHitDelay;                              		// 0x0140 (0x0004) [0x0000000000000000]              
	float                                              m_fChainAnimSwingTime;                            		// 0x0144 (0x0004) [0x0000000000000000]              
	float                                              s_fMaxControlRange;                               		// 0x0148 (0x0004) [0x0000000000000000]              
	int                                                m_nShotsPerFire;                                  		// 0x014C (0x0004) [0x0000000000000000]              
	float                                              m_fTeamPassthroughDistance;                       		// 0x0150 (0x0004) [0x0000000000000000]              
	float                                              m_fMeleeHitTime;                                  		// 0x0154 (0x0004) [0x0000000000000000]              
	struct FName                                       m_nmDamageTypeClass;                              		// 0x0158 (0x0008) [0x0000000000000000]              
	float                                              m_fMaxTargetCount;                                		// 0x0160 (0x0004) [0x0000000000000000]              
	float                                              m_fFullBodyAnimTime;                              		// 0x0164 (0x0004) [0x0000000000000000]              
	float                                              m_fFireLockTime;                                  		// 0x0168 (0x0004) [0x0000000000000000]              
	float                                              m_fVisionRange;                                   		// 0x016C (0x0004) [0x0000000000000000]              
	int                                                m_nTargetingEncroachmentActorOverride;            		// 0x0170 (0x0004) [0x0000000000000002]              ( CPF_Const )
	class AActor*                                      m_TargetingEncroachmentActor;                     		// 0x0174 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1998 );

		return pClassPointer;
	};

	bool SpawnPetFire ( );
	float eventGetConeAttackAngleOffset ( );
	float eventGetSignedConeAttackAngle ( );
	float eventGetConeAttackAngle ( );
	float eventGetContagiousRadius ( );
	void PayAccuracyForWeaponSwitch ( );
	float eventGetCooldownTime ( );
	float eventGetFireLockTime ( );
	float eventGetChainAnimSwingTime ( );
	float eventGetPostHitDelay ( );
	float eventGetPreHitDelay ( );
	float eventGetBuildupTime ( );
	float eventGetRefireTime ( );
	float GetEquipModeTime ( );
	bool ValidateApplyHit ( struct FImpactInfo Impact );
	void SubmitHitEffects ( class AActor* DamageInstigator, struct FImpactInfo Impact, int nType );
	void HandleSuccessfulHit ( class AActor* DamageInstigator, class APawn* OwnerInstigator, struct FImpactInfo Impact, int nHitType, int nSituationalType );
	bool eventApplyHit ( struct FImpactInfo Impact, class AActor* DamageInstigator );
	void GetHitType ( struct FImpactInfo Impact, class AActor* DamageInstigator, int* nHitType, int* nSituationalType );
	void TrackDeviceModeHit ( class ATgPawn* Hitter, float fDistance, unsigned long bHitPlayer );
	bool IsValidAOETarget ( class ATgPawn* P, struct FVector vHitLocation, float fRadius );
	void eventRemoveHitSpecial ( class AActor* Target, unsigned long bForceRemove, int nHitSpecialSituationalType, int StackCount );
	void eventApplyHitSpecial ( class AActor* Target, struct FImpactInfo Impact, int nHitSpecialSituationalType, int StackCount );
	void eventRemoveEffectType ( class AActor* Target, unsigned long bForceRemove, int nEffectGroupType, int StackCount );
	void eventApplyEffectType ( class AActor* Target, int nEffectGroupType, struct FImpactInfo Impact, int StackCount );
	struct FString GetTargetName ( class AActor* TargetActor );
	bool IsValidTraceTarget ( class AActor* P );
	void DisplayMessage ( struct FString sMessage );
	class ATgDevice* CheckSimutainousFiring ( );
	float eventGetInterruptChance ( );
	void eventSubmitEffect ( struct FImpactInfo Impact, class UTgEffectGroup* effectGroup, unsigned long bRemove, int StackCount );
	void eventRemoveEquipEffects ( );
	void eventApplyEquipEffects ( );
	struct FImpactInfo CalcActorEncroachmentTargetingFire ( class AActor* DamageInstigator, struct FAimData Aim, unsigned long bPredicting, TArray< struct FImpactInfo >* ImpactList );
	struct FImpactInfo CalcChargeTargetingFire ( class AActor* DamageInstigator, struct FAimData Aim, unsigned long bPredicting, float fRange, TArray< struct FImpactInfo >* ImpactList );
	struct FImpactInfo CalcDeployableTargetingFire ( class AActor* DamageInstigator, struct FAimData Aim, int nDeployableId, unsigned long bPredicting, TArray< struct FImpactInfo >* ImpactList );
	struct FImpactInfo CalcLinearFire ( class AActor* DamageInstigator, struct FAimData Aim, unsigned long bUseProximityDistance, unsigned long bPredicting, TArray< struct FImpactInfo >* ImpactList );
	struct FImpactInfo CalcArcingFire ( class AActor* DamageInstigator, struct FAimData Aim, unsigned long bPredicting, TArray< struct FImpactInfo >* ImpactList );
	struct FImpactInfo CalcInstantFire ( class AActor* DamageInstigator, struct FAimData Aim, unsigned long bPredicting, TArray< struct FImpactInfo >* ImpactList );
	struct FImpactInfo CalcAoeFire ( class AActor* DamageInstigator, struct FAimData Aim, unsigned long bPredicting, TArray< struct FImpactInfo >* ImpactList );
	struct FImpactInfo CalcConeFire ( class AActor* DamageInstigator, struct FAimData Aim, unsigned long bUseRange, unsigned long bPredicting, TArray< struct FImpactInfo >* ImpactList );
	struct FImpactInfo CalcMeleeAttack ( class AActor* DamageInstigator, struct FAimData Aim, unsigned long bPredicting, unsigned long bPriorityFirst, TArray< struct FImpactInfo >* ImpactList );
	struct FImpactInfo CalcWeaponModeFire ( class AActor* DamageInstigator, struct FAimData Aim, unsigned long bPredicting, TArray< struct FImpactInfo >* ImpactList );
	bool CheckValidTarget ( class AActor* Target, unsigned long bPredicting );
	bool IsInSlice ( class AActor* SourceActor, class AActor* TargetActor, struct FVector StartCone, struct FVector ConeDir, float ConeAngle, float ConeRadius );
	bool ShouldAddToImpactList ( class AActor* HitActor, TArray< struct FImpactInfo >* ImpactList );
	struct FVector GetHitLocationToCenter ( struct FVector* StartTrace, struct FVector* TargetLocation, struct FVector* TargetExtent );
	struct FVector GetHitLocationFlat ( struct FVector* StartTrace, struct FVector* TargetLocation, struct FVector* TargetExtent );
	bool IsBlockedByBlocker ( class AActor* DamageInstigator, class AActor* Target, struct FVector originLocation );
	float LinePointDist ( struct FVector A, struct FVector B, struct FVector Pt );
	unsigned char GetTargetingMode ( );
	void AddEffectiveRangeReduction ( class AActor* DamageInstigator, struct FVector originLocation, unsigned long bUseRadius, struct FImpactInfo* Impact );
	float GetShotPowerCost ( int nPacingType, unsigned long bBaseOnly );
	bool UsesActorEncroachmentForCalcTargetingFire ( );
	bool IsArcingAttack ( );
	bool IsRangedAttack ( );
	bool IsMeleeAttack ( );
	struct FImpactInfo GetTraceImpact ( struct FVector StartTrace, struct FVector EndTrace, struct FVector Extent, unsigned long bIgnoreWorld, unsigned long bCheckLockOn, unsigned long MapVisionAssist );
	bool IsEnemy ( class AActor* TargetActor );
	bool IsSelfOrOwner ( class AActor* Target );
	bool IsValidTarget ( class AActor* P, unsigned char eTargeterType, unsigned long bIgnoreHealth );
	bool CheckTeamPassThrough ( class AActor* HitActor );
	float GetCustomValue5 ( );
	float GetCustomValue4 ( );
	float GetCustomValue3 ( );
	float GetCustomValue2 ( );
	float GetCustomValue1 ( );
	int GetShotsPerFire ( );
	int GetMaxBotCount ( );
	int GetMaxDeployableCount ( );
	int GetMaxProjectileCount ( );
	bool IsWithinEffectiveRange ( float fDistance );
	bool IsWithinRange ( float fDistance );
	float GetMinimumRadius ( );
	float GetEffectiveRange ( );
	float GetMinRange ( );
	float GetRange ( );
	float GetProximityDistance ( );
	float GetVisionRange ( );
	float GetProjectileSpeed ( );
	float GetDeployTime ( );
	float GetPetControlRange ( );
	float GetPetLifeSpan ( );
	float GetEffectiveRadius ( );
	float GetRemoteActivationTime ( );
	float GetAIScalingDamage ( );
	float GetAIBaseDamage ( );
	float GetAIRadius ( );
	float GetAIRange ( );
	float GetDamageRadius ( );
	float GetTargetAccuracy ( );
	float GetAccuracy ( );
	bool WillFireTrackingMissile ( );
	bool WillSpawnStickyProjectile ( );
	bool LogDebugInfo ( );
	void VerifyProjectile ( );
	struct FString GetDeviceFireName ( );
	bool IsBlockedByGeometry ( class AActor* SourceActor, class AActor* TargetActor );
	struct FName QueryClass ( int nMode );
	class UTgEffectGroup* GetEffectGroup ( int nType, int* nIndex );
	float GetPropertyValueById ( int nPropertyId, int nPropertyIndex );
	float GetPropertyValue ( int nPropertyId );
	void TeleportFire ( );
	void CustomFire ( );
	class ATgPawn* SpawnPet ( unsigned long bPet );
	void Deploy ( );
	void InitializeProjectile ( class AProjectile* Proj );
	class UClass* GetProjectileClass ( );
};

UClass* UTgDeviceFire::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_AhPuch_Dev2_CorpseFire
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_AhPuch_Dev2_CorpseFire : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 1999 );

		return pClassPointer;
	};

	struct FImpactInfo CalcAoeFire ( class AActor* DamageInstigator, struct FAimData Aim, unsigned long bPredicting, TArray< struct FImpactInfo >* ImpactList );
	struct FImpactInfo CalcWeaponModeFire ( class AActor* DamageInstigator, struct FAimData Aim, unsigned long bPredicting, TArray< struct FImpactInfo >* ImpactList );
};

UClass* UTgDeviceFire_AhPuch_Dev2_CorpseFire::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_AhPuch_Dev2_Sub
// 0x000C (0x0184 - 0x0178)
class UTgDeviceFire_AhPuch_Dev2_Sub : public UTgDeviceFire
{
public:
	class ATgPawn_AhPuch*                              m_OwningAhPuch;                                   		// 0x0178 (0x0004) [0x0000000000000000]              
	class UTgDeviceFire*                               m_CorpseFireMode;                                 		// 0x017C (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bDestroyCorpseOnHit : 1;                        		// 0x0180 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bSkipFxOnDestroyCorpse : 1;                     		// 0x0180 (0x0004) [0x0000000000000000] [0x00000002] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2000 );

		return pClassPointer;
	};

	bool eventApplyHit ( struct FImpactInfo Impact, class AActor* DamageInstigator );
	bool IsValidCorpseUser ( );
	struct FImpactInfo CalcAoeFire ( class AActor* DamageInstigator, struct FAimData Aim, unsigned long bPredicting, TArray< struct FImpactInfo >* ImpactList );
	class UTgDeviceFire* GetCorpseFire ( );
	void AddCorpseEffectiveRangeReduction ( class AActor* DamageInstigator, struct FVector originLocation, unsigned long bUseRadius, struct FImpactInfo* Impact );
	bool CheckTeamPassThrough ( class AActor* HitActor );
	bool IsOwnersCorpse ( class AActor* P, unsigned char eTargeterType );
	bool IsValidTarget ( class AActor* P, unsigned char eTargeterType, unsigned long bIgnoreHealth );
};

UClass* UTgDeviceFire_AhPuch_Dev2_Sub::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_AnhurDisarm
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_AnhurDisarm : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2001 );

		return pClassPointer;
	};

	struct FImpactInfo CalcAoeFire ( class AActor* DamageInstigator, struct FAimData Aim, unsigned long bPredicting, TArray< struct FImpactInfo >* ImpactList );
};

UClass* UTgDeviceFire_AnhurDisarm::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_AoKuang_KingsSword
// 0x0004 (0x017C - 0x0178)
class UTgDeviceFire_AoKuang_KingsSword : public UTgDeviceFire
{
public:
	int                                                m_nCombatSituationalType;                         		// 0x0178 (0x0004) [0x0000000000000002]              ( CPF_Const )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2002 );

		return pClassPointer;
	};

	void eventRemoveEquipEffects ( );
	void eventApplyEquipEffects ( );
	void RemovePassive ( );
	void ReapplyPassive ( unsigned long bSkipRemove );
};

UClass* UTgDeviceFire_AoKuang_KingsSword::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Apollo_SkyJump
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_Apollo_SkyJump : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2003 );

		return pClassPointer;
	};

	struct FImpactInfo CalcAoeFire ( class AActor* DamageInstigator, struct FAimData Aim, unsigned long bPredicting, TArray< struct FImpactInfo >* ImpactList );
};

UClass* UTgDeviceFire_Apollo_SkyJump::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Arachne_Attach
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_Arachne_Attach : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2004 );

		return pClassPointer;
	};

	bool IsValidTarget ( class AActor* P, unsigned char eTargeterType, unsigned long bIgnoreHealth );
};

UClass* UTgDeviceFire_Arachne_Attach::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Arachne_Cocoon
// 0x0008 (0x0180 - 0x0178)
class UTgDeviceFire_Arachne_Cocoon : public UTgDeviceFire
{
public:
	unsigned long                                      m_bUseExplosionRadius : 1;                        		// 0x0178 (0x0004) [0x0000000000000000] [0x00000001] 
	struct FPointer                                    m_pBotSetup;                                      		// 0x017C (0x0004) [0x0000000000001000]              ( CPF_Native )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2005 );

		return pClassPointer;
	};

	int GetMaxDeployableCount ( );
	class ATgPawn* SpawnPet ( unsigned long bPet );
	void SpawnBroodlings ( class AActor* Target );
	float GetDamageRadius ( );
};

UClass* UTgDeviceFire_Arachne_Cocoon::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Arachne_TrailSpawner
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_Arachne_TrailSpawner : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2006 );

		return pClassPointer;
	};

	void Deploy ( );
};

UClass* UTgDeviceFire_Arachne_TrailSpawner::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_ArcingBeam
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_ArcingBeam : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2007 );

		return pClassPointer;
	};

	bool eventApplyHit ( struct FImpactInfo Impact, class AActor* DamageInstigator );
};

UClass* UTgDeviceFire_ArcingBeam::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_ArcMeleeRanged
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_ArcMeleeRanged : public UTgDeviceFire_ArcingBeam
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2008 );

		return pClassPointer;
	};

	bool eventApplyHit ( struct FImpactInfo Impact, class AActor* DamageInstigator );
};

UClass* UTgDeviceFire_ArcMeleeRanged::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_ArcingBeam_PVE
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_ArcingBeam_PVE : public UTgDeviceFire_ArcMeleeRanged
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2009 );

		return pClassPointer;
	};

	bool eventApplyHit ( struct FImpactInfo Impact, class AActor* DamageInstigator );
};

UClass* UTgDeviceFire_ArcingBeam_PVE::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Zeus_ChainLightning
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_Zeus_ChainLightning : public UTgDeviceFire_ArcingBeam
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2010 );

		return pClassPointer;
	};

	bool eventApplyHit ( struct FImpactInfo Impact, class AActor* DamageInstigator );
	bool IsValidTarget ( class AActor* P, unsigned char eTargeterType, unsigned long bIgnoreHealth );
};

UClass* UTgDeviceFire_Zeus_ChainLightning::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Ares_Spewing_Shield
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_Ares_Spewing_Shield : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2011 );

		return pClassPointer;
	};

	void eventSubmitEffect ( struct FImpactInfo Impact, class UTgEffectGroup* effectGroup, unsigned long bRemove, int StackCount );
	bool CanHitTargetWithPercentDamage ( class AActor* HitActor );
};

UClass* UTgDeviceFire_Ares_Spewing_Shield::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_AthenaInHand
// 0x0008 (0x0180 - 0x0178)
class UTgDeviceFire_AthenaInHand : public UTgDeviceFire
{
public:
	float                                              m_fLastEnemyHitTimestamp;                         		// 0x0178 (0x0004) [0x0000000000000000]              
	float                                              m_fPassiveDamageReductionPct;                     		// 0x017C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2012 );

		return pClassPointer;
	};

	void AddEffectiveRangeReduction ( class AActor* DamageInstigator, struct FVector originLocation, unsigned long bUseRadius, struct FImpactInfo* Impact );
};

UClass* UTgDeviceFire_AthenaInHand::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Awilix_Moonlight
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_Awilix_Moonlight : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2013 );

		return pClassPointer;
	};

	bool eventApplyHit ( struct FImpactInfo Impact, class AActor* DamageInstigator );
	struct FImpactInfo CalcWeaponModeFire ( class AActor* DamageInstigator, struct FAimData Aim, unsigned long bPredicting, TArray< struct FImpactInfo >* ImpactList );
	struct FImpactInfo CalcConeFire ( class AActor* DamageInstigator, struct FAimData Aim, unsigned long bUseRange, unsigned long bPredicting, TArray< struct FImpactInfo >* ImpactList );
};

UClass* UTgDeviceFire_Awilix_Moonlight::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_BakasuraConsumeMinion
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_BakasuraConsumeMinion : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2014 );

		return pClassPointer;
	};

	bool IsValidTarget ( class AActor* P, unsigned char eTargeterType, unsigned long bIgnoreHealth );
};

UClass* UTgDeviceFire_BakasuraConsumeMinion::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Bellona_ShieldBash
// 0x0004 (0x017C - 0x0178)
class UTgDeviceFire_Bellona_ShieldBash : public UTgDeviceFire
{
public:
	unsigned long                                      m_bDoingBlockAOE : 1;                             		// 0x0178 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bForceConeRadius : 1;                           		// 0x0178 (0x0004) [0x0000000000000000] [0x00000002] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2015 );

		return pClassPointer;
	};

	void eventRemoveEquipEffects ( );
	void eventApplyEquipEffects ( );
	int RemoveLastModesBlockGroups ( );
	float GetDamageRadius ( );
};

UClass* UTgDeviceFire_Bellona_ShieldBash::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Bellona_SpinToStrike
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_Bellona_SpinToStrike : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2016 );

		return pClassPointer;
	};

	void eventSubmitEffect ( struct FImpactInfo Impact, class UTgEffectGroup* effectGroup, unsigned long bRemove, int StackCount );
	float GetRange ( );
	float GetDamageRadius ( );
};

UClass* UTgDeviceFire_Bellona_SpinToStrike::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Blink
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_Blink : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2017 );

		return pClassPointer;
	};

	void TeleportFire ( );
};

UClass* UTgDeviceFire_Blink::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_BulwarkHope
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_BulwarkHope : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2018 );

		return pClassPointer;
	};

	void eventSubmitEffect ( struct FImpactInfo Impact, class UTgEffectGroup* effectGroup, unsigned long bRemove, int StackCount );
	float GetShieldBonus ( class AActor* HitActor );
};

UClass* UTgDeviceFire_BulwarkHope::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Cabrakan_Dev4
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_Cabrakan_Dev4 : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2019 );

		return pClassPointer;
	};

	struct FImpactInfo CalcChargeTargetingFire ( class AActor* DamageInstigator, struct FAimData Aim, unsigned long bPredicting, float fRange, TArray< struct FImpactInfo >* ImpactList );
};

UClass* UTgDeviceFire_Cabrakan_Dev4::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Chiron_Passive
// 0x0004 (0x017C - 0x0178)
class UTgDeviceFire_Chiron_Passive : public UTgDeviceFire
{
public:
	int                                                m_nTempChironLevel;                               		// 0x0178 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2020 );

		return pClassPointer;
	};

	void eventSubmitEffect ( struct FImpactInfo Impact, class UTgEffectGroup* effectGroup, unsigned long bRemove, int StackCount );
	struct FImpactInfo CalcAoeFire ( class AActor* DamageInstigator, struct FAimData Aim, unsigned long bPredicting, TArray< struct FImpactInfo >* ImpactList );
};

UClass* UTgDeviceFire_Chiron_Passive::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Chiron_SpreadShot
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_Chiron_SpreadShot : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2021 );

		return pClassPointer;
	};

	int GetShotsPerFire ( );
};

UClass* UTgDeviceFire_Chiron_SpreadShot::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Chiron_UltimateShooter
// 0x0008 (0x0180 - 0x0178)
class UTgDeviceFire_Chiron_UltimateShooter : public UTgDeviceFire
{
public:
	float                                              m_fCachedRangeTimestamp;                          		// 0x0178 (0x0004) [0x0000000000000000]              
	float                                              m_fCachedRange;                                   		// 0x017C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2022 );

		return pClassPointer;
	};

	void eventSubmitEffect ( struct FImpactInfo Impact, class UTgEffectGroup* effectGroup, unsigned long bRemove, int StackCount );
	float GetRange ( );
	class ATgPawn* SpawnPet ( unsigned long bPet );
	unsigned char GetTargetingMode ( );
};

UClass* UTgDeviceFire_Chiron_UltimateShooter::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Chronos_Fast
// 0x0004 (0x017C - 0x0178)
class UTgDeviceFire_Chronos_Fast : public UTgDeviceFire
{
public:
	int                                                m_nShotsTilMaxCost;                               		// 0x0178 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2023 );

		return pClassPointer;
	};

	float GetShotPowerCost ( int nPacingType, unsigned long bBaseOnly );
};

UClass* UTgDeviceFire_Chronos_Fast::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Cupid_HealingHearts
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_Cupid_HealingHearts : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2024 );

		return pClassPointer;
	};

	void Deploy ( );
};

UClass* UTgDeviceFire_Cupid_HealingHearts::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Deploy
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_Deploy : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2025 );

		return pClassPointer;
	};

	void eventOnDeployableDeployComplete ( class ATgDeployable* deployable );
	void eventOnDeployableDestroyed ( class ATgDeployable* deployable );
	void Deploy ( );
};

UClass* UTgDeviceFire_Deploy::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_AhPuch_Dev2
// 0x0008 (0x0180 - 0x0178)
class UTgDeviceFire_AhPuch_Dev2 : public UTgDeviceFire_Deploy
{
public:
	class UTgDeviceFire*                               m_CorpseFireMode;                                 		// 0x0178 (0x0004) [0x0000000000000000]              
	class ATgPawn_AhPuch*                              m_OwningAhPuch;                                   		// 0x017C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2026 );

		return pClassPointer;
	};

	void eventApplyCorpseHit ( struct FImpactInfo Impact, class AActor* DamageInstigator );
	float eventGetCorpseAbsorbRadius ( );
	bool IsCorpseModeAOE ( );
	bool IsOwnersCorpse ( class AActor* P, unsigned char eTargeterType );
	bool IsValidTarget ( class AActor* P, unsigned char eTargeterType, unsigned long bIgnoreHealth );
	struct FImpactInfo CalcCorpseWeaponModeFire ( class AActor* DamageInstigator, struct FAimData Aim, unsigned long bPredicting, TArray< struct FImpactInfo >* ImpactList );
	struct FImpactInfo CalcCorpseWeaponTargettingAim ( class AActor* DamageInstigator, struct FAimData Aim, unsigned long bPredicting, TArray< struct FImpactInfo >* ImpactList );
};

UClass* UTgDeviceFire_AhPuch_Dev2::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_AhPuch_Passive
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_AhPuch_Passive : public UTgDeviceFire_Deploy
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2027 );

		return pClassPointer;
	};

	void DeployAt ( struct FVector vLocation, class AActor* FiringActor, class AActor* TargetActor, struct FVector vNormal, struct FVector vInitialLocation, unsigned long bFromDev3 );
};

UClass* UTgDeviceFire_AhPuch_Passive::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_AoKuang_WaterIllusion
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_AoKuang_WaterIllusion : public UTgDeviceFire_Deploy
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2028 );

		return pClassPointer;
	};

	void TeleportFire ( );
	void CustomFire ( );
};

UClass* UTgDeviceFire_AoKuang_WaterIllusion::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Apep_BasicAttack
// 0x0004 (0x017C - 0x0178)
class UTgDeviceFire_Apep_BasicAttack : public UTgDeviceFire_Deploy
{
public:
	struct FPointer                                    m_pDepSetup;                                      		// 0x0178 (0x0004) [0x0000000000001000]              ( CPF_Native )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2029 );

		return pClassPointer;
	};

};

UClass* UTgDeviceFire_Apep_BasicAttack::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_AutoPortal
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_AutoPortal : public UTgDeviceFire_Deploy
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2030 );

		return pClassPointer;
	};

	void Deploy ( );
};

UClass* UTgDeviceFire_AutoPortal::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Cabrakan_Dev4_UltimateShooter
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_Cabrakan_Dev4_UltimateShooter : public UTgDeviceFire_Deploy
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2031 );

		return pClassPointer;
	};

	void DeployWall ( struct FVector vLocation, class AActor* FiringActor, class AActor* TargetActor, struct FVector vNormal );
};

UClass* UTgDeviceFire_Cabrakan_Dev4_UltimateShooter::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Chiron_TrainingExercise
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_Chiron_TrainingExercise : public UTgDeviceFire_Deploy
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2032 );

		return pClassPointer;
	};

};

UClass* UTgDeviceFire_Chiron_TrainingExercise::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_DeployFromDeploy
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_DeployFromDeploy : public UTgDeviceFire_Deploy
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2033 );

		return pClassPointer;
	};

	void DeployAt ( struct FVector vLocation, class AActor* FiringActor, class AActor* TargetActor, struct FVector vNormal );
};

UClass* UTgDeviceFire_DeployFromDeploy::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Fafnir_Dev1
// 0x0004 (0x017C - 0x0178)
class UTgDeviceFire_Fafnir_Dev1 : public UTgDeviceFire_Deploy
{
public:
	struct FPointer                                    m_pDepSetup;                                      		// 0x0178 (0x0004) [0x0000000000001000]              ( CPF_Native )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2034 );

		return pClassPointer;
	};

};

UClass* UTgDeviceFire_Fafnir_Dev1::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_FireGiantGC2015a_MultiDeployable
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_FireGiantGC2015a_MultiDeployable : public UTgDeviceFire_Deploy
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2035 );

		return pClassPointer;
	};

	void Deploy ( );
};

UClass* UTgDeviceFire_FireGiantGC2015a_MultiDeployable::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_FireGiantPVERounds_MultiDeployable
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_FireGiantPVERounds_MultiDeployable : public UTgDeviceFire_Deploy
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2036 );

		return pClassPointer;
	};

	void Deploy ( );
};

UClass* UTgDeviceFire_FireGiantPVERounds_MultiDeployable::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_NeZha_ChildOfLotus
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_NeZha_ChildOfLotus : public UTgDeviceFire_Deploy
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2037 );

		return pClassPointer;
	};

	void Deploy ( );
};

UClass* UTgDeviceFire_NeZha_ChildOfLotus::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Skadi_Ice
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_Skadi_Ice : public UTgDeviceFire_Deploy
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2038 );

		return pClassPointer;
	};

	void eventApplyHitSpecial ( class AActor* Target, struct FImpactInfo Impact, int nHitSpecialSituationalType, int StackCount );
};

UClass* UTgDeviceFire_Skadi_Ice::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Sol_Dev2
// 0x0004 (0x017C - 0x0178)
class UTgDeviceFire_Sol_Dev2 : public UTgDeviceFire_Deploy
{
public:
	struct FPointer                                    m_pDepSetup;                                      		// 0x0178 (0x0004) [0x0000000000001000]              ( CPF_Native )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2039 );

		return pClassPointer;
	};

};

UClass* UTgDeviceFire_Sol_Dev2::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Terra_CrushingShale
// 0x0004 (0x017C - 0x0178)
class UTgDeviceFire_Terra_CrushingShale : public UTgDeviceFire_Deploy
{
public:
	int                                                m_CenterDeployableId;                             		// 0x0178 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2040 );

		return pClassPointer;
	};

	struct FImpactInfo CalcWeaponModeFire ( class AActor* DamageInstigator, struct FAimData Aim, unsigned long bPredicting, TArray< struct FImpactInfo >* ImpactList );
	void SpawnBetweenDeployable ( );
	void CustomFire ( );
};

UClass* UTgDeviceFire_Terra_CrushingShale::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Terra_PillarOfEarth
// 0x0004 (0x017C - 0x0178)
class UTgDeviceFire_Terra_PillarOfEarth : public UTgDeviceFire_Deploy
{
public:
	int                                                m_LastHittingFiringInstance;                      		// 0x0178 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2041 );

		return pClassPointer;
	};

	bool eventApplyHit ( struct FImpactInfo Impact, class AActor* DamageInstigator );
	bool ValidateApplyHit ( struct FImpactInfo Impact );
	void eventOnDeployableDeployComplete ( class ATgDeployable* deployable );
	bool IsValidTarget ( class AActor* P, unsigned char eTargeterType, unsigned long bIgnoreHealth );
};

UClass* UTgDeviceFire_Terra_PillarOfEarth::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_ErlangShen_Dog_Attack
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_ErlangShen_Dog_Attack : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2042 );

		return pClassPointer;
	};

	void AddEffectiveRangeReduction ( class AActor* DamageInstigator, struct FVector originLocation, unsigned long bUseRadius, struct FImpactInfo* Impact );
};

UClass* UTgDeviceFire_ErlangShen_Dog_Attack::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Fafnir_Basic_D
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_Fafnir_Basic_D : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2043 );

		return pClassPointer;
	};

};

UClass* UTgDeviceFire_Fafnir_Basic_D::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Fountain
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_Fountain : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2044 );

		return pClassPointer;
	};

	bool eventApplyHit ( struct FImpactInfo Impact, class AActor* DamageInstigator );
};

UClass* UTgDeviceFire_Fountain::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Freya_Levitate
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_Freya_Levitate : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2045 );

		return pClassPointer;
	};

	bool eventApplyHit ( struct FImpactInfo Impact, class AActor* DamageInstigator );
	bool ValidateApplyHit ( struct FImpactInfo Impact );
	bool IsValidTarget ( class AActor* P, unsigned char eTargeterType, unsigned long bIgnoreHealth );
};

UClass* UTgDeviceFire_Freya_Levitate::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_G72_Dev1
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_G72_Dev1 : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2046 );

		return pClassPointer;
	};

	void GetHitType ( struct FImpactInfo Impact, class AActor* DamageInstigator, int* nHitType, int* nSituationalType );
	void eventRemoveEffectType ( class AActor* Target, unsigned long bForceRemove, int nEffectGroupType, int StackCount );
	void eventApplyEffectType ( class AActor* Target, int nEffectGroupType, struct FImpactInfo Impact, int StackCount );
};

UClass* UTgDeviceFire_G72_Dev1::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_G72_Dev2Stage
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_G72_Dev2Stage : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2047 );

		return pClassPointer;
	};

	void eventSubmitEffect ( struct FImpactInfo Impact, class UTgEffectGroup* effectGroup, unsigned long bRemove, int StackCount );
	float GetShotPowerCost ( int nPacingType, unsigned long bBaseOnly );
	struct FImpactInfo CalcWeaponModeFire ( class AActor* DamageInstigator, struct FAimData Aim, unsigned long bPredicting, TArray< struct FImpactInfo >* ImpactList );
};

UClass* UTgDeviceFire_G72_Dev2Stage::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_G72_Dev4
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_G72_Dev4 : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2048 );

		return pClassPointer;
	};

	void GetHitType ( struct FImpactInfo Impact, class AActor* DamageInstigator, int* nHitType, int* nSituationalType );
};

UClass* UTgDeviceFire_G72_Dev4::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_G84_Dev3
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_G84_Dev3 : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2049 );

		return pClassPointer;
	};

	class ATgPawn* SpawnPet ( unsigned long bPet );
};

UClass* UTgDeviceFire_G84_Dev3::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_G84_Dev4
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_G84_Dev4 : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2050 );

		return pClassPointer;
	};

	void CustomFire ( );
	class ATgPawn* SpawnPet ( unsigned long bPet );
};

UClass* UTgDeviceFire_G84_Dev4::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Gateway
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_Gateway : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2051 );

		return pClassPointer;
	};

};

UClass* UTgDeviceFire_Gateway::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Geb_ShockWave
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_Geb_ShockWave : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2052 );

		return pClassPointer;
	};

	void AddEffectiveRangeReduction ( class AActor* DamageInstigator, struct FVector originLocation, unsigned long bUseRadius, struct FImpactInfo* Impact );
};

UClass* UTgDeviceFire_Geb_ShockWave::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_GroundTarget_LockOn
// 0x0004 (0x017C - 0x0178)
class UTgDeviceFire_GroundTarget_LockOn : public UTgDeviceFire
{
public:
	unsigned long                                      m_bHitsMulti : 1;                                 		// 0x0178 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2053 );

		return pClassPointer;
	};

	struct FImpactInfo CalcWeaponModeFire ( class AActor* DamageInstigator, struct FAimData Aim, unsigned long bPredicting, TArray< struct FImpactInfo >* ImpactList );
};

UClass* UTgDeviceFire_GroundTarget_LockOn::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Isis_DeathWard
// 0x0000 (0x017C - 0x017C)
class UTgDeviceFire_Isis_DeathWard : public UTgDeviceFire_GroundTarget_LockOn
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2054 );

		return pClassPointer;
	};

};

UClass* UTgDeviceFire_Isis_DeathWard::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Kaldr_Aggro
// 0x0000 (0x017C - 0x017C)
class UTgDeviceFire_Kaldr_Aggro : public UTgDeviceFire_GroundTarget_LockOn
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2055 );

		return pClassPointer;
	};

	bool MatchesLastTarget ( class AActor* Target );
};

UClass* UTgDeviceFire_Kaldr_Aggro::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Khepri_Dev4
// 0x0000 (0x017C - 0x017C)
class UTgDeviceFire_Khepri_Dev4 : public UTgDeviceFire_GroundTarget_LockOn
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2056 );

		return pClassPointer;
	};

	bool IsValidTarget ( class AActor* P, unsigned char eTargeterType, unsigned long bIgnoreHealth );
};

UClass* UTgDeviceFire_Khepri_Dev4::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Serqet_LastBreath
// 0x000C (0x0188 - 0x017C)
class UTgDeviceFire_Serqet_LastBreath : public UTgDeviceFire_GroundTarget_LockOn
{
public:
	TArray< float >                                    m_fDamageRadiusStack;                             		// 0x017C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2057 );

		return pClassPointer;
	};

	float GetDamageRadius ( );
};

UClass* UTgDeviceFire_Serqet_LastBreath::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_HandOfTheGods
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_HandOfTheGods : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2058 );

		return pClassPointer;
	};

	struct FImpactInfo CalcAoeFire ( class AActor* DamageInstigator, struct FAimData Aim, unsigned long bPredicting, TArray< struct FImpactInfo >* ImpactList );
};

UClass* UTgDeviceFire_HandOfTheGods::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_WrathOfTheGods
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_WrathOfTheGods : public UTgDeviceFire_HandOfTheGods
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2059 );

		return pClassPointer;
	};

	void GetHitType ( struct FImpactInfo Impact, class AActor* DamageInstigator, int* nHitType, int* nSituationalType );
	bool IsObjectiveMonster ( class AActor* TargetActor );
};

UClass* UTgDeviceFire_WrathOfTheGods::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_HitInMesh
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_HitInMesh : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2060 );

		return pClassPointer;
	};

};

UClass* UTgDeviceFire_HitInMesh::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_HouYi_MarkHandling
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_HouYi_MarkHandling : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2061 );

		return pClassPointer;
	};

	void GetHitType ( struct FImpactInfo Impact, class AActor* DamageInstigator, int* nHitType, int* nSituationalType );
};

UClass* UTgDeviceFire_HouYi_MarkHandling::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_HouYi_ChargedShot
// 0x0008 (0x0180 - 0x0178)
class UTgDeviceFire_HouYi_ChargedShot : public UTgDeviceFire_HouYi_MarkHandling
{
public:
	struct FPointer                                    VfTable_ITgSplineDeviceModeInterface;             		// 0x0178 (0x0004) [0x0000000000801002]              ( CPF_Const | CPF_Native | CPF_NoExport )
	int                                                m_nNumSecions;                                    		// 0x017C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2062 );

		return pClassPointer;
	};

	void eventSubmitEffect ( struct FImpactInfo Impact, class UTgEffectGroup* effectGroup, unsigned long bRemove, int StackCount );
	struct FImpactInfo CalcSplineFire ( class AActor* DamageInstigator, unsigned long bUseProximityDistance, unsigned long bPredicting, struct FInterpCurveVector* Spline, TArray< struct FImpactInfo >* ImpactList );
};

UClass* UTgDeviceFire_HouYi_ChargedShot::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_HouYi_DiveBomb
// 0x0004 (0x017C - 0x0178)
class UTgDeviceFire_HouYi_DiveBomb : public UTgDeviceFire_HouYi_MarkHandling
{
public:
	unsigned long                                      m_bUseSecondaryTargetingValues : 1;               		// 0x0178 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2063 );

		return pClassPointer;
	};

	unsigned char GetTargetingMode ( );
	float GetDamageRadius ( );
	float GetRange ( );
};

UClass* UTgDeviceFire_HouYi_DiveBomb::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Intoxicate_PVE
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_Intoxicate_PVE : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2064 );

		return pClassPointer;
	};

	bool eventApplyHit ( struct FImpactInfo Impact, class AActor* DamageInstigator );
};

UClass* UTgDeviceFire_Intoxicate_PVE::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Janus_Ultimate
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_Janus_Ultimate : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2065 );

		return pClassPointer;
	};

	void AddEffectiveRangeReduction ( class AActor* DamageInstigator, struct FVector originLocation, unsigned long bUseRadius, struct FImpactInfo* Impact );
};

UClass* UTgDeviceFire_Janus_Ultimate::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_JingWei_Dev1
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_JingWei_Dev1 : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2066 );

		return pClassPointer;
	};

	bool IsValidTarget ( class AActor* Target, unsigned char eTargeterType, unsigned long bIgnoreHealth );
};

UClass* UTgDeviceFire_JingWei_Dev1::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Khepri_Sun
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_Khepri_Sun : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2067 );

		return pClassPointer;
	};

	bool IsValidTarget ( class AActor* P, unsigned char eTargeterType, unsigned long bIgnoreHealth );
};

UClass* UTgDeviceFire_Khepri_Sun::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Kumbhakarna_Num2
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_Kumbhakarna_Num2 : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2068 );

		return pClassPointer;
	};

	bool IsValidTarget ( class AActor* P, unsigned char eTargeterType, unsigned long bIgnoreHealth );
};

UClass* UTgDeviceFire_Kumbhakarna_Num2::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Kumbhakarna_Num3
// 0x0004 (0x017C - 0x0178)
class UTgDeviceFire_Kumbhakarna_Num3 : public UTgDeviceFire
{
public:
	unsigned long                                      m_bHitEnemyGod : 1;                               		// 0x0178 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2069 );

		return pClassPointer;
	};

	float eventGetCooldownTime ( );
	float GetShotPowerCost ( int nPacingType, unsigned long bBaseOnly );
	float GetDamageRadius ( );
};

UClass* UTgDeviceFire_Kumbhakarna_Num3::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_LineTarget_LockOn
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_LineTarget_LockOn : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2070 );

		return pClassPointer;
	};

	struct FImpactInfo CalcLinearFire ( class AActor* DamageInstigator, struct FAimData Aim, unsigned long bUseProximityDistance, unsigned long bPredicting, TArray< struct FImpactInfo >* ImpactList );
};

UClass* UTgDeviceFire_LineTarget_LockOn::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Loki_PVEDecoy
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_Loki_PVEDecoy : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2071 );

		return pClassPointer;
	};

	class ATgPawn* SpawnPet ( unsigned long bPet );
};

UClass* UTgDeviceFire_Loki_PVEDecoy::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_MapTargetLockOn
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_MapTargetLockOn : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2072 );

		return pClassPointer;
	};

	void TeleportFire ( );
	bool IsValidTargetRepInfo ( class AReplicationInfo* RepInfo );
	bool IsValidTarget ( class AActor* P, unsigned char eTargeterType, unsigned long bIgnoreHealth );
};

UClass* UTgDeviceFire_MapTargetLockOn::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_MapTargetTeleportGod
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_MapTargetTeleportGod : public UTgDeviceFire_MapTargetLockOn
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2073 );

		return pClassPointer;
	};

	void TeleportFire ( );
	bool IsValidTargetRepInfo ( class AReplicationInfo* RepInfo );
};

UClass* UTgDeviceFire_MapTargetTeleportGod::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_MapTargetTeleportTower
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_MapTargetTeleportTower : public UTgDeviceFire_MapTargetLockOn
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2074 );

		return pClassPointer;
	};

	bool IsValidTargetRepInfo ( class AReplicationInfo* RepInfo );
};

UClass* UTgDeviceFire_MapTargetTeleportTower::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_MapTargetTeleportWard
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_MapTargetTeleportWard : public UTgDeviceFire_MapTargetLockOn
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2075 );

		return pClassPointer;
	};

	bool IsValidTargetRepInfo ( class AReplicationInfo* RepInfo );
};

UClass* UTgDeviceFire_MapTargetTeleportWard::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_TeleportSiegeVariant
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_TeleportSiegeVariant : public UTgDeviceFire_MapTargetLockOn
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2076 );

		return pClassPointer;
	};

	void TeleportFire ( );
};

UClass* UTgDeviceFire_TeleportSiegeVariant::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Medusa_Dev2
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_Medusa_Dev2 : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2077 );

		return pClassPointer;
	};

	void GetHitType ( struct FImpactInfo Impact, class AActor* DamageInstigator, int* nHitType, int* nSituationalType );
	bool IsValidTarget ( class AActor* P, unsigned char eTargeterType, unsigned long bIgnoreHealth );
};

UClass* UTgDeviceFire_Medusa_Dev2::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Mercury_Num4Shooter
// 0x0008 (0x0180 - 0x0178)
class UTgDeviceFire_Mercury_Num4Shooter : public UTgDeviceFire
{
public:
	float                                              m_fCachedRangeTimestamp;                          		// 0x0178 (0x0004) [0x0000000000000000]              
	float                                              m_fCachedRange;                                   		// 0x017C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2078 );

		return pClassPointer;
	};

	bool IsValidTarget ( class AActor* P, unsigned char eTargeterType, unsigned long bIgnoreHealth );
	float GetRange ( );
};

UClass* UTgDeviceFire_Mercury_Num4Shooter::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_MinionBuff
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_MinionBuff : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2079 );

		return pClassPointer;
	};

	bool IsValidTarget ( class AActor* P, unsigned char eTargeterType, unsigned long bIgnoreHealth );
};

UClass* UTgDeviceFire_MinionBuff::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Neith_BrokenWeaveUser
// 0x0008 (0x0180 - 0x0178)
class UTgDeviceFire_Neith_BrokenWeaveUser : public UTgDeviceFire
{
public:
	class ATgPawn_Neith*                               m_OwningNeith;                                    		// 0x0178 (0x0004) [0x0000000000000000]              
	class UTgDeviceFire*                               m_BrokenWeaveFireMode;                            		// 0x017C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2080 );

		return pClassPointer;
	};

	void eventApplyBrokenWeaveHit ( struct FImpactInfo Impact, class AActor* DamageInstigator );
	bool eventApplyHit ( struct FImpactInfo Impact, class AActor* DamageInstigator );
	float eventGetBrokenWeaveAbsorbRadius ( );
	bool IsBrokenWeaveModeAOE ( );
	bool IsValidBrokenWeaveUser ( );
	struct FImpactInfo CalcBrokenWeaveWeaponModeFire ( class AActor* DamageInstigator, struct FAimData Aim, unsigned long bPredicting, TArray< struct FImpactInfo >* ImpactList );
	void AddBrokenWeaveEffectiveRangeReduction ( class AActor* DamageInstigator, struct FVector originLocation, unsigned long bUseRadius, struct FImpactInfo* Impact );
	bool CheckTeamPassThrough ( class AActor* HitActor );
	bool IsOwnersBrokenWeave ( class AActor* P, unsigned char eTargeterType );
	bool IsValidBrokenWeaveTarget ( class AActor* P, unsigned char eTargeterType );
	bool IsValidNormalTarget ( class AActor* P, unsigned char eTargeterType );
	bool IsValidTarget ( class AActor* P, unsigned char eTargeterType, unsigned long bIgnoreHealth );
};

UClass* UTgDeviceFire_Neith_BrokenWeaveUser::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Nox_Dev3
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_Nox_Dev3 : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2081 );

		return pClassPointer;
	};

	bool IsValidTarget ( class AActor* P, unsigned char eTargeterType, unsigned long bIgnoreHealth );
	struct FImpactInfo CalcAoeFire ( class AActor* DamageInstigator, struct FAimData Aim, unsigned long bPredicting, TArray< struct FImpactInfo >* ImpactList );
};

UClass* UTgDeviceFire_Nox_Dev3::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_NuWa_FlameStrike
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_NuWa_FlameStrike : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2082 );

		return pClassPointer;
	};

};

UClass* UTgDeviceFire_NuWa_FlameStrike::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_NuWa_FogSpawn
// 0x0004 (0x017C - 0x0178)
class UTgDeviceFire_NuWa_FogSpawn : public UTgDeviceFire
{
public:
	struct FPointer                                    m_pBotSetup;                                      		// 0x0178 (0x0004) [0x0000000000001000]              ( CPF_Native )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2083 );

		return pClassPointer;
	};

	class ATgPawn* SpawnPet ( unsigned long bPet );
	void CustomFire ( );
};

UClass* UTgDeviceFire_NuWa_FogSpawn::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_NuWa_InHand
// 0x0004 (0x017C - 0x0178)
class UTgDeviceFire_NuWa_InHand : public UTgDeviceFire
{
public:
	class UTgDeviceFire*                               m_AoeMode;                                        		// 0x0178 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2084 );

		return pClassPointer;
	};

	bool eventApplyHit ( struct FImpactInfo Impact, class AActor* DamageInstigator );
};

UClass* UTgDeviceFire_NuWa_InHand::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_NuWa_MinionSpawn
// 0x0014 (0x018C - 0x0178)
class UTgDeviceFire_NuWa_MinionSpawn : public UTgDeviceFire
{
public:
	int                                                m_nNextSpawnIndex;                                		// 0x0178 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bCachedPet : 1;                                 		// 0x017C (0x0004) [0x0000000000000000] [0x00000001] 
	int                                                m_nCachedLaneId;                                  		// 0x0180 (0x0004) [0x0000000000000000]              
	class UTgAISquad*                                  m_CachedSquad;                                    		// 0x0184 (0x0004) [0x0000000000000000]              
	float                                              m_fCachedStaggerTime;                             		// 0x0188 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2085 );

		return pClassPointer;
	};

	int GetSpawnCount ( );
	void ForceRemainderToSpawn ( );
	class ATgPawn* SpawnNext ( unsigned long bSetTimer );
	class ATgPawn* SpawnPet ( unsigned long bPet );
};

UClass* UTgDeviceFire_NuWa_MinionSpawn::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_NuWa_MinionSpawn_PVE
// 0x0000 (0x018C - 0x018C)
class UTgDeviceFire_NuWa_MinionSpawn_PVE : public UTgDeviceFire_NuWa_MinionSpawn
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2086 );

		return pClassPointer;
	};

	int GetSpawnCount ( );
};

UClass* UTgDeviceFire_NuWa_MinionSpawn_PVE::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_NuWa_StealthFog
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_NuWa_StealthFog : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2087 );

		return pClassPointer;
	};

};

UClass* UTgDeviceFire_NuWa_StealthFog::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_OffsetCone
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_OffsetCone : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2088 );

		return pClassPointer;
	};

	float ConeOffset ( float fMinRadius, float fMaxRadius );
	struct FImpactInfo CalcConeFire ( class AActor* DamageInstigator, struct FAimData Aim, unsigned long bUseRange, unsigned long bPredicting, TArray< struct FImpactInfo >* ImpactList );
};

UClass* UTgDeviceFire_OffsetCone::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Sol_TrailIgniter
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_Sol_TrailIgniter : public UTgDeviceFire_OffsetCone
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2089 );

		return pClassPointer;
	};

	bool eventApplyHit ( struct FImpactInfo Impact, class AActor* DamageInstigator );
	bool IsOwnersTrail ( class AActor* P, unsigned char eTargeterType );
	bool IsValidTarget ( class AActor* P, unsigned char eTargeterType, unsigned long bIgnoreHealth );
};

UClass* UTgDeviceFire_Sol_TrailIgniter::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Susano_Dev1_Part1
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_Susano_Dev1_Part1 : public UTgDeviceFire_OffsetCone
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2090 );

		return pClassPointer;
	};

	float ConeOffset ( float fMinRadius, float fMaxRadius );
};

UClass* UTgDeviceFire_Susano_Dev1_Part1::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_PercCurHealthCost
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_PercCurHealthCost : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2091 );

		return pClassPointer;
	};

	float GetShotPowerCost ( int nPacingType, unsigned long bBaseOnly );
};

UClass* UTgDeviceFire_PercCurHealthCost::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Ram_ArrowDeploy
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_Ram_ArrowDeploy : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2092 );

		return pClassPointer;
	};

	void Deploy ( );
};

UClass* UTgDeviceFire_Ram_ArrowDeploy::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Ram_AstralArrow
// 0x0008 (0x0180 - 0x0178)
class UTgDeviceFire_Ram_AstralArrow : public UTgDeviceFire
{
public:
	int                                                m_nProjectileHitOverride;                         		// 0x0178 (0x0004) [0x0000000000000000]              
	int                                                m_nThirdHitSituationalType;                       		// 0x017C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2093 );

		return pClassPointer;
	};

	void GetHitType ( struct FImpactInfo Impact, class AActor* DamageInstigator, int* nHitType, int* nSituationalType );
	float GetDamageRadius ( );
};

UClass* UTgDeviceFire_Ram_AstralArrow::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Ratatoskr_Base
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_Ratatoskr_Base : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2094 );

		return pClassPointer;
	};

	void GetHitType ( struct FImpactInfo Impact, class AActor* DamageInstigator, int* nHitType, int* nSituationalType );
	bool AllowAcornBasedHits ( struct FImpactInfo Impact, class AActor* DamageInstigator );
	bool HasAcornHitSpecialGroup ( int nSituationalType );
};

UClass* UTgDeviceFire_Ratatoskr_Base::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Ratatoskr_AcornThrow
// 0x000C (0x0184 - 0x0178)
class UTgDeviceFire_Ratatoskr_AcornThrow : public UTgDeviceFire_Ratatoskr_Base
{
public:
	int                                                s_nActiveFiringInstance;                          		// 0x0178 (0x0004) [0x0000000000000000]              
	int                                                s_nHealStackCount;                                		// 0x017C (0x0004) [0x0000000000000000]              
	int                                                s_nMaxHealStackCount;                             		// 0x0180 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2095 );

		return pClassPointer;
	};

	void HandleSuccessfulHit ( class AActor* DamageInstigator, class APawn* OwnerInstigator, struct FImpactInfo Impact, int nHitType, int nSituationalType );
	bool AllowAcornBasedHits ( struct FImpactInfo Impact, class AActor* DamageInstigator );
};

UClass* UTgDeviceFire_Ratatoskr_AcornThrow::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Scout
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_Scout : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2096 );

		return pClassPointer;
	};

	bool IsValidTarget ( class AActor* P, unsigned char eTargeterType, unsigned long bIgnoreHealth );
	void Deploy ( );
};

UClass* UTgDeviceFire_Scout::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Skadi_Dev1
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_Skadi_Dev1 : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2097 );

		return pClassPointer;
	};

	void GetHitType ( struct FImpactInfo Impact, class AActor* DamageInstigator, int* nHitType, int* nSituationalType );
	bool IsValidTarget ( class AActor* P, unsigned char eTargeterType, unsigned long bIgnoreHealth );
};

UClass* UTgDeviceFire_Skadi_Dev1::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Sol_Dev1
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_Sol_Dev1 : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2098 );

		return pClassPointer;
	};

	void Deploy ( );
};

UClass* UTgDeviceFire_Sol_Dev1::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Spline
// 0x0008 (0x0180 - 0x0178)
class UTgDeviceFire_Spline : public UTgDeviceFire
{
public:
	struct FPointer                                    VfTable_ITgSplineDeviceModeInterface;             		// 0x0178 (0x0004) [0x0000000000801002]              ( CPF_Const | CPF_Native | CPF_NoExport )
	int                                                m_nNumSecions;                                    		// 0x017C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2099 );

		return pClassPointer;
	};

	struct FImpactInfo CalcSplineFire ( class AActor* DamageInstigator, unsigned long bUseProximityDistance, unsigned long bPredicting, struct FInterpCurveVector* Spline, TArray< struct FImpactInfo >* ImpactList );
	struct FImpactInfo CalcWeaponModeFire ( class AActor* DamageInstigator, struct FAimData Aim, unsigned long bPredicting, TArray< struct FImpactInfo >* ImpactList );
};

UClass* UTgDeviceFire_Spline::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Janus_DeathGate
// 0x0000 (0x0180 - 0x0180)
class UTgDeviceFire_Janus_DeathGate : public UTgDeviceFire_Spline
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2100 );

		return pClassPointer;
	};

	bool eventApplyHit ( struct FImpactInfo Impact, class AActor* DamageInstigator );
	void AddEffectiveRangeReduction ( class AActor* DamageInstigator, struct FVector originLocation, unsigned long bUseRadius, struct FImpactInfo* Impact );
};

UClass* UTgDeviceFire_Janus_DeathGate::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_SunWukong_MastersWill
// 0x0004 (0x017C - 0x0178)
class UTgDeviceFire_SunWukong_MastersWill : public UTgDeviceFire
{
public:
	class UTgDeviceFire*                               m_ReturnFireMode;                                 		// 0x0178 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2101 );

		return pClassPointer;
	};

};

UClass* UTgDeviceFire_SunWukong_MastersWill::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Sylvanus_Auto
// 0x0004 (0x017C - 0x0178)
class UTgDeviceFire_Sylvanus_Auto : public UTgDeviceFire
{
public:
	int                                                m_nImpactCount;                                   		// 0x0178 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2102 );

		return pClassPointer;
	};

	struct FImpactInfo CalcAoeFire ( class AActor* DamageInstigator, struct FAimData Aim, unsigned long bPredicting, TArray< struct FImpactInfo >* ImpactList );
	float GetRange ( );
};

UClass* UTgDeviceFire_Sylvanus_Auto::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Terra_BasicAttack
// 0x0004 (0x017C - 0x0178)
class UTgDeviceFire_Terra_BasicAttack : public UTgDeviceFire
{
public:
	unsigned long                                      m_IsMeleeOverride : 1;                            		// 0x0178 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2103 );

		return pClassPointer;
	};

	float GetRange ( );
};

UClass* UTgDeviceFire_Terra_BasicAttack::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Terra_CrushingShale_Sub
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_Terra_CrushingShale_Sub : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2104 );

		return pClassPointer;
	};

	bool IsValidTarget ( class AActor* P, unsigned char eTargeterType, unsigned long bIgnoreHealth );
};

UClass* UTgDeviceFire_Terra_CrushingShale_Sub::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Terra_MegaPunch
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_Terra_MegaPunch : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2105 );

		return pClassPointer;
	};

	bool IsValidTarget ( class AActor* P, unsigned char eTargeterType, unsigned long bIgnoreHealth );
};

UClass* UTgDeviceFire_Terra_MegaPunch::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Thanatos_ScentOfDeath
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_Thanatos_ScentOfDeath : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2106 );

		return pClassPointer;
	};

	bool IsPotentialValidTarget ( class AActor* P, unsigned char eTargeterType );
	bool IsValidTarget ( class AActor* P, unsigned char eTargeterType, unsigned long bIgnoreHealth );
};

UClass* UTgDeviceFire_Thanatos_ScentOfDeath::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Thoth_Dash
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_Thoth_Dash : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2107 );

		return pClassPointer;
	};

	struct FImpactInfo CalcChargeTargetingFire ( class AActor* DamageInstigator, struct FAimData Aim, unsigned long bPredicting, float fRange, TArray< struct FImpactInfo >* ImpactList );
	bool ShouldAddRangeExtension ( struct FVector aimStart, struct FVector AimVector );
};

UClass* UTgDeviceFire_Thoth_Dash::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Thoth_Dev1
// 0x0008 (0x0180 - 0x0178)
class UTgDeviceFire_Thoth_Dev1 : public UTgDeviceFire
{
public:
	unsigned long                                      m_AddGlyphRangeExtension : 1;                     		// 0x0178 (0x0004) [0x0000000000000000] [0x00000001] 
	class ATgDevice_Deployable*                        m_GlyphDevice;                                    		// 0x017C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2108 );

		return pClassPointer;
	};

	struct FImpactInfo CalcLinearFire ( class AActor* DamageInstigator, struct FAimData Aim, unsigned long bUseProximityDistance, unsigned long bPredicting, TArray< struct FImpactInfo >* ImpactList );
	bool IsValidTarget ( class AActor* P, unsigned char eTargeterType, unsigned long bIgnoreHealth );
};

UClass* UTgDeviceFire_Thoth_Dev1::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_TwoPhase
// 0x0001 (0x0179 - 0x0178)
class UTgDeviceFire_TwoPhase : public UTgDeviceFire
{
public:
	unsigned char                                      m_eAltTargetingMode;                              		// 0x0178 (0x0001) [0x0000000000000002]              ( CPF_Const )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2109 );

		return pClassPointer;
	};

	float eventGetPostHitDelay ( );
	float eventGetPreHitDelay ( );
	float eventGetBuildupTime ( );
	float eventGetRefireTime ( );
	float GetDamageRadius ( );
	float GetRange ( );
	float GetShotPowerCost ( int nPacingType, unsigned long bBaseOnly );
	bool UseCustomFiringValues ( );
	unsigned char GetTargetingMode ( );
};

UClass* UTgDeviceFire_TwoPhase::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_JingWei_Dev4
// 0x0003 (0x017C - 0x0179)
class UTgDeviceFire_JingWei_Dev4 : public UTgDeviceFire_TwoPhase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2110 );

		return pClassPointer;
	};

	unsigned char GetTargetingMode ( );
};

UClass* UTgDeviceFire_JingWei_Dev4::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Vulcan_ForgeCharge
// 0x0004 (0x017C - 0x0178)
class UTgDeviceFire_Vulcan_ForgeCharge : public UTgDeviceFire
{
public:
	float                                              m_EnergyCostOfCurrentShot;                        		// 0x0178 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2111 );

		return pClassPointer;
	};

	float GetShotPowerCost ( int nPacingType, unsigned long bBaseOnly );
};

UClass* UTgDeviceFire_Vulcan_ForgeCharge::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Vulcan_InfernoCannon
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_Vulcan_InfernoCannon : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2112 );

		return pClassPointer;
	};

};

UClass* UTgDeviceFire_Vulcan_InfernoCannon::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Vulcan_ShatterBomb
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_Vulcan_ShatterBomb : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2113 );

		return pClassPointer;
	};

	void AddEffectiveRangeReduction ( class AActor* DamageInstigator, struct FVector originLocation, unsigned long bUseRadius, struct FImpactInfo* Impact );
};

UClass* UTgDeviceFire_Vulcan_ShatterBomb::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Vulcan_Shockwave
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_Vulcan_Shockwave : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2114 );

		return pClassPointer;
	};

	void AddEffectiveRangeReduction ( class AActor* DamageInstigator, struct FVector originLocation, unsigned long bUseRadius, struct FImpactInfo* Impact );
};

UClass* UTgDeviceFire_Vulcan_Shockwave::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_WithExemptList
// 0x000C (0x0184 - 0x0178)
class UTgDeviceFire_WithExemptList : public UTgDeviceFire
{
public:
	TArray< class AActor* >                            m_ExemptList;                                     		// 0x0178 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2115 );

		return pClassPointer;
	};

	bool IsValidTarget ( class AActor* P, unsigned char eTargeterType, unsigned long bIgnoreHealth );
};

UClass* UTgDeviceFire_WithExemptList::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_NuWa_ShiningMetal
// 0x0004 (0x0188 - 0x0184)
class UTgDeviceFire_NuWa_ShiningMetal : public UTgDeviceFire_WithExemptList
{
public:
	unsigned long                                      m_bClaySoldierExplosion : 1;                      		// 0x0184 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2116 );

		return pClassPointer;
	};

	void GetHitType ( struct FImpactInfo Impact, class AActor* DamageInstigator, int* nHitType, int* nSituationalType );
	float GetDamageRadius ( );
};

UClass* UTgDeviceFire_NuWa_ShiningMetal::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Xbalanque_DashAndJump
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_Xbalanque_DashAndJump : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2117 );

		return pClassPointer;
	};

	float GetRange ( );
};

UClass* UTgDeviceFire_Xbalanque_DashAndJump::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_XingTian_AxeSweepShieldBash
// 0x0004 (0x017C - 0x0178)
class UTgDeviceFire_XingTian_AxeSweepShieldBash : public UTgDeviceFire
{
public:
	unsigned long                                      m_bUseSecondaryTargetingMode : 1;                 		// 0x0178 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2118 );

		return pClassPointer;
	};

	struct FImpactInfo CalcWeaponModeFire ( class AActor* DamageInstigator, struct FAimData Aim, unsigned long bPredicting, TArray< struct FImpactInfo >* ImpactList );
	unsigned char GetTargetingMode ( );
	float GetDamageRadius ( );
	float GetRange ( );
	bool UseSecondaryTargetingMode ( );
};

UClass* UTgDeviceFire_XingTian_AxeSweepShieldBash::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_XingTian_HeroicChargeV2
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_XingTian_HeroicChargeV2 : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2119 );

		return pClassPointer;
	};

	float eventGetRefireTime ( );
	float eventGetPostHitDelay ( );
	void GetHitType ( struct FImpactInfo Impact, class AActor* DamageInstigator, int* nHitType, int* nSituationalType );
	float GetRange ( );
};

UClass* UTgDeviceFire_XingTian_HeroicChargeV2::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Zeus_BasicAttack
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_Zeus_BasicAttack : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2120 );

		return pClassPointer;
	};

	bool eventApplyHit ( struct FImpactInfo Impact, class AActor* DamageInstigator );
	bool IsValidTarget ( class AActor* P, unsigned char eTargeterType, unsigned long bIgnoreHealth );
};

UClass* UTgDeviceFire_Zeus_BasicAttack::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Zeus_ChainLightning_PVE
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_Zeus_ChainLightning_PVE : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2121 );

		return pClassPointer;
	};

	void GetHitType ( struct FImpactInfo Impact, class AActor* DamageInstigator, int* nHitType, int* nSituationalType );
	void eventApplyEquipEffects ( );
};

UClass* UTgDeviceFire_Zeus_ChainLightning_PVE::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Zeus_ForkedLightning
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_Zeus_ForkedLightning : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2122 );

		return pClassPointer;
	};

	bool eventApplyHit ( struct FImpactInfo Impact, class AActor* DamageInstigator );
};

UClass* UTgDeviceFire_Zeus_ForkedLightning::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_ZhongKui_RecallDemons
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_ZhongKui_RecallDemons : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2123 );

		return pClassPointer;
	};

};

UClass* UTgDeviceFire_ZhongKui_RecallDemons::pClassPointer = NULL;

// Class TgGame.TgDeviceForm
// 0x014C (0x0188 - 0x003C)
class UTgDeviceForm : public UObject
{
public:
	struct FPointer                                    VfTable_FCallbackEventDevice;                     		// 0x003C (0x0004) [0x0000000000801002]              ( CPF_Const | CPF_Native | CPF_NoExport )
	class ATgPawn*                                     PawnOwner;                                        		// 0x0040 (0x0004) [0x0000000000000000]              
	int                                                c_nBehaviorType;                                  		// 0x0044 (0x0004) [0x0000000000000000]              
	struct FEquipDeviceInfo                            c_EquipDeviceInfo;                                		// 0x0048 (0x000C) [0x0000000000000000]              
	int                                                m_nDeviceType;                                    		// 0x0054 (0x0004) [0x0000000000000000]              
	unsigned char                                      m_eTargetingMode;                                 		// 0x0058 (0x0001) [0x0000000000000000]              
	unsigned char                                      c_eTargetingModeStatus;                           		// 0x0059 (0x0001) [0x0000000000000000]              
	unsigned long                                      c_bDeployed : 1;                                  		// 0x005C (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      c_bHandDevice : 1;                                		// 0x005C (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_bUseOwnerSockets : 1;                           		// 0x005C (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_bUsesWardSkin : 1;                              		// 0x005C (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      c_bEquipSlotForced : 1;                           		// 0x005C (0x0004) [0x0000000000000000] [0x00000010] 
	unsigned long                                      c_bIsTransitioningToNewMode : 1;                  		// 0x005C (0x0004) [0x0000000000000000] [0x00000020] 
	unsigned long                                      c_bIsInFirstPerson : 1;                           		// 0x005C (0x0004) [0x0000000000000000] [0x00000040] 
	unsigned long                                      c_bTargetingModeEnabled : 1;                      		// 0x005C (0x0004) [0x0000000000000000] [0x00000080] 
	unsigned long                                      c_bUsesPreFireTargeting : 1;                      		// 0x005C (0x0004) [0x0000000000000000] [0x00000100] 
	unsigned long                                      c_bTargeterInitializedThisTick : 1;               		// 0x005C (0x0004) [0x0000000000000000] [0x00000200] 
	unsigned long                                      c_bTargeterIsInWorldDPG : 1;                      		// 0x005C (0x0004) [0x0000000000000000] [0x00000400] 
	unsigned long                                      c_bUseInstigatorMesh : 1;                         		// 0x005C (0x0004) [0x0000000000000000] [0x00000800] 
	unsigned long                                      c_bIsInHand : 1;                                  		// 0x005C (0x0004) [0x0000000000000000] [0x00001000] 
	unsigned long                                      m_bLandWeaponRecovery : 1;                        		// 0x005C (0x0004) [0x0000000000000000] [0x00002000] 
	unsigned long                                      m_bInitializingAssets : 1;                        		// 0x005C (0x0004) [0x0000000000000000] [0x00004000] 
	class UAnimSet*                                    c_DeviceAnimSetOverride;                          		// 0x0060 (0x0004) [0x0000000000000000]              
	TArray< class UAnimSet* >                          c_PawnAnimSetOverrideList;                        		// 0x0064 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< struct FModeData >                         ModeDatas;                                        		// 0x0070 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FPointer                                    m_pAmSetup;                                       		// 0x007C (0x0004) [0x0000000000001000]              ( CPF_Native )
	class UMeshComponent*                              c_Mesh;                                           		// 0x0080 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class UMeshComponent*                              c_AttachedMesh;                                   		// 0x0084 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class UMeshComponent*                              c_ThirdPersonMesh;                                		// 0x0088 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class UTgSkeletalMeshComponent*                    c_FirstPersonMesh;                                		// 0x008C (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	struct FName                                       c_nmMountPoint;                                   		// 0x0090 (0x0008) [0x0000000000000000]              
	int                                                c_nDamageLevel;                                   		// 0x0098 (0x0004) [0x0000000000000000]              
	class UMaterialInstanceConstant*                   m_DamageMIC;                                      		// 0x009C (0x0004) [0x0000000000000000]              
	struct FName                                       FormState;                                        		// 0x00A0 (0x0008) [0x0000000000000000]              
	int                                                c_nFireMode;                                      		// 0x00A8 (0x0004) [0x0000000000000000]              
	int                                                c_nEquipSlot;                                     		// 0x00AC (0x0004) [0x0000000000000000]              
	float                                              c_fTimeToEquipDevice;                             		// 0x00B0 (0x0004) [0x0000000000000000]              
	int                                                c_nLastFxMode;                                    		// 0x00B4 (0x0004) [0x0000000000000000]              
	int                                                c_nLastSocketIndex;                               		// 0x00B8 (0x0004) [0x0000000000000000]              
	struct FVector                                     c_vBaseFirstPersonTranslation;                    		// 0x00BC (0x000C) [0x0000000000000000]              
	struct FVector                                     c_vCustomFirstPersonTranslation;                  		// 0x00C8 (0x000C) [0x0000000000000000]              
	struct FVector                                     c_vCustomFirstPersonRotation;                     		// 0x00D4 (0x000C) [0x0000000000000000]              
	class ATgSkeletalMeshActor*                        c_TargetingModeMeshIndicator;                     		// 0x00E0 (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                c_TargetingModeFx;                                		// 0x00E4 (0x0004) [0x0000000000000000]              
	struct FAimData                                    c_TargetingAim;                                   		// 0x00E8 (0x002C) [0x0000000000000000]              
	int                                                c_nTargetingModeFxId;                             		// 0x0114 (0x0004) [0x0000000000000000]              
	float                                              c_fRemainingTransitionTime;                       		// 0x0118 (0x0004) [0x0000000000000000]              
	float                                              c_fTotalTransitionTime;                           		// 0x011C (0x0004) [0x0000000000000000]              
	class AActor*                                      m_LockedTarget;                                   		// 0x0120 (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                c_ArcFx;                                          		// 0x0124 (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                c_ArcFxSuccessfulHit;                             		// 0x0128 (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                c_ReflectTracerFx;                                		// 0x012C (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                c_ReflectHitFx;                                   		// 0x0130 (0x0004) [0x0000000000000000]              
	float                                              m_LandWeaponBob;                                  		// 0x0134 (0x0004) [0x0000000000000000]              
	float                                              m_JumpWeaponBob;                                  		// 0x0138 (0x0004) [0x0000000000000000]              
	float                                              m_AppliedWeaponBob;                               		// 0x013C (0x0004) [0x0000000000000000]              
	float                                              m_WeaponBobTime;                                  		// 0x0140 (0x0004) [0x0000000000000000]              
	struct FVector                                     m_WalkWeaponBob;                                  		// 0x0144 (0x000C) [0x0000000000000000]              
	float                                              m_bLandWeaponShifting;                            		// 0x0150 (0x0004) [0x0000000000000000]              
	struct FVector                                     m_WeaponRotationNormalized;                       		// 0x0154 (0x000C) [0x0000000000000000]              
	struct FRotator                                    m_MaxDeltaWeaponRotation;                         		// 0x0160 (0x000C) [0x0000000000000000]              
	float                                              m_fInterpSpeedIntoWeaponRotation;                 		// 0x016C (0x0004) [0x0000000000000000]              
	float                                              m_fInterpSpeedOutOfWeaponRotation;                		// 0x0170 (0x0004) [0x0000000000000000]              
	struct FRotator                                    m_MaxWeaponRotation;                              		// 0x0174 (0x000C) [0x0000000000000000]              
	class UObjectReferencer*                           m_AssetReference;                                 		// 0x0180 (0x0004) [0x0000000000000000]              
	class AActor*                                      m_OwnerActor;                                     		// 0x0184 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2124 );

		return pClassPointer;
	};

	void eventOnRetrieveAnimDone ( );
	void eventGotoFormState ( struct FName NewState );
	void EndCurrentState ( );
	void eventAttachAndDeploy_DA ( );
	void eventDeviceAnimNotify ( );
	void eventDoInterrupt ( );
	void eventCooldownComplete ( );
	void eventCooldown ( int nFireModeNum );
	void eventRadialSweep ( int nYaw, float fDuration );
	void eventReflect ( struct FVector HitLocation, int nFireMode );
	void eventSetStagingMultiActiveChild ( int nChild );
	void eventInterruptCharge ( );
	void eventEndCharge ( unsigned long bHit );
	void eventBeginCharge ( );
	void eventPlayOffhandFx ( struct FVector HitLocation, struct FVector HitDirection, int nSocketIndex );
	void eventHit ( int nFireMode, class ATgPawn* TargetPawn );
	void eventFire ( struct FVector HitLocation, int nFireMode, int nEquipSlot, int nSocketIndex, unsigned long bSuccessfulHit, float fRefireTime );
	void eventStopFire ( int nFireModeNum );
	void eventStartFire ( int nFireMode, float fRefireTime, class AActor* Target );
	bool eventIsCurrentInHandWeapon ( );
	class UTgDeviceForm* InHandWeaponForm ( );
	void eventBuildUp ( int nFireMode, int nEquipSlot, int nSocketIndex, float fBuildupTime );
	void eventExitTargetingMode ( );
	void eventNotifyTargetingModeStatusChange ( );
	void eventNotifyEnterTargetingMode ( );
	void eventNotifyExitTargetingMode ( unsigned long bDeployed );
	void eventEnterTargetingMode ( );
	void InitializeTargetingModeFX ( );
	void EndDevicePuttingDown ( );
	void eventBeginDeviceTakingOut ( unsigned long PlayEquipAnim );
	void eventBeginActive ( int desiredIdleState );
	void eventPlayTracerFx ( struct FVector HitLocation, int nEquipSlot, int nSocketIndex, unsigned long bSuccessfulHit, struct FVector FireOrigin );
	bool UsesTargetingMode ( );
	void SpawnOffhandFx ( struct FVector HitLocation, struct FVector HitDirection, int nSocket );
	void DryFire ( );
	void UpdateFirstPersonWeaponFOV ( struct FVector2D Resolution );
	void GetCurrentUsedResourceList ( TArray< struct FString > List );
	void RecalculateMaterial ( );
	void UpdateTargetingList ( TArray< struct FImpactInfo >* ImpactList );
	void UpdateTargetingModeLocation ( struct FVector NewLocation, struct FRotator NewRotation, float DistanceScale );
	void UpdateTargetingModeStatus ( unsigned char Status, struct FAimData* Aim );
	class UTgSpecialFx* SpawnSpecialFxIndependent ( int nSpecialFxId, struct FParticleChannelContainer PSysChannels );
	void ResetAfterRagDoll ( );
	void Destruct ( struct FVector vLocation );
	void PlaySoundAt ( class USoundCue* ASound, struct FVector SourceLocation );
	int GetFormIndex ( );
	bool AllowImpactEffects ( class AActor* HitActor, struct FVector HitLocation, struct FVector HitNormal );
	void SpawnReflectFxs ( struct FVector HitLocation, struct FVector HitOrigin );
	void SpawnArcingTracer ( struct FVector HitLocation, struct FVector HitOrigin, unsigned long bSuccessfulHit );
	void SpawnFxTracer ( int nFireModeNum, struct FVector HitLocation, int nSocketIndex, unsigned long bHitTracer );
	void DeactivateFxGroup ( struct FName nmGroup );
	class UTgSpecialFx* ActivateFxIndependent ( struct FName nmGroup, unsigned long bSkipActivate, struct FParticleChannelContainer PSysChannels );
	void ActivateFxGroup ( struct FName nmGroup );
	bool LogDebugInfo ( );
	void InitCameraViewpoint ( );
	void DeviceAddRemoveAnimSet ( class UAnimSet* pAnimSet, unsigned long bAdd );
	void SetVisibility ( unsigned long bVisible );
	void DetachInHandDevice_DA ( );
	void DetachDevice_DA ( class USkeletalMeshComponent* ParentMesh, class UMeshComponent* AttachedMesh );
	bool AttachInHandDevice_DA ( unsigned long bFirstPerson );
	void AttachDevice_DA ( class USkeletalMeshComponent* ParentMesh, class UMeshComponent* AttachedMesh, struct FName nmSocket );
	void SetSkin ( class UMaterial* NewMaterial );
	void SetFireMode ( int nMode );
};

UClass* UTgDeviceForm::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_AhPuch_Dev2
// 0x0028 (0x01B0 - 0x0188)
class UTgDeviceForm_AhPuch_Dev2 : public UTgDeviceForm
{
public:
	TArray< class AActor* >                            c_SelectedCorpses;                                		// 0x0188 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UTgSpecialFx* >                      c_CorpseRangeFxList;                              		// 0x0194 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FName                                       c_nmRangeFxSocketName;                            		// 0x01A0 (0x0008) [0x0000000000000000]              
	unsigned long                                      c_bUseCorpseRangeFx : 1;                          		// 0x01A8 (0x0004) [0x0000000000000000] [0x00000001] 
	int                                                c_nCorpseRangeFxID;                               		// 0x01AC (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2125 );

		return pClassPointer;
	};

	void eventExitTargetingMode ( );
	void UpdateTargetingList ( TArray< struct FImpactInfo >* ImpactList );
};

UClass* UTgDeviceForm_AhPuch_Dev2::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_Anhur_Disarm
// 0x000C (0x0194 - 0x0188)
class UTgDeviceForm_Anhur_Disarm : public UTgDeviceForm
{
public:
	class ATgSkeletalMeshActor*                        c_TargetingModeMeshIndicatorPBAOE;                		// 0x0188 (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                c_TargetingModeFxPBAOE;                           		// 0x018C (0x0004) [0x0000000000000000]              
	int                                                c_nTargetingModeFxPBAOEId;                        		// 0x0190 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2126 );

		return pClassPointer;
	};

	void eventExitTargetingMode ( );
	void eventEnterTargetingMode ( );
	void UpdateTargetingModeLocation ( struct FVector NewLocation, struct FRotator NewRotation, float DistanceScale );
	void UpdateTargetingModeStatus ( unsigned char Status, struct FAimData* Aim );
	void InitializeTargetingModeFX ( );
};

UClass* UTgDeviceForm_Anhur_Disarm::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_AoKuang_WaterIllusion
// 0x000C (0x0194 - 0x0188)
class UTgDeviceForm_AoKuang_WaterIllusion : public UTgDeviceForm
{
public:
	class ATgSkeletalMeshActor*                        c_ProximityMeshIndicator;                         		// 0x0188 (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                c_ProximityFx;                                    		// 0x018C (0x0004) [0x0000000000000000]              
	int                                                c_nProximityFxId;                                 		// 0x0190 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2127 );

		return pClassPointer;
	};

	void eventExitTargetingMode ( );
	void eventEnterTargetingMode ( );
	void UpdateTargetingModeStatus ( unsigned char Status, struct FAimData* Aim );
	void InitializeTargetingModeFX ( );
};

UClass* UTgDeviceForm_AoKuang_WaterIllusion::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_Aphrodite_GetAway
// 0x0038 (0x01C0 - 0x0188)
class UTgDeviceForm_Aphrodite_GetAway : public UTgDeviceForm
{
public:
	unsigned char                                      c_eSoulMateModeStatus;                            		// 0x0188 (0x0001) [0x0000000000000000]              
	struct FAimData                                    c_SoulMateAim;                                    		// 0x018C (0x002C) [0x0000000000000000]              
	class ATgSkeletalMeshActor*                        c_SoulMateModeMeshIndicator;                      		// 0x01B8 (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                c_SoulMateModeFx;                                 		// 0x01BC (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2128 );

		return pClassPointer;
	};

	void eventExitTargetingMode ( );
	void eventEnterTargetingMode ( );
	void ToggleSoulMateMode ( unsigned long bEnable );
	void UpdateSoulMateModeLocation ( struct FVector NewLocation, struct FRotator NewRotation, float DistanceScale );
	void UpdateSoulMateModeStatus ( unsigned char Status, struct FAimData* Aim );
};

UClass* UTgDeviceForm_Aphrodite_GetAway::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_Arcing
// 0x0004 (0x018C - 0x0188)
class UTgDeviceForm_Arcing : public UTgDeviceForm
{
public:
	int                                                c_nArcTracerFxId;                                 		// 0x0188 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2129 );

		return pClassPointer;
	};

	class UTgSpecialFx* ActivateFxIndependent ( struct FName nmGroup, unsigned long bSkipActivate, struct FParticleChannelContainer PSysChannels );
};

UClass* UTgDeviceForm_Arcing::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_AthenaLeapingLunge
// 0x0004 (0x018C - 0x0188)
class UTgDeviceForm_AthenaLeapingLunge : public UTgDeviceForm
{
public:
	class UMaterialInstanceConstant*                   c_TargetingModeMIC;                               		// 0x0188 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2130 );

		return pClassPointer;
	};

	void InitializeTargetingModeFX ( );
};

UClass* UTgDeviceForm_AthenaLeapingLunge::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_AutoPortal
// 0x0044 (0x01CC - 0x0188)
class UTgDeviceForm_AutoPortal : public UTgDeviceForm
{
public:
	unsigned long                                      m_bUseAlternateTargeter : 1;                      		// 0x0188 (0x0004) [0x0000000000000000] [0x00000001] 
	int                                                m_nFloorTargeterId;                               		// 0x018C (0x0004) [0x0000000000000002]              ( CPF_Const )
	class ATgSkeletalMeshActor*                        c_SecondaryTargetingModeMeshIndicator;            		// 0x0190 (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                c_SecondaryTargetingModeFx;                       		// 0x0194 (0x0004) [0x0000000000000000]              
	unsigned char                                      c_eSecondaryTargetingModeStatus;                  		// 0x0198 (0x0001) [0x0000000000000000]              
	struct FAimData                                    c_SecondaryTargetingAim;                          		// 0x019C (0x002C) [0x0000000000000000]              
	int                                                c_nSecondaryTargetingModeFxId;                    		// 0x01C8 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2131 );

		return pClassPointer;
	};

	void eventExitTargetingMode ( );
	void UpdateSecondaryTargetingModeLocation ( struct FVector NewLocation, struct FRotator NewRotation, float DistanceScale );
	void UpdateSecondaryTargetingModeStatus ( unsigned char Status, struct FAimData* Aim );
	void InitializeTargetingModeFX ( );
};

UClass* UTgDeviceForm_AutoPortal::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_Awilix_BasicAttack
// 0x0004 (0x018C - 0x0188)
class UTgDeviceForm_Awilix_BasicAttack : public UTgDeviceForm
{
public:
	int                                                m_nAOEMode;                                       		// 0x0188 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2132 );

		return pClassPointer;
	};

	void UpdateTargetingModeStatus ( unsigned char Status, struct FAimData* Aim );
	bool UsesTargetingMode ( );
};

UClass* UTgDeviceForm_Awilix_BasicAttack::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_Beam
// 0x0010 (0x0198 - 0x0188)
class UTgDeviceForm_Beam : public UTgDeviceForm
{
public:
	struct FName                                       c_nmContinuousFire;                               		// 0x0188 (0x0008) [0x0000000000000000]              
	struct FName                                       c_nmContinuousHit;                                		// 0x0190 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2133 );

		return pClassPointer;
	};

	void eventStopFire ( int nFireModeNum );
	void eventStartFire ( int nFireMode, float fRefireTime, class AActor* Target );
	void eventStopContinuousHitFx ( );
	void eventUpdateContinuousHitFx ( struct FVector HitLocation );
	void eventUpdateContinuousFireFx ( struct FVector HitLocation );
	void DetachDevice_DA ( class USkeletalMeshComponent* ParentMesh, class UMeshComponent* AttachedMesh );
};

UClass* UTgDeviceForm_Beam::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_DeathGaze
// 0x0000 (0x0198 - 0x0198)
class UTgDeviceForm_DeathGaze : public UTgDeviceForm_Beam
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2134 );

		return pClassPointer;
	};

};

UClass* UTgDeviceForm_DeathGaze::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_LockOnBeam
// 0x0000 (0x0198 - 0x0198)
class UTgDeviceForm_LockOnBeam : public UTgDeviceForm_Beam
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2135 );

		return pClassPointer;
	};

	void eventStartFire ( int nFireMode, float fRefireTime, class AActor* Target );
	void eventUpdateContinuousFireTarget ( );
	void eventUpdateContinuousFireFx ( struct FVector HitLocation );
};

UClass* UTgDeviceForm_LockOnBeam::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_Deployable
// 0x0008 (0x0190 - 0x0188)
class UTgDeviceForm_Deployable : public UTgDeviceForm
{
public:
	class UTgAnimNodeBlendList*                        m_ValidPlacementBlendNode;                        		// 0x0188 (0x0004) [0x0000000000000000]              
	class UAnimNodeSequence*                           m_PutawayAnimNode;                                		// 0x018C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2136 );

		return pClassPointer;
	};

	void eventNotifyExitTargetingMode ( unsigned long bDeployed );
	void eventNotifyTargetingModeStatusChange ( );
};

UClass* UTgDeviceForm_Deployable::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_Fenrir_DoubleLeap
// 0x0008 (0x0190 - 0x0188)
class UTgDeviceForm_Fenrir_DoubleLeap : public UTgDeviceForm
{
public:
	int                                                c_nBoundingRingFxID;                              		// 0x0188 (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                c_BoundingRingFx;                                 		// 0x018C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2137 );

		return pClassPointer;
	};

	void eventExitTargetingMode ( );
	void eventTurnOffBoundingRing ( );
	void TurnOnBoundingRing ( );
	void InitializeTargetingModeFX ( );
};

UClass* UTgDeviceForm_Fenrir_DoubleLeap::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_G72_Dev2
// 0x000C (0x0194 - 0x0188)
class UTgDeviceForm_G72_Dev2 : public UTgDeviceForm
{
public:
	class UTgSpecialFx*                                c_RefireFx;                                       		// 0x0188 (0x0004) [0x0000000000000000]              
	class ATgSkeletalMeshActor*                        c_RefireFxMesh;                                   		// 0x018C (0x0004) [0x0000000000000000]              
	int                                                m_nRefireFxId;                                    		// 0x0190 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2138 );

		return pClassPointer;
	};

	void DisableRefireFX ( );
	void ActivateRefireFX ( );
};

UClass* UTgDeviceForm_G72_Dev2::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_GodTargeter
// 0x0000 (0x0188 - 0x0188)
class UTgDeviceForm_GodTargeter : public UTgDeviceForm
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2139 );

		return pClassPointer;
	};

	void eventNotifyEnterTargetingMode ( );
	void eventNotifyExitTargetingMode ( unsigned long bDeployed );
	void eventNotifyTargetingModeStatusChange ( );
	bool UsesTargetingMode ( );
};

UClass* UTgDeviceForm_GodTargeter::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_Izanami_InvisibleEscape
// 0x0004 (0x018C - 0x0188)
class UTgDeviceForm_Izanami_InvisibleEscape : public UTgDeviceForm
{
public:
	float                                              c_fCurrBuildupTime;                               		// 0x0188 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2140 );

		return pClassPointer;
	};

};

UClass* UTgDeviceForm_Izanami_InvisibleEscape::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_Kumbhakarna_Num3
// 0x0000 (0x0188 - 0x0188)
class UTgDeviceForm_Kumbhakarna_Num3 : public UTgDeviceForm
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2141 );

		return pClassPointer;
	};

	void InitializeTargetingModeFX ( );
};

UClass* UTgDeviceForm_Kumbhakarna_Num3::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_LimitedGroundTarget
// 0x0008 (0x0190 - 0x0188)
class UTgDeviceForm_LimitedGroundTarget : public UTgDeviceForm
{
public:
	class ATgSkeletalMeshActor*                        c_LimitedTargetingModeMeshIndicator;              		// 0x0188 (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                c_LimitedTargetingModeFx;                         		// 0x018C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2142 );

		return pClassPointer;
	};

	void eventExitTargetingMode ( );
	void InitializeTargetingModeFX ( );
	void UpdateLimitedTargetingModeLocation ( struct FVector NewLocation, struct FRotator NewRotation, float DistanceScale );
};

UClass* UTgDeviceForm_LimitedGroundTarget::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_LineCone
// 0x0008 (0x0190 - 0x0188)
class UTgDeviceForm_LineCone : public UTgDeviceForm
{
public:
	class UTgSpecialFx*                                c_ConeTargetModeFx;                               		// 0x0188 (0x0004) [0x0000000000000000]              
	int                                                c_nConeTargetFxId;                                		// 0x018C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2143 );

		return pClassPointer;
	};

	void eventExitTargetingMode ( );
	void eventEnterTargetingMode ( );
	void UpdateConeTargetModeLocation ( float TranslationX, float TranslationY );
	void UpdateTargetingModeStatus ( unsigned char Status, struct FAimData* Aim );
	void InitializeTargetingModeFX ( );
};

UClass* UTgDeviceForm_LineCone::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_AhPuch_Dev1
// 0x0000 (0x0190 - 0x0190)
class UTgDeviceForm_AhPuch_Dev1 : public UTgDeviceForm_LineCone
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2144 );

		return pClassPointer;
	};

	void InitializeTargetingModeFX ( );
};

UClass* UTgDeviceForm_AhPuch_Dev1::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_Chiron_UltimateShooter
// 0x0000 (0x0190 - 0x0190)
class UTgDeviceForm_Chiron_UltimateShooter : public UTgDeviceForm_LineCone
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2145 );

		return pClassPointer;
	};

	void UpdateTargetingModeLocation ( struct FVector NewLocation, struct FRotator NewRotation, float DistanceScale );
};

UClass* UTgDeviceForm_Chiron_UltimateShooter::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_Mercury_Num4Shooter
// 0x0000 (0x0190 - 0x0190)
class UTgDeviceForm_Mercury_Num4Shooter : public UTgDeviceForm_LineCone
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2146 );

		return pClassPointer;
	};

	void UpdateTargetingModeLocation ( struct FVector NewLocation, struct FRotator NewRotation, float DistanceScale );
};

UClass* UTgDeviceForm_Mercury_Num4Shooter::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_XingTian_HeroicCharge
// 0x0000 (0x0190 - 0x0190)
class UTgDeviceForm_XingTian_HeroicCharge : public UTgDeviceForm_LineCone
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2147 );

		return pClassPointer;
	};

	void UpdateConeTargetModeLocation ( float TranslationX, float TranslationY );
};

UClass* UTgDeviceForm_XingTian_HeroicCharge::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_Medusa_Inhand
// 0x000C (0x0194 - 0x0188)
class UTgDeviceForm_Medusa_Inhand : public UTgDeviceForm
{
public:
	class ATgSkeletalMeshActor*                        c_TargetingModeMeshIndicatorB;                    		// 0x0188 (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                c_TargetingModeFxB;                               		// 0x018C (0x0004) [0x0000000000000000]              
	int                                                m_TargetingModeFxIdB;                             		// 0x0190 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2148 );

		return pClassPointer;
	};

	void eventExitTargetingMode ( );
	bool UsesTargetingMode ( );
	void UpdateTargetingModeLocation ( struct FVector NewLocation, struct FRotator NewRotation, float DistanceScale );
	void UpdateTargetingModeStatus ( unsigned char Status, struct FAimData* Aim );
	void InitializeTargetingModeFX ( );
};

UClass* UTgDeviceForm_Medusa_Inhand::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_MultipleTargetIndicator
// 0x0018 (0x01A0 - 0x0188)
class UTgDeviceForm_MultipleTargetIndicator : public UTgDeviceForm
{
public:
	int                                                c_nTargetFxID;                                    		// 0x0188 (0x0004) [0x0000000000000000]              
	struct FName                                       c_TargetSocketName;                               		// 0x018C (0x0008) [0x0000000000000000]              
	TArray< struct FFormTargetingInfo >                c_TargetingInfos;                                 		// 0x0194 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2149 );

		return pClassPointer;
	};

	void eventExitTargetingMode ( );
	void ClearTargetingInfos ( );
	void UpdateTargetingList ( TArray< struct FImpactInfo >* ImpactList );
};

UClass* UTgDeviceForm_MultipleTargetIndicator::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_HandOfTheGods
// 0x0010 (0x01B0 - 0x01A0)
class UTgDeviceForm_HandOfTheGods : public UTgDeviceForm_MultipleTargetIndicator
{
public:
	int                                                m_nHandOfGodsMeshAsmId;                           		// 0x01A0 (0x0004) [0x0000000000000000]              
	int                                                m_nHandOfGodsFxId;                                		// 0x01A4 (0x0004) [0x0000000000000000]              
	struct FName                                       m_nmHandOfGodsSocketName;                         		// 0x01A8 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2150 );

		return pClassPointer;
	};

	void eventHit ( int nFireMode, class ATgPawn* TargetPawn );
	void PlayHandOfGod ( class ATgPawn* TargetPawn );
};

UClass* UTgDeviceForm_HandOfTheGods::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_Neith_SpiritArrow
// 0x0028 (0x01B0 - 0x0188)
class UTgDeviceForm_Neith_SpiritArrow : public UTgDeviceForm
{
public:
	TArray< class AActor* >                            c_SelectedBrokenWeaves;                           		// 0x0188 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UTgSpecialFx* >                      c_WeaveRangeFxList;                               		// 0x0194 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FName                                       c_nmRangeFxSocketName;                            		// 0x01A0 (0x0008) [0x0000000000000000]              
	unsigned long                                      c_bUseWeaveRangeFx : 1;                           		// 0x01A8 (0x0004) [0x0000000000000000] [0x00000001] 
	int                                                c_nWeaveRangeFxID;                                		// 0x01AC (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2151 );

		return pClassPointer;
	};

	void eventExitTargetingMode ( );
	void eventNotifyTargetingModeStatusChange ( );
	void eventNotifyEnterTargetingMode ( );
	void eventNotifyExitTargetingMode ( unsigned long bDeployed );
};

UClass* UTgDeviceForm_Neith_SpiritArrow::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_Neith_WorldWeaver
// 0x0000 (0x01B0 - 0x01B0)
class UTgDeviceForm_Neith_WorldWeaver : public UTgDeviceForm_Neith_SpiritArrow
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2152 );

		return pClassPointer;
	};

	void eventSetTargetingModeFXToForeground ( );
	void InitializeTargetingModeFX ( );
};

UClass* UTgDeviceForm_Neith_WorldWeaver::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_Nemesis_Num2
// 0x0010 (0x0198 - 0x0188)
class UTgDeviceForm_Nemesis_Num2 : public UTgDeviceForm
{
public:
	TArray< class UTgSpecialFx* >                      c_Num2TargetFx;                                   		// 0x0188 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                c_Num2TargetFxId;                                 		// 0x0194 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2153 );

		return pClassPointer;
	};

	void eventExitTargetingMode ( );
	void UpdateTargetingList ( TArray< struct FImpactInfo >* ImpactList );
};

UClass* UTgDeviceForm_Nemesis_Num2::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_NeZha_Reincarnate
// 0x0000 (0x0188 - 0x0188)
class UTgDeviceForm_NeZha_Reincarnate : public UTgDeviceForm
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2154 );

		return pClassPointer;
	};

};

UClass* UTgDeviceForm_NeZha_Reincarnate::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_NuWa_ClaySoldiers
// 0x000C (0x0194 - 0x0188)
class UTgDeviceForm_NuWa_ClaySoldiers : public UTgDeviceForm
{
public:
	TArray< int >                                      m_nTargeterFXIds;                                 		// 0x0188 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2155 );

		return pClassPointer;
	};

	void SetFireMode ( int nMode );
};

UClass* UTgDeviceForm_NuWa_ClaySoldiers::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_NuWa_Fireball
// 0x0000 (0x0188 - 0x0188)
class UTgDeviceForm_NuWa_Fireball : public UTgDeviceForm
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2156 );

		return pClassPointer;
	};

	void UpdateTargetingModeLocation ( struct FVector NewLocation, struct FRotator NewRotation, float DistanceScale );
};

UClass* UTgDeviceForm_NuWa_Fireball::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_OverlaySelect
// 0x0020 (0x01A8 - 0x0188)
class UTgDeviceForm_OverlaySelect : public UTgDeviceForm
{
public:
	int                                                c_nLastOverlaySelect;                             		// 0x0188 (0x0004) [0x0000000000000000]              
	int                                                c_nOverlaySelect;                                 		// 0x018C (0x0004) [0x0000000000000000]              
	TArray< int >                                      c_nOverlayFxIds;                                  		// 0x0190 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UTgSpecialFx* >                      c_OverlayFx;                                      		// 0x019C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2157 );

		return pClassPointer;
	};

	void eventEnableOverlayFx ( );
	void eventSetOverlayFx ( int nOverlaySelect );
	void eventDisableOverlayFx ( );
	void eventExitTargetingMode ( );
	void eventEnterTargetingMode ( );
	void UpdateTargetingModeStatus ( unsigned char Status, struct FAimData* Aim );
	void InitializeTargetingModeFX ( );
};

UClass* UTgDeviceForm_OverlaySelect::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_Raijin_Ultimate
// 0x0000 (0x01A8 - 0x01A8)
class UTgDeviceForm_Raijin_Ultimate : public UTgDeviceForm_OverlaySelect
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2158 );

		return pClassPointer;
	};

};

UClass* UTgDeviceForm_Raijin_Ultimate::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_RadialSweep
// 0x000C (0x0194 - 0x0188)
class UTgDeviceForm_RadialSweep : public UTgDeviceForm
{
public:
	int                                                m_nSweepMeshId;                                   		// 0x0188 (0x0004) [0x0000000000000002]              ( CPF_Const )
	class UTgSkeletalMeshComponent*                    c_SweepMeshComponent;                             		// 0x018C (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )
	float                                              m_fMeshRemainTime;                                		// 0x0190 (0x0004) [0x0000000000000002]              ( CPF_Const )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2159 );

		return pClassPointer;
	};

	void eventActuallyEndSweep ( );
	void eventEndRadialSweep ( );
	void eventRadialSweep ( int nYaw, float fDuration );
	void DetachDevice_DA ( class USkeletalMeshComponent* ParentMesh, class UMeshComponent* AttachedMesh );
	void LoadAndPlaySweepMesh ( int nSweepMeshID, int nYaw );
};

UClass* UTgDeviceForm_RadialSweep::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_Chaac_Num2
// 0x0000 (0x0194 - 0x0194)
class UTgDeviceForm_Chaac_Num2 : public UTgDeviceForm_RadialSweep
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2160 );

		return pClassPointer;
	};

	void UpdateTargetingModeLocation ( struct FVector NewLocation, struct FRotator NewRotation, float DistanceScale );
	void InitializeTargetingModeFX ( );
};

UClass* UTgDeviceForm_Chaac_Num2::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_Ram_AstralArrow
// 0x0014 (0x019C - 0x0188)
class UTgDeviceForm_Ram_AstralArrow : public UTgDeviceForm
{
public:
	unsigned long                                      c_bDoNotResetTargetingPulseIndex : 1;             		// 0x0188 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	int                                                c_nTargetingPulseIndex;                           		// 0x018C (0x0004) [0x0000000000000000]              
	TArray< int >                                      c_TargetingFxIds;                                 		// 0x0190 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2161 );

		return pClassPointer;
	};

	void eventExitTargetingMode ( );
	void UpdateTargetingPulseIndex ( int nIndex );
};

UClass* UTgDeviceForm_Ram_AstralArrow::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_Rama_Inhand
// 0x0010 (0x0198 - 0x0188)
class UTgDeviceForm_Rama_Inhand : public UTgDeviceForm
{
public:
	class ATgSkeletalMeshActor*                        c_TargetingModeMeshIndicatorB;                    		// 0x0188 (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                c_TargetingModeFxB;                               		// 0x018C (0x0004) [0x0000000000000000]              
	class ATgSkeletalMeshActor*                        c_TargetingModeMeshIndicatorC;                    		// 0x0190 (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                c_TargetingModeFxC;                               		// 0x0194 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2162 );

		return pClassPointer;
	};

	void eventExitTargetingMode ( );
	bool UsesTargetingMode ( );
	void UpdateTargetingModeLocation ( struct FVector NewLocation, struct FRotator NewRotation, float DistanceScale );
	void UpdateTargetingModeStatus ( unsigned char Status, struct FAimData* Aim );
	void InitializeTargetingModeFX ( );
};

UClass* UTgDeviceForm_Rama_Inhand::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_ShieldedRecall
// 0x0000 (0x0188 - 0x0188)
class UTgDeviceForm_ShieldedRecall : public UTgDeviceForm
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2163 );

		return pClassPointer;
	};

	void eventFire ( struct FVector HitLocation, int nFireMode, int nEquipSlot, int nSocketIndex, unsigned long bSuccessfulHit, float fRefireTime );
	void eventBuildUp ( int nFireMode, int nEquipSlot, int nSocketIndex, float fBuildupTime );
};

UClass* UTgDeviceForm_ShieldedRecall::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_ShieldOfTheUnderWorld
// 0x0008 (0x0190 - 0x0188)
class UTgDeviceForm_ShieldOfTheUnderWorld : public UTgDeviceForm
{
public:
	int                                                c_nReflectHitFxId;                                		// 0x0188 (0x0004) [0x0000000000000000]              
	int                                                c_nReflectTracerFxId;                             		// 0x018C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2164 );

		return pClassPointer;
	};

	class UTgSpecialFx* ActivateFxIndependent ( struct FName nmGroup, unsigned long bSkipActivate, struct FParticleChannelContainer PSysChannels );
};

UClass* UTgDeviceForm_ShieldOfTheUnderWorld::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_Skadi_Dev3
// 0x0000 (0x0188 - 0x0188)
class UTgDeviceForm_Skadi_Dev3 : public UTgDeviceForm
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2165 );

		return pClassPointer;
	};

	void InitializeTargetingModeFX ( );
};

UClass* UTgDeviceForm_Skadi_Dev3::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_SplineTarget
// 0x0034 (0x01BC - 0x0188)
class UTgDeviceForm_SplineTarget : public UTgDeviceForm
{
public:
	int                                                m_NumSplines;                                     		// 0x0188 (0x0004) [0x0000000000000000]              
	int                                                m_SplineMeshId;                                   		// 0x018C (0x0004) [0x0000000000000000]              
	int                                                m_SplineMeshStartId;                              		// 0x0190 (0x0004) [0x0000000000000000]              
	int                                                m_SplineMeshEndId;                                		// 0x0194 (0x0004) [0x0000000000000000]              
	int                                                m_nNumSplineActorSections;                        		// 0x0198 (0x0004) [0x0000000000000002]              ( CPF_Const )
	TArray< struct FSplineContainer >                  m_SplineData;                                     		// 0x019C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class UStaticMesh*                                 m_DeformMesh;                                     		// 0x01A8 (0x0004) [0x0000000000000000]              
	class UStaticMesh*                                 m_DeformMeshStart;                                		// 0x01AC (0x0004) [0x0000000000000000]              
	class UStaticMesh*                                 m_DeformMeshEnd;                                  		// 0x01B0 (0x0004) [0x0000000000000000]              
	class UClass*                                      m_DefaultSplineActorClass;                        		// 0x01B4 (0x0004) [0x0000000000000000]              
	class UClass*                                      m_LinearSplineActorClass;                         		// 0x01B8 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2166 );

		return pClassPointer;
	};

	void eventExitTargetingMode ( );
	void eventEnterTargetingMode ( );
	void DestroySplines ( );
	void CreateSplines ( );
	void SetSplineLength ( int nSplineIndex, int nLength );
	int SetupSplineActors ( int nSplineIndex, int nLength );
	void UpdateTargetingModeSplines ( class UTgSplineDeviceInterface* SplineDev, struct FAimData Aim );
	void UpdateTargetingModeStatus ( unsigned char Status, struct FAimData* Aim );
	bool UsesTargetingMode ( );
};

UClass* UTgDeviceForm_SplineTarget::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_Kali_Lash
// 0x0008 (0x01C4 - 0x01BC)
class UTgDeviceForm_Kali_Lash : public UTgDeviceForm_SplineTarget
{
public:
	class ATgSkeletalMeshActor*                        c_TargetingModeMeshIndicatorB;                    		// 0x01BC (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                c_TargetingModeFxB;                               		// 0x01C0 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2167 );

		return pClassPointer;
	};

	void eventExitTargetingMode ( );
	void UpdateTargetingModeLocation ( struct FVector NewLocation, struct FRotator NewRotation, float DistanceScale );
	void UpdateTargetingModeStatus ( unsigned char Status, struct FAimData* Aim );
	void InitializeTargetingModeFX ( );
};

UClass* UTgDeviceForm_Kali_Lash::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_SunWukong_Transform
// 0x0014 (0x019C - 0x0188)
class UTgDeviceForm_SunWukong_Transform : public UTgDeviceForm
{
public:
	class ATgSkeletalMeshActor*                        c_TargetingModeMeshIndicatorLine;                 		// 0x0188 (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                c_TargetingModeFxLine;                            		// 0x018C (0x0004) [0x0000000000000000]              
	int                                                c_nTargetingModeFxLineId;                         		// 0x0190 (0x0004) [0x0000000000000000]              
	unsigned long                                      c_bShouldScaleLineTargeter : 1;                   		// 0x0194 (0x0004) [0x0000000000000000] [0x00000001] 
	float                                              c_fWeaponRange;                                   		// 0x0198 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2168 );

		return pClassPointer;
	};

	void eventExitTargetingMode ( );
	void UpdateTargetingModeStatus ( unsigned char Status, struct FAimData* Aim );
	void InitializeTargetingModeFX ( );
};

UClass* UTgDeviceForm_SunWukong_Transform::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_ErlangShen_Transform
// 0x0000 (0x019C - 0x019C)
class UTgDeviceForm_ErlangShen_Transform : public UTgDeviceForm_SunWukong_Transform
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2169 );

		return pClassPointer;
	};

};

UClass* UTgDeviceForm_ErlangShen_Transform::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_SunWukong_MastersWill
// 0x0000 (0x019C - 0x019C)
class UTgDeviceForm_SunWukong_MastersWill : public UTgDeviceForm_SunWukong_Transform
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2170 );

		return pClassPointer;
	};

};

UClass* UTgDeviceForm_SunWukong_MastersWill::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_Sylvanus_Auto
// 0x0000 (0x0188 - 0x0188)
class UTgDeviceForm_Sylvanus_Auto : public UTgDeviceForm
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2171 );

		return pClassPointer;
	};

	void UpdateTargetingModeLocation ( struct FVector NewLocation, struct FRotator NewRotation, float DistanceScale );
};

UClass* UTgDeviceForm_Sylvanus_Auto::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_TargetIndicator
// 0x0010 (0x0198 - 0x0188)
class UTgDeviceForm_TargetIndicator : public UTgDeviceForm
{
public:
	int                                                c_nTargetFxID;                                    		// 0x0188 (0x0004) [0x0000000000000000]              
	struct FName                                       c_TargetSocketName;                               		// 0x018C (0x0008) [0x0000000000000000]              
	class UTgSpecialFx*                                c_TargetFx;                                       		// 0x0194 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2172 );

		return pClassPointer;
	};

	void eventExitTargetingMode ( );
	void UpdateTargetingModeStatus ( unsigned char Status, struct FAimData* Aim );
	void InitializeTargetingModeFX ( );
};

UClass* UTgDeviceForm_TargetIndicator::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_AoKuang_NewUltimate
// 0x0000 (0x0198 - 0x0198)
class UTgDeviceForm_AoKuang_NewUltimate : public UTgDeviceForm_TargetIndicator
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2173 );

		return pClassPointer;
	};

	void UpdateTargetingModeLocation ( struct FVector NewLocation, struct FRotator NewRotation, float DistanceScale );
};

UClass* UTgDeviceForm_AoKuang_NewUltimate::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_Arachne_Attach
// 0x0000 (0x0198 - 0x0198)
class UTgDeviceForm_Arachne_Attach : public UTgDeviceForm_TargetIndicator
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2174 );

		return pClassPointer;
	};

	void InitializeTargetingModeFX ( );
};

UClass* UTgDeviceForm_Arachne_Attach::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_Mercury_Num1
// 0x0000 (0x0198 - 0x0198)
class UTgDeviceForm_Mercury_Num1 : public UTgDeviceForm_TargetIndicator
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2175 );

		return pClassPointer;
	};

	void InitializeTargetingModeFX ( );
};

UClass* UTgDeviceForm_Mercury_Num1::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_Terra_BasicAttack
// 0x0004 (0x018C - 0x0188)
class UTgDeviceForm_Terra_BasicAttack : public UTgDeviceForm
{
public:
	unsigned long                                      m_ShowSpecialTargeter : 1;                        		// 0x0188 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2176 );

		return pClassPointer;
	};

	bool UsesTargetingMode ( );
};

UClass* UTgDeviceForm_Terra_BasicAttack::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_Terra_MegaPunch
// 0x0014 (0x019C - 0x0188)
class UTgDeviceForm_Terra_MegaPunch : public UTgDeviceForm
{
public:
	class UTgSpecialFx*                                c_CrushingShaleShatterFx[ 0x2 ];                  		// 0x0188 (0x0008) [0x0000000000000000]              
	class UTgSpecialFx*                                c_ObeliskShatterFx;                               		// 0x0190 (0x0004) [0x0000000000000000]              
	int                                                c_CrushingShaleShatterFxId;                       		// 0x0194 (0x0004) [0x0000000000000000]              
	int                                                c_ObeliskShatterFxId;                             		// 0x0198 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2177 );

		return pClassPointer;
	};

	void eventExitTargetingMode ( );
	void eventEnterTargetingMode ( );
	void UpdateTargetingList ( TArray< struct FImpactInfo >* ImpactList );
	void InitializeTargetingModeFX ( );
};

UClass* UTgDeviceForm_Terra_MegaPunch::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_Thor_HammerJump
// 0x0004 (0x018C - 0x0188)
class UTgDeviceForm_Thor_HammerJump : public UTgDeviceForm
{
public:
	unsigned long                                      m_bHasAdjustedCamera : 1;                         		// 0x0188 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2178 );

		return pClassPointer;
	};

	void eventNotifyExitTargetingMode ( unsigned long bDeployed );
	void eventBuildUp ( int nFireMode, int nEquipSlot, int nSocketIndex, float fBuildupTime );
	void eventNotifyEnterTargetingMode ( );
};

UClass* UTgDeviceForm_Thor_HammerJump::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_Thoth_Dash
// 0x0010 (0x0198 - 0x0188)
class UTgDeviceForm_Thoth_Dash : public UTgDeviceForm
{
public:
	unsigned char                                      m_TargetMode;                                     		// 0x0188 (0x0001) [0x0000000000000000]              
	int                                                m_NormalDashFxId;                                 		// 0x018C (0x0004) [0x0000000000000000]              
	int                                                m_BonusDashFxId;                                  		// 0x0190 (0x0004) [0x0000000000000000]              
	int                                                m_NoDashFxId;                                     		// 0x0194 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2179 );

		return pClassPointer;
	};

	void eventSetDashTargetMode ( unsigned char Mode );
};

UClass* UTgDeviceForm_Thoth_Dash::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_TwoPhase
// 0x0010 (0x0198 - 0x0188)
class UTgDeviceForm_TwoPhase : public UTgDeviceForm
{
public:
	unsigned long                                      m_bInSecondaryTargetMode : 1;                     		// 0x0188 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned char                                      m_ePrimaryTargetMode;                             		// 0x018C (0x0001) [0x0000000000000000]              
	unsigned char                                      m_eSecondaryTargetMode;                           		// 0x018D (0x0001) [0x0000000000000000]              
	int                                                m_nPrimaryTargetingFxId;                          		// 0x0190 (0x0004) [0x0000000000000000]              
	int                                                m_nSecondaryTargetingFxId;                        		// 0x0194 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2180 );

		return pClassPointer;
	};

	void eventToggleSecondaryTargetMode ( unsigned long bOn );
};

UClass* UTgDeviceForm_TwoPhase::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_JingWei_Dev3
// 0x0000 (0x0198 - 0x0198)
class UTgDeviceForm_JingWei_Dev3 : public UTgDeviceForm_TwoPhase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2181 );

		return pClassPointer;
	};

	void UpdateAerialTargetModeLocation ( float TranslationZ );
};

UClass* UTgDeviceForm_JingWei_Dev3::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_WorldMapTarget
// 0x0000 (0x0188 - 0x0188)
class UTgDeviceForm_WorldMapTarget : public UTgDeviceForm
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2182 );

		return pClassPointer;
	};

	void eventNotifyEnterTargetingMode ( );
	void eventNotifyExitTargetingMode ( unsigned long bDeployed );
	void eventNotifyTargetingModeStatusChange ( );
	bool UsesTargetingMode ( );
};

UClass* UTgDeviceForm_WorldMapTarget::pClassPointer = NULL;

// Class TgGame.TgSplineDeviceInterface
// 0x0000 (0x003C - 0x003C)
class UTgSplineDeviceInterface : public UInterface
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2183 );

		return pClassPointer;
	};

	void eventGetAdjustedAimSpline ( int nShotIndex, struct FAimData* Aim );
	bool CalculateFlightPath ( int nIndex, class UTgDeviceFire* DeviceMode, struct FInterpCurveVector* Spline, struct FAimData* Aim );
};

UClass* UTgSplineDeviceInterface::pClassPointer = NULL;

// Class TgGame.TgSplineDeviceModeInterface
// 0x0000 (0x003C - 0x003C)
class UTgSplineDeviceModeInterface : public UInterface
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2184 );

		return pClassPointer;
	};

	struct FImpactInfo CalcSplineFire ( class AActor* DamageInstigator, unsigned long bUseProximityDistance, unsigned long bPredicting, struct FInterpCurveVector* Spline, TArray< struct FImpactInfo >* ImpactList );
};

UClass* UTgSplineDeviceModeInterface::pClassPointer = NULL;

// Class TgGame.TgCollisionProxy_AthenaShieldWall
// 0x0000 (0x0218 - 0x0218)
class ATgCollisionProxy_AthenaShieldWall : public ATgCollisionProxy
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2185 );

		return pClassPointer;
	};

};

UClass* ATgCollisionProxy_AthenaShieldWall::pClassPointer = NULL;

// Class TgGame.TgDeployable
// 0x0104 (0x02F4 - 0x01F0)
class ATgDeployable : public AActor
{
public:
	int                                                r_nDeployableId;                                  		// 0x01F0 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                c_nSavedSkinId;                                   		// 0x01F4 (0x0004) [0x0000000000000000]              
	int                                                c_nSavedSkinLevel;                                		// 0x01F8 (0x0004) [0x0000000000000000]              
	int                                                r_nSkinId;                                        		// 0x01FC (0x0004) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      r_nSkinLevel;                                     		// 0x0200 (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      r_nFlashCount;                                    		// 0x0201 (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      r_nFlashFireCount;                                		// 0x0202 (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      c_nPreviousFlashFireCount;                        		// 0x0203 (0x0001) [0x0000000000000000]              
	unsigned char                                      s_nFiringInstance;                                		// 0x0204 (0x0001) [0x0000000000000000]              
	unsigned long                                      c_bInitialized : 1;                               		// 0x0208 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bConsumedOnFire : 1;                            		// 0x0208 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_bFireOnDeploy : 1;                              		// 0x0208 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_bHasAlreadyFiredOnce : 1;                       		// 0x0208 (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      m_bInstantFire : 1;                               		// 0x0208 (0x0004) [0x0000000000000000] [0x00000010] 
	unsigned long                                      c_bMinimapOnlyOwnerSee : 1;                       		// 0x0208 (0x0004) [0x0000000000000000] [0x00000020] 
	unsigned long                                      r_bTakeDamage : 1;                                		// 0x0208 (0x0004) [0x0000000000000020] [0x00000040] ( CPF_Net )
	unsigned long                                      m_bInDestroyedState : 1;                          		// 0x0208 (0x0004) [0x0000000000000000] [0x00000080] 
	unsigned long                                      s_bDestroyedThisTick : 1;                         		// 0x0208 (0x0004) [0x0000000000000000] [0x00000100] 
	unsigned long                                      m_bIsDeployed : 1;                                		// 0x0208 (0x0004) [0x0000000000000000] [0x00000200] 
	unsigned long                                      c_bEnemyMatLoaded : 1;                            		// 0x0208 (0x0004) [0x0000000000000000] [0x00000400] 
	unsigned long                                      m_bDestroyOnOwnerDeathFlag : 1;                   		// 0x0208 (0x0004) [0x0000000000000000] [0x00000800] 
	unsigned long                                      m_bAdjustMeshToGround : 1;                        		// 0x0208 (0x0004) [0x0000000000000000] [0x00001000] 
	unsigned long                                      m_bDisableHudInfo : 1;                            		// 0x0208 (0x0004) [0x0000000000000000] [0x00002000] 
	unsigned long                                      c_bTargeted : 1;                                  		// 0x0208 (0x0004) [0x0000000000000000] [0x00004000] 
	unsigned long                                      m_bOverrideTargetComponentHeight : 1;             		// 0x0208 (0x0004) [0x0000000000000001] [0x00008000] ( CPF_Edit )
	unsigned long                                      r_bInitialIsEnemy : 1;                            		// 0x0208 (0x0004) [0x0000000000000020] [0x00010000] ( CPF_Net )
	unsigned long                                      c_bIsSpectateToggleActive : 1;                    		// 0x0208 (0x0004) [0x0000000000002000] [0x00020000] ( CPF_Transient )
	int                                                m_nDeployableType;                                		// 0x020C (0x0004) [0x0000000000000000]              
	int                                                r_nPhysicalType;                                  		// 0x0210 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nHealth;                                        		// 0x0214 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgEffectManager*                            r_EffectManager;                                  		// 0x0218 (0x0004) [0x0000000000000020]              ( CPF_Net )
	TArray< class UTgEffectGroup* >                    m_EquipEffects;                                   		// 0x021C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UTgProperty* >                       s_Properties;                                     		// 0x0228 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FName                                       c_nmName;                                         		// 0x0234 (0x0008) [0x0000000000000000]              
	class UTgDeviceForm*                               c_Form;                                           		// 0x023C (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                c_FireFx;                                         		// 0x0240 (0x0004) [0x0000000000000000]              
	class UMeshComponent*                              c_Mesh;                                           		// 0x0244 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class AActor*                                      m_Target;                                         		// 0x0248 (0x0004) [0x0000000000000000]              
	struct FVector                                     r_vFlashLocation;                                 		// 0x024C (0x000C) [0x0000000000000020]              ( CPF_Net )
	class UTgDeviceFire*                               m_FireMode;                                       		// 0x0258 (0x0004) [0x0000000000000000]              
	int                                                m_FireSkillId;                                    		// 0x025C (0x0004) [0x0000000000000000]              
	float                                              m_fStateTime;                                     		// 0x0260 (0x0004) [0x0000000000000000]              
	int                                                c_nVisibleToLocalPlayer[ 0x2 ];                   		// 0x0264 (0x0008) [0x0000000000000000]              
	class UClass*                                      c_cMinimapOnlyClassSee;                           		// 0x026C (0x0004) [0x0000000000000000]              
	class ATgActorFactory*                             s_DeployFactory;                                  		// 0x0270 (0x0004) [0x0000000000000000]              
	int                                                m_TimeCreated;                                    		// 0x0274 (0x0004) [0x0000000000000000]              
	class UMeshComponent*                              m_DestroyedMesh;                                  		// 0x0278 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	float                                              m_fLifeAfterDeathSecs;                            		// 0x027C (0x0004) [0x0000000000000000]              
	int                                                r_nReplicateDestroyIt;                            		// 0x0280 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              s_fPersistTime;                                   		// 0x0284 (0x0004) [0x0000000000000000]              
	int                                                m_nSensorConfigId;                                		// 0x0288 (0x0004) [0x0000000000000000]              
	class UDynamicLightEnvironmentComponent*           LightEnvironment;                                 		// 0x028C (0x0004) [0x000000000408000A]              ( CPF_Const | CPF_ExportObject | CPF_Component | CPF_EditInline )
	float                                              m_fDefaultDeployAnimLength;                       		// 0x0290 (0x0004) [0x0000000000000000]              
	float                                              r_fTimeToDeploySecs;                              		// 0x0294 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              r_fInitDeployTime;                                		// 0x0298 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              m_fCurrentDeployPercentage;                       		// 0x029C (0x0004) [0x0000000000000000]              
	float                                              r_fDeployRate;                                    		// 0x02A0 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              r_fCurrentDeployTime;                             		// 0x02A4 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              m_fLastDeployedHealth;                            		// 0x02A8 (0x0004) [0x0000000000000000]              
	float                                              m_fDamagedDuringDeploy;                           		// 0x02AC (0x0004) [0x0000000000000000]              
	float                                              m_BaseEyeHeight;                                  		// 0x02B0 (0x0004) [0x0000000000000000]              
	int                                                s_nLootTableId;                                   		// 0x02B4 (0x0004) [0x0000000000000000]              
	class UTgDeviceFire*                               s_SpawnerDeviceMode;                              		// 0x02B8 (0x0004) [0x0000000000000000]              
	class ATgDevice*                                   r_Owner;                                          		// 0x02BC (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nOwnerFireMode;                                 		// 0x02C0 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              AlwaysRelevantDistanceSquared;                    		// 0x02C4 (0x0004) [0x0000000000000000]              
	int                                                r_nCustomParticleSystemFilter;                    		// 0x02C8 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class UTgSpecialFx*                                c_WorldBracketFX;                                 		// 0x02CC (0x0004) [0x0000000000000000]              
	class UCylinderComponent*                          m_TargetComponent;                                		// 0x02D0 (0x0004) [0x0000000004080009]              ( CPF_Edit | CPF_ExportObject | CPF_Component | CPF_EditInline )
	float                                              m_TargetCollisionTraceDistance;                   		// 0x02D4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fOverriddenTargetComponentHeight;               		// 0x02D8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class ATgPawn*                                     m_LastDamager;                                    		// 0x02DC (0x0004) [0x0000000000000000]              
	int                                                m_LastDamagerTimeStamp;                           		// 0x02E0 (0x0004) [0x0000000000000000]              
	class ATgRepInfo_Deployable*                       r_DRI;                                            		// 0x02E4 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class UClass*                                      m_DRIClass;                                       		// 0x02E8 (0x0004) [0x0000000000000000]              
	float                                              m_fDisableSpectatorFxTime;                        		// 0x02EC (0x0004) [0x0000000000000000]              
	float                                              m_fDisableSpectatorFxTimeRemaining;               		// 0x02F0 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2186 );

		return pClassPointer;
	};

	void OnTeleportNotify ( class AActor* TeleportingActor );
	void OnTeleportToBaseNotify ( class AActor* TeleportingActor );
	void eventDeactivateSpectatorFxTimer ( );
	void ToggleSpectateFx ( unsigned long bForceDisable );
	bool IsBoxExtentInRange ( struct FVector BoxCenter, struct FVector BoxExtent );
	void eventInitReplicationInfo ( );
	bool eventCanBeRepaired ( );
	bool eventCanApplyEffects ( );
	struct FString GetDeployableNameById ( int deployableId );
	void eventTakeDamage ( int Damage, class AController* EventInstigator, struct FVector HitLocation, struct FVector Momentum, class UClass* DamageType, struct FTraceHitInfo HitInfo, class AActor* DamageCauser );
	void Destroyed ( );
	void Tick ( float DeltaSeconds );
	float GetFXScaling ( );
	void eventDestroyIt ( unsigned long bSkipFx );
	void eventTornOff ( );
	void eventSpawningDeviceToggledOff ( );
	void eventReplicatedEvent ( struct FName VarName );
	void TickDeploy ( float DeltaSeconds );
	void UpdateTimeToDeploySecs ( float fValue );
	void DeployComplete ( );
	void CalcDeployPercentage ( );
	void OnSetTaskforce ( class UTgSeqAct_SetTaskforce* Action );
	void RefireCheckTimer ( );
	void eventStartDeploy ( );
	void TimeDeviceFiring ( );
	bool IsFiring ( );
	void FlashFireCountUpdated ( );
	void FlashLocationUpdated ( );
	void FlashCountUpdated ( );
	void eventPlayFireFx ( );
	void ClearFlashLocation ( );
	void SetFlashLocation ( struct FVector NewLoc );
	void ClearFlashCount ( );
	void IncrementFlashCount ( );
	void FireAmmunitionDeployable ( );
	struct FVector GetPhysicalFireAimDirection ( struct FVector fireLoc, struct FVector TargetLocation );
	struct FVector GetPhysicalFireStartLoc ( );
	class AProjectile* ProjectileFireDeployable ( );
	void ApplyHit ( TArray< struct FImpactInfo >* ImpactList );
	void InstantFireDeployable ( );
	struct FImpactInfo CalcDeviceFire ( struct FVector StartTrace, struct FVector EndTrace, TArray< struct FImpactInfo >* ImpactList );
	void DeviceFired ( );
	void eventStopFire ( );
	void eventStartFire ( );
	void OnGetTaskForceNumber ( class UTgSeqAct_GetTaskForceNumber* Action );
	void eventApplyEquipEffects ( );
	int eventGetDeployableUniqueId ( );
	void NotifyLocalPlayerTeamReceived ( );
	void eventPostBeginPlay ( );
	struct FVector GetHudOverlayLocation ( );
	bool IsHittableToAI ( );
	bool IsInvisible ( class AActor* TestActor );
	void UpdateHealth ( );
	bool IsFriendlyWithLocalPawn ( );
	int GetSpawnerDeviceId ( );
	int GetFireDeviceSkillId ( );
	int GetSpawnerDeviceInstanceId ( );
	int GetSpawnerDeviceSkillId ( );
	void SetTaskForceNumber ( int nTaskForceId );
	int GetTaskForceNumber ( );
	class ATgRepInfo_TaskForce* GetTaskForce ( );
	void SetInitialHealthPercent ( float fPercent );
	void UpdateDamagers ( class ATgPawn* Damager );
	void UpdateTargetCylinder ( );
	float CalcMeshOffset ( );
	void AdjustMeshToGround ( );
	void RecalculateMaterial ( unsigned long bIsFriendlyWithLocalPawn, unsigned long bForce );
	void ForceRecalculateMaterial ( );
	void NotifyGroupChanged ( );
	int GetMaxDeployHealth ( );
	int GetMaxHealth ( );
	int GetDisplayMaxHealth ( );
	int GetDisplayHealth ( );
	void DeployableDestroyed ( );
	void SwapMeshToDestroyed ( );
	void ResetProperties ( );
	void SetProperty ( int nPropertyId, float fNewValue );
	class UTgProperty* GetProperty ( int nPropertyId );
	void AddProperty ( int nPropId, float fBase, float fRaw, float FMin, float FMax );
	void InitializeDefaultProps ( );
	bool ApplyDeployableSetup ( );
};

UClass* ATgDeployable::pClassPointer = NULL;

// Class TgGame.TgDeploy_AoKuang_Tornadoes
// 0x0018 (0x030C - 0x02F4)
class ATgDeploy_AoKuang_Tornadoes : public ATgDeployable
{
public:
	TArray< class ATgProj_Tornado* >                   m_Tornadoes;                                      		// 0x02F4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class UTgDeviceFire*                               m_TornadoSpawnFiremode;                           		// 0x0300 (0x0004) [0x0000000000000000]              
	float                                              m_fTornadoBlend;                                  		// 0x0304 (0x0004) [0x0000000000000000]              
	float                                              m_fTornadoDuration;                               		// 0x0308 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2187 );

		return pClassPointer;
	};

	void Tick ( float DeltaSeconds );
	class ATgProj_Tornado* GetTornadoFor ( class AActor* Actor );
	void ApplyHit ( TArray< struct FImpactInfo >* ImpactList );
};

UClass* ATgDeploy_AoKuang_Tornadoes::pClassPointer = NULL;

// Class TgGame.TgDeploy_Artillery
// 0x001C (0x0310 - 0x02F4)
class ATgDeploy_Artillery : public ATgDeployable
{
public:
	float                                              s_fTargetRadius;                                  		// 0x02F4 (0x0004) [0x0000000000000000]              
	float                                              s_fStartHeight;                                   		// 0x02F8 (0x0004) [0x0000000000000000]              
	float                                              s_fDeflectionDegrees;                             		// 0x02FC (0x0004) [0x0000000000000000]              
	unsigned char                                      s_eArtilleryType;                                 		// 0x0300 (0x0001) [0x0000000000000000]              
	struct FVector                                     s_fCurrentAimLocation;                            		// 0x0304 (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2188 );

		return pClassPointer;
	};

	struct FVector GetPhysicalFireAimDirection ( struct FVector fireLoc, struct FVector TargetLocation );
	struct FVector GetPhysicalFireStartLoc ( );
	struct FVector CalcAimLocation ( class AActor* Target );
	void FireAmmunitionDeployable ( );
	bool ShouldStartFire ( );
	void DeployComplete ( );
	class ATgPawn* FindEnemyPlayer ( );
	class AActor* FindTarget ( );
};

UClass* ATgDeploy_Artillery::pClassPointer = NULL;

// Class TgGame.TgDeploy_EffectVolume
// 0x001C (0x0310 - 0x02F4)
class ATgDeploy_EffectVolume : public ATgDeployable
{
public:
	TArray< class AActor* >                            s_AppliedList;                                    		// 0x02F4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class AActor* >                            s_HitActors;                                      		// 0x0300 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	unsigned long                                      m_bHitOnce : 1;                                   		// 0x030C (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bApplyHitOnTouch : 1;                           		// 0x030C (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_bApplyHitSpecialOnTouch : 1;                    		// 0x030C (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_bWaitForDeploy : 1;                             		// 0x030C (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      m_bApplyHitInitialOnDeploy : 1;                   		// 0x030C (0x0004) [0x0000000000000000] [0x00000010] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2189 );

		return pClassPointer;
	};

	void DeployComplete ( );
	void FireAmmunitionDeployable ( );
	void Cleanup ( );
	void eventDestroyed ( );
	void eventDestroyIt ( unsigned long bSkipFx );
	void eventHandleUnTouch ( class AActor* Other );
	void eventUnTouch ( class AActor* Other );
	bool ShouldHitOnlyOnce ( class AActor* Other );
	void eventHandleTouch ( class AActor* Other );
	void eventTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void FindTouchingActorsFromScript ( );
};

UClass* ATgDeploy_EffectVolume::pClassPointer = NULL;

// Class TgGame.TgDeploy_AutoPortal
// 0x0088 (0x0398 - 0x0310)
class ATgDeploy_AutoPortal : public ATgDeploy_EffectVolume
{
public:
	class ATgDeploy_AutoPortal*                        r_Twin;                                           		// 0x0310 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgRepInfo_Deployable*                       r_TwinDRI;                                        		// 0x0314 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                m_nLinkBeamFxId;                                  		// 0x0318 (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                c_LinkBeamFx;                                     		// 0x031C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              c_LinkBeamOffsetZ;                                		// 0x0320 (0x0004) [0x0000000000000000]              
	float                                              c_fVisibilityCacheTime;                           		// 0x0324 (0x0004) [0x0000000000000000]              
	class APlayerController*                           c_CachedLocalPC;                                  		// 0x0328 (0x0004) [0x0000000000000000]              
	unsigned long                                      c_bCachedVisibility : 1;                          		// 0x032C (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bKillAfterUse : 1;                              		// 0x032C (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_bUsedOnce : 1;                                  		// 0x032C (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned char                                      m_ePortalTweenState;                              		// 0x0330 (0x0001) [0x0000000000000000]              
	TArray< struct FPortalExcludeInfo >                s_TemporaryCannotTeleport;                        		// 0x0334 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	float                                              m_fCannotTeleportTime;                            		// 0x0340 (0x0004) [0x0000000000000000]              
	TArray< struct FPortalPermanentExcludeInfo >       s_PermanentCannotTeleport;                        		// 0x0344 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                m_nMaxTeleportsPerTarget;                         		// 0x0350 (0x0004) [0x0000000000000000]              
	int                                                s_nTotalTeleportUses;                             		// 0x0354 (0x0004) [0x0000000000000000]              
	int                                                m_nMaxTeleportUses;                               		// 0x0358 (0x0004) [0x0000000000000000]              
	TArray< class AActor* >                            s_HitOnNextTouch;                                 		// 0x035C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class AActor* >                            s_MustUnTouch;                                    		// 0x0368 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	float                                              m_fTeleportSpeed;                                 		// 0x0374 (0x0004) [0x0000000000000000]              
	float                                              m_fMinimumTravelTime;                             		// 0x0378 (0x0004) [0x0000000000000000]              
	float                                              m_fMinKillDelay;                                  		// 0x037C (0x0004) [0x0000000000000000]              
	class UMeshComponent*                              m_OverlayMesh;                                    		// 0x0380 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	int                                                m_nOverlayMICId;                                  		// 0x0384 (0x0004) [0x0000000000000000]              
	int                                                m_nOverLayMICEnemyId;                             		// 0x0388 (0x0004) [0x0000000000000000]              
	class UMaterialInstanceConstant*                   m_OverlayMIC;                                     		// 0x038C (0x0004) [0x0000000000000000]              
	class UMaterialInstanceConstant*                   m_OverlayMICEnemy;                                		// 0x0390 (0x0004) [0x0000000000000000]              
	float                                              m_fForceOverlayDistance;                          		// 0x0394 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2190 );

		return pClassPointer;
	};

	void eventDestroyed ( );
	void eventDestroyIt ( unsigned long bSkipFx );
	void CleanUpLinkFx ( );
	void AddCannotTeleportEntry ( class AActor* Target );
	float eventTeleportAction ( class AActor* Target, struct FVector EndPoint );
	void eventTeleport ( class AActor* Target );
	bool eventCanTeleport ( class AActor* Target, unsigned long bCheckPet );
	void eventHandleUnTouch ( class AActor* Other );
	void eventHandleTouch ( class AActor* Other );
	void eventSetTwin ( class ATgDeploy_AutoPortal* twin );
	void eventReplicatedEvent ( struct FName VarName );
	bool FindTeleportLocation ( class AActor* TeleportingActor, struct FVector* TeleportLocation );
	void RecalculateMaterial ( unsigned long bIsFriendlyWithLocalPawn, unsigned long bForce );
	void InitializeLinkBeamFx ( );
};

UClass* ATgDeploy_AutoPortal::pClassPointer = NULL;

// Class TgGame.TgDeployable_Janus_WallPortal
// 0x0000 (0x0398 - 0x0398)
class ATgDeployable_Janus_WallPortal : public ATgDeploy_AutoPortal
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2191 );

		return pClassPointer;
	};

	void eventDestroyed ( );
	void eventDestroyIt ( unsigned long bSkipFx );
	void RemoveFromJanusPassive ( );
};

UClass* ATgDeployable_Janus_WallPortal::pClassPointer = NULL;

// Class TgGame.TgDeploy_Bakasura_VomitPool
// 0x0000 (0x0310 - 0x0310)
class ATgDeploy_Bakasura_VomitPool : public ATgDeploy_EffectVolume
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2192 );

		return pClassPointer;
	};

	void Tick ( float DeltaSeconds );
	void eventPostBeginPlay ( );
};

UClass* ATgDeploy_Bakasura_VomitPool::pClassPointer = NULL;

// Class TgGame.TgDeploy_MovingEffectVolume
// 0x0070 (0x0380 - 0x0310)
class ATgDeploy_MovingEffectVolume : public ATgDeploy_EffectVolume
{
public:
	struct FInterpAnchor                               m_InterpAnchors[ 0x3 ];                           		// 0x0310 (0x006C) [0x0000000000000000]              
	unsigned long                                      m_bOnlyAnchorCollision : 1;                       		// 0x037C (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2193 );

		return pClassPointer;
	};

	void ResetCollisionAnchors ( );
};

UClass* ATgDeploy_MovingEffectVolume::pClassPointer = NULL;

// Class TgGame.TgDeploy_Awilix_KittenCannon
// 0x0000 (0x0380 - 0x0380)
class ATgDeploy_Awilix_KittenCannon : public ATgDeploy_MovingEffectVolume
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2194 );

		return pClassPointer;
	};

};

UClass* ATgDeploy_Awilix_KittenCannon::pClassPointer = NULL;

// Class TgGame.TgDeploy_ExplodingCylinder
// 0x0018 (0x0398 - 0x0380)
class ATgDeploy_ExplodingCylinder : public ATgDeploy_MovingEffectVolume
{
public:
	float                                              r_fPersistTime;                                   		// 0x0380 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              m_fStartRadius;                                   		// 0x0384 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bExplosionFinished : 1;                         		// 0x0388 (0x0004) [0x0000000000000000] [0x00000001] 
	TArray< class AActor* >                            s_InSlice;                                        		// 0x038C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2195 );

		return pClassPointer;
	};

	void eventDestroyed ( );
	void eventDestroyIt ( unsigned long bSkipFx );
	void ApplyHit ( TArray< struct FImpactInfo >* ImpactList );
	void Cleanup ( );
	void eventHandleUnTouch ( class AActor* Other );
	void eventHandleTouch ( class AActor* Other );
	float AdjustRadiusToTarget ( float CurrentRadius, float DeltaRadius, float TargetRadius );
	float GetTargetRadius ( );
	float GetExplosionTime ( );
	void GrowCylinder ( class UCylinderComponent* cyl, float dSeconds, float MaxRadius );
	void FinishExplosion ( );
};

UClass* ATgDeploy_ExplodingCylinder::pClassPointer = NULL;

// Class TgGame.TgDeploy_CylinderPulse
// 0x0010 (0x03A8 - 0x0398)
class ATgDeploy_CylinderPulse : public ATgDeploy_ExplodingCylinder
{
public:
	unsigned long                                      s_bWillImplode : 1;                               		// 0x0398 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      r_bImploding : 1;                                 		// 0x0398 (0x0004) [0x0000000000000020] [0x00000002] ( CPF_Net )
	TArray< class AActor* >                            s_RetractingHits;                                 		// 0x039C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2196 );

		return pClassPointer;
	};

	void DeployComplete ( );
	void eventHandleUnTouch ( class AActor* Other );
	void eventHandleTouch ( class AActor* Other );
	void eventReplicatedEvent ( struct FName VarName );
	void FinishExplosion ( );
	void TriggerImplosion ( );
	float GetTargetRadius ( );
	float GetExplosionTime ( );
};

UClass* ATgDeploy_CylinderPulse::pClassPointer = NULL;

// Class TgGame.TgDeploy_ExplodingCylinder_ScalingMesh
// 0x0008 (0x03A0 - 0x0398)
class ATgDeploy_ExplodingCylinder_ScalingMesh : public ATgDeploy_ExplodingCylinder
{
public:
	float                                              r_fFXRadius;                                      		// 0x0398 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              r_fExplosionTime;                                 		// 0x039C (0x0004) [0x0000000000000020]              ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2197 );

		return pClassPointer;
	};

	float GetExplosionTime ( );
	void SetFXScaling ( float fScale );
	void GrowCylinder ( class UCylinderComponent* cyl, float dSeconds, float MaxRadius );
};

UClass* ATgDeploy_ExplodingCylinder_ScalingMesh::pClassPointer = NULL;

// Class TgGame.TgDeployable_Serqet_Catalyst
// 0x0000 (0x0398 - 0x0398)
class ATgDeployable_Serqet_Catalyst : public ATgDeploy_ExplodingCylinder
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2198 );

		return pClassPointer;
	};

	float GetExplosionTime ( );
};

UClass* ATgDeployable_Serqet_Catalyst::pClassPointer = NULL;

// Class TgGame.TgDeployable_Susano_Dev1
// 0x0014 (0x03AC - 0x0398)
class ATgDeployable_Susano_Dev1 : public ATgDeploy_ExplodingCylinder
{
public:
	float                                              m_MaxLobHeight;                                   		// 0x0398 (0x0004) [0x0000000000000000]              
	int                                                m_LobCount;                                       		// 0x039C (0x0004) [0x0000000000000000]              
	TArray< class ATgPawn* >                           s_ToApplyKnockupActors;                           		// 0x03A0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2199 );

		return pClassPointer;
	};

	void Tick ( float fDeltaSeconds );
	void ApplyHit ( TArray< struct FImpactInfo >* ImpactList );
	bool CanBeKnockedUp ( class ATgPawn* Target );
	void LobPawn ( class ATgPawn* Target );
};

UClass* ATgDeployable_Susano_Dev1::pClassPointer = NULL;

// Class TgGame.TgDeploy_Scylla_Ultimate
// 0x0000 (0x0380 - 0x0380)
class ATgDeploy_Scylla_Ultimate : public ATgDeploy_MovingEffectVolume
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2200 );

		return pClassPointer;
	};

	void eventHandleTouch ( class AActor* Other );
	bool KnockbackRangeCheck ( class AActor* Other );
	bool CanPerformKnockback ( class AActor* Other );
	void PerformKnockback ( class AActor* Other );
};

UClass* ATgDeploy_Scylla_Ultimate::pClassPointer = NULL;

// Class TgGame.TgDeployable_ChangE_Sweep
// 0x0000 (0x0380 - 0x0380)
class ATgDeployable_ChangE_Sweep : public ATgDeploy_MovingEffectVolume
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2201 );

		return pClassPointer;
	};

};

UClass* ATgDeployable_ChangE_Sweep::pClassPointer = NULL;

// Class TgGame.TgDeployable_Poseidon_Surge
// 0x0004 (0x0384 - 0x0380)
class ATgDeployable_Poseidon_Surge : public ATgDeploy_MovingEffectVolume
{
public:
	float                                              m_fTide;                                          		// 0x0380 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2202 );

		return pClassPointer;
	};

	void ApplyHit ( TArray< struct FImpactInfo >* ImpactList );
};

UClass* ATgDeployable_Poseidon_Surge::pClassPointer = NULL;

// Class TgGame.TgDeploy_PVE_Web
// 0x0018 (0x0328 - 0x0310)
class ATgDeploy_PVE_Web : public ATgDeploy_EffectVolume
{
public:
	float                                              m_fLifeAfterHit;                                  		// 0x0310 (0x0004) [0x0000000000000000]              
	int                                                m_nMaxHits;                                       		// 0x0314 (0x0004) [0x0000000000000000]              
	int                                                r_nHitCount;                                      		// 0x0318 (0x0004) [0x0000000000000020]              ( CPF_Net )
	unsigned long                                      m_bFirstHit : 1;                                  		// 0x031C (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bBroodlingsSpawned : 1;                         		// 0x031C (0x0004) [0x0000000000000000] [0x00000002] 
	class UMeshComponent*                              m_CollisionMesh;                                  		// 0x0320 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	int                                                m_nCollisionMeshId;                               		// 0x0324 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2203 );

		return pClassPointer;
	};

	void eventDestroyIt ( unsigned long bSkipFx );
	void OnWebHit ( );
	void eventHandleTouch ( class AActor* Other );
	void ApplyHit ( TArray< struct FImpactInfo >* ImpactList );
	void eventReplicatedEvent ( struct FName VarName );
	void SpawnBroodlings ( class AActor* Target );
};

UClass* ATgDeploy_PVE_Web::pClassPointer = NULL;

// Class TgGame.TgDeploy_Scaling_EffectVolume
// 0x0004 (0x0314 - 0x0310)
class ATgDeploy_Scaling_EffectVolume : public ATgDeploy_EffectVolume
{
public:
	float                                              r_fScaleFactor;                                   		// 0x0310 (0x0004) [0x0000000000000020]              ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2204 );

		return pClassPointer;
	};

	float GetFXScaling ( );
	void eventReplicatedEvent ( struct FName VarName );
	void ScaleDisplayGroups ( );
};

UClass* ATgDeploy_Scaling_EffectVolume::pClassPointer = NULL;

// Class TgGame.TgDeploy_Sol_Diamond
// 0x0000 (0x0310 - 0x0310)
class ATgDeploy_Sol_Diamond : public ATgDeploy_EffectVolume
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2205 );

		return pClassPointer;
	};

};

UClass* ATgDeploy_Sol_Diamond::pClassPointer = NULL;

// Class TgGame.TgDeployable_Aphrodite_FlowerBed
// 0x0008 (0x0318 - 0x0310)
class ATgDeployable_Aphrodite_FlowerBed : public ATgDeploy_EffectVolume
{
public:
	class UTgTrailComponent_Aphrodite_FertileGround*   m_OwningTrail;                                    		// 0x0310 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	unsigned long                                      m_bAllowTrailToCallDestroyIt : 1;                 		// 0x0314 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2206 );

		return pClassPointer;
	};

	void eventDestroyed ( );
	void eventDestroyIt ( unsigned long bSkipFx );
	void eventUnTouch ( class AActor* Other );
	void eventHandleTouch ( class AActor* Other );
};

UClass* ATgDeployable_Aphrodite_FlowerBed::pClassPointer = NULL;

// Class TgGame.TgDeployable_Sol_Trail
// 0x0004 (0x031C - 0x0318)
class ATgDeployable_Sol_Trail : public ATgDeployable_Aphrodite_FlowerBed
{
public:
	unsigned long                                      r_bIgnited : 1;                                   		// 0x0318 (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2207 );

		return pClassPointer;
	};

	void eventDestroyIt ( unsigned long bSkipFx );
};

UClass* ATgDeployable_Sol_Trail::pClassPointer = NULL;

// Class TgGame.TgDeployable_Arachne_Web
// 0x0018 (0x0328 - 0x0310)
class ATgDeployable_Arachne_Web : public ATgDeploy_EffectVolume
{
public:
	float                                              m_fLifeAfterHit;                                  		// 0x0310 (0x0004) [0x0000000000000000]              
	int                                                m_nMaxHits;                                       		// 0x0314 (0x0004) [0x0000000000000000]              
	int                                                r_nHitCount;                                      		// 0x0318 (0x0004) [0x0000000000000020]              ( CPF_Net )
	unsigned long                                      m_bFirstHit : 1;                                  		// 0x031C (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bBroodlingsSpawned : 1;                         		// 0x031C (0x0004) [0x0000000000000000] [0x00000002] 
	class UMeshComponent*                              m_CollisionMesh;                                  		// 0x0320 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	int                                                m_nCollisionMeshId;                               		// 0x0324 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2208 );

		return pClassPointer;
	};

	void eventDestroyIt ( unsigned long bSkipFx );
	void OnWebHit ( );
	void eventHandleTouch ( class AActor* Other );
	void ApplyHit ( TArray< struct FImpactInfo >* ImpactList );
	void eventReplicatedEvent ( struct FName VarName );
};

UClass* ATgDeployable_Arachne_Web::pClassPointer = NULL;

// Class TgGame.TgDeployable_Camazotz_Essence
// 0x0030 (0x0340 - 0x0310)
class ATgDeployable_Camazotz_Essence : public ATgDeploy_EffectVolume
{
public:
	unsigned long                                      s_bEffectApplied : 1;                             		// 0x0310 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bForceDestroy : 1;                              		// 0x0310 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_bTimerDestroy : 1;                              		// 0x0310 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_bDestroyingSelf : 1;                            		// 0x0310 (0x0004) [0x0000000000000000] [0x00000008] 
	class UTgDeviceFire*                               s_EffectModeApplied;                              		// 0x0314 (0x0004) [0x0000000000000000]              
	unsigned char                                      c_CurrentNetOwnerDepthGroup;                      		// 0x0318 (0x0001) [0x0000000000000000]              
	int                                                m_nTotalDrinks;                                   		// 0x031C (0x0004) [0x0000000000000000]              
	int                                                m_nConsumedDrinks;                                		// 0x0320 (0x0004) [0x0000000000000000]              
	float                                              m_fFastTimeIncrement;                             		// 0x0324 (0x0004) [0x0000000000000000]              
	float                                              m_fSlowTimeIncrement;                             		// 0x0328 (0x0004) [0x0000000000000000]              
	class ATgPawn*                                     m_SpawnerPawn;                                    		// 0x032C (0x0004) [0x0000000000000000]              
	float                                              m_fSpawnTimeStamp;                                		// 0x0330 (0x0004) [0x0000000000000000]              
	TArray< struct FCamazotzTouchData >                m_TrackedData;                                    		// 0x0334 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2209 );

		return pClassPointer;
	};

	void Cleanup ( );
	void eventDestroyed ( );
	void eventDestroyIt ( unsigned long bSkipFx );
	void eventUnTouch ( class AActor* Other );
	void eventTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void eventReplicatedEvent ( struct FName VarName );
	bool IsFriendlyWithLocalPawn ( );
	void RemoveTouchData ( class ATgPawn_Camazotz* removingCamazotz );
	void CreateNewTouchData ( class ATgPawn_Camazotz* touchingCamazotz );
	int CheckTrackedDataForCamazotz ( class ATgPawn_Camazotz* touchingCamazotz );
	void EndConsuming ( );
};

UClass* ATgDeployable_Camazotz_Essence::pClassPointer = NULL;

// Class TgGame.TgDeployable_Cupid_HeartMineField
// 0x000C (0x031C - 0x0310)
class ATgDeployable_Cupid_HeartMineField : public ATgDeploy_EffectVolume
{
public:
	class UMaterialInstanceConstant*                   c_MIC;                                            		// 0x0310 (0x0004) [0x0000000000000000]              
	float                                              m_SecondsSinceDeployed;                           		// 0x0314 (0x0004) [0x0000000000000000]              
	int                                                s_LovestruckCount;                                		// 0x0318 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2210 );

		return pClassPointer;
	};

	void Tick ( float DeltaSeconds );
	void eventInitializeMIC ( );
};

UClass* ATgDeployable_Cupid_HeartMineField::pClassPointer = NULL;

// Class TgGame.TgDeployable_FloorPortal
// 0x0014 (0x0324 - 0x0310)
class ATgDeployable_FloorPortal : public ATgDeploy_EffectVolume
{
public:
	int                                                c_nExitMeshId;                                    		// 0x0310 (0x0004) [0x0000000000000000]              
	class UMeshComponent*                              c_ExitMesh;                                       		// 0x0314 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	TArray< class AActor* >                            s_PendingTeleportActors;                          		// 0x0318 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2211 );

		return pClassPointer;
	};

	void Tick ( float DeltaSeconds );
	void eventHandleUnTouch ( class AActor* Other );
	void eventHandleTouch ( class AActor* Other );
	bool eventCanUsePortalNow ( class AActor* Other );
};

UClass* ATgDeployable_FloorPortal::pClassPointer = NULL;

// Class TgGame.TgDeployable_Janus_FloorPortal
// 0x0000 (0x0324 - 0x0324)
class ATgDeployable_Janus_FloorPortal : public ATgDeployable_FloorPortal
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2212 );

		return pClassPointer;
	};

	void eventDestroyed ( );
	void eventDestroyIt ( unsigned long bSkipFx );
	void RemoveFromJanusPassive ( );
};

UClass* ATgDeployable_Janus_FloorPortal::pClassPointer = NULL;

// Class TgGame.TgDeployable_Hercules_HercSmash
// 0x0038 (0x0348 - 0x0310)
class ATgDeployable_Hercules_HercSmash : public ATgDeploy_EffectVolume
{
public:
	int                                                m_iLobsDone;                                      		// 0x0310 (0x0004) [0x0000000000000000]              
	float                                              m_fMaxLobHeight;                                  		// 0x0314 (0x0004) [0x0000000000000000]              
	TArray< struct FHercSmashHitInfo >                 m_HitEntities;                                    		// 0x0318 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FVector                                     m_vHitExtent;                                     		// 0x0324 (0x000C) [0x0000000000000000]              
	float                                              m_fLastFirePercentage;                            		// 0x0330 (0x0004) [0x0000000000000000]              
	float                                              m_fCurrentFirePercentage;                         		// 0x0334 (0x0004) [0x0000000000000000]              
	float                                              r_fKnockbackMinRange;                             		// 0x0338 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              r_fKnockbackMaxRange;                             		// 0x033C (0x0004) [0x0000000000000000]              
	float                                              r_fKnockbackRadius;                               		// 0x0340 (0x0004) [0x0000000000000000]              
	float                                              r_fMoveDist;                                      		// 0x0344 (0x0004) [0x0000000000000020]              ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2213 );

		return pClassPointer;
	};

	void Cleanup ( );
	bool CanBeKnockedUp ( struct FHercSmashHitInfo HitInfo );
	void eventTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void LobPawn ( class ATgPawn* Other );
	bool InKnockUpArea ( class AActor* Other, struct FVector HitLocation );
	void DetectHits ( float DeltaSeconds );
};

UClass* ATgDeployable_Hercules_HercSmash::pClassPointer = NULL;

// Class TgGame.TgDeployable_JingWei_Dev1
// 0x0024 (0x0334 - 0x0310)
class ATgDeployable_JingWei_Dev1 : public ATgDeploy_EffectVolume
{
public:
	TArray< class AActor* >                            s_TouchingActors;                                 		// 0x0310 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< float >                                    s_fTouchingTime;                                  		// 0x031C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class AActor* >                            s_ToApplyKnockupActors;                           		// 0x0328 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2214 );

		return pClassPointer;
	};

	void Tick ( float fDeltaSeconds );
	void eventHandleUnTouch ( class AActor* Other );
	bool ShouldHitOnlyOnce ( class AActor* Other );
	void eventHandleTouch ( class AActor* Other );
};

UClass* ATgDeployable_JingWei_Dev1::pClassPointer = NULL;

// Class TgGame.TgDeployable_Poseidon_Whirlpool
// 0x0008 (0x0318 - 0x0310)
class ATgDeployable_Poseidon_Whirlpool : public ATgDeploy_EffectVolume
{
public:
	float                                              m_fTide;                                          		// 0x0310 (0x0004) [0x0000000000000000]              
	class ATgCollisionProxy_Vortex_Poseidon*           m_Vortex;                                         		// 0x0314 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2215 );

		return pClassPointer;
	};

	void Cleanup ( );
	void eventDestroyed ( );
	void eventDestroyIt ( unsigned long bSkipFx );
	void ApplyHit ( TArray< struct FImpactInfo >* ImpactList );
	void eventProxyUnTouch ( class AActor* Other );
	void eventProxyTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void DeployComplete ( );
};

UClass* ATgDeployable_Poseidon_Whirlpool::pClassPointer = NULL;

// Class TgGame.TgDeployable_Susano_Dev4_Typhoon
// 0x0020 (0x0330 - 0x0310)
class ATgDeployable_Susano_Dev4_Typhoon : public ATgDeploy_EffectVolume
{
public:
	float                                              m_GrowthTime;                                     		// 0x0310 (0x0004) [0x0000000000000000]              
	float                                              r_StartRadius;                                    		// 0x0314 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              r_MaxRadius;                                      		// 0x0318 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              r_MaxGrowthTime;                                  		// 0x031C (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              r_TravelTime;                                     		// 0x0320 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              r_TravelRange;                                    		// 0x0324 (0x0004) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      r_CurrentState;                                   		// 0x0328 (0x0001) [0x0000000000000020]              ( CPF_Net )
	class ATgCollisionProxy_Vortex_Susano*             m_Vortex;                                         		// 0x032C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2216 );

		return pClassPointer;
	};

	void Cleanup ( );
	void eventDestroyed ( );
	void eventDestroyIt ( unsigned long bSkipFx );
	void TravelTimerDone ( );
	void GrowthTimerDone ( );
	void eventSpawningDeviceToggledOff ( );
	void InstantFireDeployable ( );
	void eventHandleTouch ( class AActor* Other );
	void eventProxyUnTouch ( class AActor* Other );
	void eventProxyTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void DeployComplete ( );
	void StartTraveling ( );
	void StartGrowth ( );
	void ToggleOffConsumePowerPool ( class ATgDeployable* deployable );
	void eventReplicatedEvent ( struct FName VarName );
	void SetParticleSystemScale ( float Scale );
	void SetupTravelingPhysics ( );
};

UClass* ATgDeployable_Susano_Dev4_Typhoon::pClassPointer = NULL;

// Class TgGame.TgDeployable_Terra_Trap
// 0x0004 (0x0314 - 0x0310)
class ATgDeployable_Terra_Trap : public ATgDeploy_EffectVolume
{
public:
	class ATgCollisionProxy_Box*                       s_CollisionProxy;                                 		// 0x0310 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2217 );

		return pClassPointer;
	};

	void Cleanup ( );
	void eventDestroyed ( );
	void eventDestroyIt ( unsigned long bSkipFx );
	void DeployComplete ( );
	void eventProxyUnTouch ( class AActor* Other );
	void eventProxyTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void eventInitializeCollisionProxy ( );
};

UClass* ATgDeployable_Terra_Trap::pClassPointer = NULL;

// Class TgGame.TgDeployable_Thoth_DeathGlyph
// 0x0004 (0x0314 - 0x0310)
class ATgDeployable_Thoth_DeathGlyph : public ATgDeploy_EffectVolume
{
public:
	unsigned long                                      m_DisplayWarning : 1;                             		// 0x0310 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2218 );

		return pClassPointer;
	};

	void eventDestroyIt ( unsigned long bSkipFx );
	void DashTriggered ( );
};

UClass* ATgDeployable_Thoth_DeathGlyph::pClassPointer = NULL;

// Class TgGame.TgDeployable_Thoth_SpeedGlyph
// 0x0018 (0x0328 - 0x0310)
class ATgDeployable_Thoth_SpeedGlyph : public ATgDeploy_EffectVolume
{
public:
	class UStaticMeshComponent*                        m_CollisionBox;                                   		// 0x0310 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	struct FSpeedGlyphImpactFXData                     r_LastImpact;                                     		// 0x0314 (0x0014) [0x0000000000000020]              ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2219 );

		return pClassPointer;
	};

	void eventHandleTouch ( class AActor* Other );
	void eventReplicatedEvent ( struct FName VarName );
	void PlayImpactFX ( );
};

UClass* ATgDeployable_Thoth_SpeedGlyph::pClassPointer = NULL;

// Class TgGame.TgDeployable_Trail
// 0x02F8 (0x0608 - 0x0310)
class ATgDeployable_Trail : public ATgDeploy_EffectVolume
{
public:
	struct FVector                                     r_vTrailPoints[ 0x1E ];                           		// 0x0310 (0x0168) [0x0000000000000020]              ( CPF_Net )
	float                                              s_fTrailDecayTimes[ 0x1E ];                       		// 0x0478 (0x0078) [0x0000000000000000]              
	class UStaticMeshComponent*                        s_CollisionComps[ 0x1E ];                         		// 0x04F0 (0x0078) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class UTgSpecialFx*                                c_TrailFx[ 0x1E ];                                		// 0x0568 (0x0078) [0x0000000000000000]              
	int                                                r_nTrailHeadIndex;                                		// 0x05E0 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nTrailTailIndex;                                		// 0x05E4 (0x0004) [0x0000000000000020]              ( CPF_Net )
	unsigned long                                      s_bIsStillTrailing : 1;                           		// 0x05E8 (0x0004) [0x0000000000000000] [0x00000001] 
	int                                                c_nCurrentFxTailIndex;                            		// 0x05EC (0x0004) [0x0000000000000000]              
	int                                                c_nCurrentFxHeadIndex;                            		// 0x05F0 (0x0004) [0x0000000000000000]              
	float                                              m_fMinPointDist;                                  		// 0x05F4 (0x0004) [0x0000000000000000]              
	float                                              m_fPointFrequency;                                		// 0x05F8 (0x0004) [0x0000000000000000]              
	float                                              m_fPointDuration;                                 		// 0x05FC (0x0004) [0x0000000000000000]              
	float                                              s_fNextPointTime;                                 		// 0x0600 (0x0004) [0x0000000000000000]              
	float                                              m_fTrailWidth;                                    		// 0x0604 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2220 );

		return pClassPointer;
	};

	void InitializeTrail ( );
	void AddNewPointToTrail ( );
	void DeployComplete ( );
	void ActivateFxAtIndex ( int Index );
	void Tick ( float DeltaSeconds );
	bool eventShouldTrail ( );
	class UTgStaticMeshComponent* AddCollisionAtHead ( );
};

UClass* ATgDeployable_Trail::pClassPointer = NULL;

// Class TgGame.TgDeploy_ForceField
// 0x0010 (0x0304 - 0x02F4)
class ATgDeploy_ForceField : public ATgDeployable
{
public:
	unsigned long                                      m_bBlockFriendlyFire : 1;                         		// 0x02F4 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bUseMeshAsCollision : 1;                        		// 0x02F4 (0x0004) [0x0000000000000000] [0x00000002] 
	struct FVector                                     m_vExtent;                                        		// 0x02F8 (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2221 );

		return pClassPointer;
	};

	bool eventAllowPassthrough ( unsigned long bFriendly );
	bool CanBeRepaired ( );
};

UClass* ATgDeploy_ForceField::pClassPointer = NULL;

// Class TgGame.TgDeploy_Wall
// 0x0020 (0x0324 - 0x0304)
class ATgDeploy_Wall : public ATgDeploy_ForceField
{
public:
	TArray< class AActor* >                            m_OverlappingActors;                              		// 0x0304 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< struct FVector >                           m_DesiredPushDirection;                           		// 0x0310 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	unsigned long                                      m_bPushOverlappingActors : 1;                     		// 0x031C (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bHasRegisteredObstacle : 1;                     		// 0x031C (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_bAutoRegisterObstacle : 1;                      		// 0x031C (0x0004) [0x0000000000000000] [0x00000004] 
	float                                              m_fPushFactor;                                    		// 0x0320 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2222 );

		return pClassPointer;
	};

	void PushOverlappingActors ( float DeltaSeconds );
	void eventUnTouch ( class AActor* Other );
	void eventTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void Tick ( float DeltaSeconds );
	void eventCollisionChanged ( );
	void eventDestroyIt ( unsigned long bSkipFx );
	void Destroyed ( );
	void DeployComplete ( );
	void UnRegisterObstacle ( );
	void RegisterObstacle ( );
	bool RemoveOverlappingActorByIndex ( int Index );
	bool UpdateOverlappingActorByIndex ( int Index, struct FVector PushDirection );
	void RemoveOverlappingActor ( class AActor* Other );
	void AddOverlappingActor ( class AActor* Other, struct FVector PushDirection, unsigned long bForceNewEntry );
	bool IsPushable ( class AActor* Other );
	void FindOverlappingActors ( );
	bool ShouldSelfDestructWhenTouchedBy ( class AActor* Other );
};

UClass* ATgDeploy_Wall::pClassPointer = NULL;

// Class TgGame.TgDeploy_Anhur_Consecrate
// 0x0024 (0x0348 - 0x0324)
class ATgDeploy_Anhur_Consecrate : public ATgDeploy_Wall
{
public:
	TArray< class AActor* >                            s_AppliedList;                                    		// 0x0324 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class ATgCollisionProxy*                           s_CollisionProxy;                                 		// 0x0330 (0x0004) [0x0000000000000000]              
	class UMeshComponent*                              m_CollisionMesh;                                  		// 0x0334 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	int                                                m_nCollisionMeshId;                               		// 0x0338 (0x0004) [0x0000000000000000]              
	class UMeshComponent*                              m_SandMesh;                                       		// 0x033C (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	int                                                m_nSandMeshId;                                    		// 0x0340 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bApplyHitOnTouch : 1;                           		// 0x0344 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bApplyHitSpecialOnTouch : 1;                    		// 0x0344 (0x0004) [0x0000000000000000] [0x00000002] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2223 );

		return pClassPointer;
	};

	void Cleanup ( );
	void eventDestroyed ( );
	void eventDestroyIt ( unsigned long bSkipFx );
	void eventProxyUnTouch ( class AActor* Other );
	void eventProxyTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void DeployComplete ( );
};

UClass* ATgDeploy_Anhur_Consecrate::pClassPointer = NULL;

// Class TgGame.TgDeployable_NuWa_Pillars
// 0x0018 (0x0360 - 0x0348)
class ATgDeployable_NuWa_Pillars : public ATgDeploy_Anhur_Consecrate
{
public:
	class UMeshComponent*                              s_HitMesh;                                        		// 0x0348 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	int                                                s_nHitMeshId;                                     		// 0x034C (0x0004) [0x0000000000000000]              
	int                                                s_nDamageEffectGroupId;                           		// 0x0350 (0x0004) [0x0000000000000000]              
	TArray< struct FCannotTouchInfo >                  s_CannotTouchList;                                		// 0x0354 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2224 );

		return pClassPointer;
	};

	struct FImpactInfo CalcDeviceFire ( struct FVector StartTrace, struct FVector EndTrace, TArray< struct FImpactInfo >* ImpactList );
	void eventProxyUnTouch ( class AActor* Other );
	void eventProxyTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	float TimeUntilActorCanBeReTouched ( class AActor* Target );
};

UClass* ATgDeployable_NuWa_Pillars::pClassPointer = NULL;

// Class TgGame.TgDeploy_Izanami_Dev4
// 0x0024 (0x0348 - 0x0324)
class ATgDeploy_Izanami_Dev4 : public ATgDeploy_Wall
{
public:
	class UMeshComponent*                              m_CollisionMesh;                                  		// 0x0324 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	int                                                m_nCollisionMeshId;                               		// 0x0328 (0x0004) [0x0000000000000000]              
	TArray< class AActor* >                            s_AppliedList;                                    		// 0x032C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class ATgCollisionProxy*                           s_CollisionProxy;                                 		// 0x0338 (0x0004) [0x0000000000000000]              
	class ATgPawn*                                     r_TargetPawn;                                     		// 0x033C (0x0004) [0x0000000000000020]              ( CPF_Net )
	class UTgSpecialFx*                                c_SpawnEffect;                                    		// 0x0340 (0x0004) [0x0000000000000000]              
	int                                                m_nSpawnEffectId;                                 		// 0x0344 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2225 );

		return pClassPointer;
	};

	bool eventAllowPassthrough ( unsigned long bFriendly );
	void eventDestroyed ( );
	void eventDestroyIt ( unsigned long bSkipFx );
	void Cleanup ( );
	void eventProxyUnTouch ( class AActor* Other );
	void eventProxyTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	bool IsPushable ( class AActor* Other );
};

UClass* ATgDeploy_Izanami_Dev4::pClassPointer = NULL;

// Class TgGame.TgDeploy_Odin_Spears
// 0x001C (0x0340 - 0x0324)
class ATgDeploy_Odin_Spears : public ATgDeploy_Wall
{
public:
	class UMeshComponent*                              m_CollisionMesh;                                  		// 0x0324 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	int                                                m_nCollisionMeshId;                               		// 0x0328 (0x0004) [0x0000000000000000]              
	float                                              m_fCollisionHeightAdjust;                         		// 0x032C (0x0004) [0x0000000000000000]              
	TArray< class AActor* >                            s_AppliedList;                                    		// 0x0330 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class ATgCollisionProxy*                           s_CollisionProxy;                                 		// 0x033C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2226 );

		return pClassPointer;
	};

	bool eventAllowPassthrough ( unsigned long bFriendly );
	void eventDestroyed ( );
	void eventDestroyIt ( unsigned long bSkipFx );
	void Cleanup ( );
	void eventProxyUnTouch ( class AActor* Other );
	void eventProxyTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void DeployComplete ( );
	bool IsPushable ( class AActor* Other );
	void UpdateCollisionOffset ( );
};

UClass* ATgDeploy_Odin_Spears::pClassPointer = NULL;

// Class TgGame.TgDeploy_Wall_Destructible
// 0x0000 (0x0324 - 0x0324)
class ATgDeploy_Wall_Destructible : public ATgDeploy_Wall
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2227 );

		return pClassPointer;
	};

	void SetTaskForceNumber ( int nTaskForceId );
};

UClass* ATgDeploy_Wall_Destructible::pClassPointer = NULL;

// Class TgGame.TgDeployable_Cabrakan_Dev4_Wall
// 0x0004 (0x0328 - 0x0324)
class ATgDeployable_Cabrakan_Dev4_Wall : public ATgDeploy_Wall_Destructible
{
public:
	class ATgPawn_Cabrakan*                            m_OwningCabrakan;                                 		// 0x0324 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2228 );

		return pClassPointer;
	};

	void eventTakeDamage ( int Damage, class AController* EventInstigator, struct FVector HitLocation, struct FVector Momentum, class UClass* DamageType, struct FTraceHitInfo HitInfo, class AActor* DamageCauser );
	bool IsInvisible ( class AActor* TestActor );
	struct FVector GetHudOverlayLocation ( );
};

UClass* ATgDeployable_Cabrakan_Dev4_Wall::pClassPointer = NULL;

// Class TgGame.TgDeployable_Medusa_Statue
// 0x0008 (0x032C - 0x0324)
class ATgDeployable_Medusa_Statue : public ATgDeploy_Wall_Destructible
{
public:
	class ATgPawn_Medusa*                              m_OwningMedusa;                                   		// 0x0324 (0x0004) [0x0000000000000000]              
	int                                                r_nStatuePawnId;                                  		// 0x0328 (0x0004) [0x0000000000000020]              ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2229 );

		return pClassPointer;
	};

	void eventTakeDamage ( int Damage, class AController* EventInstigator, struct FVector HitLocation, struct FVector Momentum, class UClass* DamageType, struct FTraceHitInfo HitInfo, class AActor* DamageCauser );
	bool IsPushable ( class AActor* Other );
	void RecalculateMaterial ( unsigned long bIsFriendlyWithLocalPawn, unsigned long bForce );
	bool IsInvisible ( class AActor* TestActor );
	struct FVector GetHudOverlayLocation ( );
};

UClass* ATgDeployable_Medusa_Statue::pClassPointer = NULL;

// Class TgGame.TgDeployable_Terra_StandingStone
// 0x0010 (0x0334 - 0x0324)
class ATgDeployable_Terra_StandingStone : public ATgDeploy_Wall_Destructible
{
public:
	class ATgPawn_Terra*                               m_OwningTerra;                                    		// 0x0324 (0x0004) [0x0000000000000000]              
	unsigned long                                      r_WallCracking : 1;                               		// 0x0328 (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )
	float                                              m_WallCrackTime;                                  		// 0x032C (0x0004) [0x0000000000000000]              
	float                                              m_WallCrackDuration;                              		// 0x0330 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2230 );

		return pClassPointer;
	};

	void StartWallCrack ( );
	void eventDestroyIt ( unsigned long bSkipFx );
	void MegaPunched ( class ATgPawn_Terra* attacker, struct FVector HitLocation );
	void OwningTerraShattered ( );
	void Tick ( float DeltaSeconds );
	void eventReplicatedEvent ( struct FName VarName );
	void SetMICParameter ( struct FName ScalarParam, float ScalarValue );
	bool IsInvisible ( class AActor* TestActor );
};

UClass* ATgDeployable_Terra_StandingStone::pClassPointer = NULL;

// Class TgGame.TgDeployable_Terra_CrushingShale
// 0x0031 (0x0365 - 0x0334)
class ATgDeployable_Terra_CrushingShale : public ATgDeployable_Terra_StandingStone
{
public:
	class ATgDeployable_Terra_CrushingShale*           r_SisterShale;                                    		// 0x0334 (0x0004) [0x0000000000000020]              ( CPF_Net )
	unsigned long                                      r_IsCrushing : 1;                                 		// 0x0338 (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )
	unsigned long                                      r_CollisionReady : 1;                             		// 0x0338 (0x0004) [0x0000000000000020] [0x00000002] ( CPF_Net )
	TArray< class ATgPawn* >                           s_HitActors;                                      		// 0x033C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FVector                                     m_TweenStart;                                     		// 0x0348 (0x000C) [0x0000000000000000]              
	struct FVector                                     m_TweenEnd;                                       		// 0x0354 (0x000C) [0x0000000000000000]              
	float                                              m_TweenTime;                                      		// 0x0360 (0x0004) [0x0000000000000000]              
	unsigned char                                      m_DestructionState;                               		// 0x0364 (0x0001) [0x0000000000000020]              ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2231 );

		return pClassPointer;
	};

	void eventDestroyed ( );
	void eventDestroyIt ( unsigned long bSkipFx );
	void CrushTravelTimeExpired ( );
	void eventTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void OwningTerraShattered ( );
	void ClientTriggerCrush ( );
	void TriggerCrush ( );
	bool CanTriggerCrush ( class ATgDeployable* Other );
	void ClientCollisionReady ( );
	void CollisionReady ( );
	void eventReplicatedEvent ( struct FName VarName );
	void StopCrushPhysics ( );
	void StartCrushPhysics ( );
};

UClass* ATgDeployable_Terra_CrushingShale::pClassPointer = NULL;

// Class TgGame.TgDeployable_Terra_Obelisk
// 0x0014 (0x0348 - 0x0334)
class ATgDeployable_Terra_Obelisk : public ATgDeployable_Terra_StandingStone
{
public:
	TArray< class AActor* >                            s_AppliedList;                                    		// 0x0334 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class ATgCollisionProxy*                           s_CollisionProxy;                                 		// 0x0340 (0x0004) [0x0000000000000000]              
	class UCylinderComponent*                          m_CollisionCylinder;                              		// 0x0344 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2232 );

		return pClassPointer;
	};

	void eventTakeDamage ( int Damage, class AController* EventInstigator, struct FVector HitLocation, struct FVector Momentum, class UClass* DamageType, struct FTraceHitInfo HitInfo, class AActor* DamageCauser );
	void Cleanup ( );
	void eventDestroyed ( );
	void eventDestroyIt ( unsigned long bSkipFx );
	void eventProxyUnTouch ( class AActor* Other );
	void eventProxyTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void eventSetupCollisionProxy ( );
	void DeployComplete ( );
};

UClass* ATgDeployable_Terra_Obelisk::pClassPointer = NULL;

// Class TgGame.TgDeployable_Terra_PillarOfEarth
// 0x0004 (0x0338 - 0x0334)
class ATgDeployable_Terra_PillarOfEarth : public ATgDeployable_Terra_StandingStone
{
public:
	unsigned long                                      m_FiredOnce : 1;                                  		// 0x0334 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2233 );

		return pClassPointer;
	};

	void ShatterOnBanishedTargets ( );
	void eventDestroyIt ( unsigned long bSkipFx );
};

UClass* ATgDeployable_Terra_PillarOfEarth::pClassPointer = NULL;

// Class TgGame.TgDeployable_HunBatz_FearTotem
// 0x0000 (0x0324 - 0x0324)
class ATgDeployable_HunBatz_FearTotem : public ATgDeploy_Wall
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2234 );

		return pClassPointer;
	};

};

UClass* ATgDeployable_HunBatz_FearTotem::pClassPointer = NULL;

// Class TgGame.TgDeployable_Thor_HammerSlam
// 0x0024 (0x0348 - 0x0324)
class ATgDeployable_Thor_HammerSlam : public ATgDeploy_Wall
{
public:
	TArray< class AActor* >                            s_AppliedList;                                    		// 0x0324 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class UMeshComponent*                              m_CollisionMesh;                                  		// 0x0330 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	int                                                m_nCollisionMeshId;                               		// 0x0334 (0x0004) [0x0000000000000000]              
	float                                              m_fCollisionHeightAdjust;                         		// 0x0338 (0x0004) [0x0000000000000000]              
	class ATgCollisionProxy*                           s_CollisionProxy;                                 		// 0x033C (0x0004) [0x0000000000000000]              
	int                                                m_nHitMeshId;                                     		// 0x0340 (0x0004) [0x0000000000000000]              
	float                                              m_fHitHeightAdjust;                               		// 0x0344 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2235 );

		return pClassPointer;
	};

	void Destroyed ( );
	void NotifyCollisionOff ( );
	void NotifyCollisionOn ( );
	bool ShouldHit ( class AActor* Other );
	struct FImpactInfo CalcDeviceFire ( struct FVector StartTrace, struct FVector EndTrace, TArray< struct FImpactInfo >* ImpactList );
	void DeployComplete ( );
	void eventProxyTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void ToggleCollisionMesh ( unsigned long bCollide );
	void UpdateMeshOffset ( );
};

UClass* ATgDeployable_Thor_HammerSlam::pClassPointer = NULL;

// Class TgGame.TgDeployable_Ymir_IceWall
// 0x0000 (0x0324 - 0x0324)
class ATgDeployable_Ymir_IceWall : public ATgDeploy_Wall
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2236 );

		return pClassPointer;
	};

};

UClass* ATgDeployable_Ymir_IceWall::pClassPointer = NULL;

// Class TgGame.TgDeploy_Kukulkan_Tornadoes
// 0x0014 (0x0308 - 0x02F4)
class ATgDeploy_Kukulkan_Tornadoes : public ATgDeployable
{
public:
	TArray< class ATgProj_Tornado* >                   m_Tornadoes;                                      		// 0x02F4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class UTgDeviceFire*                               m_TornadoSpawnFiremode;                           		// 0x0300 (0x0004) [0x0000000000000000]              
	float                                              m_fTornadoBlend;                                  		// 0x0304 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2237 );

		return pClassPointer;
	};

	void Tick ( float DeltaSeconds );
	class ATgProj_Tornado* GetTornadoFor ( class AActor* Actor );
	void ApplyHit ( TArray< struct FImpactInfo >* ImpactList );
};

UClass* ATgDeploy_Kukulkan_Tornadoes::pClassPointer = NULL;

// Class TgGame.TgDeployable_Agni_NoxiousFumes
// 0x000C (0x0300 - 0x02F4)
class ATgDeployable_Agni_NoxiousFumes : public ATgDeployable
{
public:
	unsigned long                                      r_IsExploding : 1;                                		// 0x02F4 (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )
	class UCylinderComponent*                          m_CollisionCylinder;                              		// 0x02F8 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class UTgSpecialFx*                                m_ExplodeFX;                                      		// 0x02FC (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2238 );

		return pClassPointer;
	};

	void ExplodeNoxiousFumes ( );
	void eventReplicatedEvent ( struct FName VarName );
	void Explode ( );
	void TriggerExplosion ( );
	void Tick ( float DeltaSeconds );
	void eventEncroachedBy ( class AActor* Other );
	void eventTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	bool ShouldTouchCauseExplosion ( class AActor* Other );
};

UClass* ATgDeployable_Agni_NoxiousFumes::pClassPointer = NULL;

// Class TgGame.TgDeployable_Agni_PathOfFlames
// 0x0004 (0x02F8 - 0x02F4)
class ATgDeployable_Agni_PathOfFlames : public ATgDeployable
{
public:
	class UCylinderComponent*                          m_CollisionCylinder;                              		// 0x02F4 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2239 );

		return pClassPointer;
	};

};

UClass* ATgDeployable_Agni_PathOfFlames::pClassPointer = NULL;

// Class TgGame.TgDeployable_Agni_RainFire
// 0x0004 (0x02F8 - 0x02F4)
class ATgDeployable_Agni_RainFire : public ATgDeployable
{
public:
	class UCylinderComponent*                          m_CollisionCylinder;                              		// 0x02F4 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2240 );

		return pClassPointer;
	};

	void FireAmmunitionDeployable ( );
	void AdjustMeshToGround ( );
};

UClass* ATgDeployable_Agni_RainFire::pClassPointer = NULL;

// Class TgGame.TgDeployable_AhMuzenCab_HoneyPool
// 0x0018 (0x030C - 0x02F4)
class ATgDeployable_AhMuzenCab_HoneyPool : public ATgDeployable
{
public:
	TArray< class AActor* >                            s_AppliedList;                                    		// 0x02F4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class ATgCollisionProxy*                           s_CollisionProxy;                                 		// 0x0300 (0x0004) [0x0000000000000000]              
	unsigned long                                      r_bIsBuffedWithBees : 1;                          		// 0x0304 (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )
	class ATgDeployable_AhMuzenCab_Hive*               r_HiveBuffing;                                    		// 0x0308 (0x0004) [0x0000000000000020]              ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2241 );

		return pClassPointer;
	};

	void Cleanup ( );
	void eventDestroyed ( );
	void eventDestroyIt ( unsigned long bSkipFx );
	void eventProxyUnTouch ( class AActor* Other );
	void eventProxyTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void DeployComplete ( );
	void PlayHiveBuffingEffects ( );
	void PlayHiveBuffingEffectsTimer ( );
	void PlayBuffedWithBeesEffects ( );
	void BuffWithBees ( unsigned long bBuffPreviousHoneyPools );
	void BuffWithBeesTimer ( );
	void StartBuffWithBeesTimer ( float Time );
	void eventReplicatedEvent ( struct FName VarName );
};

UClass* ATgDeployable_AhMuzenCab_HoneyPool::pClassPointer = NULL;

// Class TgGame.TgDeployable_AhMuzenCab_Stinger
// 0x0010 (0x0304 - 0x02F4)
class ATgDeployable_AhMuzenCab_Stinger : public ATgDeployable
{
public:
	TArray< class AActor* >                            s_AppliedList;                                    		// 0x02F4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class ATgCollisionProxy*                           s_CollisionProxy;                                 		// 0x0300 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2242 );

		return pClassPointer;
	};

	void Cleanup ( );
	void eventDestroyed ( );
	void eventDestroyIt ( unsigned long bSkipFx );
	void eventProxyTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void DeployComplete ( );
};

UClass* ATgDeployable_AhMuzenCab_Stinger::pClassPointer = NULL;

// Class TgGame.TgDeployable_AhPuch_Dev1
// 0x0020 (0x0314 - 0x02F4)
class ATgDeployable_AhPuch_Dev1 : public ATgDeployable
{
public:
	unsigned long                                      s_bEffectApplied : 1;                             		// 0x02F4 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bForceDestroy : 1;                              		// 0x02F4 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_bTimerDestroy : 1;                              		// 0x02F4 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_Triggered : 1;                                  		// 0x02F4 (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      m_bDestroyCorpseOnHit : 1;                        		// 0x02F4 (0x0004) [0x0000000000000000] [0x00000010] 
	unsigned long                                      m_bSkipFxOnDestroyCorpse : 1;                     		// 0x02F4 (0x0004) [0x0000000000000000] [0x00000020] 
	unsigned long                                      r_IsExploding : 1;                                		// 0x02F4 (0x0004) [0x0000000000000020] [0x00000040] ( CPF_Net )
	unsigned long                                      m_bSpawnedByDev3 : 1;                             		// 0x02F4 (0x0004) [0x0000000000000000] [0x00000080] 
	class UTgDeviceFire*                               s_EffectModeApplied;                              		// 0x02F8 (0x0004) [0x0000000000000000]              
	int                                                m_nExplodeFxId;                                   		// 0x02FC (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                m_ExplodeFX;                                      		// 0x0300 (0x0004) [0x0000000000000000]              
	float                                              r_InitialMeshOffset;                              		// 0x0304 (0x0004) [0x0000000000000020]              ( CPF_Net )
	struct FVector                                     m_TargetMeshOffset;                               		// 0x0308 (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2243 );

		return pClassPointer;
	};

	void eventExplodeFX ( );
	bool StopsProjectile ( class AProjectile* P );
	void eventDestroyIt ( unsigned long bSkipFx );
	void eventSpecialDestroyIt ( unsigned long bSkipFx );
	void TriggerDeployable ( class AActor* Other );
	void eventTakeDamage ( int Damage, class AController* EventInstigator, struct FVector HitLocation, struct FVector Momentum, class UClass* DamageType, struct FTraceHitInfo HitInfo, class AActor* DamageCauser );
	void eventTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void eventTick ( float DeltaSeconds );
	void eventReplicatedEvent ( struct FName VarName );
	bool IsInvisible ( class AActor* TestActor );
	void SetSelected ( unsigned long bIsSelected );
	void Detonate ( );
	void DetonateNearbyCorpses ( float Radius );
};

UClass* ATgDeployable_AhPuch_Dev1::pClassPointer = NULL;

// Class TgGame.TgDeployable_AhPuch_Dev2
// 0x0004 (0x02F8 - 0x02F4)
class ATgDeployable_AhPuch_Dev2 : public ATgDeployable
{
public:
	class ATgPawn_AhPuch*                              r_PawnOwner;                                      		// 0x02F4 (0x0004) [0x0000000000000020]              ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2244 );

		return pClassPointer;
	};

};

UClass* ATgDeployable_AhPuch_Dev2::pClassPointer = NULL;

// Class TgGame.TgDeployable_AoKuang_WaterIllusion
// 0x0004 (0x02F8 - 0x02F4)
class ATgDeployable_AoKuang_WaterIllusion : public ATgDeployable
{
public:
	unsigned long                                      m_bUsePassive : 1;                                		// 0x02F4 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2245 );

		return pClassPointer;
	};

	void eventSpawningDeviceToggledOff ( );
	void FireAmmunitionDeployable ( );
	void ApplyHit ( TArray< struct FImpactInfo >* ImpactList );
	void DeployComplete ( );
	void DeviceFired ( );
	void eventStartDeploy ( );
};

UClass* ATgDeployable_AoKuang_WaterIllusion::pClassPointer = NULL;

// Class TgGame.TgDeployable_Apep_AcidSpray
// 0x0010 (0x0304 - 0x02F4)
class ATgDeployable_Apep_AcidSpray : public ATgDeployable
{
public:
	TArray< class AActor* >                            s_AppliedList;                                    		// 0x02F4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class ATgCollisionProxy*                           s_CollisionProxy;                                 		// 0x0300 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2246 );

		return pClassPointer;
	};

	void Cleanup ( );
	void eventDestroyed ( );
	void eventDestroyIt ( unsigned long bSkipFx );
	void eventProxyUnTouch ( class AActor* Other );
	void eventProxyTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void DeployComplete ( );
};

UClass* ATgDeployable_Apep_AcidSpray::pClassPointer = NULL;

// Class TgGame.TgDeployable_Apep_Pickup
// 0x0008 (0x02FC - 0x02F4)
class ATgDeployable_Apep_Pickup : public ATgDeployable
{
public:
	int                                                m_ItemAwardId;                                    		// 0x02F4 (0x0004) [0x0000000000000000]              
	int                                                m_MaximumItems;                                   		// 0x02F8 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2247 );

		return pClassPointer;
	};

	void eventTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	bool GiveDevice ( int nItemId, class ATgInventoryManager* TargetInv );
};

UClass* ATgDeployable_Apep_Pickup::pClassPointer = NULL;

// Class TgGame.TgDeployable_Ares_ChainPylon
// 0x0028 (0x031C - 0x02F4)
class ATgDeployable_Ares_ChainPylon : public ATgDeployable
{
public:
	TArray< class UTgSkeletalMeshComponent* >          m_TetherMeshComponents;                           		// 0x02F4 (0x000C) [0x0000000004480008]              ( CPF_ExportObject | CPF_Component | CPF_NeedCtorLink | CPF_EditInline )
	class ATgCollisionProxy_Cylinder*                  m_CollisionProxy;                                 		// 0x0300 (0x0004) [0x0000000000000000]              
	TArray< class ATgPawn* >                           m_TetheredPawns;                                  		// 0x0304 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class UTgDeviceFire*                               m_PullDeviceMode;                                 		// 0x0310 (0x0004) [0x0000000000000000]              
	class UMeshComponent*                              m_CollisionMesh;                                  		// 0x0314 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	int                                                m_nCollisionMeshId;                               		// 0x0318 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2248 );

		return pClassPointer;
	};

	void eventDestroyed ( );
	void UntetherPawn ( class ATgPawn* TetheredPawn );
	void TetherPawn ( class ATgPawn* touchedPawn );
	void eventCollisionProxyOnTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void eventTick ( float DeltaSeconds );
	void eventInitializeCollisionProxy ( );
	class UTgSkeletalMeshComponent* CreateTetherSkeletalMeshComponent ( );
};

UClass* ATgDeployable_Ares_ChainPylon::pClassPointer = NULL;

// Class TgGame.TgDeployable_Buff_Monster
// 0x0018 (0x030C - 0x02F4)
class ATgDeployable_Buff_Monster : public ATgDeployable
{
public:
	unsigned long                                      m_Triggered : 1;                                  		// 0x02F4 (0x0004) [0x0000000000000000] [0x00000001] 
	float                                              r_InitialMeshOffset;                              		// 0x02F8 (0x0004) [0x0000000000000020]              ( CPF_Net )
	struct FVector                                     m_TargetMeshOffset;                               		// 0x02FC (0x000C) [0x0000000000000000]              
	class ATgBotFactory*                               s_OriginalFactory;                                		// 0x0308 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2249 );

		return pClassPointer;
	};

	void eventDestroyIt ( unsigned long bSkipFx );
	void eventSetSpawnFactory ( class ATgBotFactory* Factory );
	void TriggerBuff ( class AActor* Other );
	void eventTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void eventTick ( float DeltaSeconds );
	bool CanApplyBuff ( class AActor* Target );
};

UClass* ATgDeployable_Buff_Monster::pClassPointer = NULL;

// Class TgGame.TgDeployable_Buff_Monster_ApplyDevice
// 0x0000 (0x030C - 0x030C)
class ATgDeployable_Buff_Monster_ApplyDevice : public ATgDeployable_Buff_Monster
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2250 );

		return pClassPointer;
	};

	void TriggerBuff ( class AActor* Other );
	bool CanApplyBuff ( class AActor* Target );
};

UClass* ATgDeployable_Buff_Monster_ApplyDevice::pClassPointer = NULL;

// Class TgGame.TgDeployable_Cabrakan_Dev4_Ultimate
// 0x0004 (0x02F8 - 0x02F4)
class ATgDeployable_Cabrakan_Dev4_Ultimate : public ATgDeployable
{
public:
	class ATgPawn_Cabrakan*                            m_OwningCabrakan;                                 		// 0x02F4 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2251 );

		return pClassPointer;
	};

	void InstantFireDeployable ( );
};

UClass* ATgDeployable_Cabrakan_Dev4_Ultimate::pClassPointer = NULL;

// Class TgGame.TgDeployable_Chiron_TrainingExercise
// 0x0000 (0x02F4 - 0x02F4)
class ATgDeployable_Chiron_TrainingExercise : public ATgDeployable
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2252 );

		return pClassPointer;
	};

	void FireAmmunitionDeployable ( );
};

UClass* ATgDeployable_Chiron_TrainingExercise::pClassPointer = NULL;

// Class TgGame.TgDeployable_Cupid_HealingHearts
// 0x0018 (0x030C - 0x02F4)
class ATgDeployable_Cupid_HealingHearts : public ATgDeployable
{
public:
	unsigned long                                      m_Triggered : 1;                                  		// 0x02F4 (0x0004) [0x0000000000000000] [0x00000001] 
	int                                                s_LovestruckCount;                                		// 0x02F8 (0x0004) [0x0000000000000000]              
	float                                              r_InitialMeshOffset;                              		// 0x02FC (0x0004) [0x0000000000000020]              ( CPF_Net )
	struct FVector                                     m_TargetMeshOffset;                               		// 0x0300 (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2253 );

		return pClassPointer;
	};

	void TriggerHeart ( class AActor* Other );
	void eventTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void eventTick ( float DeltaSeconds );
};

UClass* ATgDeployable_Cupid_HealingHearts::pClassPointer = NULL;

// Class TgGame.TgDeployable_FogWall
// 0x0008 (0x02FC - 0x02F4)
class ATgDeployable_FogWall : public ATgDeployable
{
public:
	unsigned long                                      m_bOneDirectional : 1;                            		// 0x02F4 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_bBlockAllowFriendlies : 1;                      		// 0x02F4 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	float                                              m_fBlockMinimumDistance;                          		// 0x02F8 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2254 );

		return pClassPointer;
	};

};

UClass* ATgDeployable_FogWall::pClassPointer = NULL;

// Class TgGame.TgDeployable_Jumong_Quiver
// 0x0010 (0x0304 - 0x02F4)
class ATgDeployable_Jumong_Quiver : public ATgDeployable
{
public:
	TArray< class AActor* >                            s_AppliedList;                                    		// 0x02F4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class ATgCollisionProxy*                           s_CollisionProxy;                                 		// 0x0300 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2255 );

		return pClassPointer;
	};

	void eventDestroyed ( );
	void eventDestroyIt ( unsigned long bSkipFx );
	void Cleanup ( );
	void eventProxyUnTouch ( class AActor* Other );
	void eventProxyTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
};

UClass* ATgDeployable_Jumong_Quiver::pClassPointer = NULL;

// Class TgGame.TgDeployable_Khepri_Scarab
// 0x003C (0x0330 - 0x02F4)
class ATgDeployable_Khepri_Scarab : public ATgDeployable
{
public:
	TArray< class AActor* >                            s_PotentialPassengers;                            		// 0x02F4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class AActor* >                            s_InnerOccupants;                                 		// 0x0300 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< float >                                    s_PotentialTimers;                                		// 0x030C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	float                                              m_fTotalLife;                                     		// 0x0318 (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                m_ChargingFx;                                     		// 0x031C (0x0004) [0x0000000000000000]              
	int                                                m_nChargingFxId;                                  		// 0x0320 (0x0004) [0x0000000000000000]              
	class ATgPawn*                                     r_NewestChargingActor;                            		// 0x0324 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgCollisionProxy*                           s_CollisionProxy;                                 		// 0x0328 (0x0004) [0x0000000000000000]              
	class ATgCollisionProxy*                           s_AcceptProxy;                                    		// 0x032C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2256 );

		return pClassPointer;
	};

	void eventDestroyed ( );
	void eventDestroyIt ( unsigned long bSkipFx );
	void Cleanup ( );
	void UntrackAllTracked ( );
	void UntrackActorAt ( int Idx );
	void TrackActor ( class AActor* tracked );
	bool IsTrackingAny ( );
	void SetChargingFx ( unsigned long isCharging );
	void Tick ( float DeltaSeconds );
	void eventProxyScarabUnTouch ( class AActor* Other );
	void eventProxyScarabTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void eventProxyUnTouch ( class AActor* Other );
	void eventProxyTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void AddChargingFxToActor ( class ATgPawn* newTrackedPawn );
	void eventReplicatedEvent ( struct FName VarName );
};

UClass* ATgDeployable_Khepri_Scarab::pClassPointer = NULL;

// Class TgGame.TgDeployable_LimitedGroundTarget
// 0x0000 (0x02F4 - 0x02F4)
class ATgDeployable_LimitedGroundTarget : public ATgDeployable
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2257 );

		return pClassPointer;
	};

};

UClass* ATgDeployable_LimitedGroundTarget::pClassPointer = NULL;

// Class TgGame.TgDeployable_Mercury_Num4Rift
// 0x0020 (0x0314 - 0x02F4)
class ATgDeployable_Mercury_Num4Rift : public ATgDeployable
{
public:
	float                                              r_fMaxLengthPct;                                  		// 0x02F4 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              r_fTotalEruptTime;                                		// 0x02F8 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              m_fRemainingEruptTime;                            		// 0x02FC (0x0004) [0x0000000000000000]              
	float                                              m_fTimeBeforeFading;                              		// 0x0300 (0x0004) [0x0000000000000000]              
	float                                              m_fRemainingTimeBeforeFading;                     		// 0x0304 (0x0004) [0x0000000000000000]              
	float                                              m_fFadeOutTime;                                   		// 0x0308 (0x0004) [0x0000000000000000]              
	float                                              m_fRemainingFadeOutTime;                          		// 0x030C (0x0004) [0x0000000000000000]              
	class UMaterialInstanceConstant*                   m_MIC;                                            		// 0x0310 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2258 );

		return pClassPointer;
	};

	void DeployComplete ( );
	void RecalculateMaterial ( unsigned long bIsFriendlyWithLocalPawn, unsigned long bForce );
};

UClass* ATgDeployable_Mercury_Num4Rift::pClassPointer = NULL;

// Class TgGame.TgDeployable_Neith_BrokenWeave
// 0x0011 (0x0305 - 0x02F4)
class ATgDeployable_Neith_BrokenWeave : public ATgDeployable
{
public:
	class ATgPawn_Neith*                               s_PawnOwner;                                      		// 0x02F4 (0x0004) [0x0000000000000000]              
	class ATgDevice*                                   s_PawnOwnerHealDevice;                            		// 0x02F8 (0x0004) [0x0000000000000000]              
	unsigned long                                      s_bEffectApplied : 1;                             		// 0x02FC (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bForceDestroy : 1;                              		// 0x02FC (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_bTimerDestroy : 1;                              		// 0x02FC (0x0004) [0x0000000000000000] [0x00000004] 
	class UTgDeviceFire*                               s_EffectModeApplied;                              		// 0x0300 (0x0004) [0x0000000000000000]              
	unsigned char                                      c_CurrentNetOwnerDepthGroup;                      		// 0x0304 (0x0001) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2259 );

		return pClassPointer;
	};

	bool StopsProjectile ( class AProjectile* P );
	void Cleanup ( );
	void eventDestroyed ( );
	void eventDestroyIt ( unsigned long bSkipFx );
	void eventSpecialDestroyIt ( unsigned long bSkipFx );
	void HealOwner ( );
	void eventReplicatedEvent ( struct FName VarName );
	void SetSelected ( unsigned long bIsSelected );
	void ToggleParticleSystemVisibility ( unsigned long bVisible );
	void AdjustWardsDepthPriorityGroup ( unsigned char DepthPriorityGroup );
	void AbsorbNearbyWeaves ( float Radius );
};

UClass* ATgDeployable_Neith_BrokenWeave::pClassPointer = NULL;

// Class TgGame.TgDeployable_Nox_NightTerror
// 0x001C (0x0310 - 0x02F4)
class ATgDeployable_Nox_NightTerror : public ATgDeployable
{
public:
	TArray< class AActor* >                            s_TouchingGods;                                   		// 0x02F4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class AActor* >                            s_PreviouslyStunned;                              		// 0x0300 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class ATgCollisionProxy*                           s_CollisionProxy;                                 		// 0x030C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2260 );

		return pClassPointer;
	};

	void eventDestroyed ( );
	void eventDestroyIt ( unsigned long bSkipFx );
	void Cleanup ( );
	void UntrackAllTracked ( );
	void UntrackActorAt ( int Idx );
	void TrackActor ( class AActor* tracked );
	void eventProxyUnTouch ( class AActor* Other );
	void eventProxyTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
};

UClass* ATgDeployable_Nox_NightTerror::pClassPointer = NULL;

// Class TgGame.TgDeployable_Nox_Siphon
// 0x0014 (0x0308 - 0x02F4)
class ATgDeployable_Nox_Siphon : public ATgDeployable
{
public:
	TArray< class AActor* >                            s_AppliedList;                                    		// 0x02F4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class ATgCollisionProxy*                           s_CollisionProxy;                                 		// 0x0300 (0x0004) [0x0000000000000000]              
	unsigned long                                      bCleaningUp : 1;                                  		// 0x0304 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2261 );

		return pClassPointer;
	};

	void eventDestroyed ( );
	void eventDestroyIt ( unsigned long bSkipFx );
	void Cleanup ( );
	void eventProxyUnTouch ( class AActor* Other );
	void eventProxyTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
};

UClass* ATgDeployable_Nox_Siphon::pClassPointer = NULL;

// Class TgGame.TgDeployable_Poseidon_Kraken
// 0x0014 (0x0308 - 0x02F4)
class ATgDeployable_Poseidon_Kraken : public ATgDeployable
{
public:
	class ATgCollisionProxy*                           s_CollisionProxy;                                 		// 0x02F4 (0x0004) [0x0000000000000000]              
	TArray< class AActor* >                            s_AppliedList;                                    		// 0x02F8 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	float                                              m_fTide;                                          		// 0x0304 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2262 );

		return pClassPointer;
	};

	void ApplyInitialHit ( );
	void ApplyHit ( TArray< struct FImpactInfo >* ImpactList );
	bool ShouldHit ( class AActor* Other );
	struct FImpactInfo CalcDeviceFire ( struct FVector StartTrace, struct FVector EndTrace, TArray< struct FImpactInfo >* ImpactList );
	void eventProxyUnTouch ( class AActor* Other );
	void eventProxyTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void Cleanup ( );
	void eventDestroyed ( );
	void eventDestroyIt ( unsigned long bSkipFx );
	void DeployComplete ( );
};

UClass* ATgDeployable_Poseidon_Kraken::pClassPointer = NULL;

// Class TgGame.TgDeployable_PulseEffectVolume
// 0x0000 (0x02F4 - 0x02F4)
class ATgDeployable_PulseEffectVolume : public ATgDeployable
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2263 );

		return pClassPointer;
	};

	bool ShouldHit ( class AActor* Other );
	struct FImpactInfo CalcDeviceFire ( struct FVector StartTrace, struct FVector EndTrace, TArray< struct FImpactInfo >* ImpactList );
	void Tick ( float DeltaSeconds );
	void FindTouchingActorsFromScript ( );
};

UClass* ATgDeployable_PulseEffectVolume::pClassPointer = NULL;

// Class TgGame.TgDeployable_Ram_PickupArrow
// 0x0014 (0x0308 - 0x02F4)
class ATgDeployable_Ram_PickupArrow : public ATgDeployable
{
public:
	unsigned long                                      m_Triggered : 1;                                  		// 0x02F4 (0x0004) [0x0000000000000000] [0x00000001] 
	float                                              r_InitialMeshOffset;                              		// 0x02F8 (0x0004) [0x0000000000000020]              ( CPF_Net )
	struct FVector                                     m_TargetMeshOffset;                               		// 0x02FC (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2264 );

		return pClassPointer;
	};

	void TriggerDeployable ( class AActor* Other );
	void eventTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
};

UClass* ATgDeployable_Ram_PickupArrow::pClassPointer = NULL;

// Class TgGame.TgDeployable_Scaling
// 0x0004 (0x02F8 - 0x02F4)
class ATgDeployable_Scaling : public ATgDeployable
{
public:
	float                                              r_fScalingFactor;                                 		// 0x02F4 (0x0004) [0x0000000000000020]              ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2265 );

		return pClassPointer;
	};

	void DeployComplete ( );
};

UClass* ATgDeployable_Scaling::pClassPointer = NULL;

// Class TgGame.TgDeployable_Sol_Ult
// 0x0004 (0x02F8 - 0x02F4)
class ATgDeployable_Sol_Ult : public ATgDeployable
{
public:
	unsigned long                                      r_bPassiveStacked : 1;                            		// 0x02F4 (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2266 );

		return pClassPointer;
	};

	void DeployComplete ( );
	void ApplyHit ( TArray< struct FImpactInfo >* ImpactList );
};

UClass* ATgDeployable_Sol_Ult::pClassPointer = NULL;

// Class TgGame.TgDeployable_Sol_Whip
// 0x0000 (0x02F4 - 0x02F4)
class ATgDeployable_Sol_Whip : public ATgDeployable
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2267 );

		return pClassPointer;
	};

	void InstantFireDeployable ( );
};

UClass* ATgDeployable_Sol_Whip::pClassPointer = NULL;

// Class TgGame.TgDeployable_Sylvanus_Dev1
// 0x0008 (0x02FC - 0x02F4)
class ATgDeployable_Sylvanus_Dev1 : public ATgDeployable
{
public:
	unsigned long                                      m_bHasHit : 1;                                    		// 0x02F4 (0x0004) [0x0000000000000000] [0x00000001] 
	class ATgPawn*                                     m_OwningPawn;                                     		// 0x02F8 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2268 );

		return pClassPointer;
	};

	void Cleanup ( );
	void eventDestroyed ( );
	void eventDestroyIt ( unsigned long bSkipFx );
	void ApplyHit ( TArray< struct FImpactInfo >* ImpactList );
};

UClass* ATgDeployable_Sylvanus_Dev1::pClassPointer = NULL;

// Class TgGame.TgDeployable_Sylvanus_Sub1
// 0x002C (0x0320 - 0x02F4)
class ATgDeployable_Sylvanus_Sub1 : public ATgDeployable
{
public:
	class ATgPawn*                                     m_OwningPawn;                                     		// 0x02F4 (0x0004) [0x0000000000000000]              
	class UMaterialInstanceConstant*                   c_MIC;                                            		// 0x02F8 (0x0004) [0x0000000000000000]              
	float                                              m_SecondsSinceDeployed;                           		// 0x02FC (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bFullyDeployed : 1;                             		// 0x0300 (0x0004) [0x0000000000000000] [0x00000001] 
	TArray< class AActor* >                            s_ApplyList;                                      		// 0x0304 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class AActor* >                            s_AppliedList;                                    		// 0x0310 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class ATgCollisionProxy*                           s_CollisionProxy;                                 		// 0x031C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2269 );

		return pClassPointer;
	};

	void Cleanup ( );
	void eventDestroyed ( );
	void eventDestroyIt ( unsigned long bSkipFx );
	void eventTakeDamage ( int Damage, class AController* EventInstigator, struct FVector HitLocation, struct FVector Momentum, class UClass* DamageType, struct FTraceHitInfo HitInfo, class AActor* DamageCauser );
	void eventProxyUnTouch ( class AActor* Other );
	void eventHandleTouch ( class AActor* Other );
	void eventProxyTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void DeployComplete ( );
	void Tick ( float DeltaSeconds );
	void eventInitializeMIC ( );
	bool IsInvisible ( class AActor* TestActor );
};

UClass* ATgDeployable_Sylvanus_Sub1::pClassPointer = NULL;

// Class TgGame.TgDeployable_Ward
// 0x002C (0x0320 - 0x02F4)
class ATgDeployable_Ward : public ATgDeployable
{
public:
	float                                              s_MinimapDetectionRange;                          		// 0x02F4 (0x0004) [0x0000000000000000]              
	unsigned long                                      s_bRequireLOS : 1;                                		// 0x02F8 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_Initialized : 1;                                		// 0x02F8 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      r_bVisibleToEnemies : 1;                          		// 0x02F8 (0x0004) [0x0000000000000020] [0x00000004] ( CPF_Net )
	unsigned long                                      m_bRevealOtherWards : 1;                          		// 0x02F8 (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      m_bMustBeRevealed : 1;                            		// 0x02F8 (0x0004) [0x0000000000000000] [0x00000010] 
	unsigned long                                      m_bStatTrack : 1;                                 		// 0x02F8 (0x0004) [0x0000000000000000] [0x00000020] 
	unsigned long                                      r_bTeleportIncoming : 1;                          		// 0x02F8 (0x0004) [0x0000000000000020] [0x00000040] ( CPF_Net )
	unsigned long                                      r_bBeingTouched : 1;                              		// 0x02F8 (0x0004) [0x0000000000000020] [0x00000080] ( CPF_Net )
	unsigned long                                      r_bInitiallyVisible : 1;                          		// 0x02F8 (0x0004) [0x0000000000000020] [0x00000100] ( CPF_Net )
	int                                                r_nPhysTriggerType;                               		// 0x02FC (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nIncomingAttackDirection;                       		// 0x0300 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                s_nTeleportsIncoming;                             		// 0x0304 (0x0004) [0x0000000000000000]              
	class UTgAnimNodeSlot*                             m_FullBodyAnimNode;                               		// 0x0308 (0x0004) [0x0000000000000000]              
	float                                              m_nInitialVisibility;                             		// 0x030C (0x0004) [0x0000000000000000]              
	int                                                m_nOdyssey2017LevelMap[ 0x4 ];                    		// 0x0310 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2270 );

		return pClassPointer;
	};

	void HidePostSetup ( );
	bool StopsProjectile ( class AProjectile* P );
	void PlayDamageAnim ( int Dir );
	void eventTakeDamage ( int Damage, class AController* EventInstigator, struct FVector HitLocation, struct FVector Momentum, class UClass* DamageType, struct FTraceHitInfo HitInfo, class AActor* DamageCauser );
	void eventUnTouch ( class AActor* Other );
	void eventTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void UpdateTeleportFX ( );
	void eventUpdateClientVisibility ( );
	void RemoveIncomingTeleport ( );
	void AddIncomingTeleport ( );
	void DeployComplete ( );
	bool IsTriggerType ( int nPhysType );
	void eventSetVisibleToEnemies ( unsigned long Value );
	void eventInitReplicationInfo ( );
	void eventStartDeploy ( );
	void eventPostBeginPlay ( );
	bool eventCanApplyEffects ( );
	void eventDestroyIt ( unsigned long bSkipFx );
	void eventReplicatedEvent ( struct FName VarName );
	void CreditKill ( class AController* PC );
	void SetMinimapDetectionRange ( float MinimapDetectionRange );
	void NotifyGroupChanged ( );
	bool IsInvisible ( class AActor* TestActor );
};

UClass* ATgDeployable_Ward::pClassPointer = NULL;

// Class TgGame.TgDeployable_AhMuzenCab_Hive
// 0x001C (0x033C - 0x0320)
class ATgDeployable_AhMuzenCab_Hive : public ATgDeployable_Ward
{
public:
	TArray< class AActor* >                            s_AppliedList;                                    		// 0x0320 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class ATgCollisionProxy*                           s_CollisionProxy;                                 		// 0x032C (0x0004) [0x0000000000000000]              
	TArray< class ATgPawn_AhMuzenCab_BeeFlock* >       m_BeeFlocks;                                      		// 0x0330 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2271 );

		return pClassPointer;
	};

	void Cleanup ( );
	void eventDestroyed ( );
	void eventDestroyIt ( unsigned long bSkipFx );
	void eventProxyUnTouch ( class AActor* Other );
	void eventProxyTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void DeployComplete ( );
	void CreditKill ( class AController* PC );
	bool IsInvisible ( class AActor* TestActor );
	void SpawnNewBeeFlock ( );
};

UClass* ATgDeployable_AhMuzenCab_Hive::pClassPointer = NULL;

// Class TgGame.TgDeployable_Artemis_Trap
// 0x0018 (0x0338 - 0x0320)
class ATgDeployable_Artemis_Trap : public ATgDeployable_Ward
{
public:
	unsigned long                                      r_IsTriggered : 1;                                		// 0x0320 (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )
	class ATgPawn*                                     m_TargetPawn;                                     		// 0x0324 (0x0004) [0x0000000000000000]              
	float                                              m_fMaxPullSpeed;                                  		// 0x0328 (0x0004) [0x0000000000000000]              
	float                                              c_Opacity;                                        		// 0x032C (0x0004) [0x0000000000000000]              
	class UMaterialInstanceConstant*                   c_MIC;                                            		// 0x0330 (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                m_HiddenFx;                                       		// 0x0334 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2272 );

		return pClassPointer;
	};

	void eventDestroyed ( );
	void eventDestroyIt ( unsigned long bSkipFx );
	void OnTeleportNotify ( class AActor* TeleportingActor );
	bool ContinuePulling ( class ATgPawn* Other );
	void PullTargetIntoTrap ( );
	void TriggerUpon ( class AActor* Other );
	void eventTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void Tick ( float DeltaSeconds );
	void eventInitializeHiddenFx ( );
	void eventInitializeMIC ( );
	void eventReplicatedEvent ( struct FName VarName );
};

UClass* ATgDeployable_Artemis_Trap::pClassPointer = NULL;

// Class TgGame.TgDeployable_Isis_CircleOfProtection
// 0x0024 (0x0344 - 0x0320)
class ATgDeployable_Isis_CircleOfProtection : public ATgDeployable_Ward
{
public:
	TArray< class AActor* >                            ActorsWithEffects;                                		// 0x0320 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	unsigned long                                      bHasFired : 1;                                    		// 0x032C (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	float                                              CurrentChargePool;                                		// 0x0330 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              r_CurrentChargeValue;                             		// 0x0334 (0x0004) [0x0000000000002020]              ( CPF_Net | CPF_Transient )
	int                                                r_MaxChargeValue;                                 		// 0x0338 (0x0004) [0x0000000000002020]              ( CPF_Net | CPF_Transient )
	int                                                CurrentChargeStep;                                		// 0x033C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class ATgCollisionProxy_PawnListener*              CollisionProxyListener;                           		// 0x0340 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2273 );

		return pClassPointer;
	};

	void eventSetVisibleToEnemies ( unsigned long Value );
	void eventInitReplicationInfo ( );
	void Cleanup ( );
	void DeviceFired ( );
	void FireAmmunitionDeployable ( );
	void eventDestroyed ( );
	void eventDestroyIt ( unsigned long SkipFx );
	void eventTick ( float DeltaSeconds );
	void UpdateChargeFx ( );
	void eventPostDemoRewind ( );
	void eventCollisionProxyOnPawnDamaged ( class ATgPawn* Other, struct FOnDamagedParams* DamageParams );
	void eventCollisionProxyOnUnTouch ( class AActor* Other );
	void eventCollisionProxyOnTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void DeployComplete ( );
	void eventReplicatedEvent ( struct FName VarName );
	int GetDisplayMaxHealth ( );
	int GetDisplayHealth ( );
	void UpdateHealth ( );
	struct FVector GetHudOverlayLocation ( );
};

UClass* ATgDeployable_Isis_CircleOfProtection::pClassPointer = NULL;

// Class TgGame.TgDeployable_Portal
// 0x0004 (0x0324 - 0x0320)
class ATgDeployable_Portal : public ATgDeployable_Ward
{
public:
	unsigned long                                      r_bPortalActive : 1;                              		// 0x0320 (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2274 );

		return pClassPointer;
	};

	void eventPostDemoRewind ( );
	void DestroyIt ( unsigned long bSkipFx );
	void UpdatePortalVisuals ( );
	void eventReplicatedEvent ( struct FName VarName );
	void SetPortalActive ( unsigned long bActive );
	void DeployComplete ( );
	void CalcDeployPercentage ( );
	void UpdateMICState ( );
};

UClass* ATgDeployable_Portal::pClassPointer = NULL;

// Class TgGame.TgDeployable_GatewayEntrance
// 0x0004 (0x0328 - 0x0324)
class ATgDeployable_GatewayEntrance : public ATgDeployable_Portal
{
public:
	class ATgDevice_Gateway*                           m_ownerGateway;                                   		// 0x0324 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2275 );

		return pClassPointer;
	};

	void eventTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void Destroyed ( );
	void DestroyIt ( unsigned long bSkipFx );
	void DeployComplete ( );
	void eventStartDeploy ( );
};

UClass* ATgDeployable_GatewayEntrance::pClassPointer = NULL;

// Class TgGame.TgDeployable_GatewayExit
// 0x0004 (0x0328 - 0x0324)
class ATgDeployable_GatewayExit : public ATgDeployable_Portal
{
public:
	class ATgDevice_Gateway*                           m_ownerGateway;                                   		// 0x0324 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2276 );

		return pClassPointer;
	};

	void Destroyed ( );
	void DestroyIt ( unsigned long bSkipFx );
	void eventStartDeploy ( );
};

UClass* ATgDeployable_GatewayExit::pClassPointer = NULL;

// Class TgGame.TgDeployable_PortalEntrance
// 0x0014 (0x0338 - 0x0324)
class ATgDeployable_PortalEntrance : public ATgDeployable_Portal
{
public:
	class ATgDeployable_PortalExit*                    s_Exit;                                           		// 0x0324 (0x0004) [0x0000000000000000]              
	TArray< struct FPortalTimer >                      s_TouchingPawns;                                  		// 0x0328 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	unsigned long                                      s_bTeleportsAllowed : 1;                          		// 0x0334 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2277 );

		return pClassPointer;
	};

	void DestroyIt ( unsigned long bSkipFx );
	void PortalCooldown ( );
	void TriggerPortal ( class ATgPawn* P );
	void Tick ( float fDeltaTime );
	void eventUnTouch ( class AActor* Other );
	void eventTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
};

UClass* ATgDeployable_PortalEntrance::pClassPointer = NULL;

// Class TgGame.TgDeployable_PortalExit
// 0x0004 (0x0328 - 0x0324)
class ATgDeployable_PortalExit : public ATgDeployable_Portal
{
public:
	class ATgDeployable_PortalEntrance*                s_Entrance;                                       		// 0x0324 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2278 );

		return pClassPointer;
	};

	void Destroyed ( );
	void DestroyIt ( unsigned long bSkipFx );
	void eventDeployComplete ( );
	void eventStartDeploy ( );
	void DestroyEntrance ( );
	void SpawnEntrance ( );
};

UClass* ATgDeployable_PortalExit::pClassPointer = NULL;

// Class TgGame.TgDeployable_PortalSiegeGame
// 0x0018 (0x033C - 0x0324)
class ATgDeployable_PortalSiegeGame : public ATgDeployable_Portal
{
public:
	float                                              s_fPortalTriggerTime;                             		// 0x0324 (0x0004) [0x0000000000000002]              ( CPF_Const )
	float                                              s_fPortalReuseDelay;                              		// 0x0328 (0x0004) [0x0000000000000002]              ( CPF_Const )
	TArray< struct FPortalTimer >                      s_TouchingPawns;                                  		// 0x032C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	unsigned long                                      s_bTeleportsAllowed : 1;                          		// 0x0338 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      c_bCooldownEffectsActive : 1;                     		// 0x0338 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      c_bPortalCooldownEffectsInitialized : 1;          		// 0x0338 (0x0004) [0x0000000000000000] [0x00000004] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2279 );

		return pClassPointer;
	};

	void PortalCooldown ( );
	void TriggerPortal ( class ATgPawn* P );
	void SetPortalActive ( unsigned long bActive );
	class ATgPawn* UpdateActiveState ( );
	void UpdatePortalVisuals ( );
	void Tick ( float fDeltaTime );
	void eventHandleUnTouch ( class AActor* Other );
	void eventHandleTouch ( class AActor* Other );
	void eventUnTouch ( class AActor* Other );
	void eventTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void DestroyIt ( unsigned long bSkipFx );
	void eventDeployComplete ( );
	bool CanTeleportNow ( class AActor* Traveler );
	bool CanTeleport ( class AActor* Traveler );
	bool CalcTeleportLocation ( class AActor* Traveler, class AActor* DestinationActor, struct FVector* BestLocation );
};

UClass* ATgDeployable_PortalSiegeGame::pClassPointer = NULL;

// Class TgGame.TgDeployable_ScyllaWard
// 0x0008 (0x0328 - 0x0320)
class ATgDeployable_ScyllaWard : public ATgDeployable_Ward
{
public:
	class UMeshComponent*                              m_OverlayMesh;                                    		// 0x0320 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class UMaterialInstanceConstant*                   m_OverlayMIC;                                     		// 0x0324 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2280 );

		return pClassPointer;
	};

};

UClass* ATgDeployable_ScyllaWard::pClassPointer = NULL;

// Class TgGame.TgDeployable_TriggerableWard
// 0x001C (0x033C - 0x0320)
class ATgDeployable_TriggerableWard : public ATgDeployable_Ward
{
public:
	class ATgCollisionProxy_WardTrigger*               m_TriggerCollisionProxy;                          		// 0x0320 (0x0004) [0x0000000000000000]              
	float                                              m_TriggerRange;                                   		// 0x0324 (0x0004) [0x0000000000000000]              
	unsigned long                                      r_IsTriggered : 1;                                		// 0x0328 (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )
	unsigned long                                      m_bApplyRevealEffectOnTrigger : 1;                		// 0x0328 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_bRevealOnlyOnTrigger : 1;                       		// 0x0328 (0x0004) [0x0000000000000000] [0x00000004] 
	float                                              m_TriggeredLifetime;                              		// 0x032C (0x0004) [0x0000000000000000]              
	TArray< class ATgRepInfo_Player* >                 m_PotentialTriggers;                              		// 0x0330 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2281 );

		return pClassPointer;
	};

	void Destroyed ( );
	void DeployComplete ( );
	void Tick ( float DeltaSeconds );
	void eventTriggerCollisionProxyUnTouch ( class AActor* Other );
	void eventTriggerCollisionProxyTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	bool CanTriggerWardNow ( class ATgRepInfo_Player* PRI );
	void DoTrigger ( class ATgRepInfo_Player* TriggererPRI );
	void eventInitReplicationInfo ( );
};

UClass* ATgDeployable_TriggerableWard::pClassPointer = NULL;

// Class TgGame.TgDeploy_Arachne_Broodlings
// 0x0000 (0x033C - 0x033C)
class ATgDeploy_Arachne_Broodlings : public ATgDeployable_TriggerableWard
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2282 );

		return pClassPointer;
	};

	void eventTakeDamage ( int Damage, class AController* EventInstigator, struct FVector HitLocation, struct FVector Momentum, class UClass* DamageType, struct FTraceHitInfo HitInfo, class AActor* DamageCauser );
	void DoTrigger ( class ATgRepInfo_Player* TriggererPRI );
	bool IsInvisible ( class AActor* TestActor );
	void SpawnBroodlings ( class ATgRepInfo_Player* TriggererPRI );
};

UClass* ATgDeploy_Arachne_Broodlings::pClassPointer = NULL;

// Class TgGame.TgDeployable_WardSentry
// 0x0000 (0x0320 - 0x0320)
class ATgDeployable_WardSentry : public ATgDeployable_Ward
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2283 );

		return pClassPointer;
	};

};

UClass* ATgDeployable_WardSentry::pClassPointer = NULL;

// Class TgGame.TgDeployable_WayPoint
// 0x0000 (0x02F4 - 0x02F4)
class ATgDeployable_WayPoint : public ATgDeployable
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2284 );

		return pClassPointer;
	};

};

UClass* ATgDeployable_WayPoint::pClassPointer = NULL;

// Class TgGame.TgDeployable_Zeus_LightningStorm
// 0x0014 (0x0308 - 0x02F4)
class ATgDeployable_Zeus_LightningStorm : public ATgDeployable
{
public:
	TArray< class AActor* >                            s_AppliedList;                                    		// 0x02F4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class ATgCollisionProxy*                           s_CollisionProxy;                                 		// 0x0300 (0x0004) [0x0000000000000000]              
	unsigned long                                      bCleaningUp : 1;                                  		// 0x0304 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2285 );

		return pClassPointer;
	};

	void eventDestroyed ( );
	void eventDestroyIt ( unsigned long bSkipFx );
	void Cleanup ( );
	void eventProxyUnTouch ( class AActor* Other );
	void eventProxyTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
};

UClass* ATgDeployable_Zeus_LightningStorm::pClassPointer = NULL;

// Class TgGame.TgProjectile
// 0x008C (0x02B8 - 0x022C)
class ATgProjectile : public AProjectile
{
public:
	class UTgDeviceFire*                               s_LastDefaultMode;                                		// 0x022C (0x0004) [0x0000000000000000]              
	int                                                r_nProjectileId;                                  		// 0x0230 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              r_fDuration;                                      		// 0x0234 (0x0004) [0x0000000000000020]              ( CPF_Net )
	unsigned long                                      m_bCanPulse : 1;                                  		// 0x0238 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      c_bSuppressExplosionFX : 1;                       		// 0x0238 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      c_bRotationFollowsVelocity : 1;                   		// 0x0238 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_bStickToWalls : 1;                              		// 0x0238 (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      m_bTrackTarget : 1;                               		// 0x0238 (0x0004) [0x0000000000000000] [0x00000010] 
	unsigned long                                      m_bTrackToWorldLocation : 1;                      		// 0x0238 (0x0004) [0x0000000000000000] [0x00000020] 
	unsigned long                                      m_bHasExploded : 1;                               		// 0x0238 (0x0004) [0x0000000000000000] [0x00000040] 
	unsigned long                                      m_bIngoreBehindProjCollisions : 1;                		// 0x0238 (0x0004) [0x0000000000000000] [0x00000080] 
	unsigned long                                      m_bIsInitialized : 1;                             		// 0x0238 (0x0004) [0x0000000000000000] [0x00000100] 
	unsigned long                                      m_bIsShutDown : 1;                                		// 0x0238 (0x0004) [0x0000000000000000] [0x00000200] 
	unsigned long                                      m_bPIEInitialized : 1;                            		// 0x0238 (0x0004) [0x0000000000000000] [0x00000400] 
	unsigned long                                      m_bHasPlayedFizzleFX : 1;                         		// 0x0238 (0x0004) [0x0000000000000000] [0x00000800] 
	unsigned long                                      m_bHasPlayedHitWallFX : 1;                        		// 0x0238 (0x0004) [0x0000000000000000] [0x00001000] 
	unsigned long                                      m_bHasPlayedHitTargetFX : 1;                      		// 0x0238 (0x0004) [0x0000000000000000] [0x00002000] 
	unsigned long                                      m_bProximityDistanceOverridesCollision : 1;       		// 0x0238 (0x0004) [0x0000000000000000] [0x00004000] 
	unsigned long                                      m_bUseProximityCollisionOnClient : 1;             		// 0x0238 (0x0004) [0x0000000000000000] [0x00008000] 
	float                                              m_fPersistTime;                                   		// 0x023C (0x0004) [0x0000000000000000]              
	float                                              m_fPersistHitPulse;                               		// 0x0240 (0x0004) [0x0000000000000000]              
	int                                                m_nTargetPhysicalType;                            		// 0x0244 (0x0004) [0x0000000000000000]              
	class UMeshComponent*                              c_Mesh;                                           		// 0x0248 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class UTgSpecialFx*                                c_ExplosionFx;                                    		// 0x024C (0x0004) [0x0000000000000000]              
	float                                              r_fAccelRate;                                     		// 0x0250 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                c_FiringOwnerStatsID;                             		// 0x0254 (0x0004) [0x0000000000000000]              
	int                                                c_FiringWeaponStatsID;                            		// 0x0258 (0x0004) [0x0000000000000000]              
	int                                                c_FiringWeaponMode;                               		// 0x025C (0x0004) [0x0000000000000000]              
	float                                              m_fTossZ;                                         		// 0x0260 (0x0004) [0x0000000000000000]              
	class AActor*                                      r_Owner;                                          		// 0x0264 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nOwnerFireModeId;                               		// 0x0268 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class UTgDeviceFire*                               s_OwnerFireMode;                                  		// 0x026C (0x0004) [0x0000000000000000]              
	float                                              r_fRange;                                         		// 0x0270 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              m_fAcquireDistance;                               		// 0x0274 (0x0004) [0x0000000000000000]              
	float                                              m_fProximityDistance;                             		// 0x0278 (0x0004) [0x0000000000000000]              
	class ATgCollisionProxy*                           m_CollisionProxy;                                 		// 0x027C (0x0004) [0x0000000000000000]              
	int                                                s_nSpawnBotId;                                    		// 0x0280 (0x0004) [0x0000000000000000]              
	int                                                s_nSpawnDeployableId;                             		// 0x0284 (0x0004) [0x0000000000000000]              
	float                                              m_fDelayTrackSeconds;                             		// 0x0288 (0x0004) [0x0000000000000000]              
	float                                              m_fDamageRadius;                                  		// 0x028C (0x0004) [0x0000000000000000]              
	struct FVector                                     r_vSpawnLocation;                                 		// 0x0290 (0x000C) [0x0000000000000020]              ( CPF_Net )
	struct FVector                                     m_vLocationLastTick;                              		// 0x029C (0x000C) [0x0000000000000000]              
	float                                              m_fMinTravelRange;                                		// 0x02A8 (0x0004) [0x0000000000000000]              
	float                                              s_fSpawnTime;                                     		// 0x02AC (0x0004) [0x0000000000000000]              
	unsigned char                                      s_nFiringInstance;                                		// 0x02B0 (0x0001) [0x0000000000000000]              
	class UDynamicLightEnvironmentComponent*           LightEnvironment;                                 		// 0x02B4 (0x0004) [0x00000000040A000B]              ( CPF_Edit | CPF_Const | CPF_ExportObject | CPF_EditConst | CPF_Component | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2286 );

		return pClassPointer;
	};

	void PlayHitTargetFX ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal, unsigned long bExploded );
	void eventPlayHitWallExplosionFX ( struct FVector HitNormal, struct FVector HitLocation );
	class UPhysicalMaterial* TraceWorldPhysicalGeometry ( struct FVector StartLoc, struct FVector EndLoc, struct FVector* TraceHitLocation );
	void PlayFizzleFX ( struct FVector HitLocation, struct FVector HitNormal, unsigned long bIsExplosionFizzle );
	void PlayLandingSound ( class AActor* LandingHitActor );
	void eventReplicatedEvent ( struct FName VarName );
	void eventServerDetonate ( );
	bool ProjectileCalcCamera ( float fDeltaTime, struct FVector* out_CamLoc, struct FRotator* out_CamRot, float* out_FOV );
	void MyOnParticleSystemFinished ( class UParticleSystemComponent* PSC );
	void Destroyed ( );
	void ShowProjectile ( );
	void HideProjectile ( );
	void eventTornOff ( );
	void ShutDown ( );
	void SpawnExplosionEffects ( struct FVector HitLocation, struct FVector HitNormal );
	void eventSpawnFlightEffects ( );
	void eventExplodeOnTarget ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal );
	void eventExplode ( struct FVector HitLocation, struct FVector HitNormal );
	bool ApplyHit ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal, int HitItem );
	void CalcAoeFire ( struct FAimData Aim, TArray< struct FImpactInfo >* ImpactList );
	struct FAimData GetApplyHitAim ( );
	bool CheckTeamPassThrough ( class AActor* Other );
	void eventProxyUnTouch ( class AActor* Other );
	void eventProxyTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void ProcessTouch ( class AActor* Other, struct FVector HitLocation, struct FVector HitNormal );
	void eventProcessTouchAsEvent ( class AActor* Other, struct FVector HitLocation, struct FVector HitNormal );
	void eventFellOutOfWorld ( class UClass* dmgType );
	void eventHitWall ( struct FVector HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp );
	bool IsOutsideMinRange ( struct FVector HitLocation );
	void SetAcceleration ( );
	bool ProximityReached ( class AActor* A, struct FVector HitLocation, struct FVector HitNormal );
	void GetHitLocationForProximityTouch ( class AActor* Target, struct FVector* HitLocation, struct FVector* HitNormal );
	bool IsValidTarget ( class AActor* A );
	void RangeReached ( );
	bool CheckProjectileRange ( struct FVector vLocOverride );
	void eventInit ( struct FVector Direction );
	void eventLanded ( struct FVector HitNormal, class AActor* FloorActor );
	void TimerExplode ( );
	void TimerPulse ( );
	void eventClientSetExplode ( );
	void StartPulse ( );
	void eventPostProjectileInitialize ( );
	void PostBeginPlay ( );
	bool eventUseAOE ( );
	bool ProximityDistanceOverridesCollision ( );
	class ATgDeployable* SpawnTheDeployable ( struct FVector HitLocation, struct FVector HitNormal );
	class ATgPawn* SpawnTheBot ( struct FVector HitLocation, struct FVector HitNormal );
	void CompleteInitialization ( );
	bool CheckPhysicality ( int nPawnType );
	float GetBuffedRange ( );
};

UClass* ATgProjectile::pClassPointer = NULL;

// Class TgGame.TgProj_Bounce
// 0x000C (0x02C4 - 0x02B8)
class ATgProj_Bounce : public ATgProjectile
{
public:
	float                                              m_fMaxSpeed;                                      		// 0x02B8 (0x0004) [0x0000000000000000]              
	float                                              m_fMinSpeed;                                      		// 0x02BC (0x0004) [0x0000000000000000]              
	float                                              m_fMaxRange;                                      		// 0x02C0 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2287 );

		return pClassPointer;
	};

	void Destroyed ( );
	void eventLanded ( struct FVector HitNormal, class AActor* FloorActor );
	void AdjustedInit ( struct FVector StartLocation, struct FVector HitLocation );
	void SetSpeed ( float Distance );
	bool SuggestProjVelocity ( struct FVector End, struct FVector Start, float projSpeed, float* BaseTossZ );
	void ProcessTouch ( class AActor* Other, struct FVector HitLocation, struct FVector HitNormal );
	void eventHitWall ( struct FVector HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp );
	void MyOnParticleSystemFinished ( class UParticleSystemComponent* PSC );
};

UClass* ATgProj_Bounce::pClassPointer = NULL;

// Class TgGame.TgProj_Grapple
// 0x0030 (0x02F4 - 0x02C4)
class ATgProj_Grapple : public ATgProj_Bounce
{
public:
	class AEmitter*                                    c_GrappleEffect;                                  		// 0x02C4 (0x0004) [0x0000000000000000]              
	struct FVector                                     r_vTargetLocation;                                		// 0x02C8 (0x000C) [0x0000000000000020]              ( CPF_Net )
	struct FVector                                     m_ClimbDir;                                       		// 0x02D4 (0x000C) [0x0000000000000000]              
	struct FVector                                     m_LookDir;                                        		// 0x02E0 (0x000C) [0x0000000000000000]              
	struct FName                                       c_nmBoneName;                                     		// 0x02EC (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2288 );

		return pClassPointer;
	};

	void eventReplicatedEvent ( struct FName VarName );
	void InitGrapple ( );
	void AdjustedInit ( struct FVector StartLocation, struct FVector HitLocation );
	void PostBeginPlay ( );
};

UClass* ATgProj_Grapple::pClassPointer = NULL;

// Class TgGame.TgProj_FreeGrenade
// 0x0008 (0x02C0 - 0x02B8)
class ATgProj_FreeGrenade : public ATgProjectile
{
public:
	unsigned long                                      m_bFFTouched : 1;                                 		// 0x02B8 (0x0004) [0x0000000000000000] [0x00000001] 
	class ATgDeploy_ForceField*                        m_touchedFF;                                      		// 0x02BC (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2289 );

		return pClassPointer;
	};

	void Destroyed ( );
	void eventLanded ( struct FVector HitNormal, class AActor* FloorActor );
	void ProcessTouch ( class AActor* Other, struct FVector HitLocation, struct FVector HitNormal );
	void eventHitWall ( struct FVector HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp );
	void Timer ( );
	void ShutDown ( );
	void PostBeginPlay ( );
};

UClass* ATgProj_FreeGrenade::pClassPointer = NULL;

// Class TgGame.TgProj_Bot
// 0x0000 (0x02C0 - 0x02C0)
class ATgProj_Bot : public ATgProj_FreeGrenade
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2290 );

		return pClassPointer;
	};

	void eventHitWall ( struct FVector HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp );
	void SpawnExplosionEffects ( struct FVector HitLocation, struct FVector HitNormal );
	void SpawnTheBotOld ( struct FVector HitLocation, class AActor* TargetActor );
	class ATgPawn* SpawnBot ( struct FVector vLocation );
};

UClass* ATgProj_Bot::pClassPointer = NULL;

// Class TgGame.TgProj_Deployable
// 0x0000 (0x02C0 - 0x02C0)
class ATgProj_Deployable : public ATgProj_FreeGrenade
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2291 );

		return pClassPointer;
	};

	void RangeReached ( );
	void ServerDetonate ( );
	void eventHitWall ( struct FVector HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp );
	void SpawnTheDeployableOld ( struct FVector HitLocation, class AActor* TargetActor, struct FVector HitNormal );
	class ATgDeployable* SpawnDeployable ( struct FVector vLocation, class AActor* TargetActor, struct FVector vNormal );
};

UClass* ATgProj_Deployable::pClassPointer = NULL;

// Class TgGame.TgProj_Mortar
// 0x0000 (0x02C0 - 0x02C0)
class ATgProj_Mortar : public ATgProj_FreeGrenade
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2292 );

		return pClassPointer;
	};

	void ProcessTouch ( class AActor* Other, struct FVector HitLocation, struct FVector HitNormal );
	void eventHitWall ( struct FVector HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp );
};

UClass* ATgProj_Mortar::pClassPointer = NULL;

// Class TgGame.TgProj_Missile
// 0x0038 (0x02F0 - 0x02B8)
class ATgProj_Missile : public ATgProjectile
{
public:
	float                                              m_fDefaultExplosionRange;                         		// 0x02B8 (0x0004) [0x0000000000000000]              
	struct FVector                                     m_vInitialDir;                                    		// 0x02BC (0x000C) [0x0000000000000000]              
	struct FVector                                     m_vInitialPos;                                    		// 0x02C8 (0x000C) [0x0000000000000000]              
	class AActor*                                      r_aSeeking;                                       		// 0x02D4 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nNumBounces;                                    		// 0x02D8 (0x0004) [0x0000000000000020]              ( CPF_Net )
	struct FVector                                     r_vTargetWorldLocation;                           		// 0x02DC (0x000C) [0x0000000000000020]              ( CPF_Net )
	unsigned long                                      s_bInitializedSeekingWorldLocation : 1;           		// 0x02E8 (0x0004) [0x0000000000000000] [0x00000001] 
	class UStaticMeshComponent*                        c_PhotonMesh;                                     		// 0x02EC (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2293 );

		return pClassPointer;
	};

	void eventReplicatedEvent ( struct FName VarName );
	class ATgPlayerController* GetLocalPlayerPawn ( );
	void ShutDown ( );
	void eventHitWall ( struct FVector HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp );
	void eventLanded ( struct FVector HitNormal, class AActor* FloorActor );
	void CheckAcquireRange ( );
	void CheckSeekingTarget ( );
	void PostBeginPlay ( );
	void CheckRange ( );
	void SetInitSeekingTarget ( class AActor* LockedTarget );
	void eventSetInitialState ( );
};

UClass* ATgProj_Missile::pClassPointer = NULL;

// Class TgGame.TgProj_Rocket
// 0x002C (0x02E4 - 0x02B8)
class ATgProj_Rocket : public ATgProjectile
{
public:
	unsigned char                                      FlockIndex;                                       		// 0x02B8 (0x0001) [0x0000000000000020]              ( CPF_Net )
	class ATgProj_Rocket*                              Flock[ 0x2 ];                                     		// 0x02BC (0x0008) [0x0000000000000000]              
	float                                              FlockRadius;                                      		// 0x02C4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              FlockStiffness;                                   		// 0x02C8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              FlockMaxForce;                                    		// 0x02CC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              FlockCurlForce;                                   		// 0x02D0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      bCurl : 1;                                        		// 0x02D4 (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )
	struct FVector                                     Dir;                                              		// 0x02D8 (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2294 );

		return pClassPointer;
	};

	void FlockTimer ( );
	void eventReplicatedEvent ( struct FName VarName );
	void Destroyed ( );
	void Init ( struct FVector Direction );
};

UClass* ATgProj_Rocket::pClassPointer = NULL;

// Class TgGame.TgProj_Simulated
// 0x0014 (0x02CC - 0x02B8)
class ATgProj_Simulated : public ATgProjectile
{
public:
	unsigned long                                      m_bHasFlashedShutdown : 1;                        		// 0x02B8 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bHasFlashExploded : 1;                          		// 0x02B8 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_bForceInterested : 1;                           		// 0x02B8 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_bForceRangeInterestCheck : 1;                   		// 0x02B8 (0x0004) [0x0000000000000000] [0x00000008] 
	int                                                m_nProjectileInstanceId;                          		// 0x02BC (0x0004) [0x0000000000000000]              
	TArray< class ATgPlayerController* >               s_InterestedPlayers;                              		// 0x02C0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2295 );

		return pClassPointer;
	};

	void eventSetTarget ( class AActor* TargetActor, struct FVector TargetLocation );
	void eventClientTargetUpdate ( class AActor* TargetActor, struct FVector TargetLocation );
	void eventHitWall ( struct FVector HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp );
	bool ApplyHit ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal, int HitItem );
	bool CheckProjectileRange ( struct FVector vLocOverride );
	void Tick ( float DeltaSeconds );
	void Destroyed ( );
	void ShutDown ( );
	void eventClientHitUpdate ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal );
	void eventExplodeOnTarget ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal );
	void eventClientExplode ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal );
	void eventExplode ( struct FVector HitLocation, struct FVector HitNormal );
	void FlashNotifyTarget ( class AActor* TargetActor, struct FVector TargetLocation );
	void FlashNotifyHitWall ( class AActor* Wall, struct FVector HitNormal, struct FVector HitLocation );
	void FlashNotifyHit ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal );
	void FlashNotifyExploded ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal );
	void FlashNotifyShutdown ( );
	void FlashNotifySpawn ( );
	void CompleteInitialization ( );
};

UClass* ATgProj_Simulated::pClassPointer = NULL;

// Class TgGame.TgProj_AhPuch_Dev1
// 0x000C (0x02D8 - 0x02CC)
class ATgProj_AhPuch_Dev1 : public ATgProj_Simulated
{
public:
	struct FVector                                     m_vMeshTranslationOffset;                         		// 0x02CC (0x000C) [0x0000000000000002]              ( CPF_Const )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2296 );

		return pClassPointer;
	};

	void Destroyed ( );
	void ShutDown ( );
	void CalcAoeFire ( struct FAimData Aim, TArray< struct FImpactInfo >* ImpactList );
	void eventExplodeOnTarget ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal );
	void NativeCalcAoeFire ( struct FAimData Aim, TArray< struct FImpactInfo >* ImpactList );
	void ArrangeDeployables ( struct FVector HitLocation );
};

UClass* ATgProj_AhPuch_Dev1::pClassPointer = NULL;

// Class TgGame.TgProj_Anhur_Spear
// 0x0008 (0x02D4 - 0x02CC)
class ATgProj_Anhur_Spear : public ATgProj_Simulated
{
public:
	float                                              m_RollVariance;                                   		// 0x02CC (0x0004) [0x0000000000000000]              
	float                                              m_fPitchOffset;                                   		// 0x02D0 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2297 );

		return pClassPointer;
	};

	void PostBeginPlay ( );
	bool IsOutsideMinRange ( struct FVector HitLocation );
	float GetGravityZ ( );
	void Init ( struct FVector Direction );
};

UClass* ATgProj_Anhur_Spear::pClassPointer = NULL;

// Class TgGame.TgProj_Anhur_ImpalingSpear
// 0x0010 (0x02E4 - 0x02D4)
class ATgProj_Anhur_ImpalingSpear : public ATgProj_Anhur_Spear
{
public:
	unsigned long                                      m_bInitialHit : 1;                                		// 0x02D4 (0x0004) [0x0000000000000000] [0x00000001] 
	TArray< class AActor* >                            m_PreviouslyHitTargets;                           		// 0x02D8 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2298 );

		return pClassPointer;
	};

	void HitTarget ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal );
	void ProcessTouch ( class AActor* Other, struct FVector HitLocation, struct FVector HitNormal );
	void PerformWallKnockback ( class ATgPawn* HitActor, struct FVector HitLocation, struct FVector HitNormal );
};

UClass* ATgProj_Anhur_ImpalingSpear::pClassPointer = NULL;

// Class TgGame.TgProj_Anhur_SpearVolley
// 0x0010 (0x02E4 - 0x02D4)
class ATgProj_Anhur_SpearVolley : public ATgProj_Anhur_Spear
{
public:
	unsigned long                                      m_bInitialHit : 1;                                		// 0x02D4 (0x0004) [0x0000000000000000] [0x00000001] 
	TArray< class AActor* >                            m_PreviouslyHitTargets;                           		// 0x02D8 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2299 );

		return pClassPointer;
	};

	void HitTarget ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal );
	void ProcessTouch ( class AActor* Other, struct FVector HitLocation, struct FVector HitNormal );
};

UClass* ATgProj_Anhur_SpearVolley::pClassPointer = NULL;

// Class TgGame.TgProj_Arachne_Web
// 0x0000 (0x02CC - 0x02CC)
class ATgProj_Arachne_Web : public ATgProj_Simulated
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2300 );

		return pClassPointer;
	};

	void eventExplodeOnTarget ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal );
	void RangeReached ( );
	void eventHitWall ( struct FVector HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp );
	struct FVector GetDeployablePlacement ( struct FVector HitLoc );
};

UClass* ATgProj_Arachne_Web::pClassPointer = NULL;

// Class TgGame.TgProj_Cabrakan_Dev4_Ult
// 0x0010 (0x02DC - 0x02CC)
class ATgProj_Cabrakan_Dev4_Ult : public ATgProj_Simulated
{
public:
	unsigned long                                      m_bInitialHit : 1;                                		// 0x02CC (0x0004) [0x0000000000000000] [0x00000001] 
	TArray< class AActor* >                            m_PreviouslyHitTargets;                           		// 0x02D0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2301 );

		return pClassPointer;
	};

	void ShutDown ( );
	void eventExplodeOnTarget ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal );
	void HitTarget ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal );
	void ProcessTouch ( class AActor* Other, struct FVector HitLocation, struct FVector HitNormal );
};

UClass* ATgProj_Cabrakan_Dev4_Ult::pClassPointer = NULL;

// Class TgGame.TgProj_Cocoon
// 0x0000 (0x02CC - 0x02CC)
class ATgProj_Cocoon : public ATgProj_Simulated
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2302 );

		return pClassPointer;
	};

	void eventClientExplode ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal );
	void eventSpawnFlightEffects ( );
};

UClass* ATgProj_Cocoon::pClassPointer = NULL;

// Class TgGame.TgProj_Cupid_HeartBomb
// 0x0004 (0x02D0 - 0x02CC)
class ATgProj_Cupid_HeartBomb : public ATgProj_Simulated
{
public:
	int                                                s_LovestruckCount;                                		// 0x02CC (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2303 );

		return pClassPointer;
	};

	bool ApplyHit ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal, int HitItem );
};

UClass* ATgProj_Cupid_HeartBomb::pClassPointer = NULL;

// Class TgGame.TgProj_Isis_SpiritBall
// 0x0000 (0x02CC - 0x02CC)
class ATgProj_Isis_SpiritBall : public ATgProj_Simulated
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2304 );

		return pClassPointer;
	};

	void Destroyed ( );
	void ShutDown ( );
	void RangeReached ( );
	void eventPostProjectileInitialize ( );
};

UClass* ATgProj_Isis_SpiritBall::pClassPointer = NULL;

// Class TgGame.TgProj_Medusa_Dev2
// 0x0000 (0x02CC - 0x02CC)
class ATgProj_Medusa_Dev2 : public ATgProj_Simulated
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2305 );

		return pClassPointer;
	};

	void SpawnExplosionEffects ( struct FVector HitLocation, struct FVector HitNormal );
	void SpawnTheDeployableSpecial ( struct FVector HitLocation, class AActor* TargetActor, struct FVector HitNormal );
	bool ApplyHit ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal, int HitItem );
	bool ProximityReached ( class AActor* A, struct FVector HitLocation, struct FVector HitNormal );
	bool IsValidTarget ( class AActor* A );
	class ATgDeployable* SpawnDeployable ( struct FVector vLocation, class AActor* TargetActor, struct FVector vNormal );
};

UClass* ATgProj_Medusa_Dev2::pClassPointer = NULL;

// Class TgGame.TgProj_Mercury_Num1
// 0x0028 (0x02F4 - 0x02CC)
class ATgProj_Mercury_Num1 : public ATgProj_Simulated
{
public:
	struct FVector                                     m_vSourceLocation;                                		// 0x02CC (0x000C) [0x0000000000000000]              
	struct FVector                                     m_vTargetLocation;                                		// 0x02D8 (0x000C) [0x0000000000000000]              
	float                                              m_fTotalToTargetTime;                             		// 0x02E4 (0x0004) [0x0000000000000000]              
	float                                              m_fRemainingToTargetTime;                         		// 0x02E8 (0x0004) [0x0000000000000000]              
	float                                              m_fTotalToMercuryTime;                            		// 0x02EC (0x0004) [0x0000000000000000]              
	float                                              m_fRemainingToMercuryTime;                        		// 0x02F0 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2306 );

		return pClassPointer;
	};

	bool CheckProjectileRange ( struct FVector vLocOverride );
	void eventSetTarget ( class AActor* TargetActor, struct FVector TargetLocation );
	void Tick ( float fDeltaTime );
};

UClass* ATgProj_Mercury_Num1::pClassPointer = NULL;

// Class TgGame.TgProj_Poseidon_TridentShot
// 0x0008 (0x02D4 - 0x02CC)
class ATgProj_Poseidon_TridentShot : public ATgProj_Simulated
{
public:
	float                                              m_fTide;                                          		// 0x02CC (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bApplyItemEffects : 1;                          		// 0x02D0 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2307 );

		return pClassPointer;
	};

	bool ApplyHit ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal, int HitItem );
};

UClass* ATgProj_Poseidon_TridentShot::pClassPointer = NULL;

// Class TgGame.TgProj_Raijin_RaijuuSeeking
// 0x0038 (0x0304 - 0x02CC)
class ATgProj_Raijin_RaijuuSeeking : public ATgProj_Simulated
{
public:
	struct FPointer                                    VfTable_ITgProjGroundTargetInterface;             		// 0x02CC (0x0004) [0x0000000000801002]              ( CPF_Const | CPF_Native | CPF_NoExport )
	float                                              m_fTurnStrength;                                  		// 0x02D0 (0x0004) [0x0000000000000000]              
	float                                              m_fVertTurnStrength;                              		// 0x02D4 (0x0004) [0x0000000000000000]              
	struct FRotator                                    m_SeekingRotation;                                		// 0x02D8 (0x000C) [0x0000000000000000]              
	class UTgAnimNodeBlendList*                        m_AttackBlendList;                                		// 0x02E4 (0x0004) [0x0000000000000000]              
	class ATgSkeletalMeshActor*                        m_WarningFxMesh;                                  		// 0x02E8 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bGroundTargetReached : 1;                       		// 0x02EC (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bRaijuuTargetFound : 1;                         		// 0x02EC (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_bDeployedOnActorTarget : 1;                     		// 0x02EC (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_bInitialHit : 1;                                		// 0x02EC (0x0004) [0x0000000000000000] [0x00000008] 
	struct FVector                                     m_GroundTargetLocation;                           		// 0x02F0 (0x000C) [0x0000000000000000]              
	class AActor*                                      m_ActorTarget;                                    		// 0x02FC (0x0004) [0x0000000000000000]              
	float                                              m_fLastHitTime;                                   		// 0x0300 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2308 );

		return pClassPointer;
	};

	void ShutDown ( );
	void PlayFizzleFX ( struct FVector HitLocation, struct FVector HitNormal, unsigned long bIsExplosionFizzle );
	void eventExplodeOnTarget ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal );
	void eventHitWall ( struct FVector HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp );
	void ProcessTouch ( class AActor* Other, struct FVector HitLocation, struct FVector HitNormal );
	void DeployRaijuu ( class AActor* ActorTarget );
	void SetActorTarget ( class AActor* ActorTarget );
	void eventSetGroundTarget ( struct FVector GTLocation );
	void eventClientTargetUpdate ( class AActor* TargetActor, struct FVector TargetLocation );
	bool CalcRaijuuAoe ( struct FAimData Aim, class AActor** EnemyTarget );
	struct FVector eventGetActorSeekLocation ( class AActor* ActorTarget );
	void UpdateActorTargetSeekingDirection ( float fDeltaTime );
	void UpdateGroundTargetSeekingDirection ( float fDeltaTime );
	bool CheckProjectileRange ( struct FVector vLocOverride );
	bool CheckProjectileRangeSpecial ( struct FVector vLocOverride );
	bool CheckActorTargetDistance ( struct FVector vLocOverride );
	bool CheckGroundTargetDistance ( struct FVector vLocOverride );
	void ActorTargetReached ( );
	void GroundTargetReached ( );
	void Tick ( float fDeltaTime );
	void eventPostInitAnimTree ( class USkeletalMeshComponent* SkelComp );
	void PlayAttackAnim ( );
	void UpdateVisualsOnSetGroundTarget ( );
	void CompleteInitialization ( );
};

UClass* ATgProj_Raijin_RaijuuSeeking::pClassPointer = NULL;

// Class TgGame.TgProj_Ravana_Dev4
// 0x0010 (0x02DC - 0x02CC)
class ATgProj_Ravana_Dev4 : public ATgProj_Simulated
{
public:
	unsigned long                                      m_bInitialHit : 1;                                		// 0x02CC (0x0004) [0x0000000000000000] [0x00000001] 
	TArray< class AActor* >                            m_PreviouslyHitTargets;                           		// 0x02D0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2309 );

		return pClassPointer;
	};

	void HitTarget ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal );
	void ProcessTouch ( class AActor* Other, struct FVector HitLocation, struct FVector HitNormal );
	void PerformWallKnockback ( class ATgPawn* HitActor, struct FVector HitLocation, struct FVector HitNormal );
};

UClass* ATgProj_Ravana_Dev4::pClassPointer = NULL;

// Class TgGame.TgProj_Scylla_Num1
// 0x0000 (0x02CC - 0x02CC)
class ATgProj_Scylla_Num1 : public ATgProj_Simulated
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2310 );

		return pClassPointer;
	};

	void SpawnClientEffects ( );
};

UClass* ATgProj_Scylla_Num1::pClassPointer = NULL;

// Class TgGame.TgProj_SimulatedGroundTarget
// 0x001C (0x02E8 - 0x02CC)
class ATgProj_SimulatedGroundTarget : public ATgProj_Simulated
{
public:
	struct FPointer                                    VfTable_ITgProjGroundTargetInterface;             		// 0x02CC (0x0004) [0x0000000000801002]              ( CPF_Const | CPF_Native | CPF_NoExport )
	struct FVector                                     m_GroundTargetLocation;                           		// 0x02D0 (0x000C) [0x0000000000000000]              
	float                                              m_fGravityMultipler;                              		// 0x02DC (0x0004) [0x0000000000000000]              
	float                                              m_fPredictedTravelTime;                           		// 0x02E0 (0x0004) [0x0000000000000000]              
	class ATgSkeletalMeshActor*                        m_WarningFxMesh;                                  		// 0x02E4 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2311 );

		return pClassPointer;
	};

	void PlayFizzleFX ( struct FVector HitLocation, struct FVector HitNormal, unsigned long bIsExplosionFizzle );
	void SpawnExplosionEffects ( struct FVector HitLocation, struct FVector HitNormal );
	void eventExplodeOnTarget ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal );
	bool CheckTargetDistance ( struct FVector vLocOverride );
	void TargetReached ( );
	void Tick ( float DeltaSeconds );
	bool CheckProjectileRange ( struct FVector vLocOverride );
	void eventHitWall ( struct FVector HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp );
	void ProcessTouch ( class AActor* Other, struct FVector HitLocation, struct FVector HitNormal );
	void ShutDown ( );
	void PlayHitTargetFX ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal, unsigned long bExploded );
	void eventSetGroundTarget ( struct FVector GTLocation );
	void eventClientTargetUpdate ( class AActor* TargetActor, struct FVector TargetLocation );
	void UpdateVisualsOnSetGroundTarget ( );
	float GetGravityZ ( );
	void CompleteInitialization ( );
	void CalculateLob ( );
};

UClass* ATgProj_SimulatedGroundTarget::pClassPointer = NULL;

// Class TgGame.TgProj_SimulatedGroundTarget_FixedAngle
// 0x0004 (0x02EC - 0x02E8)
class ATgProj_SimulatedGroundTarget_FixedAngle : public ATgProj_SimulatedGroundTarget
{
public:
	float                                              m_LobAngle;                                       		// 0x02E8 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2312 );

		return pClassPointer;
	};

	void CalculateLob ( );
};

UClass* ATgProj_SimulatedGroundTarget_FixedAngle::pClassPointer = NULL;

// Class TgGame.TgProj_SimulatedGroundTarget_FixedTime
// 0x0008 (0x02F0 - 0x02E8)
class ATgProj_SimulatedGroundTarget_FixedTime : public ATgProj_SimulatedGroundTarget
{
public:
	float                                              m_StartTime;                                      		// 0x02E8 (0x0004) [0x0000000000000000]              
	float                                              m_AirTime;                                        		// 0x02EC (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2313 );

		return pClassPointer;
	};

	bool CheckTargetDistance ( struct FVector vLocOverride );
	void eventSetGroundTarget ( struct FVector GTLocation );
	void CalculateLob ( );
};

UClass* ATgProj_SimulatedGroundTarget_FixedTime::pClassPointer = NULL;

// Class TgGame.TgProj_Artemis_Volley_Arrow
// 0x0000 (0x02F0 - 0x02F0)
class ATgProj_Artemis_Volley_Arrow : public ATgProj_SimulatedGroundTarget_FixedTime
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2314 );

		return pClassPointer;
	};

	float GetGravityZ ( );
};

UClass* ATgProj_Artemis_Volley_Arrow::pClassPointer = NULL;

// Class TgGame.TgProj_SimulatedGroundTarget_FixedTime_NoLob
// 0x0000 (0x02F0 - 0x02F0)
class ATgProj_SimulatedGroundTarget_FixedTime_NoLob : public ATgProj_SimulatedGroundTarget_FixedTime
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2315 );

		return pClassPointer;
	};

	bool CheckTargetDistance ( struct FVector vLocOverride );
	void CalculateLob ( );
};

UClass* ATgProj_SimulatedGroundTarget_FixedTime_NoLob::pClassPointer = NULL;

// Class TgGame.TgProj_Ram_AstralArrow
// 0x0004 (0x02F4 - 0x02F0)
class ATgProj_Ram_AstralArrow : public ATgProj_SimulatedGroundTarget_FixedTime_NoLob
{
public:
	int                                                m_nProjectileIndex;                               		// 0x02F0 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2316 );

		return pClassPointer;
	};

	bool ApplyHit ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal, int HitItem );
};

UClass* ATgProj_Ram_AstralArrow::pClassPointer = NULL;

// Class TgGame.TgProj_SimulatedGroundTarget_FixedVelocity_XY_MinAirTime
// 0x0000 (0x02F0 - 0x02F0)
class ATgProj_SimulatedGroundTarget_FixedVelocity_XY_MinAirTime : public ATgProj_SimulatedGroundTarget_FixedTime
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2317 );

		return pClassPointer;
	};

	void CalculateLob ( );
};

UClass* ATgProj_SimulatedGroundTarget_FixedVelocity_XY_MinAirTime::pClassPointer = NULL;

// Class TgGame.TgProj_SimulatedGroundTarget_FixedVelocity_XY_MinAirTime_NoLob
// 0x0004 (0x02F4 - 0x02F0)
class ATgProj_SimulatedGroundTarget_FixedVelocity_XY_MinAirTime_NoLob : public ATgProj_SimulatedGroundTarget_FixedVelocity_XY_MinAirTime
{
public:
	unsigned long                                      m_bDoNotAllowZVelocity : 1;                       		// 0x02F0 (0x0004) [0x0000000000000002] [0x00000001] ( CPF_Const )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2318 );

		return pClassPointer;
	};

	bool CheckTargetDistance ( struct FVector vLocOverride );
	void eventSetGroundTarget ( struct FVector GTLocation );
	void CalculateLob ( );
};

UClass* ATgProj_SimulatedGroundTarget_FixedVelocity_XY_MinAirTime_NoLob::pClassPointer = NULL;

// Class TgGame.TgProj_Vulcan_ShatterBomb
// 0x0000 (0x02F0 - 0x02F0)
class ATgProj_Vulcan_ShatterBomb : public ATgProj_SimulatedGroundTarget_FixedVelocity_XY_MinAirTime
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2319 );

		return pClassPointer;
	};

	void UpdateVisualsOnSetGroundTarget ( );
};

UClass* ATgProj_Vulcan_ShatterBomb::pClassPointer = NULL;

// Class TgGame.TgProj_Zeus_Shield
// 0x000C (0x02FC - 0x02F0)
class ATgProj_Zeus_Shield : public ATgProj_SimulatedGroundTarget_FixedVelocity_XY_MinAirTime
{
public:
	struct FVector                                     m_ActualGroundLocation;                           		// 0x02F0 (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2320 );

		return pClassPointer;
	};

	void eventExplodeOnTarget ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal );
	void eventSetGroundTarget ( struct FVector GTLocation );
};

UClass* ATgProj_Zeus_Shield::pClassPointer = NULL;

// Class TgGame.TgProj_SimulatedGroundTarget_FixedVelocity_NoLob
// 0x0004 (0x02EC - 0x02E8)
class ATgProj_SimulatedGroundTarget_FixedVelocity_NoLob : public ATgProj_SimulatedGroundTarget
{
public:
	unsigned long                                      m_bDoNotAllowZVelocity : 1;                       		// 0x02E8 (0x0004) [0x0000000000000002] [0x00000001] ( CPF_Const )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2321 );

		return pClassPointer;
	};

	bool CheckTargetDistance ( struct FVector vLocOverride );
	void CalculateLob ( );
};

UClass* ATgProj_SimulatedGroundTarget_FixedVelocity_NoLob::pClassPointer = NULL;

// Class TgGame.TgProj_SimulatedGroundTarget_FixedVelocity_XY
// 0x0000 (0x02E8 - 0x02E8)
class ATgProj_SimulatedGroundTarget_FixedVelocity_XY : public ATgProj_SimulatedGroundTarget
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2322 );

		return pClassPointer;
	};

	void CalculateLob ( );
};

UClass* ATgProj_SimulatedGroundTarget_FixedVelocity_XY::pClassPointer = NULL;

// Class TgGame.TgProj_Bakasura_Spat_Minion
// 0x0004 (0x02EC - 0x02E8)
class ATgProj_Bakasura_Spat_Minion : public ATgProj_SimulatedGroundTarget_FixedVelocity_XY
{
public:
	int                                                m_nMinionCount;                                   		// 0x02E8 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2323 );

		return pClassPointer;
	};

	void SpawnExplosionEffects ( struct FVector HitLocation, struct FVector HitNormal );
	class ATgPawn* SpawnTheBot ( struct FVector HitLocation, struct FVector HitNormal );
};

UClass* ATgProj_Bakasura_Spat_Minion::pClassPointer = NULL;

// Class TgGame.TgProj_Hercules_Boulder
// 0x004C (0x0334 - 0x02E8)
class ATgProj_Hercules_Boulder : public ATgProj_SimulatedGroundTarget_FixedVelocity_XY
{
public:
	unsigned long                                      m_bIsRolling : 1;                                 		// 0x02E8 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bApplyBounceVelocity : 1;                       		// 0x02E8 (0x0004) [0x0000000000000000] [0x00000002] 
	float                                              m_fGroundDistTraveled;                            		// 0x02EC (0x0004) [0x0000000000000000]              
	float                                              m_fGroundRange;                                   		// 0x02F0 (0x0004) [0x0000000000000000]              
	float                                              m_fRollingDampening;                              		// 0x02F4 (0x0004) [0x0000000000000000]              
	struct FVector                                     m_vBounceVelocity;                                		// 0x02F8 (0x000C) [0x0000000000000000]              
	int                                                m_iNumBounces;                                    		// 0x0304 (0x0004) [0x0000000000000000]              
	TArray< struct FBoulderHitInfo >                   m_HitActors;                                      		// 0x0308 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class AActor* >                            m_HitActorsThisWallBounce;                        		// 0x0314 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                s_nDamageEffectGroupId;                           		// 0x0320 (0x0004) [0x0000000000000000]              
	TArray< struct FCannotTouchInfo >                  s_CannotTouchList;                                		// 0x0324 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class UTgSpecialFx*                                c_GroundHitFx;                                    		// 0x0330 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2324 );

		return pClassPointer;
	};

	void RangeReached ( );
	bool CheckTargetDistance ( struct FVector vLocOverride );
	void TargetReached ( );
	bool CheckProjectileRange ( struct FVector vLocOverride );
	void eventHitWall ( struct FVector HitNormal, class AActor* WallActor, class UPrimitiveComponent* WallComp );
	void eventLanded ( struct FVector HitNormal, class AActor* FloorActor );
	void SpawnGroundHitEffects ( struct FVector HitLocation, struct FVector HitNormal );
	void StartCollision ( );
	void eventProxyUnTouch ( class AActor* Other );
	void ProcessTouch ( class AActor* Other, struct FVector HitLocation, struct FVector HitNormal );
	float TimeUntilActorCanBeReTouched ( class AActor* Target );
};

UClass* ATgProj_Hercules_Boulder::pClassPointer = NULL;

// Class TgGame.TgProj_Vulcan_CannonTurretBall
// 0x0004 (0x02EC - 0x02E8)
class ATgProj_Vulcan_CannonTurretBall : public ATgProj_SimulatedGroundTarget_FixedVelocity_XY
{
public:
	unsigned long                                      m_IsFallingHarmlessly : 1;                        		// 0x02E8 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2325 );

		return pClassPointer;
	};

	void eventLanded ( struct FVector HitNormal, class AActor* FloorActor );
	void eventHitWall ( struct FVector HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp );
	void ProcessTouch ( class AActor* Other, struct FVector HitLocation, struct FVector HitNormal );
	bool CheckProjectileRange ( struct FVector vLocOverride );
};

UClass* ATgProj_Vulcan_CannonTurretBall::pClassPointer = NULL;

// Class TgGame.TgProj_SimulatedPassThrough
// 0x0010 (0x02DC - 0x02CC)
class ATgProj_SimulatedPassThrough : public ATgProj_Simulated
{
public:
	unsigned long                                      m_bInitialHit : 1;                                		// 0x02CC (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bExplodeOnBlocker : 1;                          		// 0x02CC (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_bSkipFriendlies : 1;                            		// 0x02CC (0x0004) [0x0000000000000000] [0x00000004] 
	TArray< class AActor* >                            m_PreviouslyHitTargets;                           		// 0x02D0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2326 );

		return pClassPointer;
	};

	void Destroyed ( );
	void HitTarget ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal );
	void ProcessTouch ( class AActor* Other, struct FVector HitLocation, struct FVector HitNormal );
	bool ShouldExplode ( class AActor* Other, struct FVector HitLocation, struct FVector HitNormal );
	bool ProximityDistanceOverridesCollision ( );
};

UClass* ATgProj_SimulatedPassThrough::pClassPointer = NULL;

// Class TgGame.TgProj_AhPuch_EmptyTheCrypts
// 0x001C (0x02F8 - 0x02DC)
class ATgProj_AhPuch_EmptyTheCrypts : public ATgProj_SimulatedPassThrough
{
public:
	TArray< int >                                      m_NormalMeshAssemblyIds;                          		// 0x02DC (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< int >                                      m_HighSettingsMeshAssemblyIds;                    		// 0x02E8 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                m_nHighSettingsMode;                              		// 0x02F4 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2327 );

		return pClassPointer;
	};

	void HitTarget ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal );
	void ProcessTouch ( class AActor* Other, struct FVector HitLocation, struct FVector HitNormal );
	bool eventUseAOE ( );
	bool ProximityDistanceOverridesCollision ( );
};

UClass* ATgProj_AhPuch_EmptyTheCrypts::pClassPointer = NULL;

// Class TgGame.TgProj_HouYi_Dev1
// 0x0034 (0x0310 - 0x02DC)
class ATgProj_HouYi_Dev1 : public ATgProj_SimulatedPassThrough
{
public:
	int                                                m_nMaxHitsPerTarget;                              		// 0x02DC (0x0004) [0x0000000000000002]              ( CPF_Const )
	struct FVector                                     m_LastBounceLocation;                             		// 0x02E0 (0x000C) [0x0000000000000000]              
	int                                                m_nBounceCount;                                   		// 0x02EC (0x0004) [0x0000000000000000]              
	int                                                m_nMaxBounceCount;                                		// 0x02F0 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bApplyBounceVelocity : 1;                       		// 0x02F4 (0x0004) [0x0000000000000000] [0x00000001] 
	struct FVector                                     m_vBounceVelocity;                                		// 0x02F8 (0x000C) [0x0000000000000000]              
	TArray< class AActor* >                            m_TotalHitTargets;                                		// 0x0304 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2328 );

		return pClassPointer;
	};

	void HitTarget ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal );
	void eventHitWall ( struct FVector HitNormal, class AActor* WallActor, class UPrimitiveComponent* WallComp );
	bool ApplyHit ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal, int HitItem );
	bool CheckProjectileRange ( struct FVector vLocOverride );
};

UClass* ATgProj_HouYi_Dev1::pClassPointer = NULL;

// Class TgGame.TgProj_Izanami_Dev2
// 0x0004 (0x02E0 - 0x02DC)
class ATgProj_Izanami_Dev2 : public ATgProj_SimulatedPassThrough
{
public:
	class UTgAnimNodeSlot*                             c_FullBodyAnimNode;                               		// 0x02DC (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2329 );

		return pClassPointer;
	};

	void PlayHitTargetFX ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal, unsigned long bExploded );
};

UClass* ATgProj_Izanami_Dev2::pClassPointer = NULL;

// Class TgGame.TgProj_Janus_PortalGenerator
// 0x0014 (0x02F0 - 0x02DC)
class ATgProj_Janus_PortalGenerator : public ATgProj_SimulatedPassThrough
{
public:
	struct FVector                                     m_LastLocation;                                   		// 0x02DC (0x000C) [0x0000000000000000]              
	float                                              m_fMinPortalDistance;                             		// 0x02E8 (0x0004) [0x0000000000000000]              
	float                                              m_fMaxPortalGenerationRange;                      		// 0x02EC (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2330 );

		return pClassPointer;
	};

};

UClass* ATgProj_Janus_PortalGenerator::pClassPointer = NULL;

// Class TgGame.TgProj_Kali_Lash
// 0x001C (0x02F8 - 0x02DC)
class ATgProj_Kali_Lash : public ATgProj_SimulatedPassThrough
{
public:
	struct FPointer                                    VfTable_ITgProjGroundTargetInterface;             		// 0x02DC (0x0004) [0x0000000000801002]              ( CPF_Const | CPF_Native | CPF_NoExport )
	float                                              m_fTurnStrength;                                  		// 0x02E0 (0x0004) [0x0000000000000000]              
	float                                              m_fVertTurnStrength;                              		// 0x02E4 (0x0004) [0x0000000000000000]              
	struct FVector                                     m_GroundTargetLocation;                           		// 0x02E8 (0x000C) [0x0000000000000000]              
	unsigned long                                      m_bHasPassedTarget : 1;                           		// 0x02F4 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2331 );

		return pClassPointer;
	};

	struct FVector eventGetSeekLocation ( );
	void UpdateSeekingDirection ( float fDeltaTime );
	void Tick ( float fDeltaTime );
	bool IsOutsideMinRange ( struct FVector HitLocation );
	void eventSetGroundTarget ( struct FVector GTLocation );
	void eventClientTargetUpdate ( class AActor* TargetActor, struct FVector TargetLocation );
	void CompleteInitialization ( );
};

UClass* ATgProj_Kali_Lash::pClassPointer = NULL;

// Class TgGame.TgProj_Kali_Lash_Spear
// 0x000C (0x02E8 - 0x02DC)
class ATgProj_Kali_Lash_Spear : public ATgProj_SimulatedPassThrough
{
public:
	float                                              m_RollVariance;                                   		// 0x02DC (0x0004) [0x0000000000000000]              
	float                                              m_fPitchOffset;                                   		// 0x02E0 (0x0004) [0x0000000000000000]              
	float                                              m_fGravityMultiplier;                             		// 0x02E4 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2332 );

		return pClassPointer;
	};

	bool IsOutsideMinRange ( struct FVector HitLocation );
	void PostBeginPlay ( );
	float GetGravityZ ( );
	void Init ( struct FVector Direction );
};

UClass* ATgProj_Kali_Lash_Spear::pClassPointer = NULL;

// Class TgGame.TgProj_Rama_Offhand1_Toggle
// 0x0000 (0x02DC - 0x02DC)
class ATgProj_Rama_Offhand1_Toggle : public ATgProj_SimulatedPassThrough
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2333 );

		return pClassPointer;
	};

	void HitTarget ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal );
};

UClass* ATgProj_Rama_Offhand1_Toggle::pClassPointer = NULL;

// Class TgGame.TgProj_Ratatoskr_AcornThrow
// 0x0000 (0x02DC - 0x02DC)
class ATgProj_Ratatoskr_AcornThrow : public ATgProj_SimulatedPassThrough
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2334 );

		return pClassPointer;
	};

};

UClass* ATgProj_Ratatoskr_AcornThrow::pClassPointer = NULL;

// Class TgGame.TgProj_Ratatoskr_AcornThrowSapphire
// 0x0000 (0x02DC - 0x02DC)
class ATgProj_Ratatoskr_AcornThrowSapphire : public ATgProj_SimulatedPassThrough
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2335 );

		return pClassPointer;
	};

	void ShutDown ( );
	void eventExplodeOnTarget ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal );
	bool ShouldExplode ( class AActor* Other, struct FVector HitLocation, struct FVector HitNormal );
	bool CheckTeamPassThrough ( class AActor* Other );
	bool AlreadyHasDeployable ( class AActor* HitActor );
	bool ValidDeployableId ( int nDeployableId );
	void SpawnTheDeployableSpecial ( struct FVector HitLocation, struct FVector HitNormal, class AActor* BaseActor );
};

UClass* ATgProj_Ratatoskr_AcornThrowSapphire::pClassPointer = NULL;

// Class TgGame.TgProj_SimulatedBoomerang
// 0x0004 (0x02E0 - 0x02DC)
class ATgProj_SimulatedBoomerang : public ATgProj_SimulatedPassThrough
{
public:
	float                                              m_fTurnStrength;                                  		// 0x02DC (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2336 );

		return pClassPointer;
	};

	struct FVector eventGetSeekLocation ( );
	void UpdateSeekingDirection ( float fDeltaTime );
	void ReturnToOwner ( );
	void RangeReached ( );
};

UClass* ATgProj_SimulatedBoomerang::pClassPointer = NULL;

// Class TgGame.TgProj_Izanami_Inhand
// 0x0014 (0x02F4 - 0x02E0)
class ATgProj_Izanami_Inhand : public ATgProj_SimulatedBoomerang
{
public:
	class ATgPawn_Izanami*                             m_IzanamiPawn;                                    		// 0x02E0 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bIsBitingStrike : 1;                            		// 0x02E4 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bRecallBitingSickle : 1;                        		// 0x02E4 (0x0004) [0x0000000000000000] [0x00000002] 
	TArray< class AActor* >                            m_AllHitTargets;                                  		// 0x02E8 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2337 );

		return pClassPointer;
	};

	void eventNativeReturnToOwner ( );
	void eventHitWall ( struct FVector HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp );
	void RangeReached ( );
	void ReturnToOwner ( );
	bool ApplyHit ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal, int HitItem );
	void HitTarget ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal );
};

UClass* ATgProj_Izanami_Inhand::pClassPointer = NULL;

// Class TgGame.TgProj_Ratatoskr_TailSpinSapphire
// 0x000C (0x02EC - 0x02E0)
class ATgProj_Ratatoskr_TailSpinSapphire : public ATgProj_SimulatedBoomerang
{
public:
	float                                              m_fWaitInPlaceTime;                               		// 0x02E0 (0x0004) [0x0000000000000000]              
	struct FName                                       m_BlendListName;                                  		// 0x02E4 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2338 );

		return pClassPointer;
	};

	void SetAnimBlendListActiveChild ( int nActiveChild );
	void WaitInPlace ( );
	void RangeReached ( );
};

UClass* ATgProj_Ratatoskr_TailSpinSapphire::pClassPointer = NULL;

// Class TgGame.TgProj_SimulatedPassThroughUntilGod
// 0x0000 (0x02DC - 0x02DC)
class ATgProj_SimulatedPassThroughUntilGod : public ATgProj_SimulatedPassThrough
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2339 );

		return pClassPointer;
	};

	bool ShouldExplode ( class AActor* Other, struct FVector HitLocation, struct FVector HitNormal );
};

UClass* ATgProj_SimulatedPassThroughUntilGod::pClassPointer = NULL;

// Class TgGame.TgProj_Camazotz_Screech
// 0x0000 (0x02DC - 0x02DC)
class ATgProj_Camazotz_Screech : public ATgProj_SimulatedPassThroughUntilGod
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2340 );

		return pClassPointer;
	};

};

UClass* ATgProj_Camazotz_Screech::pClassPointer = NULL;

// Class TgGame.TgProj_Camazotz_ScreechEcho
// 0x0000 (0x02DC - 0x02DC)
class ATgProj_Camazotz_ScreechEcho : public ATgProj_SimulatedPassThroughUntilGod
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2341 );

		return pClassPointer;
	};

	void eventHitWall ( struct FVector HitNormal, class AActor* WallActor, class UPrimitiveComponent* WallComp );
	void ProcessTouch ( class AActor* Other, struct FVector HitLocation, struct FVector HitNormal );
};

UClass* ATgProj_Camazotz_ScreechEcho::pClassPointer = NULL;

// Class TgGame.TgProj_Izanami_Dev4
// 0x0000 (0x02DC - 0x02DC)
class ATgProj_Izanami_Dev4 : public ATgProj_SimulatedPassThroughUntilGod
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2342 );

		return pClassPointer;
	};

	bool ApplyHit ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal, int HitItem );
	void MarkTarget ( class AActor* Target );
};

UClass* ATgProj_Izanami_Dev4::pClassPointer = NULL;

// Class TgGame.TgProj_Raijin_Dev1
// 0x0014 (0x02F0 - 0x02DC)
class ATgProj_Raijin_Dev1 : public ATgProj_SimulatedPassThroughUntilGod
{
public:
	float                                              m_fStartRadius;                                   		// 0x02DC (0x0004) [0x0000000000000000]              
	float                                              m_fEndRadius;                                     		// 0x02E0 (0x0004) [0x0000000000000000]              
	float                                              m_fCurrentRadius;                                 		// 0x02E4 (0x0004) [0x0000000000000000]              
	float                                              m_fDeltaRadiusPerSec;                             		// 0x02E8 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bIsFirst : 1;                                   		// 0x02EC (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bShouldApplyPassiveHits : 1;                    		// 0x02EC (0x0004) [0x0000000000000000] [0x00000002] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2343 );

		return pClassPointer;
	};

	void ShutDown ( );
	bool ApplyHit ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal, int HitItem );
	void Tick ( float DeltaSeconds );
};

UClass* ATgProj_Raijin_Dev1::pClassPointer = NULL;

// Class TgGame.TgProj_SimulatedSinusoid
// 0x0020 (0x02FC - 0x02DC)
class ATgProj_SimulatedSinusoid : public ATgProj_SimulatedPassThrough
{
public:
	float                                              m_fAmplitude;                                     		// 0x02DC (0x0004) [0x0000000000000000]              
	float                                              m_fFrequency;                                     		// 0x02E0 (0x0004) [0x0000000000000000]              
	float                                              m_fPhaseOffset;                                   		// 0x02E4 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bMirror : 1;                                    		// 0x02E8 (0x0004) [0x0000000000000000] [0x00000001] 
	float                                              m_fForwardSpeed;                                  		// 0x02EC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FVector                                     m_vForwardVector;                                 		// 0x02F0 (0x000C) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2344 );

		return pClassPointer;
	};

	void FixUpInitialVelocityAndRotation ( );
	void CompleteInitialization ( );
};

UClass* ATgProj_SimulatedSinusoid::pClassPointer = NULL;

// Class TgGame.TgProj_Sol_SolarFlair
// 0x0014 (0x0310 - 0x02FC)
class ATgProj_Sol_SolarFlair : public ATgProj_SimulatedSinusoid
{
public:
	struct FPointer                                    VfTable_ITgProjGroundTargetInterface;             		// 0x02FC (0x0004) [0x0000000000801002]              ( CPF_Const | CPF_Native | CPF_NoExport )
	unsigned long                                      m_bIsUnstable : 1;                                		// 0x0300 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	struct FVector                                     m_GroundTargetLocation;                           		// 0x0304 (0x000C) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2345 );

		return pClassPointer;
	};

	void ShutDown ( );
	bool ApplyHit ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal, int HitItem );
	void eventSetGroundTarget ( struct FVector GTLocation );
	void eventClientTargetUpdate ( class AActor* TargetActor, struct FVector TargetLocation );
	bool CheckProjectileRange ( struct FVector vLocOverride );
	bool IsOutsideMinRange ( struct FVector HitLocation );
	float CalcFrequency ( struct FVector* StartLocation, struct FVector* EndLocation );
};

UClass* ATgProj_Sol_SolarFlair::pClassPointer = NULL;

// Class TgGame.TgProj_Thor_TeleportHammer
// 0x0014 (0x02F0 - 0x02DC)
class ATgProj_Thor_TeleportHammer : public ATgProj_SimulatedPassThrough
{
public:
	unsigned long                                      m_ShouldReturnToOwner : 1;                        		// 0x02DC (0x0004) [0x0000000000000000] [0x00000001] 
	float                                              m_fTurnStrength;                                  		// 0x02E0 (0x0004) [0x0000000000000000]              
	TArray< class AActor* >                            m_HitActors;                                      		// 0x02E4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2346 );

		return pClassPointer;
	};

	void Destroyed ( );
	void ShutDown ( );
	void ReturnToOwner ( );
	void RangeReached ( );
	void HitTarget ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal );
	void ProcessTouch ( class AActor* Other, struct FVector HitLocation, struct FVector HitNormal );
	bool ProximityReached ( class AActor* A, struct FVector HitLocation, struct FVector HitNormal );
	struct FVector eventGetSeekLocation ( );
	void UpdateSeekingDirection ( float fDeltaTime );
	void Tick ( float fDeltaTime );
	void CompleteInitialization ( );
};

UClass* ATgProj_Thor_TeleportHammer::pClassPointer = NULL;

// Class TgGame.TgProj_Ullr_Num4
// 0x0000 (0x02DC - 0x02DC)
class ATgProj_Ullr_Num4 : public ATgProj_SimulatedPassThrough
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2347 );

		return pClassPointer;
	};

	void HitTarget ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal );
	bool ApplyHit ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal, int HitItem );
};

UClass* ATgProj_Ullr_Num4::pClassPointer = NULL;

// Class TgGame.TgProj_VamanaUmbrella
// 0x0008 (0x02E4 - 0x02DC)
class ATgProj_VamanaUmbrella : public ATgProj_SimulatedPassThrough
{
public:
	unsigned long                                      m_ShouldReturnToVamana : 1;                       		// 0x02DC (0x0004) [0x0000000000000000] [0x00000001] 
	float                                              m_fTurnStrength;                                  		// 0x02E0 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2348 );

		return pClassPointer;
	};

	void PlayHitTargetFX ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal, unsigned long bExploded );
	void eventProxyTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void ProcessTouch ( class AActor* Other, struct FVector HitLocation, struct FVector HitNormal );
	struct FVector eventGetSeekLocation ( );
	void UpdateSeekingDirection ( float fDeltaTime );
	void Tick ( float fDeltaTime );
	bool CheckProjectileRange ( struct FVector vLocOverride );
	void RangeReached ( );
};

UClass* ATgProj_VamanaUmbrella::pClassPointer = NULL;

// Class TgGame.TgProj_Vulcan_ForgeProjectile
// 0x0004 (0x02E0 - 0x02DC)
class ATgProj_Vulcan_ForgeProjectile : public ATgProj_SimulatedPassThrough
{
public:
	unsigned long                                      m_bHasHitGod : 1;                                 		// 0x02DC (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2349 );

		return pClassPointer;
	};

	bool ApplyHit ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal, int HitItem );
};

UClass* ATgProj_Vulcan_ForgeProjectile::pClassPointer = NULL;

// Class TgGame.TgProj_SimulatedSeeking
// 0x001C (0x02E8 - 0x02CC)
class ATgProj_SimulatedSeeking : public ATgProj_Simulated
{
public:
	unsigned long                                      m_IgnoreCollisionWithNonTargets : 1;              		// 0x02CC (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_IgnoreCollisionWithWorldIfSeeking : 1;          		// 0x02CC (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_IgnoreCollisionWithWorldIfNotSeeking : 1;       		// 0x02CC (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_bFollowSeekingRotation : 1;                     		// 0x02CC (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      m_bAllowAcceleration : 1;                         		// 0x02CC (0x0004) [0x0000000000000000] [0x00000010] 
	class AActor*                                      m_Target;                                         		// 0x02D0 (0x0004) [0x0000000000000000]              
	float                                              m_fTurnStrength;                                  		// 0x02D4 (0x0004) [0x0000000000000000]              
	float                                              m_fVertTurnStrength;                              		// 0x02D8 (0x0004) [0x0000000000000000]              
	struct FRotator                                    m_SeekingRotation;                                		// 0x02DC (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2350 );

		return pClassPointer;
	};

	bool CheckTeamPassThrough ( class AActor* Other );
	struct FVector eventGetSeekLocation ( );
	void UpdateSeekingDirection ( float fDeltaTime );
	bool CheckProjectileRange ( struct FVector vLocOverride );
	void Tick ( float fDeltaTime );
	void eventSetTarget ( class AActor* TargetActor, struct FVector TargetLocation );
	void CompleteInitialization ( );
};

UClass* ATgProj_SimulatedSeeking::pClassPointer = NULL;

// Class TgGame.TgProj_Chiron_SpreadShotArrow
// 0x0004 (0x02EC - 0x02E8)
class ATgProj_Chiron_SpreadShotArrow : public ATgProj_SimulatedSeeking
{
public:
	class UTgSpecialFx*                                m_WarningFx;                                      		// 0x02E8 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2351 );

		return pClassPointer;
	};

	void ShutDown ( );
	void eventSetTarget ( class AActor* TargetActor, struct FVector TargetLocation );
	void UpdateVisualsOnSetTarget ( );
};

UClass* ATgProj_Chiron_SpreadShotArrow::pClassPointer = NULL;

// Class TgGame.TgProj_Cocoon_PVE
// 0x0004 (0x02EC - 0x02E8)
class ATgProj_Cocoon_PVE : public ATgProj_SimulatedSeeking
{
public:
	unsigned long                                      s_bAlreadyPulled : 1;                             		// 0x02E8 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2352 );

		return pClassPointer;
	};

	void eventClientExplode ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal );
	void eventSpawnFlightEffects ( );
	bool ApplyHit ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal, int HitItem );
	bool GetValidPullLocation ( class ATgPawn* Target, struct FVector* OutLocation );
};

UClass* ATgProj_Cocoon_PVE::pClassPointer = NULL;

// Class TgGame.TgProj_HouYi_GoldenCrow
// 0x0030 (0x0318 - 0x02E8)
class ATgProj_HouYi_GoldenCrow : public ATgProj_SimulatedSeeking
{
public:
	struct FVector                                     m_TranslationFrequency;                           		// 0x02E8 (0x000C) [0x0000000000000000]              
	struct FVector                                     m_TranslationAmplitude;                           		// 0x02F4 (0x000C) [0x0000000000000000]              
	struct FVector                                     m_TranslationPhase;                               		// 0x0300 (0x000C) [0x0000000000000000]              
	struct FVector                                     m_TranslationOffset;                              		// 0x030C (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2353 );

		return pClassPointer;
	};

	bool eventUseAOE ( );
};

UClass* ATgProj_HouYi_GoldenCrow::pClassPointer = NULL;

// Class TgGame.TgProj_Neith_SeekingBrokenWeaveUser
// 0x0008 (0x02F0 - 0x02E8)
class ATgProj_Neith_SeekingBrokenWeaveUser : public ATgProj_SimulatedSeeking
{
public:
	unsigned long                                      m_bDestroyWeaveOnHit : 1;                         		// 0x02E8 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bSkipFxOnDestroyWeave : 1;                      		// 0x02E8 (0x0004) [0x0000000000000000] [0x00000002] 
	class UTgDeviceFire_Neith_BrokenWeaveUser*         s_OwnerSpecialFireMode;                           		// 0x02EC (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2354 );

		return pClassPointer;
	};

	bool CheckTeamPassThrough ( class AActor* Other );
	void HandleBrokenWeaveHit ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal, int HitItem );
	bool IsValidTarget ( class AActor* A );
	bool ApplyHit ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal, int HitItem );
};

UClass* ATgProj_Neith_SeekingBrokenWeaveUser::pClassPointer = NULL;

// Class TgGame.TgProj_Neith_WorldWeaver
// 0x000C (0x02FC - 0x02F0)
class ATgProj_Neith_WorldWeaver : public ATgProj_Neith_SeekingBrokenWeaveUser
{
public:
	class UTgSpecialFx*                                c_TargetFx;                                       		// 0x02F0 (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                c_TargetHitSoundFx;                               		// 0x02F4 (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                c_TargetWarningArrowFx;                           		// 0x02F8 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2355 );

		return pClassPointer;
	};

	void HitTarget ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal );
	void Tick ( float fDeltaTime );
	void ShutDown ( );
	bool IsValidTarget ( class AActor* A );
	void PlayTargetHitSound ( class AActor* Target );
	void eventExplodeOnTarget ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal );
	void eventClientTargetUpdate ( class AActor* TargetActor, struct FVector TargetLocation );
};

UClass* ATgProj_Neith_WorldWeaver::pClassPointer = NULL;

// Class TgGame.TgProj_Osiris_SoulRipDummy
// 0x0004 (0x02EC - 0x02E8)
class ATgProj_Osiris_SoulRipDummy : public ATgProj_SimulatedSeeking
{
public:
	unsigned long                                      bReturnFlight : 1;                                		// 0x02E8 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2356 );

		return pClassPointer;
	};

	void ProcessTouch ( class AActor* Other, struct FVector HitLocation, struct FVector HitNormal );
	bool IsValidTarget ( class AActor* A );
	bool CheckTeamPassThrough ( class AActor* Other );
	void UpdateSeekingDirection ( float fDeltaTime );
	void eventSetTarget ( class AActor* TargetActor, struct FVector TargetLocation );
	void Tick ( float fDeltaTime );
	void CreateSoulMesh ( class ATgPawn* Target );
};

UClass* ATgProj_Osiris_SoulRipDummy::pClassPointer = NULL;

// Class TgGame.TgProj_SimulatedArcing
// 0x0038 (0x0320 - 0x02E8)
class ATgProj_SimulatedArcing : public ATgProj_SimulatedSeeking
{
public:
	unsigned long                                      m_bCanBounceOnSame : 1;                           		// 0x02E8 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bInitialHit : 1;                                		// 0x02E8 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_bIgnorePreviousTargets : 1;                     		// 0x02E8 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_bInTargetDelay : 1;                             		// 0x02E8 (0x0004) [0x0000000000000000] [0x00000008] 
	int                                                m_nArcingJumps;                                   		// 0x02EC (0x0004) [0x0000000000000000]              
	float                                              m_fDelayOnHit;                                    		// 0x02F0 (0x0004) [0x0000000000000000]              
	float                                              m_fArcRange;                                      		// 0x02F4 (0x0004) [0x0000000000000000]              
	float                                              m_fArcMaxRange;                                   		// 0x02F8 (0x0004) [0x0000000000000000]              
	float                                              m_fAttachRange;                                   		// 0x02FC (0x0004) [0x0000000000000000]              
	struct FVector                                     m_vLastArcLocation;                               		// 0x0300 (0x000C) [0x0000000000000000]              
	TArray< class AActor* >                            m_PreviousTargets;                                		// 0x030C (0x000C) [0x0000000000500000]              ( CPF_NeedCtorLink )
	class AActor*                                      m_LastTarget;                                     		// 0x0318 (0x0004) [0x0000000000000000]              
	float                                              m_fLastHitTime;                                   		// 0x031C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2357 );

		return pClassPointer;
	};

	void HitTarget ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal );
	void ProcessTouch ( class AActor* Other, struct FVector HitLocation, struct FVector HitNormal );
	void Tick ( float fDeltaTime );
	void eventSetSeekingTarget ( class AActor* LockedTarget );
	void eventClientHitUpdate ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal );
	void eventClientArcCountUpdate ( int ArcCount );
	void eventClientTargetUpdate ( class AActor* TargetActor, struct FVector TargetLocation );
	void eventAdvanceToNextTarget ( class AActor* NewTargetOverride );
	void AdvanceTimer ( );
	void ShutDown ( );
	void eventSetAdvanceTimer ( );
	bool CheckProjectileRange ( struct FVector vLocOverride );
	class AActor* GetNextSeekTarget ( );
};

UClass* ATgProj_SimulatedArcing::pClassPointer = NULL;

// Class TgGame.TgProj_FuriousMonkey
// 0x0024 (0x0344 - 0x0320)
class ATgProj_FuriousMonkey : public ATgProj_SimulatedArcing
{
public:
	class UTgAnimNodeBlendList*                        m_PhaseBlendList;                                 		// 0x0320 (0x0004) [0x0000000000000000]              
	class UTgAnimNodeBlendList*                        m_AttackBlendList;                                		// 0x0324 (0x0004) [0x0000000000000000]              
	float                                              m_fTweenTime;                                     		// 0x0328 (0x0004) [0x0000000000000000]              
	float                                              m_fTween;                                         		// 0x032C (0x0004) [0x0000000000000000]              
	struct FVector                                     m_vTweenSource;                                   		// 0x0330 (0x000C) [0x0000000000000000]              
	unsigned long                                      s_bTeleportOnNextHit : 1;                         		// 0x033C (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      s_bDidTeleport : 1;                               		// 0x033C (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_bSkipAnimations : 1;                            		// 0x033C (0x0004) [0x0000000000002000] [0x00000004] ( CPF_Transient )
	class ATgPawn*                                     s_LastHitTarget;                                  		// 0x0340 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2358 );

		return pClassPointer;
	};

	void Destroyed ( );
	void ShutDown ( );
	bool CanTriggerTeleport ( );
	void TeleportToLastHit ( class ATgPawn* TgP, struct FVector vDest, struct FRotator rDest );
	void eventSetSeekingTarget ( class AActor* LockedTarget );
	struct FVector eventGetSeekLocation ( );
	void UpdateSeekingDirection ( float fDeltaTime );
	void HitTarget ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal );
	void eventAdvanceToNextTarget ( class AActor* NewTargetOverride );
	void eventPostInitAnimTree ( class USkeletalMeshComponent* SkelComp );
	void PostBeginPlay ( );
	void CompleteInitialization ( );
	void PlayJumpAnim ( );
	void PlayAttackAnim ( );
};

UClass* ATgProj_FuriousMonkey::pClassPointer = NULL;

// Class TgGame.TgProj_NeZha_UniverseRing
// 0x0000 (0x0320 - 0x0320)
class ATgProj_NeZha_UniverseRing : public ATgProj_SimulatedArcing
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2359 );

		return pClassPointer;
	};

};

UClass* ATgProj_NeZha_UniverseRing::pClassPointer = NULL;

// Class TgGame.TgProj_Raijin_RaijuuBouncing
// 0x001C (0x033C - 0x0320)
class ATgProj_Raijin_RaijuuBouncing : public ATgProj_SimulatedArcing
{
public:
	class UTgAnimNodeBlendList*                        m_AttackBlendList;                                		// 0x0320 (0x0004) [0x0000000000000000]              
	float                                              m_fTweenTime;                                     		// 0x0324 (0x0004) [0x0000000000000000]              
	float                                              m_fTween;                                         		// 0x0328 (0x0004) [0x0000000000000000]              
	struct FVector                                     m_vTweenSource;                                   		// 0x032C (0x000C) [0x0000000000000000]              
	class AActor*                                      m_LastHitTarget;                                  		// 0x0338 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2360 );

		return pClassPointer;
	};

	void ShutDown ( );
	void eventSetSeekingTarget ( class AActor* LockedTarget );
	struct FVector eventGetSeekLocation ( );
	void UpdateSeekingDirection ( float fDeltaTime );
	void HitTarget ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal );
	void eventPostInitAnimTree ( class USkeletalMeshComponent* SkelComp );
	void PostBeginPlay ( );
	void StopAttackAnim ( );
	void PlayAttackAnim ( );
	void CompleteInitialization ( );
};

UClass* ATgProj_Raijin_RaijuuBouncing::pClassPointer = NULL;

// Class TgGame.TgProj_Zeus_LightningBolt
// 0x0008 (0x0328 - 0x0320)
class ATgProj_Zeus_LightningBolt : public ATgProj_SimulatedArcing
{
public:
	unsigned long                                      m_bFirstHit : 1;                                  		// 0x0320 (0x0004) [0x0000000000000000] [0x00000001] 
	int                                                m_nMeshId;                                        		// 0x0324 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2361 );

		return pClassPointer;
	};

	void eventAdvanceToNextTarget ( class AActor* NewTargetOverride );
	void Destroyed ( );
	void ShutDown ( );
	void SwapMesh ( );
	void CompleteInitialization ( );
};

UClass* ATgProj_Zeus_LightningBolt::pClassPointer = NULL;

// Class TgGame.TgProj_SimulatedReturnStroke
// 0x0004 (0x02EC - 0x02E8)
class ATgProj_SimulatedReturnStroke : public ATgProj_SimulatedSeeking
{
public:
	unsigned long                                      m_bKillOnTouchedTarget : 1;                       		// 0x02E8 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bKillWhenReachedTargetLocation : 1;             		// 0x02E8 (0x0004) [0x0000000000000000] [0x00000002] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2362 );

		return pClassPointer;
	};

	void Tick ( float fDeltaTime );
	void ProcessTouch ( class AActor* Other, struct FVector HitLocation, struct FVector HitNormal );
};

UClass* ATgProj_SimulatedReturnStroke::pClassPointer = NULL;

// Class TgGame.TgProj_Nemesis_Num4ProtectionsSteal
// 0x0000 (0x02EC - 0x02EC)
class ATgProj_Nemesis_Num4ProtectionsSteal : public ATgProj_SimulatedReturnStroke
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2363 );

		return pClassPointer;
	};

	void eventExplodeOnTarget ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal );
	void UpdateSeekingDirection ( float fDeltaTime );
};

UClass* ATgProj_Nemesis_Num4ProtectionsSteal::pClassPointer = NULL;

// Class TgGame.TgProj_SimulatedSeekingPassThrough
// 0x0010 (0x02F8 - 0x02E8)
class ATgProj_SimulatedSeekingPassThrough : public ATgProj_SimulatedSeeking
{
public:
	unsigned long                                      m_bInitialHit : 1;                                		// 0x02E8 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bExplodeOnBlocker : 1;                          		// 0x02E8 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_bSkipFriendlies : 1;                            		// 0x02E8 (0x0004) [0x0000000000000000] [0x00000004] 
	TArray< class AActor* >                            m_PreviouslyHitTargets;                           		// 0x02EC (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2364 );

		return pClassPointer;
	};

	void HitTarget ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal );
	void ProcessTouch ( class AActor* Other, struct FVector HitLocation, struct FVector HitNormal );
};

UClass* ATgProj_SimulatedSeekingPassThrough::pClassPointer = NULL;

// Class TgGame.TgProj_AoKuang_DragonCallMini
// 0x0028 (0x0320 - 0x02F8)
class ATgProj_AoKuang_DragonCallMini : public ATgProj_SimulatedSeekingPassThrough
{
public:
	float                                              m_fExplosionDelay;                                		// 0x02F8 (0x0004) [0x0000000000000000]              
	class AActor*                                      m_ExplodeTarget;                                  		// 0x02FC (0x0004) [0x0000000000000000]              
	struct FVector                                     m_vExplodeHitLocation;                            		// 0x0300 (0x000C) [0x0000000000000000]              
	struct FVector                                     m_vExplodeHitNormal;                              		// 0x030C (0x000C) [0x0000000000000000]              
	unsigned long                                      m_bExplodeFlashed : 1;                            		// 0x0318 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bUsePassive : 1;                                		// 0x0318 (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	float                                              m_fInitialLifeSpan;                               		// 0x031C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2365 );

		return pClassPointer;
	};

	bool ApplyHit ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal, int HitItem );
	void ExplodeOnTargetTimer ( );
	void eventExplodeOnTarget ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal );
	void eventPostProjectileInitialize ( );
};

UClass* ATgProj_AoKuang_DragonCallMini::pClassPointer = NULL;

// Class TgGame.TgProj_Tornado
// 0x0000 (0x02E8 - 0x02E8)
class ATgProj_Tornado : public ATgProj_SimulatedSeeking
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2366 );

		return pClassPointer;
	};

	void ProcessTouch ( class AActor* Other, struct FVector HitLocation, struct FVector HitNormal );
	void SetDuration ( float Duration );
};

UClass* ATgProj_Tornado::pClassPointer = NULL;

// Class TgGame.TgProj_Xbalanque_Split_Projectile
// 0x000C (0x02F4 - 0x02E8)
class ATgProj_Xbalanque_Split_Projectile : public ATgProj_SimulatedSeeking
{
public:
	TArray< class AActor* >                            m_ExcludedTargets;                                		// 0x02E8 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2367 );

		return pClassPointer;
	};

	void ProcessTouch ( class AActor* Other, struct FVector HitLocation, struct FVector HitNormal );
};

UClass* ATgProj_Xbalanque_Split_Projectile::pClassPointer = NULL;

// Class TgGame.TgProj_SimulatedWithExemptList
// 0x000C (0x02D8 - 0x02CC)
class ATgProj_SimulatedWithExemptList : public ATgProj_Simulated
{
public:
	TArray< class AActor* >                            m_ExemptList;                                     		// 0x02CC (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2368 );

		return pClassPointer;
	};

	bool IsValidTarget ( class AActor* A );
};

UClass* ATgProj_SimulatedWithExemptList::pClassPointer = NULL;

// Class TgGame.TgProj_Susano_Dev3
// 0x000C (0x02D8 - 0x02CC)
class ATgProj_Susano_Dev3 : public ATgProj_Simulated
{
public:
	struct FVector                                     m_LastValidLocation;                              		// 0x02CC (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2369 );

		return pClassPointer;
	};

};

UClass* ATgProj_Susano_Dev3::pClassPointer = NULL;

// Class TgGame.TgProj_Sylvanus_Dev3
// 0x0000 (0x02CC - 0x02CC)
class ATgProj_Sylvanus_Dev3 : public ATgProj_Simulated
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2370 );

		return pClassPointer;
	};

	void ShutDown ( );
	void eventClientExplode ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal );
	void eventSpawnFlightEffects ( );
};

UClass* ATgProj_Sylvanus_Dev3::pClassPointer = NULL;

// Class TgGame.TgProj_Thor_Hammer
// 0x0008 (0x02D4 - 0x02CC)
class ATgProj_Thor_Hammer : public ATgProj_Simulated
{
public:
	unsigned long                                      m_ShouldReturnToOwner : 1;                        		// 0x02CC (0x0004) [0x0000000000000000] [0x00000001] 
	float                                              m_fTurnStrength;                                  		// 0x02D0 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2371 );

		return pClassPointer;
	};

	void ReturnToOwner ( );
	void RangeReached ( );
	bool ApplyHit ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal, int HitItem );
	void ProcessTouch ( class AActor* Other, struct FVector HitLocation, struct FVector HitNormal );
	bool ProximityReached ( class AActor* A, struct FVector HitLocation, struct FVector HitNormal );
	struct FVector eventGetSeekLocation ( );
	void UpdateSeekingDirection ( float fDeltaTime );
	void Tick ( float fDeltaTime );
};

UClass* ATgProj_Thor_Hammer::pClassPointer = NULL;

// Class TgGame.TgProj_Xbalanque_Splitting_Projectile
// 0x0008 (0x02D4 - 0x02CC)
class ATgProj_Xbalanque_Splitting_Projectile : public ATgProj_Simulated
{
public:
	class UTgDeviceFire*                               m_SplitProjectileDeviceMode;                      		// 0x02CC (0x0004) [0x0000000000000000]              
	int                                                m_nCachedMode;                                    		// 0x02D0 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2372 );

		return pClassPointer;
	};

	void CalculateSplitProjectileTargets ( class AActor* HitActor, struct FVector SpawnLocation, struct FVector ConeDirection, TArray< class AActor* >* Targets );
	void SpawnSplitProjectiles ( class AActor* HitActor, struct FVector originLocation, struct FVector ConeDirection );
	bool ApplyHit ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal, int HitItem );
};

UClass* ATgProj_Xbalanque_Splitting_Projectile::pClassPointer = NULL;

// Class TgGame.TgAudioComponent
// 0x0000 (0x0250 - 0x0250)
class UTgAudioComponent : public UAudioComponent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2373 );

		return pClassPointer;
	};

	void ApplyAdditionalPriority ( );
};

UClass* UTgAudioComponent::pClassPointer = NULL;

// Class TgGame.TgCameraShake
// 0x0015 (0x00CD - 0x00B8)
class UTgCameraShake : public UCameraShake
{
public:
	float                                              m_fShakeScale;                                    		// 0x00B8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_bDoControllerVibration : 1;                     		// 0x00BC (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_bRadialShake : 1;                               		// 0x00BC (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_bOrientTowardRadialEpicenter : 1;               		// 0x00BC (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	float                                              m_fRadialShake_InnerRadius;                       		// 0x00C0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fRadialShake_OuterRadius;                       		// 0x00C4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fRadialShake_Falloff;                           		// 0x00C8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_PlaySpace;                                      		// 0x00CC (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2374 );

		return pClassPointer;
	};

};

UClass* UTgCameraShake::pClassPointer = NULL;

// Class TgGame.TgDominantDirectionalLightSwitchable
// 0x0000 (0x01F8 - 0x01F8)
class ATgDominantDirectionalLightSwitchable : public ADominantDirectionalLight
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2375 );

		return pClassPointer;
	};

	void SetOverrideMode ( unsigned char NewMode );
};

UClass* ATgDominantDirectionalLightSwitchable::pClassPointer = NULL;

// Class TgGame.TgHybridDirectionalLight
// 0x0000 (0x01F8 - 0x01F8)
class ATgHybridDirectionalLight : public ATgDominantDirectionalLightSwitchable
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2376 );

		return pClassPointer;
	};

};

UClass* ATgHybridDirectionalLight::pClassPointer = NULL;

// Class TgGame.TgDominantDirectionalLightSwitchableComponent
// 0x0003 (0x024F - 0x024C)
class UTgDominantDirectionalLightSwitchableComponent : public UDominantDirectionalLightComponent
{
public:
	unsigned char                                      m_OverrideMode;                                   		// 0x024C (0x0001) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      m_PlayInEditorViewMode;                           		// 0x024D (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_CachedLightType;                                		// 0x024E (0x0001) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2377 );

		return pClassPointer;
	};

	void SetOverrideMode ( unsigned char NewMode );
};

UClass* UTgDominantDirectionalLightSwitchableComponent::pClassPointer = NULL;

// Class TgGame.TgDropShadowDecalComponent
// 0x0010 (0x02B4 - 0x02A4)
class UTgDropShadowDecalComponent : public UStaticMeshComponent
{
public:
	float                                              LastCachedZ;                                      		// 0x02A4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FVector                                     LastOwnerPos;                                     		// 0x02A8 (0x000C) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2378 );

		return pClassPointer;
	};

	void UpdatePosition ( class ATgPawn* TgPOwner, unsigned long bIsInitial, struct FVector* OwnerOffset );
};

UClass* UTgDropShadowDecalComponent::pClassPointer = NULL;

// Class TgGame.TgEmitter
// 0x0008 (0x0204 - 0x01FC)
class ATgEmitter : public AEmitter
{
public:
	struct FName                                       BoneName;                                         		// 0x01FC (0x0008) [0x0000000000000020]              ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2379 );

		return pClassPointer;
	};

	void ScaleEmitter ( float ScaleFactor );
	void AttachTo ( class APawn* P, struct FName NewBoneName );
	void eventReplicatedEvent ( struct FName VarName );
};

UClass* ATgEmitter::pClassPointer = NULL;

// Class TgGame.TgMusicThemePlayer
// 0x0004 (0x0090 - 0x008C)
class UTgMusicThemePlayer : public UPComMusicThemePlayer
{
public:
	class UTgManifestGroup*                            c_AssetManifestGroup;                             		// 0x008C (0x0004) [0x0000000004400008]              ( CPF_ExportObject | CPF_NeedCtorLink | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2380 );

		return pClassPointer;
	};

	void LoadThemeByItemId ( int nItemId, unsigned long bAsync );
	void LoadDefaultTheme ( );
	void Init ( );
};

UClass* UTgMusicThemePlayer::pClassPointer = NULL;

// Class TgGame.TgParticleModuleTypeDataLight
// 0x0008 (0x004C - 0x0044)
class UTgParticleModuleTypeDataLight : public UParticleModuleTypeDataBase
{
public:
	class UPointLightComponent*                        m_PointLightComponent;                            		// 0x0044 (0x0004) [0x0000000004080009]              ( CPF_Edit | CPF_ExportObject | CPF_Component | CPF_EditInline )
	class UPointLightComponent*                        m_PLCDuplicate;                                   		// 0x0048 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2381 );

		return pClassPointer;
	};

};

UClass* UTgParticleModuleTypeDataLight::pClassPointer = NULL;

// Class TgGame.TgPhysicalMaterialProperty
// 0x0008 (0x0044 - 0x003C)
class UTgPhysicalMaterialProperty : public UPhysicalMaterialPropertyBase
{
public:
	struct FName                                       MaterialType;                                     		// 0x003C (0x0008) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2382 );

		return pClassPointer;
	};

};

UClass* UTgPhysicalMaterialProperty::pClassPointer = NULL;

// Class TgGame.TgScaryPotionPSComponent
// 0x0000 (0x031C - 0x031C)
class UTgScaryPotionPSComponent : public UParticleSystemComponent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2383 );

		return pClassPointer;
	};

};

UClass* UTgScaryPotionPSComponent::pClassPointer = NULL;

// Class TgGame.TgSoundGroup
// 0x0018 (0x0054 - 0x003C)
class UTgSoundGroup : public UObject
{
public:
	TArray< class USoundCue* >                         c_SoundCues;                                      		// 0x003C (0x000C) [0x0000000000400002]              ( CPF_Const | CPF_NeedCtorLink )
	TArray< struct FFootstepSoundInfo >                c_FootstepSounds;                                 		// 0x0048 (0x000C) [0x0000000000400002]              ( CPF_Const | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2384 );

		return pClassPointer;
	};

	void PlayFootStepSound ( class APawn* P, int FootDown, struct FName MaterialType );
	void PlaySound ( unsigned char eSound, class APawn* P );
};

UClass* UTgSoundGroup::pClassPointer = NULL;

// Class TgGame.TgSpecialFx
// 0x0094 (0x00D0 - 0x003C)
class UTgSpecialFx : public UObject
{
public:
	int                                                c_nFxId;                                          		// 0x003C (0x0004) [0x0000000000000000]              
	class UMeshComponent*                              c_OwnerMesh;                                      		// 0x0040 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class AActor*                                      c_Owner;                                          		// 0x0044 (0x0004) [0x0000000000000000]              
	unsigned long                                      c_bAttached : 1;                                  		// 0x0048 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      c_bAppliesToAllModes : 1;                         		// 0x0048 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      c_bSelfManage : 1;                                		// 0x0048 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      c_bFromEffectForm : 1;                            		// 0x0048 (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      c_bVisualComplete : 1;                            		// 0x0048 (0x0004) [0x0000000000000000] [0x00000010] 
	unsigned long                                      c_bAudioComplete : 1;                             		// 0x0048 (0x0004) [0x0000000000000000] [0x00000020] 
	unsigned long                                      c_bMuteSound : 1;                                 		// 0x0048 (0x0004) [0x0000000000000000] [0x00000040] 
	unsigned long                                      c_bAttachToGround : 1;                            		// 0x0048 (0x0004) [0x0000000000000000] [0x00000080] 
	unsigned long                                      c_bIsDebuff : 1;                                  		// 0x0048 (0x0004) [0x0000000000000000] [0x00000100] 
	unsigned long                                      c_bHasTeamMaterials : 1;                          		// 0x0048 (0x0004) [0x0000000000000000] [0x00000200] 
	unsigned long                                      c_bActive : 1;                                    		// 0x0048 (0x0004) [0x0000000000000000] [0x00000400] 
	unsigned long                                      c_bIsSpawnFx : 1;                                 		// 0x0048 (0x0004) [0x0000000000000000] [0x00000800] 
	unsigned long                                      c_bUseBeam : 1;                                   		// 0x0048 (0x0004) [0x0000000000000000] [0x00001000] 
	unsigned long                                      c_bLocalPawnIsOwner : 1;                          		// 0x0048 (0x0004) [0x0000000000100000] [0x00002000] 
	int                                                c_nPriorityType;                                  		// 0x004C (0x0004) [0x0000000000000000]              
	int                                                c_nPrioritySort;                                  		// 0x0050 (0x0004) [0x0000000000000000]              
	struct FName                                       c_nmSocket;                                       		// 0x0054 (0x0008) [0x0000000000000000]              
	struct FName                                       c_nmDisplayGroup;                                 		// 0x005C (0x0008) [0x0000000000000000]              
	int                                                c_nDisplayMode;                                   		// 0x0064 (0x0004) [0x0000000000000000]              
	int                                                c_nIndex;                                         		// 0x0068 (0x0004) [0x0000000000000000]              
	int                                                c_nEquipSlot;                                     		// 0x006C (0x0004) [0x0000000000000000]              
	class UMaterialInstanceConstant*                   c_MIC;                                            		// 0x0070 (0x0004) [0x0000000000000000]              
	float                                              c_fTransition;                                    		// 0x0074 (0x0004) [0x0000000000000000]              
	int                                                c_nHitEffectBase;                                 		// 0x0078 (0x0004) [0x0000000000000000]              
	float                                              c_fMaxEffectDistance;                             		// 0x007C (0x0004) [0x0000000000000000]              
	struct FParticleChannelContainer                   c_ParticleChannelOverride;                        		// 0x0080 (0x0004) [0x0000000000000000]              
	int                                                c_nSortPriorityOverride;                          		// 0x0084 (0x0004) [0x0000000000000000]              
	int                                                c_nCustomFilterOverride;                          		// 0x0088 (0x0004) [0x0000000000000000]              
	unsigned char                                      c_LightComponentState;                            		// 0x008C (0x0001) [0x0000000000000000]              
	class ULightComponent*                             c_LightComponent;                                 		// 0x0090 (0x0004) [0x0000000004180008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	struct FPointer                                    c_ManagedLightEmitter;                            		// 0x0094 (0x0004) [0x0000000000100000]              
	TArray< struct FFx_Sound >                         c_SoundList;                                      		// 0x0098 (0x000C) [0x0000000000580000]              ( CPF_Component | CPF_NeedCtorLink )
	TArray< struct FFx_PSC >                           c_PSCList;                                        		// 0x00A4 (0x000C) [0x0000000000580000]              ( CPF_Component | CPF_NeedCtorLink )
	TArray< struct FFx_Material >                      c_MaterialList;                                   		// 0x00B0 (0x000C) [0x0000000000500000]              ( CPF_NeedCtorLink )
	TArray< struct FFx_Decal >                         c_DecalList;                                      		// 0x00BC (0x000C) [0x0000000000580000]              ( CPF_Component | CPF_NeedCtorLink )
	class UTgCameraShake*                              c_CameraShake;                                    		// 0x00C8 (0x0004) [0x0000000000000000]              
	class UTgTimerManager*                             c_ActiveTimer;                                    		// 0x00CC (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2385 );

		return pClassPointer;
	};

	void SetDepthPriorityGroup ( unsigned char NewDepthPriorityGroup );
	void SetKillOnDeactivate ( );
	void ListSounds ( );
	void eventUpdateBeamFx ( struct FVector HitLocation, struct FVector HitOrigin, class AActor* targetOverride );
	class UDecalComponent* eventSpawnDecal ( class AWorldInfo* WorldInfo, unsigned long bUsePool, struct FFx_Decal* Decal );
	void eventSpawnTracer ( struct FVector HitLocation, struct FVector HitOrigin );
	class AActor* GetHitActor ( struct FVector EffectLocation, struct FVector HitLocation );
	bool HasSoundCue ( );
	void StopCameraShake ( );
	void PlayCameraShake ( struct FVector Epicenter, float fRadius );
	void DeactivateDecal ( struct FFx_Decal* Decal );
	void ActivateDecal ( struct FFx_Decal* Decal );
	void StopSound ( );
	void PlaySound ( );
	void CheckDeactivate ( );
	void OnAudioFinishedFX ( class UAudioComponent* FinishedComponent );
	void OnParticleSystemFinished ( class UParticleSystemComponent* FinishedComponent );
	void Deactivate ( unsigned long bForceDeactivate );
	float Activate ( struct FVector HitLocation, unsigned long bSkipRelevantChecking );
	void AdjustEffectTranslation ( int nPSCIndex, struct FVector NewTranslation, unsigned long bAbsoluteTranslation );
	void AdjustEffectScale ( int nPSCIndex, float fScale );
	void AdjustFxScaleByRadius ( float fScale );
	void AdjustEffectRadius ( int nPSCIndex, float fScale );
	class ATgPawn* FindLocalPlayerPawn ( );
	class ATgPlayerController* FindLocalPlayerController ( );
	bool IsFxRelevant ( struct FVector SpawnLocation );
	void SetHitEffectScaleBasedOnDamage ( int nHealthChange );
	void SpawnSound ( struct FVector Location );
	void SpawnEmitter ( struct FVector HitLocation, struct FVector HitNormal, float fScale );
	void CleanupRunningState ( );
	void UpdateSoundPlaying ( class UAudioComponent* pacSound );
	bool AreAnySoundsPlaying ( );
	void SetPSCRunning ( class UParticleSystemComponent* pPSC, unsigned long bOn );
	bool AreAnyPSCRunning ( );
	void ResetParticles ( unsigned long bResetInstances );
	void PlaySoundAt ( struct FVector Location );
	bool ShouldShowWhenStealthed ( );
	void SetHidden ( unsigned long bNewHidden );
	void AdjustHidden ( unsigned long bHidden );
	void OnActiveTimeExpired ( );
	void SetActiveTime ( float Duration, class ATgPawn* Owner );
	class AActor* SpawnActor ( class UClass* InClass, struct FVector Location, struct FRotator Rotation );
	void SetPSCChannels ( class UParticleSystemComponent* PSC, unsigned long bOnlyAllowNonZeroMask );
	void ActivateLocalPlayerFx ( class UParticleSystemComponent* ActivePSC );
	class UMeshComponent* GetOwnerMesh ( class AActor* pOwner );
	struct FVector GetEffectLocation ( );
	void Detach ( );
	void AttachToOwner ( class AActor* pOwner );
};

UClass* UTgSpecialFx::pClassPointer = NULL;

// Class TgGame.TgSpecialFxLightManager
// 0x0028 (0x0064 - 0x003C)
class UTgSpecialFxLightManager : public UObject
{
public:
	unsigned long                                      c_FxLightsEnabled : 1;                            		// 0x003C (0x0004) [0x0000000000004000] [0x00000001] ( CPF_Config )
	unsigned long                                      c_FxLightsUnconstrained : 1;                      		// 0x003C (0x0004) [0x0000000000004000] [0x00000002] ( CPF_Config )
	int                                                c_FxLightsMaxActive;                              		// 0x0040 (0x0004) [0x0000000000004000]              ( CPF_Config )
	int                                                c_FxLightsMaxDying;                               		// 0x0044 (0x0004) [0x0000000000004000]              ( CPF_Config )
	TArray< struct FPointer >                          m_ActiveEmitters;                                 		// 0x0048 (0x000C) [0x0000000000500000]              ( CPF_NeedCtorLink )
	TArray< struct FPointer >                          m_DyingEmitters;                                  		// 0x0054 (0x000C) [0x0000000000500000]              ( CPF_NeedCtorLink )
	class ATgPawn*                                     c_LocalPawn;                                      		// 0x0060 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2386 );

		return pClassPointer;
	};

	void UserSetLevel ( int LightLevel );
	void SetLevelInternal ( int LightLevel );
	void LightKilledElsewhere ( struct FPointer FxEmitterKilled );
	void SetLightState ( struct FPointer ExtantFxEmitter, unsigned char NewFxLightState );
	void AddLight ( struct FPointer NewFxEmitter );
	void InitializeFxLightManager ( );
};

UClass* UTgSpecialFxLightManager::pClassPointer = NULL;

// Class TgGame.TgEffect
// 0x0038 (0x0074 - 0x003C)
class UTgEffect : public UObject
{
public:
	class UTgEffectGroup*                              m_EffectGroup;                                    		// 0x003C (0x0004) [0x0000000000000000]              
	int                                                m_nPropertyId;                                    		// 0x0040 (0x0004) [0x0000000000000000]              
	int                                                m_nCalcMethodCode;                                		// 0x0044 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bUseOnInterval : 1;                             		// 0x0048 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bRemovable : 1;                                 		// 0x0048 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_bAllowStacking : 1;                             		// 0x0048 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_bApplyToProperty : 1;                           		// 0x0048 (0x0004) [0x0000000000000000] [0x00000008] 
	int                                                m_nPropertyValueId;                               		// 0x004C (0x0004) [0x0000000000000000]              
	float                                              m_fCurrent;                                       		// 0x0050 (0x0004) [0x0000000000000000]              
	float                                              m_fBase;                                          		// 0x0054 (0x0004) [0x0000000000000000]              
	float                                              m_fMinimum;                                       		// 0x0058 (0x0004) [0x0000000000000000]              
	float                                              m_fMaximum;                                       		// 0x005C (0x0004) [0x0000000000000000]              
	float                                              m_fScalingFactor;                                 		// 0x0060 (0x0004) [0x0000000000000000]              
	float                                              m_fStaticValueOffset;                             		// 0x0064 (0x0004) [0x0000000000000000]              
	float                                              m_MaxKnockbackZ;                                  		// 0x0068 (0x0004) [0x0000000000000000]              
	float                                              m_MinKnockbackZ;                                  		// 0x006C (0x0004) [0x0000000000000000]              
	float                                              m_KnockbackZMultiplier;                           		// 0x0070 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2387 );

		return pClassPointer;
	};

	int GetDeviceIdFromMode ( class UTgDeviceFire* DeviceFireMode );
	class UTgProperty* GetTargetProperty ( class AActor* Target, int nPropertyId );
	void ApplyHitReaction ( class ATgPawn* TargetPawn, struct FImpactInfo Impact, float TweenDistance );
	int GetTopMostDevice ( class UTgDeviceFire* devFire );
	void TrackStats ( class ATgPawn* Instigator, class AActor* Target, struct FImpactInfo Impact, float fDamage, int iTargetDeviceModeId, unsigned long bIsEnemy, float fMissingHealth, float fMitigatedDamage );
	void Remove ( class AActor* Target, unsigned long bResetToFollow );
	void Reapply ( class AActor* Target );
	float GetProratedValue ( );
	void ApplyToProperty ( class AActor* Target, int nPropertyId, float fProratedAmount, unsigned long bRemove );
	bool RemoveStacks ( class AActor* Target, int nNumStacks );
	bool ApplyStacks ( class AActor* Target, int nNumStacks, int nRequestedStacks );
	unsigned char ApplyEffect ( class AActor* Target, struct FImpactInfo Impact, unsigned long bConvertDOT );
	bool IsValidInstigator ( class ATgPawn* InstigatorPawn );
	void SetProperty ( class AActor* Target, int nPropertyId, float fNewValue );
	unsigned char CanBeApplied ( class AActor* Target );
	void PowerScalingModifier ( class ATgPawn* pawnInstigator, class ATgPawn* PawnTarget, struct FImpactInfo Impact, float* fAmount );
	void ReduceActiveCooldowns ( class AActor* Target, float fValue, unsigned long bPercentage );
	class UTgEffect* CloneEffect ( );
};

UClass* UTgEffect::pClassPointer = NULL;

// Class TgGame.TgEffect_Listener
// 0x0004 (0x0078 - 0x0074)
class UTgEffect_Listener : public UTgEffect
{
public:
	class UTgInventoryObject*                          s_InvObject;                                      		// 0x0074 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2388 );

		return pClassPointer;
	};

	void Remove ( class AActor* Target, unsigned long bResetToFollow );
	unsigned char ApplyEffect ( class AActor* Target, struct FImpactInfo Impact, unsigned long bConvertDOT );
};

UClass* UTgEffect_Listener::pClassPointer = NULL;

// Class TgGame.TgEffectDamage
// 0x0014 (0x0088 - 0x0074)
class UTgEffectDamage : public UTgEffect
{
public:
	int                                                m_nSimplifiedPropertyId;                          		// 0x0074 (0x0004) [0x0000000000000000]              
	class UClass*                                      m_DamageTypeClass;                                		// 0x0078 (0x0004) [0x0000000000000000]              
	class UClass*                                      m_DefaultDamageTypeClass;                         		// 0x007C (0x0004) [0x0000000000000000]              
	float                                              m_fDamageInitial;                                 		// 0x0080 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bApplyEveryInterval : 1;                        		// 0x0084 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2389 );

		return pClassPointer;
	};

	bool ApplyOnThisInterval ( );
	bool RemoveStacks ( class AActor* Target, int nNumStacks );
	bool ApplyStacks ( class AActor* Target, int nNumStacks, int nRequestedStacks );
	void ReturnLifeSteal ( class ATgPawn* InstigatorPawn, struct FImpactInfo Impact, float fProratedAmount );
	bool AddCriticalStrikeDamage ( class ATgPawn* InstigatorPawn, struct FImpactInfo Impact, float* fProratedAmount );
	void AddInstigatorScaling ( class ATgPawn* InstigatorPawn, class AActor* Target, struct FImpactInfo Impact, float* fProratedAmount );
	void ProtectionModifier ( struct FImpactInfo Impact, float* NewValue, float* fPercReduction );
	unsigned char ApplyEffect ( class AActor* Target, struct FImpactInfo Impact, unsigned long bConvertDOT );
	unsigned char CanBeApplied ( class AActor* Target );
	void SendKillingBlowMessage ( class AActor* Source, class AActor* Target, float fDamage, float fMitigated, struct FImpactInfo thisImpact, unsigned long bWasCritical );
	void SendDamageMessages ( class AActor* Source, class AActor* Target, float fDamage, float fMitigated, struct FImpactInfo thisImpact, unsigned long bWasCritical );
	void UnmitigatedDamageReflectHandler ( class AActor* pTarget, class ATgPawn* pInstigator, float fReflectableDamage );
	void DamageReflectHandler ( class AActor* pTarget, class ATgPawn* pInstigator, float fReflectableDamage );
	void PostDamageHandler ( class AActor* pTarget, class ATgPawn* pInstigator, struct FImpactInfo Impact, float fPrevHealth, float fHealthChange, float fBuffedDamage, float fMitigatedDamage, unsigned long bCritical );
	void DamageRedirectHandler ( class ATgPawn* pTarget, class ATgPawn* pInstigator, struct FImpactInfo Impact, float* NewValue );
	void PreDamageRedirectMitigation ( class ATgPawn* pTarget, class ATgPawn* pInstigator, struct FImpactInfo Impact, float* NewValue );
	void SetDamageTypeClass ( unsigned long WasCritical );
	class UTgEffect* CloneEffect ( );
};

UClass* UTgEffectDamage::pClassPointer = NULL;

// Class TgGame.TgEffectDamage_Backstab
// 0x0004 (0x008C - 0x0088)
class UTgEffectDamage_Backstab : public UTgEffectDamage
{
public:
	unsigned long                                      m_bIsBackstab : 1;                                		// 0x0088 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2390 );

		return pClassPointer;
	};

	void AddInstigatorScaling ( class ATgPawn* InstigatorPawn, class AActor* Target, struct FImpactInfo Impact, float* fProratedAmount );
	void SendDamageMessages ( class AActor* Source, class AActor* Target, float fDamage, float fMitigated, struct FImpactInfo thisImpact, unsigned long bWasCritical );
	unsigned char ApplyEffect ( class AActor* Target, struct FImpactInfo Impact, unsigned long bConvertDOT );
};

UClass* UTgEffectDamage_Backstab::pClassPointer = NULL;

// Class TgGame.TgEffectDamage_Distance
// 0x0010 (0x0098 - 0x0088)
class UTgEffectDamage_Distance : public UTgEffectDamage
{
public:
	class UTgEffectDamage_DistanceApplyComponent*      m_ApplyComponent;                                 		// 0x0088 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	float                                              m_fApplyDistance;                                 		// 0x008C (0x0004) [0x0000000000000000]              
	int                                                m_nApplyMax;                                      		// 0x0090 (0x0004) [0x0000000000000000]              
	int                                                m_nAppliesLeft;                                   		// 0x0094 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2391 );

		return pClassPointer;
	};

	void Remove ( class AActor* Target, unsigned long bResetToFollow );
	unsigned char ApplyEffect ( class AActor* Target, struct FImpactInfo Impact, unsigned long bConvertDOT );
	class UTgEffect* CloneEffect ( );
};

UClass* UTgEffectDamage_Distance::pClassPointer = NULL;

// Class TgGame.TgEffectDamage_ExposeEvil
// 0x0004 (0x008C - 0x0088)
class UTgEffectDamage_ExposeEvil : public UTgEffectDamage
{
public:
	float                                              m_fPortionToApplyOnRemove;                        		// 0x0088 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2392 );

		return pClassPointer;
	};

	void Remove ( class AActor* Target, unsigned long bResetToFollow );
};

UClass* UTgEffectDamage_ExposeEvil::pClassPointer = NULL;

// Class TgGame.TgEffectDamage_MegaKill
// 0x000C (0x0094 - 0x0088)
class UTgEffectDamage_MegaKill : public UTgEffectDamage
{
public:
	int                                                m_nMegaKillDamageType;                            		// 0x0088 (0x0004) [0x0000000000000000]              
	float                                              m_fMegaKillDamageAmount;                          		// 0x008C (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bAllowCrowdControlImmuneTargets : 1;            		// 0x0090 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2393 );

		return pClassPointer;
	};

	float GetProratedValue ( );
	void SendKillingBlowMessage ( class AActor* Source, class AActor* Target, float fDamage, float fMitigated, struct FImpactInfo thisImpact, unsigned long bWasCritical );
	void SendDamageMessages ( class AActor* Source, class AActor* Target, float fDamage, float fMitigated, struct FImpactInfo thisImpact, unsigned long bWasCritical );
	void ReturnLifeSteal ( class ATgPawn* InstigatorPawn, struct FImpactInfo Impact, float fProratedAmount );
	bool AddCriticalStrikeDamage ( class ATgPawn* InstigatorPawn, struct FImpactInfo Impact, float* fProratedAmount );
	void AddInstigatorScaling ( class ATgPawn* InstigatorPawn, class AActor* Target, struct FImpactInfo Impact, float* fProratedAmount );
	void ProtectionModifier ( struct FImpactInfo Impact, float* NewValue, float* fPercReduction );
	void PowerScalingModifier ( class ATgPawn* pawnInstigator, class ATgPawn* PawnTarget, struct FImpactInfo Impact, float* fAmount );
	unsigned char ApplyEffect ( class AActor* Target, struct FImpactInfo Impact, unsigned long bConvertDOT );
	void UnmitigatedDamageReflectHandler ( class AActor* pTarget, class ATgPawn* pInstigator, float fReflectableDamage );
	void DamageReflectHandler ( class AActor* pTarget, class ATgPawn* pInstigator, float fReflectableDamage );
	void DamageRedirectHandler ( class ATgPawn* pTarget, class ATgPawn* pInstigator, struct FImpactInfo Impact, float* NewValue );
	void PreDamageRedirectMitigation ( class ATgPawn* pTarget, class ATgPawn* pInstigator, struct FImpactInfo Impact, float* NewValue );
};

UClass* UTgEffectDamage_MegaKill::pClassPointer = NULL;

// Class TgGame.TgEffectDamage_UnstoppableKill
// 0x0000 (0x0094 - 0x0094)
class UTgEffectDamage_UnstoppableKill : public UTgEffectDamage_MegaKill
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2394 );

		return pClassPointer;
	};

};

UClass* UTgEffectDamage_UnstoppableKill::pClassPointer = NULL;

// Class TgGame.TgEffectDamage_NeZha_UltCrit
// 0x0004 (0x008C - 0x0088)
class UTgEffectDamage_NeZha_UltCrit : public UTgEffectDamage
{
public:
	unsigned long                                      bIsSuccessfulHit : 1;                             		// 0x0088 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2395 );

		return pClassPointer;
	};

	bool AddCriticalStrikeDamage ( class ATgPawn* InstigatorPawn, struct FImpactInfo Impact, float* ProratedAmount );
	unsigned char ApplyEffect ( class AActor* Target, struct FImpactInfo Impact, unsigned long bConvertDOT );
};

UClass* UTgEffectDamage_NeZha_UltCrit::pClassPointer = NULL;

// Class TgGame.TgEffectDamage_NoLifeSteal
// 0x0000 (0x0088 - 0x0088)
class UTgEffectDamage_NoLifeSteal : public UTgEffectDamage
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2396 );

		return pClassPointer;
	};

	void ReturnLifeSteal ( class ATgPawn* InstigatorPawn, struct FImpactInfo Impact, float fProratedAmount );
};

UClass* UTgEffectDamage_NoLifeSteal::pClassPointer = NULL;

// Class TgGame.TgEffectDamage_ReducedLifeSteal
// 0x0000 (0x0088 - 0x0088)
class UTgEffectDamage_ReducedLifeSteal : public UTgEffectDamage
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2397 );

		return pClassPointer;
	};

	void ReturnLifeSteal ( class ATgPawn* InstigatorPawn, struct FImpactInfo Impact, float fProratedAmount );
};

UClass* UTgEffectDamage_ReducedLifeSteal::pClassPointer = NULL;

// Class TgGame.TgEffectHeal
// 0x0008 (0x007C - 0x0074)
class UTgEffectHeal : public UTgEffect
{
public:
	float                                              m_MissingHealthInitial;                           		// 0x0074 (0x0004) [0x0000000000000000]              
	int                                                m_nSimplifiedPropertyId;                          		// 0x0078 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2398 );

		return pClassPointer;
	};

	void HealScalingModifier ( class ATgPawn* pawnInstigator, class ATgPawn* PawnTarget, struct FImpactInfo Impact, float* fAmount );
	class UTgEffect* CloneEffect ( );
	void PostHealHandler ( class AActor* pTarget, class ATgPawn* pInstigator, struct FImpactInfo Impact, float fHealthChange, float fHealAmount );
	bool RemoveStacks ( class AActor* Target, int nNumStacks );
	bool ApplyStacks ( class AActor* Target, int nNumStacks, int nRequestedStacks );
	void AddInstigatorScaling ( class ATgPawn* InstigatorPawn, class AActor* Target, struct FImpactInfo Impact, float* fProratedAmount );
	unsigned char ApplyEffect ( class AActor* Target, struct FImpactInfo Impact, unsigned long bConvertDOT );
	bool CanTargetBeRepaired ( class AActor* Target );
	unsigned char CanBeApplied ( class AActor* Target );
};

UClass* UTgEffectHeal::pClassPointer = NULL;

// Class TgGame.TgEffectDamage_DistanceApplyComponent
// 0x0017 (0x006C - 0x0055)
class UTgEffectDamage_DistanceApplyComponent : public UActorComponent
{
public:
	class UTgEffectDamage_Distance*                    m_OwningEffect;                                   		// 0x0058 (0x0004) [0x0000000000000000]              
	struct FVector                                     m_fLastLocation;                                  		// 0x005C (0x000C) [0x0000000000000000]              
	float                                              m_fDistanceCache;                                 		// 0x0068 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2399 );

		return pClassPointer;
	};

};

UClass* UTgEffectDamage_DistanceApplyComponent::pClassPointer = NULL;

// Class TgGame.TgEffectForm
// 0x005C (0x0098 - 0x003C)
class UTgEffectForm : public UObject
{
public:
	int                                                c_nEffectGroupId;                                 		// 0x003C (0x0004) [0x0000000000000000]              
	int                                                c_nType;                                          		// 0x0040 (0x0004) [0x0000000000000000]              
	class AActor*                                      c_Owner;                                          		// 0x0044 (0x0004) [0x0000000000000000]              
	struct FPointer                                    c_pwzEffectName;                                  		// 0x0048 (0x0004) [0x0000000000001000]              ( CPF_Native )
	struct FPointer                                    c_pwzDescription;                                 		// 0x004C (0x0004) [0x0000000000001000]              ( CPF_Native )
	int                                                c_nEffectIconId;                                  		// 0x0050 (0x0004) [0x0000000000000000]              
	TArray< class UTgSpecialFx* >                      c_AppliedFxArray;                                 		// 0x0054 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	unsigned long                                      c_bHiddenDueToStealth : 1;                        		// 0x0060 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      c_bHiddenDueToFirstPerson : 1;                    		// 0x0060 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      c_bMICApplied : 1;                                		// 0x0060 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_bSpawnAtHitLocation : 1;                        		// 0x0060 (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      m_bSpawnAtGround : 1;                             		// 0x0060 (0x0004) [0x0000000000000000] [0x00000010] 
	unsigned long                                      c_bIsDebuff : 1;                                  		// 0x0060 (0x0004) [0x0000000000000000] [0x00000020] 
	unsigned long                                      c_bIsCrit : 1;                                    		// 0x0060 (0x0004) [0x0000000000000000] [0x00000040] 
	unsigned long                                      c_bLocal : 1;                                     		// 0x0060 (0x0004) [0x0000000000000000] [0x00000080] 
	unsigned char                                      c_Posture;                                        		// 0x0064 (0x0001) [0x0000000000000000]              
	unsigned char                                      c_nSkinLevel;                                     		// 0x0065 (0x0001) [0x0000000000000000]              
	int                                                c_PostureID;                                      		// 0x0068 (0x0004) [0x0000000000000000]              
	class UMaterialInstanceConstant*                   m_MaterialInstanceConstant;                       		// 0x006C (0x0004) [0x0000000000000000]              
	class ATgPawn*                                     m_OwnerPawn;                                      		// 0x0070 (0x0004) [0x0000000000000000]              
	struct FVector                                     m_HitLocation;                                    		// 0x0074 (0x000C) [0x0000000000000000]              
	struct FVector                                     m_HitNormal;                                      		// 0x0080 (0x000C) [0x0000000000000000]              
	int                                                c_nSkinId;                                        		// 0x008C (0x0004) [0x0000000000000000]              
	int                                                c_nCustomParticleSystemFilter;                    		// 0x0090 (0x0004) [0x0000000000000000]              
	int                                                c_nInstigatorId;                                  		// 0x0094 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2400 );

		return pClassPointer;
	};

	bool ShouldShowEffectForm ( );
	void AdjustHidden ( );
	void Detach ( );
	void Reattach ( );
	void Attach ( class AActor* pOwner );
	void RefreshEffectForm ( );
	void HideEffectForm ( );
	void ShowEffectForm ( unsigned long bLocal );
	void RecalculateFx ( );
};

UClass* UTgEffectForm::pClassPointer = NULL;

// Class TgGame.TgEffectForm_Ares_Aura
// 0x000C (0x00A4 - 0x0098)
class UTgEffectForm_Ares_Aura : public UTgEffectForm
{
public:
	int                                                m_InstigatorFXId;                                 		// 0x0098 (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                m_InstigatorFX;                                   		// 0x009C (0x0004) [0x0000000000000000]              
	int                                                m_DespawnFXId;                                    		// 0x00A0 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2401 );

		return pClassPointer;
	};

	void HideEffectForm ( );
	void ShowEffectForm ( unsigned long bLocal );
};

UClass* UTgEffectForm_Ares_Aura::pClassPointer = NULL;

// Class TgGame.TgEffectForm_BuffBelt
// 0x0019 (0x00B1 - 0x0098)
class UTgEffectForm_BuffBelt : public UTgEffectForm
{
public:
	struct FPointer                                    VfTable_FTickableObject;                          		// 0x0098 (0x0004) [0x0000000000801002]              ( CPF_Const | CPF_Native | CPF_NoExport )
	float                                              m_OrbitAngleYawOffset;                            		// 0x009C (0x0004) [0x0000000000000000]              
	float                                              m_OrbitHeightOffset;                              		// 0x00A0 (0x0004) [0x0000000000000000]              
	float                                              m_fBeltHeight;                                    		// 0x00A4 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bFirstUpdate : 1;                               		// 0x00A8 (0x0004) [0x0000000000000000] [0x00000001] 
	float                                              m_OrbitRotationSpeed;                             		// 0x00AC (0x0004) [0x0000000000000000]              
	unsigned char                                      Priority;                                         		// 0x00B0 (0x0001) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2402 );

		return pClassPointer;
	};

	bool ShouldShowEffectForm ( );
};

UClass* UTgEffectForm_BuffBelt::pClassPointer = NULL;

// Class TgGame.TgEffectForm_BulwarkOfHope
// 0x000C (0x00A4 - 0x0098)
class UTgEffectForm_BulwarkOfHope : public UTgEffectForm
{
public:
	int                                                m_OutroFXId;                                      		// 0x0098 (0x0004) [0x0000000000000000]              
	struct FName                                       m_OutroDisplayGroup;                              		// 0x009C (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2403 );

		return pClassPointer;
	};

	void HideEffectForm ( );
};

UClass* UTgEffectForm_BulwarkOfHope::pClassPointer = NULL;

// Class TgGame.TgEffectForm_Neith_RootBreak
// 0x0000 (0x00A4 - 0x00A4)
class UTgEffectForm_Neith_RootBreak : public UTgEffectForm_BulwarkOfHope
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2404 );

		return pClassPointer;
	};

};

UClass* UTgEffectForm_Neith_RootBreak::pClassPointer = NULL;

// Class TgGame.TgEffectForm_DisablePawn
// 0x0004 (0x009C - 0x0098)
class UTgEffectForm_DisablePawn : public UTgEffectForm
{
public:
	unsigned long                                      m_bPauseAnims : 1;                                		// 0x0098 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2405 );

		return pClassPointer;
	};

	void HideEffectForm ( );
	void ShowEffectForm ( unsigned long bLocal );
};

UClass* UTgEffectForm_DisablePawn::pClassPointer = NULL;

// Class TgGame.TgEffectForm_Freeze
// 0x0004 (0x00A0 - 0x009C)
class UTgEffectForm_Freeze : public UTgEffectForm_DisablePawn
{
public:
	int                                                m_BurstingIceFXId;                                		// 0x009C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2406 );

		return pClassPointer;
	};

	void HideEffectForm ( );
};

UClass* UTgEffectForm_Freeze::pClassPointer = NULL;

// Class TgGame.TgEffectForm_HideNameplates
// 0x0000 (0x0098 - 0x0098)
class UTgEffectForm_HideNameplates : public UTgEffectForm
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2407 );

		return pClassPointer;
	};

};

UClass* UTgEffectForm_HideNameplates::pClassPointer = NULL;

// Class TgGame.TgEffectForm_NeZha_UltCrit
// 0x0000 (0x0098 - 0x0098)
class UTgEffectForm_NeZha_UltCrit : public UTgEffectForm
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2408 );

		return pClassPointer;
	};

	bool ShouldShowEffectForm ( );
};

UClass* UTgEffectForm_NeZha_UltCrit::pClassPointer = NULL;

// Class TgGame.TgEffectForm_Nike_Armor
// 0x000C (0x00A4 - 0x0098)
class UTgEffectForm_Nike_Armor : public UTgEffectForm
{
public:
	TArray< int >                                      m_MaterialsToSwap;                                		// 0x0098 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2409 );

		return pClassPointer;
	};

};

UClass* UTgEffectForm_Nike_Armor::pClassPointer = NULL;

// Class TgGame.TgEffectForm_Osiris_SoulRip
// 0x0004 (0x009C - 0x0098)
class UTgEffectForm_Osiris_SoulRip : public UTgEffectForm
{
public:
	class ATgProj_Osiris_SoulRipDummy*                 m_Projectile;                                     		// 0x0098 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2410 );

		return pClassPointer;
	};

	void AdjustHidden ( );
	void Detach ( );
	void HideEffectForm ( );
	void ShowEffectForm ( unsigned long bLocal );
};

UClass* UTgEffectForm_Osiris_SoulRip::pClassPointer = NULL;

// Class TgGame.TgEffectForm_ScaryPotion
// 0x000C (0x00A4 - 0x0098)
class UTgEffectForm_ScaryPotion : public UTgEffectForm
{
public:
	TArray< int >                                      m_OutroFXIds;                                     		// 0x0098 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2411 );

		return pClassPointer;
	};

	void HideEffectForm ( );
};

UClass* UTgEffectForm_ScaryPotion::pClassPointer = NULL;

// Class TgGame.TgEffectForm_Stealth
// 0x0000 (0x0098 - 0x0098)
class UTgEffectForm_Stealth : public UTgEffectForm
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2412 );

		return pClassPointer;
	};

	void AdjustHidden ( );
	void HideEffectForm ( );
	void ShowEffectForm ( unsigned long bLocal );
};

UClass* UTgEffectForm_Stealth::pClassPointer = NULL;

// Class TgGame.TgEffectForm_Loki_Vanish
// 0x0004 (0x009C - 0x0098)
class UTgEffectForm_Loki_Vanish : public UTgEffectForm_Stealth
{
public:
	int                                                m_BreakingStealthFXId;                            		// 0x0098 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2413 );

		return pClassPointer;
	};

	void HideEffectForm ( );
};

UClass* UTgEffectForm_Loki_Vanish::pClassPointer = NULL;

// Class TgGame.TgEffectForm_TeleportToBase
// 0x0008 (0x00A0 - 0x0098)
class UTgEffectForm_TeleportToBase : public UTgEffectForm
{
public:
	int                                                c_DefaultFxId;                                    		// 0x0098 (0x0004) [0x0000000000000000]              
	int                                                m_FxOverrideId;                                   		// 0x009C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2414 );

		return pClassPointer;
	};

};

UClass* UTgEffectForm_TeleportToBase::pClassPointer = NULL;

// Class TgGame.TgEffectForm_UniqueForSelf
// 0x0000 (0x0098 - 0x0098)
class UTgEffectForm_UniqueForSelf : public UTgEffectForm
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2415 );

		return pClassPointer;
	};

	void RefreshEffectForm ( );
	void ShowEffectForm ( unsigned long bLocal );
};

UClass* UTgEffectForm_UniqueForSelf::pClassPointer = NULL;

// Class TgGame.TgEffectForm_WithDuration
// 0x0000 (0x0098 - 0x0098)
class UTgEffectForm_WithDuration : public UTgEffectForm
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2416 );

		return pClassPointer;
	};

	float GetEffectGroupDuration ( );
	void ShowEffectForm ( unsigned long bLocal );
};

UClass* UTgEffectForm_WithDuration::pClassPointer = NULL;

// Class TgGame.TgEffectForm_WithMeshes
// 0x000C (0x00A4 - 0x0098)
class UTgEffectForm_WithMeshes : public UTgEffectForm
{
public:
	TArray< struct FEffectMeshInfo >                   m_EffectMeshInfos;                                		// 0x0098 (0x000C) [0x0000000000480000]              ( CPF_Component | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2417 );

		return pClassPointer;
	};

	void DetachMeshes ( );
	void AttachMeshes ( class AActor* pOwner );
	void AdjustHidden ( );
	void Detach ( );
	void Reattach ( );
	void Attach ( class AActor* pOwner );
	void HideEffectForm ( );
	void ShowEffectForm ( unsigned long bLocal );
	void RecalculateFx ( );
};

UClass* UTgEffectForm_WithMeshes::pClassPointer = NULL;

// Class TgGame.TgEffectForm_AbsoluteTranslation
// 0x0000 (0x00A4 - 0x00A4)
class UTgEffectForm_AbsoluteTranslation : public UTgEffectForm_WithMeshes
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2418 );

		return pClassPointer;
	};

	void AttachMeshes ( class AActor* pOwner );
};

UClass* UTgEffectForm_AbsoluteTranslation::pClassPointer = NULL;

// Class TgGame.TgEffectForm_Aphrodite_Birds
// 0x0000 (0x00A4 - 0x00A4)
class UTgEffectForm_Aphrodite_Birds : public UTgEffectForm_WithMeshes
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2419 );

		return pClassPointer;
	};

};

UClass* UTgEffectForm_Aphrodite_Birds::pClassPointer = NULL;

// Class TgGame.TgEffectForm_Arachne_SpiderGrenade
// 0x0000 (0x00A4 - 0x00A4)
class UTgEffectForm_Arachne_SpiderGrenade : public UTgEffectForm_WithMeshes
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2420 );

		return pClassPointer;
	};

};

UClass* UTgEffectForm_Arachne_SpiderGrenade::pClassPointer = NULL;

// Class TgGame.TgEffectForm_Cupid_Mark
// 0x0004 (0x00A8 - 0x00A4)
class UTgEffectForm_Cupid_Mark : public UTgEffectForm_WithMeshes
{
public:
	int                                                c_CupidHeartMarkExplosionFXId;                    		// 0x00A4 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2421 );

		return pClassPointer;
	};

	void AdjustHidden ( );
	void Detach ( );
	void Reattach ( );
	void Attach ( class AActor* pOwner );
	void HideEffectForm ( );
	void ShowEffectForm ( unsigned long bLocal );
};

UClass* UTgEffectForm_Cupid_Mark::pClassPointer = NULL;

// Class TgGame.TgEffectForm_Mummify
// 0x0008 (0x00AC - 0x00A4)
class UTgEffectForm_Mummify : public UTgEffectForm_WithMeshes
{
public:
	int                                                m_BurstingBandagesFXId;                           		// 0x00A4 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bPauseAnims : 1;                                		// 0x00A8 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2422 );

		return pClassPointer;
	};

	void HideEffectForm ( );
	void ShowEffectForm ( unsigned long bLocal );
};

UClass* UTgEffectForm_Mummify::pClassPointer = NULL;

// Class TgGame.TgEffectForm_Mummify_V2
// 0x0000 (0x00AC - 0x00AC)
class UTgEffectForm_Mummify_V2 : public UTgEffectForm_Mummify
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2423 );

		return pClassPointer;
	};

};

UClass* UTgEffectForm_Mummify_V2::pClassPointer = NULL;

// Class TgGame.TgEffectForm_Ravana_Root
// 0x0000 (0x00A4 - 0x00A4)
class UTgEffectForm_Ravana_Root : public UTgEffectForm_WithMeshes
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2424 );

		return pClassPointer;
	};

	void DetachMeshes ( );
};

UClass* UTgEffectForm_Ravana_Root::pClassPointer = NULL;

// Class TgGame.TgEffectForm_Scylla_TentacleRoot
// 0x0000 (0x00A4 - 0x00A4)
class UTgEffectForm_Scylla_TentacleRoot : public UTgEffectForm_WithMeshes
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2425 );

		return pClassPointer;
	};

	void DetachMeshes ( );
};

UClass* UTgEffectForm_Scylla_TentacleRoot::pClassPointer = NULL;

// Class TgGame.TgEffectForm_Sylvanus_Wisp
// 0x0000 (0x00A4 - 0x00A4)
class UTgEffectForm_Sylvanus_Wisp : public UTgEffectForm_WithMeshes
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2426 );

		return pClassPointer;
	};

};

UClass* UTgEffectForm_Sylvanus_Wisp::pClassPointer = NULL;

// Class TgGame.TgEffectForm_ZhongKui_FierceGlare
// 0x0000 (0x00A4 - 0x00A4)
class UTgEffectForm_ZhongKui_FierceGlare : public UTgEffectForm_WithMeshes
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2427 );

		return pClassPointer;
	};

	void AttachMeshes ( class AActor* pOwner );
};

UClass* UTgEffectForm_ZhongKui_FierceGlare::pClassPointer = NULL;

// Class TgGame.TgEffectForm_Xbalanque_ApocalypseShroud
// 0x0014 (0x00AC - 0x0098)
class UTgEffectForm_Xbalanque_ApocalypseShroud : public UTgEffectForm
{
public:
	struct FPointer                                    VfTable_FTickableObject;                          		// 0x0098 (0x0004) [0x0000000000801002]              ( CPF_Const | CPF_Native | CPF_NoExport )
	class UMeshComponent*                              m_CounterMesh;                                    		// 0x009C (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	int                                                m_ShroudFXId;                                     		// 0x00A0 (0x0004) [0x0000000000000000]              
	int                                                m_OutroFXId;                                      		// 0x00A4 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bAllowShroudAttach : 1;                         		// 0x00A8 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2428 );

		return pClassPointer;
	};

	void DetachMeshes ( );
	void AttachMeshes ( class AActor* pOwner );
	void AdjustHidden ( );
	void Detach ( );
	void Reattach ( );
	void Attach ( class AActor* pOwner );
	void HideEffectForm ( );
	void ShowEffectForm ( unsigned long bLocal );
	void RecalculateFx ( );
};

UClass* UTgEffectForm_Xbalanque_ApocalypseShroud::pClassPointer = NULL;

// Class TgGame.TgEffectForm_Xbalanque_SplittingProjectileStim
// 0x0004 (0x009C - 0x0098)
class UTgEffectForm_Xbalanque_SplittingProjectileStim : public UTgEffectForm
{
public:
	struct FPointer                                    VfTable_FTickableObject;                          		// 0x0098 (0x0004) [0x0000000000801002]              ( CPF_Const | CPF_Native | CPF_NoExport )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2429 );

		return pClassPointer;
	};

};

UClass* UTgEffectForm_Xbalanque_SplittingProjectileStim::pClassPointer = NULL;

// Class TgGame.TgEffectGroup
// 0x0114 (0x0150 - 0x003C)
class UTgEffectGroup : public UObject
{
public:
	int                                                m_nType;                                          		// 0x003C (0x0004) [0x0000000000000000]              
	class AActor*                                      m_Target;                                         		// 0x0040 (0x0004) [0x0000000000000000]              
	class AActor*                                      m_Instigator;                                     		// 0x0044 (0x0004) [0x0000000000000000]              
	int                                                m_nEffectGroupId;                                 		// 0x0048 (0x0004) [0x0000000000000000]              
	float                                              m_fLifeTime;                                      		// 0x004C (0x0004) [0x0000000000000000]              
	float                                              m_fModLifeTime;                                   		// 0x0050 (0x0004) [0x0000000000000000]              
	float                                              m_fApplyInterval;                                 		// 0x0054 (0x0004) [0x0000000000000000]              
	TArray< class UTgEffect* >                         m_Effects;                                        		// 0x0058 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                m_nDamageType;                                    		// 0x0064 (0x0004) [0x0000000000000000]              
	unsigned char                                      m_eAttackType;                                    		// 0x0068 (0x0001) [0x0000000000000000]              
	unsigned long                                      m_bIsManaged : 1;                                 		// 0x006C (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bSkillEffect : 1;                               		// 0x006C (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_bItemEffect : 1;                                		// 0x006C (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_bEfficiencyEffect : 1;                          		// 0x006C (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      m_bHasSlowEffect : 1;                             		// 0x006C (0x0004) [0x0000000000000000] [0x00000010] 
	unsigned long                                      m_bHasStealthEffect : 1;                          		// 0x006C (0x0004) [0x0000000000000000] [0x00000020] 
	unsigned long                                      m_bHasSlowToHaltEffect : 1;                       		// 0x006C (0x0004) [0x0000000000000000] [0x00000040] 
	unsigned long                                      m_bHasPortalFallEffect : 1;                       		// 0x006C (0x0004) [0x0000000000000000] [0x00000080] 
	unsigned long                                      m_bHasAttackSpeedDebuff : 1;                      		// 0x006C (0x0004) [0x0000000000000000] [0x00000100] 
	unsigned long                                      m_bDoesDamage : 1;                                		// 0x006C (0x0004) [0x0000000000000000] [0x00000200] 
	unsigned long                                      m_bIrreducible : 1;                               		// 0x006C (0x0004) [0x0000000000000000] [0x00000400] 
	unsigned long                                      m_bContagious : 1;                                		// 0x006C (0x0004) [0x0000000000000000] [0x00000800] 
	unsigned long                                      s_bActiveFlag : 1;                                		// 0x006C (0x0004) [0x0000000000000000] [0x00001000] 
	unsigned long                                      s_bCriticalHitFlag : 1;                           		// 0x006C (0x0004) [0x0000000000000000] [0x00002000] 
	unsigned long                                      m_bDeviceSpecificFlag : 1;                        		// 0x006C (0x0004) [0x0000000000000000] [0x00004000] 
	unsigned long                                      m_bReflectDamage : 1;                             		// 0x006C (0x0004) [0x0000000000000000] [0x00008000] 
	unsigned long                                      m_bHasVisual : 1;                                 		// 0x006C (0x0004) [0x0000000000000000] [0x00010000] 
	float                                              m_fPercAbsorbedDamage;                            		// 0x0070 (0x0004) [0x0000000000000000]              
	int                                                m_nApplicationType;                               		// 0x0074 (0x0004) [0x0000000000000000]              
	float                                              m_fApplicationValue;                              		// 0x0078 (0x0004) [0x0000000000000000]              
	float                                              m_fApplicationChance;                             		// 0x007C (0x0004) [0x0000000000000000]              
	int                                                m_nApplicationCategoryCode;                       		// 0x0080 (0x0004) [0x0000000000000000]              
	int                                                m_nBehaviorCategoryCode;                          		// 0x0084 (0x0004) [0x0000000000000000]              
	int                                                m_nReqDeviceInstanceId;                           		// 0x0088 (0x0004) [0x0000000000000000]              
	float                                              m_fBuffValue;                                     		// 0x008C (0x0004) [0x0000000000000000]              
	float                                              m_fPhysicalPowerScaling;                          		// 0x0090 (0x0004) [0x0000000000000000]              
	float                                              m_fMagicalPowerScaling;                           		// 0x0094 (0x0004) [0x0000000000000000]              
	float                                              m_fLifetimeScaling;                               		// 0x0098 (0x0004) [0x0000000000000000]              
	float                                              m_fLifetimeMax;                                   		// 0x009C (0x0004) [0x0000000000000000]              
	int                                                m_nScalingType;                                   		// 0x00A0 (0x0004) [0x0000000000000000]              
	int                                                m_nTargetType;                                    		// 0x00A4 (0x0004) [0x0000000000000000]              
	int                                                m_nTargetAffectsType;                             		// 0x00A8 (0x0004) [0x0000000000000000]              
	int                                                m_nHitSpecialSituationalType;                     		// 0x00AC (0x0004) [0x0000000000000000]              
	int                                                m_nNumStacks;                                     		// 0x00B0 (0x0004) [0x0000000000000000]              
	int                                                m_nNumMaxStacks;                                  		// 0x00B4 (0x0004) [0x0000000000000000]              
	class UTgEffectGroup*                              s_NonContagiousEffectGroup;                       		// 0x00B8 (0x0004) [0x0000000000000000]              
	struct FImpactInfo                                 m_Impact;                                         		// 0x00BC (0x0060) [0x0000000000080000]              ( CPF_Component )
	int                                                m_nPosture;                                       		// 0x011C (0x0004) [0x0000000000000000]              
	int                                                m_nFxAppliedId;                                   		// 0x0120 (0x0004) [0x0000000000000000]              
	struct FName                                       m_nmDisplayGroup;                                 		// 0x0124 (0x0008) [0x0000000000000000]              
	int                                                s_ManagedEffectListIndex;                         		// 0x012C (0x0004) [0x0000000000000000]              
	class ATgEffectManager*                            s_OwnerEffectManager;                             		// 0x0130 (0x0004) [0x0000000000000000]              
	struct FName                                       m_nmDamageTypeClass;                              		// 0x0134 (0x0008) [0x0000000000000000]              
	int                                                m_nSourceDeviceSkillId;                           		// 0x013C (0x0004) [0x0000000000000000]              
	int                                                m_nSourceDeviceInstId;                            		// 0x0140 (0x0004) [0x0000000000000000]              
	int                                                m_nSourceItemId;                                  		// 0x0144 (0x0004) [0x0000000000000000]              
	float                                              s_fEGShieldHealth;                                		// 0x0148 (0x0004) [0x0000000000000000]              
	float                                              s_fEGShieldHealthMax;                             		// 0x014C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2430 );

		return pClassPointer;
	};

	float HealShield ( float fHeal );
	float DamageShield ( float fDamage );
	float GetShieldMaxHealth ( );
	float GetShieldHealth ( );
	bool HasShield ( );
	void QueueRemovalOnManagerTick ( );
	float GetUtilityPower ( );
	float GetLifeTime ( unsigned long bModifiers );
	void LifeDone ( );
	void ApplyInterval ( );
	bool ApplyEffects ( );
	float GetIntervalTimeRemaining ( );
	float GetPercentTimeRemaining ( );
	float GetTimeRemaining ( );
	float GetTimeElapsed ( );
	void SetActive ( unsigned long bActive, unsigned long bRemoving );
	bool IsActive ( );
	bool HasCategoryCode ( int nCategoryCode, unsigned long bBehaviorOnly );
	bool Irreducible ( );
	bool DoesDamage ( );
	bool IsAttackSpeedDebuff ( );
	bool IsPortalFall ( );
	bool IsCrit ( );
	bool IsSlowToHalt ( );
	bool IsStealth ( );
	bool IsSlow ( );
	bool IsInstantaneous ( );
	bool PersistsThroughDeath ( );
	bool IsBuff ( );
	float CalcAttackTypeProtection ( class AActor* Target, float fValue, float* fPercReduction );
	float CalcDamageTypeProtection ( class AActor* Target, float fValue, int nPropertyId, float* fPercReduction );
	float CalcProtection ( class AActor* Target, int nProtectionType, float fValue, unsigned long bDamageReduction, int nDamagedPropertyId, float* fPercReduction );
	float CalcCategoryProtection ( class AActor* Target, float fValue, float* fPercReduction );
	class UTgProperty* GetProperty ( class AActor* Target, int nPropertyId );
	bool EffectExists ( int nPropId );
	float QueryFxTransitionTime ( );
	float TotalPropertyEffectAmt ( int nPropertyId );
	void RemoveEffects ( unsigned long bClearTimers );
	class UTgEffectGroup* CloneEffectGroup ( unsigned long bCloneAllEffects );
};

UClass* UTgEffectGroup::pClassPointer = NULL;

// Class TgGame.TgEffectManager
// 0x04E4 (0x06D4 - 0x01F0)
class ATgEffectManager : public AActor
{
public:
	struct FEffectListEntry                            r_ManagedEffectList[ 0x10 ];                      		// 0x01F0 (0x0180) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      c_byCounterList[ 0x10 ];                          		// 0x0370 (0x0010) [0x0000000000000000]              
	unsigned char                                      s_eCachedStunType;                                		// 0x0380 (0x0001) [0x0000000000000000]              
	unsigned char                                      s_CachedReveal[ 0x3 ];                            		// 0x0381 (0x0003) [0x0000000000000000]              
	float                                              m_fTimeRemaining[ 0x10 ];                         		// 0x0384 (0x0040) [0x0000000000000000]              
	class UTgEffectForm*                               c_Forms[ 0x10 ];                                  		// 0x03C4 (0x0040) [0x0000000000000000]              
	unsigned long                                      c_ActiveTimers : 1;                               		// 0x0404 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      r_bRelevancyNotify : 1;                           		// 0x0404 (0x0004) [0x0000000000000020] [0x00000002] ( CPF_Net )
	struct FEffectQueueEntry                           r_EventQueue[ 0x10 ];                             		// 0x0408 (0x0200) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nNextQueueIndex;                                		// 0x0608 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                c_nLastQueueIndex;                                		// 0x060C (0x0004) [0x0000000000000000]              
	TArray< class UTgEffectGroup* >                    s_AppliedEffectGroups;                            		// 0x0610 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class AActor*                                      r_Owner;                                          		// 0x061C (0x0004) [0x0000000000000020]              ( CPF_Net )
	class UTgEffectGroup*                              m_ApplyDamageEffectGroup;                         		// 0x0620 (0x0004) [0x0000000000000000]              
	class UTgEffect*                                   m_ApplyDamageEffect;                              		// 0x0624 (0x0004) [0x0000000000000000]              
	class UTgEffectGroup*                              m_ApplyUnstoppableKillEffectGroup;                		// 0x0628 (0x0004) [0x0000000000000000]              
	class UTgEffect*                                   m_ApplyUnstoppableKillEffect;                     		// 0x062C (0x0004) [0x0000000000000000]              
	class UTgEffectGroup*                              m_ApplyHealthEffectGroup;                         		// 0x0630 (0x0004) [0x0000000000000000]              
	class UTgEffect*                                   m_ApplyHealthEffect;                              		// 0x0634 (0x0004) [0x0000000000000000]              
	class UTgEffectGroup*                              m_ApplyManaEffectGroup;                           		// 0x0638 (0x0004) [0x0000000000000000]              
	class UTgEffect*                                   m_ApplyManaEffect;                                		// 0x063C (0x0004) [0x0000000000000000]              
	class UTgEffectGroup*                              m_ApplyEnergyEffectGroup;                         		// 0x0640 (0x0004) [0x0000000000000000]              
	class UTgEffect*                                   m_ApplyEnergyEffect;                              		// 0x0644 (0x0004) [0x0000000000000000]              
	TArray< struct FStunStackEntry >                   s_StunStack;                                      		// 0x0648 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< struct FRevealStackEntry >                 s_RevealStack;                                    		// 0x0654 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                r_nInvulnerableCount;                             		// 0x0660 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                s_nSilenceCount;                                  		// 0x0664 (0x0004) [0x0000000000000000]              
	int                                                s_nDisarmCount;                                   		// 0x0668 (0x0004) [0x0000000000000000]              
	int                                                s_nCrippleCount;                                  		// 0x066C (0x0004) [0x0000000000000000]              
	int                                                s_nSpellAbsorbCount;                              		// 0x0670 (0x0004) [0x0000000000000000]              
	int                                                s_nBasicAttackAbsorbCount;                        		// 0x0674 (0x0004) [0x0000000000000000]              
	int                                                s_nStealthCount;                                  		// 0x0678 (0x0004) [0x0000000000000000]              
	int                                                s_nNoWardStealthCount;                            		// 0x067C (0x0004) [0x0000000000000000]              
	int                                                s_nIntoxicateCount;                               		// 0x0680 (0x0004) [0x0000000000000000]              
	int                                                s_nImmortalCount;                                 		// 0x0684 (0x0004) [0x0000000000000000]              
	int                                                s_nSlowToHaltCount;                               		// 0x0688 (0x0004) [0x0000000000000000]              
	int                                                s_nCannotAutoPortalCount;                         		// 0x068C (0x0004) [0x0000000000000000]              
	int                                                s_nSlideCount;                                    		// 0x0690 (0x0004) [0x0000000000000000]              
	int                                                s_nHardCCCount;                                   		// 0x0694 (0x0004) [0x0000000000000000]              
	TArray< class UTgDeviceFire* >                     s_HardCCModesThisTick;                            		// 0x0698 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	TArray< class UTgEffectGroup* >                    s_ActiveSpellAbsorbs;                             		// 0x06A4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UTgEffectGroup* >                    s_ActiveBasicAttackAbsorbs;                       		// 0x06B0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UTgEffectGroup* >                    s_ActiveDamageRedirects;                          		// 0x06BC (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UTgDeviceFire* >                     s_ActiveSlowToHaltModes;                          		// 0x06C8 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2431 );

		return pClassPointer;
	};

	int ShieldTakeDamage ( int nDamage );
	void eventPostDemoRewind ( );
	void eventReplicatedEvent ( struct FName VarName );
	void PostBeginPlay ( );
	class ATgEffectManager* GetEffectManagerFor ( class AActor* ManagerOwner );
	class UTgEffectGroup* ProcessEffect ( class UTgEffectGroup* effectGroup, class AActor* aInstigator, int nNumStacks, struct FImpactInfo Impact );
	void RemoveProperty ( class UTgEffectGroup* effectGroup );
	class UTgEffectGroup* ApplyProperty ( float nValue, int nPropId, class AActor* aInstigator, struct FImpactInfo Impact, int nCategory, unsigned long bApplyAsPercent );
	void ApplyStasis ( int nValue, class AActor* aInstigator, int nAttackType, int nDamageType, struct FImpactInfo Impact, int nEffectGroupCategory );
	void ApplyStun ( float fDuration, class AActor* aInstigator, int nAttackType, int nDamageType, struct FImpactInfo Impact );
	void ApplyEnergy ( int nEnergy, class AActor* aInstigator, int nAttackType, int nDamageType, struct FImpactInfo Impact, int nEffectGroupCategory );
	void ApplyMana ( int nMana, class AActor* aInstigator, int nAttackType, int nDamageType, struct FImpactInfo Impact, int nEffectGroupCategory );
	void ApplyHealth ( int nHealth, class AActor* aInstigator, int nAttackType, int nDamageType, struct FImpactInfo Impact, int nEffectGroupCategory );
	void ApplyUnstoppableKill ( int nDamage, class AActor* aInstigator, int nAttackType, int nDamageType, struct FImpactInfo Impact, int nEffectGroupCategory );
	void ApplyDamage ( int nDamage, class AActor* aInstigator, int nAttackType, int nDamageType, struct FImpactInfo Impact, int nEffectGroupCategory );
	void ApplyHaltEffectGroups ( );
	bool Dodge ( class UTgDeviceFire* FireMode, class AActor* Source );
	bool AbsorbBasicAttack ( class UTgDeviceFire* FireMode, class AActor* Source );
	bool AbsorbSpell ( class UTgDeviceFire* FireMode, class AActor* Source );
	int GetHardCCCount ( class UTgDeviceFire* DeviceMode );
	void ResetCCEvents ( );
	void AddCCEvent ( class UTgEffectGroup* effectGroup );
	void RecalculateBeltFx ( );
	void RecalculateFx ( );
	int GetCombatMsgIdFromEffectGroup ( class UTgEffectGroup* effectGroup );
	bool IsSliding ( );
	bool IsIntoxicated ( );
	bool IsStunned ( );
	bool IsInvulnerable ( );
	void ClearAllClientEffectForms ( );
	void UpdateEffectFormVisibility ( );
	class UTgEffectGroup* GetEffectGroupByCategory ( int nCategoryCode, class AActor* theInstigator, int nNumToSkip );
	class UTgEffectGroup* GetEffectGroup ( int nEffectGroupId, class AActor* theInstigator );
	void MarkAllPortalFallEffectsAsNonRemovable ( );
	void RemoveAllStealthEffects ( );
	void RemoveAllEffectsOnDeath ( );
	void RemoveAllEffects ( );
	class UTgEffectGroup* GetNextStrongest ( class UTgEffectGroup* eg );
	bool IsStrongest ( class UTgEffectGroup* eg, unsigned long bConsiderLifetime, class UTgEffectGroup** prevStrongest );
	bool ResetEffectGroupLifeTimeByCategory ( int nCategoryCode, float Lifetime );
	bool ResetEffectGroupLifeTimeById ( int nEffectGroupId, float Lifetime );
	bool RemoveAllEffectGroups ( class UTgEffectGroup* eg );
	bool RemoveEffectGroupsByCategory ( int nCategoryCode, int nNumStacks, class AActor* theInstigator );
	bool RemoveEffectGroupById ( int nEffectGroupId, int nNumStacks, class AActor* theInstigator );
	void UpdateManagedEffectForms ( );
	void UpdateQueueEffectForms ( );
	void UpdateEffectForms ( );
	void ClearEffectRep ( class UTgEffectGroup* Group );
	void UpdateEffectRep ( class UTgEffectGroup* eg );
	int SetEffectRep ( class UTgEffectGroup* eg, int nSkinId, int nSkinLevel, int nCustomFilter );
};

UClass* ATgEffectManager::pClassPointer = NULL;

// Class TgGame.TgActorFactory
// 0x0034 (0x0224 - 0x01F0)
class ATgActorFactory : public AActor
{
public:
	int                                                m_nMapObjectId;                                   		// 0x01F0 (0x0004) [0x0000000000020001]              ( CPF_Edit | CPF_EditConst )
	unsigned long                                      s_bAutoSpawn : 1;                                 		// 0x01F4 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	int                                                s_nTeamNumber;                                    		// 0x01F8 (0x0004) [0x0000000000020000]              ( CPF_EditConst )
	unsigned char                                      s_nTaskForce;                                     		// 0x01FC (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_MinimapType;                                    		// 0x01FD (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      s_eSelectionMethod;                               		// 0x01FE (0x0001) [0x0000000000000001]              ( CPF_Edit )
	int                                                s_nSelectionListId;                               		// 0x0200 (0x0004) [0x0000000000000000]              
	int                                                s_nSelectedObjectId;                              		// 0x0204 (0x0004) [0x0000000000000000]              
	int                                                m_nSelectionListPropId;                           		// 0x0208 (0x0004) [0x0000000000000000]              
	int                                                s_nNameId;                                        		// 0x020C (0x0004) [0x0000000000000000]              
	int                                                s_nFactoryId;                                     		// 0x0210 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class ATgRepInfo_Factory*                          m_FRI;                                            		// 0x0214 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UClass*                                      m_FRIClass;                                       		// 0x0218 (0x0004) [0x0000000000000000]              
	int                                                s_nCurListIndex;                                  		// 0x021C (0x0004) [0x0000000000000000]              
	class USpriteComponent*                            m_WorldIconSprite;                                		// 0x0220 (0x0004) [0x0000000004080009]              ( CPF_Edit | CPF_ExportObject | CPF_Component | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2432 );

		return pClassPointer;
	};

	class AActor* GetLastActor ( );
	void Destroyed ( );
	void PostBeginPlay ( );
	void PreBeginPlay ( );
	void SetTaskForceNumber ( int nNewTaskForce );
	void CalcFactoryPlacement ( struct FVector Extent, unsigned long bCenterOnGround, struct FVector* OutLocation, struct FRotator* OutRotation );
	void SpawnObject ( );
	void LoadObjectConfig ( );
};

UClass* ATgActorFactory::pClassPointer = NULL;

// Class TgGame.TgBotFactory
// 0x0098 (0x02BC - 0x0224)
class ATgBotFactory : public ATgActorFactory
{
public:
	unsigned char                                      LocationSelection;                                		// 0x0224 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	TArray< class ANavigationPoint* >                  LocationList;                                     		// 0x0228 (0x000C) [0x0000000000400003]              ( CPF_Edit | CPF_Const | CPF_NeedCtorLink )
	int                                                s_nCurLocationIndex;                              		// 0x0234 (0x0004) [0x0000000000000000]              
	class ANavigationPoint*                            SafetyLocation;                                   		// 0x0238 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      ShouldTraceSpawnLocationToFloor : 1;              		// 0x023C (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      bStaggerSpawning : 1;                             		// 0x023C (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      bSpawnAsSquad : 1;                                		// 0x023C (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      bAutoSpawn : 1;                                   		// 0x023C (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      m_bFirstSpawn : 1;                                		// 0x023C (0x0004) [0x0000000000000000] [0x00000010] 
	unsigned long                                      bBulkSpawn : 1;                                   		// 0x023C (0x0004) [0x0000000000000001] [0x00000020] ( CPF_Edit )
	unsigned long                                      bRespawn : 1;                                     		// 0x023C (0x0004) [0x0000000000000001] [0x00000040] ( CPF_Edit )
	unsigned long                                      delayRespawnIndicator : 1;                        		// 0x023C (0x0004) [0x0000000000000000] [0x00000080] 
	unsigned long                                      bStartBotsInIntroState : 1;                       		// 0x023C (0x0004) [0x0000000000000001] [0x00000100] ( CPF_Edit )
	unsigned long                                      bHasDifferentInitialIntro : 1;                    		// 0x023C (0x0004) [0x0000000000000001] [0x00000200] ( CPF_Edit )
	unsigned long                                      m_bFirstSpawnWave : 1;                            		// 0x023C (0x0004) [0x0000000000000000] [0x00000400] 
	unsigned long                                      m_bRespawnRebuildMeshEnabled : 1;                 		// 0x023C (0x0004) [0x0000000000000000] [0x00000800] 
	unsigned long                                      m_bIgnoreCollisionOnSpawn : 1;                    		// 0x023C (0x0004) [0x0000000000000001] [0x00001000] ( CPF_Edit )
	unsigned long                                      m_bForceTracking : 1;                             		// 0x023C (0x0004) [0x0000000000000001] [0x00002000] ( CPF_Edit )
	unsigned long                                      m_bSpawnPaused : 1;                               		// 0x023C (0x0004) [0x0000000000000001] [0x00004000] ( CPF_Edit )
	unsigned long                                      m_bUseCollisionHeightForSpawnPlacement : 1;       		// 0x023C (0x0004) [0x0000000000000001] [0x00008000] ( CPF_Edit )
	int                                                nBotCount;                                        		// 0x0240 (0x0004) [0x0000000000000000]              
	int                                                nCurrentCount;                                    		// 0x0244 (0x0004) [0x0000000000000000]              
	int                                                nActiveCount;                                     		// 0x0248 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                nTotalSpawns;                                     		// 0x024C (0x0004) [0x0000000000000000]              
	int                                                nLane;                                            		// 0x0250 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                nNavPointsToSkipForPathing;                       		// 0x0254 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UTgAISquad*                                  s_CurrentSquad;                                   		// 0x0258 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UClass*                                      m_SquadClass;                                     		// 0x025C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_nLocationId;                                    		// 0x0260 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                nSpawnTableId;                                    		// 0x0264 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                nDefaultSpawnTableId;                             		// 0x0268 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              fSpawnDelay;                                      		// 0x026C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	TArray< struct FSpawnQueueEntry >                  m_SpawnQueue;                                     		// 0x0270 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class ATgBotEncounterVolume*                       m_SpawnVolume;                                    		// 0x027C (0x0004) [0x0000000000000000]              
	int                                                m_nLastGroup;                                     		// 0x0280 (0x0004) [0x0000000000000000]              
	float                                              fSpawnHealthPercent;                              		// 0x0284 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              fIntroductionDuration;                            		// 0x0288 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              fInitialIntroductionDuration;                     		// 0x028C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UStaticMeshComponent*                        m_RespawnIndicator;                               		// 0x0290 (0x0004) [0x0000000004080009]              ( CPF_Edit | CPF_ExportObject | CPF_Component | CPF_EditInline )
	class UMaterialInstanceConstant*                   m_RespawnIndicatorMIC;                            		// 0x0294 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UMeshComponent*                              m_RespawnRebuildMesh;                             		// 0x0298 (0x0004) [0x0000000004080009]              ( CPF_Edit | CPF_ExportObject | CPF_Component | CPF_EditInline )
	class UAnimNodeSequence*                           m_RespawnRebuildAnimNode;                         		// 0x029C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class ULightEnvironmentComponent*                  RespawnRebuildLightEnvironment;                   		// 0x02A0 (0x0004) [0x00000000040A000B]              ( CPF_Edit | CPF_Const | CPF_ExportObject | CPF_EditConst | CPF_Component | CPF_EditInline )
	class UTexture2D*                                  m_TextureNormal;                                  		// 0x02A4 (0x0004) [0x0000000000000000]              
	float                                              fLastKillTime;                                    		// 0x02A8 (0x0004) [0x0000000000000000]              
	float                                              fRespawnDelay;                                    		// 0x02AC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	TArray< struct FFactorySpawnModifier >             m_SpawnModifiers;                                 		// 0x02B0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2433 );

		return pClassPointer;
	};

	void eventTick ( float DeltaTime );
	void UpdateRespawnTimeIndicator ( float fPct );
	void OnBotDamaged ( class ATgPawn* Bot, class AController* DamageInstigator, class UClass* DamageType, int DamageAmount );
	void OnGetBot ( class UTgSeqAct_GetBot* inAction );
	void OnSetTaskforce ( class UTgSeqAct_SetTaskforce* Action );
	void OnTriggerBots ( class UTgSeqAct_TriggerBots* Action );
	void eventKillBots ( unsigned long bDespawn );
	void Despawn ( );
	void eventStartEncounter ( class ATgBotEncounterVolume* Volume );
	void eventContinueEncounter ( );
	void eventEndEncounter ( );
	void OnModifyFactorySpawn ( class UTgSeqAct_ModifyFactorySpawn* inAction );
	void OnDespawnBots ( class UTgSeqAct_DespawnBots* inAction );
	void OnKillBots ( class UTgSeqAct_KillBots* inAction );
	void OnToggle ( class USeqAct_Toggle* Action );
	void PostInitAnimTree ( class USkeletalMeshComponent* SkelComp );
	void PostBeginPlay ( );
	void ApplySpawnModifierToPawn ( class ATgPawn* ModifiedPawn, int ItemId, int NumStacks );
	void RemoveSpawnModifier ( int ModifierIndex );
	void ApplyNewSpawnModifier ( int ModifierItemId, int NumStacks, float ModifierDuration );
	void TriggerFactoryEmptiedKismet ( class AActor* DeadBot, int nNewEmpties, class AActor* Killer );
	void TriggerBotDiedKismet ( class AActor* DeadBot, class AActor* Killer, int nNewDeaths );
	void TriggerBotSpawnedKismet ( class AActor* SpawnedBot, int nNewSpawns );
	float GetRespawnDelay ( );
	void ReInitLight ( );
	int GetRemainingTotalSpawns ( );
	void SquadDied ( class UTgAISquad* squad );
	void BotDied ( class ATgPawn* Pawn, class ATgAIController* aic );
	class AActor* UseSpawnTable ( );
	void CalcFactoryPlacement ( struct FVector Extent, unsigned long bCenterOnGround, struct FVector* OutLocation, struct FRotator* OutRotation );
	class AActor* SpawnBotAdjusted ( struct FSpawnQueueEntry Entry );
	class AActor* SpawnBotId ( int nBotId, int nSkinId );
	class AActor* SpawnNextBot ( );
	class AActor* SpawnBot ( );
	void ClearQueue ( );
	void BuildQueue ( );
	void ResetQueue ( );
	void LoadObjectConfig ( );
};

UClass* ATgBotFactory::pClassPointer = NULL;

// Class TgGame.TgBotFactory_BonusTrigger
// 0x0000 (0x02BC - 0x02BC)
class ATgBotFactory_BonusTrigger : public ATgBotFactory
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2434 );

		return pClassPointer;
	};

};

UClass* ATgBotFactory_BonusTrigger::pClassPointer = NULL;

// Class TgGame.TgBotFactory_Leashed
// 0x0014 (0x02D0 - 0x02BC)
class ATgBotFactory_Leashed : public ATgBotFactory
{
public:
	struct FVector                                     LeashLocation;                                    		// 0x02BC (0x000C) [0x0000000000000001]              ( CPF_Edit )
	float                                              LeashRange;                                       		// 0x02C8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class AVolume*                                     LeashVolume;                                      		// 0x02CC (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2435 );

		return pClassPointer;
	};

	class AActor* SpawnBotAdjusted ( struct FSpawnQueueEntry Entry );
};

UClass* ATgBotFactory_Leashed::pClassPointer = NULL;

// Class TgGame.TgBotFactory_ClearCampScore
// 0x0030 (0x0300 - 0x02D0)
class ATgBotFactory_ClearCampScore : public ATgBotFactory_Leashed
{
public:
	TArray< int >                                      m_nItemAwardIds;                                  		// 0x02D0 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	float                                              m_fTimeoutPeriod;                                 		// 0x02DC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_nCurrentSpawnGroup;                             		// 0x02E0 (0x0004) [0x0000000000000000]              
	TArray< int >                                      m_nSpawnTableIds;                                 		// 0x02E4 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< float >                                    m_fRespawnDelays;                                 		// 0x02F0 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	unsigned long                                      m_bShouldLoop : 1;                                		// 0x02FC (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2436 );

		return pClassPointer;
	};

	void OnKillBots ( class UTgSeqAct_KillBots* inAction );
	void eventTick ( float DeltaTime );
	void ApplyNewModifer ( class ATgRepInfo_TaskForce* Winner );
	void AwardItemToWinners ( );
	void TriggerFactoryEmptiedKismet ( class AActor* DeadBot, int nNewEmpties, class AActor* Killer );
	void TriggerBotDiedKismet ( class AActor* DeadBot, class AActor* Killer, int nNewDeaths );
};

UClass* ATgBotFactory_ClearCampScore::pClassPointer = NULL;

// Class TgGame.TgBotFactory_PointCapture
// 0x0004 (0x02D4 - 0x02D0)
class ATgBotFactory_PointCapture : public ATgBotFactory_Leashed
{
public:
	class ATgCapturePoint_WithBot*                     m_CapturePoint;                                   		// 0x02D0 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2437 );

		return pClassPointer;
	};

	void BotDied ( class ATgPawn* Pawn, class ATgAIController* aic );
};

UClass* ATgBotFactory_PointCapture::pClassPointer = NULL;

// Class TgGame.TgBotFactory_Minions
// 0x001C (0x02D8 - 0x02BC)
class ATgBotFactory_Minions : public ATgBotFactory
{
public:
	unsigned char                                      m_eFactoryType;                                   		// 0x02BC (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_OverrideShouldSpawnSuperMinions : 1;            		// 0x02C0 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	int                                                m_nWaveNumber;                                    		// 0x02C4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_nLastBonusWave;                                 		// 0x02C8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_nLanePushersInQueue;                            		// 0x02CC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_fLastBonusActivationTime;                       		// 0x02D0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_fSuperMinionEndTime;                            		// 0x02D4 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2438 );

		return pClassPointer;
	};

	void BuildQueue ( );
	bool ShouldSpawnBonusMinions ( );
	bool ShouldSpawnSuperMinions ( );
	void SetSuperMinionsActive ( float fSeconds );
};

UClass* ATgBotFactory_Minions::pClassPointer = NULL;

// Class TgGame.TgBotFactorySpawnable
// 0x0000 (0x02BC - 0x02BC)
class ATgBotFactorySpawnable : public ATgBotFactory
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2439 );

		return pClassPointer;
	};

};

UClass* ATgBotFactorySpawnable::pClassPointer = NULL;

// Class TgGame.TgDeployableFactory
// 0x0014 (0x0238 - 0x0224)
class ATgDeployableFactory : public ATgActorFactory
{
public:
	int                                                nCurrentCount;                                    		// 0x0224 (0x0004) [0x0000000000000000]              
	float                                              s_fLastSpawnTime;                                 		// 0x0228 (0x0004) [0x0000000000000000]              
	unsigned long                                      s_bSpawnOnce : 1;                                 		// 0x022C (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      s_bTimeoutDeployable : 1;                         		// 0x022C (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	int                                                s_nDeployableId;                                  		// 0x0230 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              s_fDeployableLifetime;                            		// 0x0234 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2440 );

		return pClassPointer;
	};

	void OnSetTaskforce ( class UTgSeqAct_SetTaskforce* Action );
	void OnKillBots ( class UTgSeqAct_KillBots* inAction );
	void OnToggle ( class USeqAct_Toggle* Action );
	void DeployableDied ( );
	void PostBeginPlay ( );
	void SpawnObject ( );
};

UClass* ATgDeployableFactory::pClassPointer = NULL;

// Class TgGame.TgDestructibleFactory
// 0x0004 (0x0228 - 0x0224)
class ATgDestructibleFactory : public ATgActorFactory
{
public:
	class ULightEnvironmentComponent*                  LightEnvironment;                                 		// 0x0224 (0x0004) [0x00000000040A000B]              ( CPF_Edit | CPF_Const | CPF_ExportObject | CPF_EditConst | CPF_Component | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2441 );

		return pClassPointer;
	};

	void SpawnObject ( );
};

UClass* ATgDestructibleFactory::pClassPointer = NULL;

// Class TgGame.TgBotFactoryComponent
// 0x0000 (0x01FC - 0x01FC)
class UTgBotFactoryComponent : public UPrimitiveComponent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2442 );

		return pClassPointer;
	};

};

UClass* UTgBotFactoryComponent::pClassPointer = NULL;

// Class TgGame.TgDroppedItem
// 0x0024 (0x0214 - 0x01F0)
class ATgDroppedItem : public AActor
{
public:
	float                                              m_fLifeSpan;                                      		// 0x01F0 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bFadeOut : 1;                                   		// 0x01F4 (0x0004) [0x0000000000000000] [0x00000001] 
	struct FName                                       m_nmPickUpState;                                  		// 0x01F8 (0x0008) [0x0000000000000000]              
	int                                                r_nItemId;                                        		// 0x0200 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class UMeshComponent*                              c_Mesh;                                           		// 0x0204 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	TArray< class UTgEffectGroup* >                    s_EffectGroupList;                                		// 0x0208 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2443 );

		return pClassPointer;
	};

	void GiveTo ( class ATgPawn* P );
	void eventReplicatedEvent ( struct FName VarName );
	bool ApplyItemSetup ( );
	class UTgEffectGroup* GetEffectGroup ( int nType, int* nIndex );
};

UClass* ATgDroppedItem::pClassPointer = NULL;

// Class TgGame.TgInventoryManager
// 0x0490 (0x069C - 0x020C)
class ATgInventoryManager : public AInventoryManager
{
public:
	struct FCourierTransaction                         r_CourierTransaction;                             		// 0x020C (0x001C) [0x0000000000000020]              ( CPF_Net )
	int                                                s_CourierUpgradeRetryCount;                       		// 0x0228 (0x0004) [0x0000000000000000]              
	class AActor*                                      s_CourierBackupTimerActor;                        		// 0x022C (0x0004) [0x0000000000000000]              
	unsigned long                                      r_bTransacting : 1;                               		// 0x0230 (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )
	unsigned long                                      m_bHasDoneAutoPurchase : 1;                       		// 0x0230 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_ShouldSuppressHitProcs : 1;                     		// 0x0230 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_ShouldSuppressDamageProcs : 1;                  		// 0x0230 (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      m_ShouldSuppressCritProcs : 1;                    		// 0x0230 (0x0004) [0x0000000000000000] [0x00000010] 
	unsigned long                                      m_bNeedsInvUpdate : 1;                            		// 0x0230 (0x0004) [0x0000000000000000] [0x00000020] 
	TArray< struct FInventoryTransaction >             s_InventoryTransactions;                          		// 0x0234 (0x000C) [0x0000000000500000]              ( CPF_NeedCtorLink )
	struct FInventoryTransaction                       r_ReplicatedTransactions[ 0x20 ];                 		// 0x0240 (0x0380) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nTransactionCount;                              		// 0x05C0 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_ItemCount;                                      		// 0x05C4 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                m_nPreviousDeviceInstanceId;                      		// 0x05C8 (0x0004) [0x0000000000000000]              
	TArray< struct FAutoPurchaseItem >                 m_bCustomAutoPurchaseList;                        		// 0x05CC (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                m_last_role_item_index;                           		// 0x05D8 (0x0004) [0x0000000000000000]              
	unsigned char                                      UnknownData00[ 0x3C ];                            		// 0x05DC (0x003C) UNKNOWN PROPERTY: MapProperty TgGame.TgInventoryManager.m_InventoryMap
	unsigned char                                      UnknownData01[ 0x3C ];                            		// 0x0618 (0x003C) UNKNOWN PROPERTY: MapProperty TgGame.TgInventoryManager.s_ReplicateMap
	unsigned char                                      UnknownData02[ 0x3C ];                            		// 0x0654 (0x003C) UNKNOWN PROPERTY: MapProperty TgGame.TgInventoryManager.s_DeletionMap
	TArray< struct FsInventoryStackItem >              m_InventoryStack;                                 		// 0x0690 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2444 );

		return pClassPointer;
	};

	void eventServerSetCurrentWeapon ( class ATgDevice* NewWeapon );
	void ClientSetCurrentWeapon ( class ATgDevice* NewWeapon );
	bool SetCurrentWeapon ( class ATgDevice* DesiredWeapon, unsigned long bMessageFromNetwork, unsigned long bForceFastClear );
	void ChangedWeapon ( class ATgDevice* DesiredWeapon );
	void ReplicatedEvent ( struct FName VarName );
	void eventServerSetInventoryDirty ( );
	void eventServerTestShowInventory ( );
	void eventDestroyed ( );
	void PostBeginPlay ( );
	void CommitTransaction ( );
	void BeginTransaction ( );
	bool WasItemPurchasedInTransaction ( int nInventoryId, int* nExistingInventoryId );
	void OnCanPurchaseFlagSet ( unsigned long bCanPurchase );
	bool CanCourierPurchaseItems ( );
	void CourierPhaseChanged ( unsigned char Phase );
	void DeliverCourierItem ( );
	void CancelCourierItem ( );
	void UpdateCourierUI ( );
	void ForwardPawnOnVisiblityVolumeChange ( );
	void InventoryCleanup ( );
	void TestShowInventory ( );
	void ApplyAllPassiveItemEffects ( unsigned long bRemove );
	void RequestInventory ( );
	void UpdateBroadcastedItems ( );
	class UTgInventoryObject_Device* GetDeviceByEquipPoint ( unsigned char ePoint );
	void SetInventoryDirty ( );
	bool IsValid ( );
	class UTgInventoryObject* GetInventoryByName ( struct FString sName );
	class UTgInventoryObject* GetInventoryByEquipPoint ( unsigned char ePoint, int nItemType );
	class UTgInventoryObject* GetInventoryById ( int nInventoryId );
	class ATgDevice* GetDeviceByInstanceId ( int nDeviceInstanceId );
	void PopDevice ( class UTgInventoryObject_Device* pInv, int nEquipPoint );
	void PushDevice ( class UTgInventoryObject_Device* pInv, int nEquipPoint );
	void SwapDevices ( class UTgInventoryObject_Device* pInv, int nEquipPoint );
	void SwapDeviceEquipPoints ( int nEquipPoint1, int nEquipPoint2 );
	void RemoveDevice ( class UTgInventoryObject_Device* pInv );
	class ATgDevice* AddDevice ( int nDeviceId, int nEquipPoint, class ATgDevice* parentDevice, unsigned long bWhollyOwnedByParent );
};

UClass* ATgInventoryManager::pClassPointer = NULL;

// Class TgGame.TgInventoryManager_Artemis
// 0x0000 (0x069C - 0x069C)
class ATgInventoryManager_Artemis : public ATgInventoryManager
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2445 );

		return pClassPointer;
	};

};

UClass* ATgInventoryManager_Artemis::pClassPointer = NULL;

// Class TgGame.TgInventoryManager_Ratatoskr
// 0x001C (0x06B8 - 0x069C)
class ATgInventoryManager_Ratatoskr : public ATgInventoryManager
{
public:
	struct FAcornPurchaseInfo                          r_PendingAcornPurchase;                           		// 0x069C (0x0010) [0x0000000000000020]              ( CPF_Net )
	TArray< class UTgRatatoskrAcorn* >                 s_Acorns;                                         		// 0x06AC (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2446 );

		return pClassPointer;
	};

	unsigned char eventGetAcornType ( );
	bool PerformPendingAcornPurchase ( );
	bool CancelPendingAcornPurchase ( unsigned long bNoDeviceInterrupt );
	bool HasAcorn ( unsigned char AcornType );
	void OnCanPurchaseFlagSet ( unsigned long bCanPurchase );
};

UClass* ATgInventoryManager_Ratatoskr::pClassPointer = NULL;

// Class TgGame.TgInventoryObject
// 0x0038 (0x0074 - 0x003C)
class UTgInventoryObject : public UObject
{
public:
	struct FInventoryData                              m_InventoryData;                                  		// 0x003C (0x001C) [0x0000000000000000]              
	int                                                m_nRefData;                                       		// 0x0058 (0x0004) [0x0000000000000000]              
	class ATgInventoryManager*                         m_InvManager;                                     		// 0x005C (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bTemporary : 1;                                 		// 0x0060 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned char                                      s_ReplicatedState;                                		// 0x0064 (0x0001) [0x0000000000000000]              
	struct FPointer                                    m_pAmItem;                                        		// 0x0068 (0x0004) [0x0000000000001002]              ( CPF_Const | CPF_Native )
	int                                                c_nNbrAcquired;                                   		// 0x006C (0x0004) [0x0000000000000000]              
	float                                              c_fTimeAcquired;                                  		// 0x0070 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2447 );

		return pClassPointer;
	};

	int GetInstanceCount ( );
	void SetInstanceCount ( int nInstanceCount );
	struct FInventoryData GetInventoryData ( );
	bool IsEquippableType ( );
	bool IsUsableType ( );
};

UClass* UTgInventoryObject::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Device
// 0x0020 (0x0094 - 0x0074)
class UTgInventoryObject_Device : public UTgInventoryObject
{
public:
	class ATgDevice*                                   s_Device;                                         		// 0x0074 (0x0004) [0x0000000000000000]              
	int                                                m_nDeviceInstanceId;                              		// 0x0078 (0x0004) [0x0000000000000000]              
	int                                                c_nNumFindDeviceFails;                            		// 0x007C (0x0004) [0x0000000000000000]              
	int                                                m_nStackCount;                                    		// 0x0080 (0x0004) [0x0000000000000000]              
	struct FPointer                                    m_pAmDevice;                                      		// 0x0084 (0x0004) [0x0000000000001002]              ( CPF_Const | CPF_Native )
	TArray< class UTgInventoryObject_Device* >         s_WhollyOwnedChildDevices;                        		// 0x0088 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2448 );

		return pClassPointer;
	};

	void AddStackCount ( int nStackCount );
	void SetInstanceCount ( int nInstanceCount );
};

UClass* UTgInventoryObject_Device::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen
// 0x0004 (0x0098 - 0x0094)
class UTgInventoryObject_Listen : public UTgInventoryObject_Device
{
public:
	unsigned long                                      m_bHearsOwnDevice : 1;                            		// 0x0094 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      s_bEquippedAsEffectListener : 1;                  		// 0x0094 (0x0004) [0x0000000000000000] [0x00000002] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2449 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_AchillesSpear
// 0x0004 (0x009C - 0x0098)
class UTgInventoryObject_Listen_AchillesSpear : public UTgInventoryObject_Listen
{
public:
	int                                                m_nAchillesCategoryCode;                          		// 0x0098 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2450 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_AchillesSpear::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_AhMuzenCabBees
// 0x0010 (0x00A8 - 0x0098)
class UTgInventoryObject_Listen_AhMuzenCabBees : public UTgInventoryObject_Listen
{
public:
	TArray< struct FBeeVictimInfo >                    m_BeeVictimList;                                  		// 0x0098 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	float                                              m_fMaxBeesTime;                                   		// 0x00A4 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2451 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_AhMuzenCabBees::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_Ancile_S3
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_Ancile_S3 : public UTgInventoryObject_Listen
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2452 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_Ancile_S3::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_AOEOnCreepAssist
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_AOEOnCreepAssist : public UTgInventoryObject_Listen
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2453 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_AOEOnCreepAssist::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_AOEOnDamageType
// 0x0004 (0x009C - 0x0098)
class UTgInventoryObject_Listen_AOEOnDamageType : public UTgInventoryObject_Listen
{
public:
	int                                                m_nDamageType;                                    		// 0x0098 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2454 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_AOEOnDamageType::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_AoKuangDragonCall
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_AoKuangDragonCall : public UTgInventoryObject_Listen
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2455 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_AoKuangDragonCall::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_AoKuangKingsSword
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_AoKuangKingsSword : public UTgInventoryObject_Listen
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2456 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_AoKuangKingsSword::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_AoKuangNewUltimate
// 0x0010 (0x00A8 - 0x0098)
class UTgInventoryObject_Listen_AoKuangNewUltimate : public UTgInventoryObject_Listen
{
public:
	class UTgEffectGroup*                              MegaKillEffectGroup;                              		// 0x0098 (0x0004) [0x0000000000000000]              
	TArray< class UTgEffectGroup* >                    KnockupEffectGroups;                              		// 0x009C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2457 );

		return pClassPointer;
	};

	void FreeAllDelayedActionTargets ( );
};

UClass* UTgInventoryObject_Listen_AoKuangNewUltimate::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_AoKuangWaterIllusion
// 0x0004 (0x009C - 0x0098)
class UTgInventoryObject_Listen_AoKuangWaterIllusion : public UTgInventoryObject_Listen
{
public:
	int                                                m_nRemovableCategoryCode;                         		// 0x0098 (0x0004) [0x0000000000000002]              ( CPF_Const )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2458 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_AoKuangWaterIllusion::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_AphroditeMarkedDamageBuff
// 0x0008 (0x00A0 - 0x0098)
class UTgInventoryObject_Listen_AphroditeMarkedDamageBuff : public UTgInventoryObject_Listen
{
public:
	class AActor*                                      MarkedActor;                                      		// 0x0098 (0x0004) [0x0000000000000000]              
	float                                              m_fDamageMultipler;                               		// 0x009C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2459 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_AphroditeMarkedDamageBuff::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_Apply_On_Damage
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_Apply_On_Damage : public UTgInventoryObject_Listen
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2460 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_Apply_On_Damage::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_Apply_Chance_On_Damage
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_Apply_Chance_On_Damage : public UTgInventoryObject_Listen_Apply_On_Damage
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2461 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_Apply_Chance_On_Damage::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_NearbyCountOnDamage
// 0x0008 (0x00A0 - 0x0098)
class UTgInventoryObject_Listen_NearbyCountOnDamage : public UTgInventoryObject_Listen_Apply_On_Damage
{
public:
	int                                                m_nNearbyRequired;                                		// 0x0098 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bIncludeDamaged : 1;                            		// 0x009C (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bIncludeSelf : 1;                               		// 0x009C (0x0004) [0x0000000000000000] [0x00000002] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2462 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_NearbyCountOnDamage::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_Apply_On_Duel
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_Apply_On_Duel : public UTgInventoryObject_Listen
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2463 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_Apply_On_Duel::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_Apply_On_Heal
// 0x0004 (0x009C - 0x0098)
class UTgInventoryObject_Listen_Apply_On_Heal : public UTgInventoryObject_Listen
{
public:
	unsigned long                                      m_bHealthOnly : 1;                                		// 0x0098 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bOffhandOnly : 1;                               		// 0x0098 (0x0004) [0x0000000000000000] [0x00000002] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2464 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_Apply_On_Heal::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_LotusCrown
// 0x0000 (0x009C - 0x009C)
class UTgInventoryObject_Listen_LotusCrown : public UTgInventoryObject_Listen_Apply_On_Heal
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2465 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_LotusCrown::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_Apply_On_Healed
// 0x0004 (0x009C - 0x0098)
class UTgInventoryObject_Listen_Apply_On_Healed : public UTgInventoryObject_Listen
{
public:
	unsigned long                                      m_bHealthOnly : 1;                                		// 0x0098 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bFromSelfOnly : 1;                              		// 0x0098 (0x0004) [0x0000000000000000] [0x00000002] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2466 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_Apply_On_Healed::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_AhPuch_Dev3
// 0x000C (0x00A8 - 0x009C)
class UTgInventoryObject_Listen_AhPuch_Dev3 : public UTgInventoryObject_Listen_Apply_On_Healed
{
public:
	class AActor*                                      OwningActor;                                      		// 0x009C (0x0004) [0x0000000000000000]              
	float                                              m_fHealInterval;                                  		// 0x00A0 (0x0004) [0x0000000000000000]              
	float                                              m_fSecondsUntilReProc;                            		// 0x00A4 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2467 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_AhPuch_Dev3::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_Apply_On_PlayerCount
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_Apply_On_PlayerCount : public UTgInventoryObject_Listen
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2468 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_Apply_On_PlayerCount::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_Apply_On_Take_AbilityDamage
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_Apply_On_Take_AbilityDamage : public UTgInventoryObject_Listen
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2469 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_Apply_On_Take_AbilityDamage::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_Apply_On_Take_Damage
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_Apply_On_Take_Damage : public UTgInventoryObject_Listen
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2470 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_Apply_On_Take_Damage::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_Apply_On_Take_Damage_GodsOnly
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_Apply_On_Take_Damage_GodsOnly : public UTgInventoryObject_Listen
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2471 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_Apply_On_Take_Damage_GodsOnly::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_Apply_On_Take_InHandDamage
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_Apply_On_Take_InHandDamage : public UTgInventoryObject_Listen
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2472 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_Apply_On_Take_InHandDamage::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_Apply_On_Take_MagDamage
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_Apply_On_Take_MagDamage : public UTgInventoryObject_Listen
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2473 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_Apply_On_Take_MagDamage::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_Apply_On_Take_PhysDamage
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_Apply_On_Take_PhysDamage : public UTgInventoryObject_Listen
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2474 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_Apply_On_Take_PhysDamage::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_ArachneCocoon
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_ArachneCocoon : public UTgInventoryObject_Listen
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2475 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_ArachneCocoon::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_ArachneWebWall
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_ArachneWebWall : public UTgInventoryObject_Listen
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2476 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_ArachneWebWall::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_ArachneWrap
// 0x0004 (0x009C - 0x0098)
class UTgInventoryObject_Listen_ArachneWrap : public UTgInventoryObject_Listen
{
public:
	int                                                m_nCurrentStacks;                                 		// 0x0098 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2477 );

		return pClassPointer;
	};

	int GetCurrentStacks ( );
	void RemoveStackCount ( int nStackCount );
	void SetStackCount ( int nStackCount );
};

UClass* UTgInventoryObject_Listen_ArachneWrap::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_BackStab
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_BackStab : public UTgInventoryObject_Listen
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2478 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_BackStab::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_BastetPassive
// 0x0004 (0x009C - 0x0098)
class UTgInventoryObject_Listen_BastetPassive : public UTgInventoryObject_Listen
{
public:
	int                                                m_nNumDeaths;                                     		// 0x0098 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2479 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_BastetPassive::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_BellonaPassive
// 0x0004 (0x009C - 0x0098)
class UTgInventoryObject_Listen_BellonaPassive : public UTgInventoryObject_Listen
{
public:
	unsigned long                                      m_bHitAppliedThisTick : 1;                        		// 0x0098 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2480 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_BellonaPassive::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_BellonaScourge
// 0x000C (0x00A4 - 0x0098)
class UTgInventoryObject_Listen_BellonaScourge : public UTgInventoryObject_Listen
{
public:
	TArray< struct FHealAdder >                        m_CanHealDevices;                                 		// 0x0098 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2481 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_BellonaScourge::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_BellonaShieldBash
// 0x000C (0x00A4 - 0x0098)
class UTgInventoryObject_Listen_BellonaShieldBash : public UTgInventoryObject_Listen
{
public:
	TArray< struct FBlockStackAdder >                  m_CanAddBlockStacks;                              		// 0x0098 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2482 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_BellonaShieldBash::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_BlindBlade
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_BlindBlade : public UTgInventoryObject_Listen
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2483 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_BlindBlade::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_BulwarkOfHope
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_BulwarkOfHope : public UTgInventoryObject_Listen
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2484 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_BulwarkOfHope::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_CollisionProxyPawnListener_Cast
// 0x0004 (0x009C - 0x0098)
class UTgInventoryObject_Listen_CollisionProxyPawnListener_Cast : public UTgInventoryObject_Listen
{
public:
	class ATgCollisionProxy_PawnListener*              m_CPPawnListener;                                 		// 0x0098 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2485 );

		return pClassPointer;
	};

	void eventUninitializeCollisionProxyListener ( );
	void eventInitializeCollisionProxyListener ( );
	void CollisionDeviceOnStopFire ( class ATgPawn* Other, class ATgDevice* OtherDevice, unsigned long bWasInterrupted );
};

UClass* UTgInventoryObject_Listen_CollisionProxyPawnListener_Cast::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_Combat
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_Combat : public UTgInventoryObject_Listen
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2486 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_Combat::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_FountainBuff
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_FountainBuff : public UTgInventoryObject_Listen_Combat
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2487 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_FountainBuff::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_CritStacker
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_CritStacker : public UTgInventoryObject_Listen
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2488 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_CritStacker::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_Cupid_HeartBomb
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_Cupid_HeartBomb : public UTgInventoryObject_Listen
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2489 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_Cupid_HeartBomb::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_DamageCap
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_DamageCap : public UTgInventoryObject_Listen
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2490 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_DamageCap::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_Dont_Die
// 0x000C (0x00A4 - 0x0098)
class UTgInventoryObject_Listen_Dont_Die : public UTgInventoryObject_Listen
{
public:
	float                                              m_fLengthOfEffect;                                		// 0x0098 (0x0004) [0x0000000000000000]              
	float                                              m_fHP5Added;                                      		// 0x009C (0x0004) [0x0000000000000000]              
	float                                              m_fMP5Added;                                      		// 0x00A0 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2491 );

		return pClassPointer;
	};

	void EffectDone ( );
};

UClass* UTgInventoryObject_Listen_Dont_Die::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_Effect
// 0x000C (0x00A4 - 0x0098)
class UTgInventoryObject_Listen_Effect : public UTgInventoryObject_Listen
{
public:
	class UTgEffectGroup*                              s_OwningEffectGroup;                              		// 0x0098 (0x0004) [0x0000000000000000]              
	class ATgPawn*                                     s_InstigatorPawn;                                 		// 0x009C (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bEquippedWhileApplied : 1;                      		// 0x00A0 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2492 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_Effect::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_DamageTakenConditional
// 0x0000 (0x00A4 - 0x00A4)
class UTgInventoryObject_Listen_DamageTakenConditional : public UTgInventoryObject_Listen_Effect
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2494 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_DamageTakenConditional::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_Runeforged_S3
// 0x0000 (0x00A4 - 0x00A4)
class UTgInventoryObject_Listen_Runeforged_S3 : public UTgInventoryObject_Listen_DamageTakenConditional
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2495 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_Runeforged_S3::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_Effect_Shockwave_OnHitHigherLevel
// 0x000C (0x00B0 - 0x00A4)
class UTgInventoryObject_Listen_Effect_Shockwave_OnHitHigherLevel : public UTgInventoryObject_Listen_Effect
{
public:
	TArray< struct FTGHHL_HITINFO >                    s_TrackedTriggers;                                		// 0x00A4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2496 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_Effect_Shockwave_OnHitHigherLevel::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_Fafnir_Dev2
// 0x0000 (0x00A4 - 0x00A4)
class UTgInventoryObject_Listen_Fafnir_Dev2 : public UTgInventoryObject_Listen_Effect
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2497 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_Fafnir_Dev2::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_NikePassive
// 0x0024 (0x00C8 - 0x00A4)
class UTgInventoryObject_Listen_NikePassive : public UTgInventoryObject_Listen_Effect
{
public:
	int                                                s_nGoalsMet;                                      		// 0x00A4 (0x0004) [0x0000000000000000]              
	unsigned long                                      s_bGoalGodsReached : 1;                           		// 0x00A8 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      s_bGoalCreaturesReached : 1;                      		// 0x00A8 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      s_bGoalMaxLevelReached : 1;                       		// 0x00A8 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      s_bInitalized : 1;                                		// 0x00A8 (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      s_bOwnerWasKilled : 1;                            		// 0x00A8 (0x0004) [0x0000000000000000] [0x00000010] 
	int                                                s_nGoalGodsKilled;                                		// 0x00AC (0x0004) [0x0000000000000000]              
	int                                                s_nGoalCreaturesKilled;                           		// 0x00B0 (0x0004) [0x0000000000000000]              
	int                                                s_nGoalMaxLevelAllies;                            		// 0x00B4 (0x0004) [0x0000000000000000]              
	int                                                s_nOwnerTaskforce;                                		// 0x00B8 (0x0004) [0x0000000000000000]              
	int                                                s_nTotalGodsKilled;                               		// 0x00BC (0x0004) [0x0000000000000000]              
	int                                                s_nTotalCreaturesKilled;                          		// 0x00C0 (0x0004) [0x0000000000000000]              
	int                                                s_nTotalMaxLevelAllies;                           		// 0x00C4 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2498 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_NikePassive::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_PotionOfMagMight
// 0x0018 (0x00BC - 0x00A4)
class UTgInventoryObject_Listen_PotionOfMagMight : public UTgInventoryObject_Listen_Effect
{
public:
	TArray< struct FTGHHL_HITINFO >                    s_TrackedTriggers;                                		// 0x00A4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< struct FDeviceToReduce >                   CooldownDevices;                                  		// 0x00B0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2499 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_PotionOfMagMight::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_PotionOfPhysMight
// 0x000C (0x00B0 - 0x00A4)
class UTgInventoryObject_Listen_PotionOfPhysMight : public UTgInventoryObject_Listen_Effect
{
public:
	TArray< struct FTGHHL_HITINFO >                    s_TrackedTriggers;                                		// 0x00A4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2500 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_PotionOfPhysMight::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_Terra_MotherEarth
// 0x0008 (0x00AC - 0x00A4)
class UTgInventoryObject_Listen_Terra_MotherEarth : public UTgInventoryObject_Listen_Effect
{
public:
	int                                                m_HitCount;                                       		// 0x00A4 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_Detonated : 1;                                  		// 0x00A8 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2501 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_Terra_MotherEarth::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_Thoth_SpeedGlyph
// 0x0000 (0x00A4 - 0x00A4)
class UTgInventoryObject_Listen_Thoth_SpeedGlyph : public UTgInventoryObject_Listen_Effect
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2502 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_Thoth_SpeedGlyph::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_FafnirPassive
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_FafnirPassive : public UTgInventoryObject_Listen
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2503 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_FafnirPassive::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_G84_Dev2
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_G84_Dev2 : public UTgInventoryObject_Listen
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2504 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_G84_Dev2::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_G84_Psv
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_G84_Psv : public UTgInventoryObject_Listen
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2505 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_G84_Psv::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_GebUltimate
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_GebUltimate : public UTgInventoryObject_Listen
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2506 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_GebUltimate::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_Genji
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_Genji : public UTgInventoryObject_Listen
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2507 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_Genji::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_GuanYuPassive
// 0x0018 (0x00B0 - 0x0098)
class UTgInventoryObject_Listen_GuanYuPassive : public UTgInventoryObject_Listen
{
public:
	unsigned long                                      m_bHitAppliedThisTick : 1;                        		// 0x0098 (0x0004) [0x0000000000000000] [0x00000001] 
	TArray< int >                                      m_nStackRemovingDevices;                          		// 0x009C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                s_nModifiedDeviceId;                              		// 0x00A8 (0x0004) [0x0000000000000000]              
	int                                                s_nModifiedDeviceFiringInstance;                  		// 0x00AC (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2508 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_GuanYuPassive::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_HandOfTheGods
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_HandOfTheGods : public UTgInventoryObject_Listen
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2509 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_HandOfTheGods::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_WrathOfTheGods
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_WrathOfTheGods : public UTgInventoryObject_Listen_HandOfTheGods
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2510 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_WrathOfTheGods::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_HouYiGoldenCrow
// 0x0010 (0x00A8 - 0x0098)
class UTgInventoryObject_Listen_HouYiGoldenCrow : public UTgInventoryObject_Listen
{
public:
	TArray< class AActor* >                            m_CurrentMarkedTargets;                           		// 0x0098 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                m_MaxMarkedTargets;                               		// 0x00A4 (0x0004) [0x0000000000000002]              ( CPF_Const )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2511 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_HouYiGoldenCrow::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_InAndOutOfCombat
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_InAndOutOfCombat : public UTgInventoryObject_Listen
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2512 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_InAndOutOfCombat::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_InHand
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_InHand : public UTgInventoryObject_Listen
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2513 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_InHand::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_InHand_Aoe
// 0x000C (0x00A4 - 0x0098)
class UTgInventoryObject_Listen_InHand_Aoe : public UTgInventoryObject_Listen_InHand
{
public:
	TArray< class ATgPawn* >                           s_HitPawns;                                       		// 0x0098 (0x000C) [0x0000000000502000]              ( CPF_Transient | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2514 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_InHand_Aoe::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_InHand_CategoryCheck
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_InHand_CategoryCheck : public UTgInventoryObject_Listen_InHand
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2515 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_InHand_CategoryCheck::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_InHand_ChanceOnHit
// 0x0004 (0x009C - 0x0098)
class UTgInventoryObject_Listen_InHand_ChanceOnHit : public UTgInventoryObject_Listen_InHand
{
public:
	float                                              m_fPercentChance;                                 		// 0x0098 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2516 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_InHand_ChanceOnHit::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_InHand_HitXTimes
// 0x000C (0x00A4 - 0x0098)
class UTgInventoryObject_Listen_InHand_HitXTimes : public UTgInventoryObject_Listen_InHand
{
public:
	int                                                m_nTimesToProc;                                   		// 0x0098 (0x0004) [0x0000000000000000]              
	int                                                m_nCurrentHits;                                   		// 0x009C (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bHitAppliedThisTick : 1;                        		// 0x00A0 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2517 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_InHand_HitXTimes::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_InHand_TargetSlowed
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_InHand_TargetSlowed : public UTgInventoryObject_Listen_InHand
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2518 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_InHand_TargetSlowed::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_InHand_TargetSlowRootCripple
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_InHand_TargetSlowRootCripple : public UTgInventoryObject_Listen_InHand
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2519 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_InHand_TargetSlowRootCripple::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_NuWaPassiveV2
// 0x0008 (0x00A0 - 0x0098)
class UTgInventoryObject_Listen_NuWaPassiveV2 : public UTgInventoryObject_Listen_InHand
{
public:
	int                                                m_nSuccessfulHitCount;                            		// 0x0098 (0x0004) [0x0000000000000000]              
	int                                                m_nActiveEffectSituationalType;                   		// 0x009C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2520 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_NuWaPassiveV2::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_QinsBlades2
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_QinsBlades2 : public UTgInventoryObject_Listen_InHand
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2521 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_QinsBlades2::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_ZeusDualWield
// 0x0010 (0x00A8 - 0x0098)
class UTgInventoryObject_Listen_ZeusDualWield : public UTgInventoryObject_Listen_InHand
{
public:
	unsigned long                                      s_bActive : 1;                                    		// 0x0098 (0x0004) [0x0000000000000000] [0x00000001] 
	int                                                s_nActiveCategoryCode;                            		// 0x009C (0x0004) [0x0000000000000002]              ( CPF_Const )
	int                                                s_nProcOnHitsAboveFiringInstance;                 		// 0x00A0 (0x0004) [0x0000000000000000]              
	int                                                s_nProcOnHitsBelowFiringInstance;                 		// 0x00A4 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2522 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_ZeusDualWield::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_InHand_Crit
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_InHand_Crit : public UTgInventoryObject_Listen
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2523 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_InHand_Crit::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_InHand_Crit_Self
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_InHand_Crit_Self : public UTgInventoryObject_Listen
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2524 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_InHand_Crit_Self::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_InHand_Kill
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_InHand_Kill : public UTgInventoryObject_Listen
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2525 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_InHand_Kill::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_InHand_Melee_Ranged
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_InHand_Melee_Ranged : public UTgInventoryObject_Listen
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2526 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_InHand_Melee_Ranged::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_InHand_Nth_Hit
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_InHand_Nth_Hit : public UTgInventoryObject_Listen
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2527 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_InHand_Nth_Hit::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_InHand_SuccessfulHit
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_InHand_SuccessfulHit : public UTgInventoryObject_Listen
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2528 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_InHand_SuccessfulHit::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_InHand_SuccessfulHitOnGod
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_InHand_SuccessfulHitOnGod : public UTgInventoryObject_Listen_InHand_SuccessfulHit
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2529 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_InHand_SuccessfulHitOnGod::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_TankStarter
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_TankStarter : public UTgInventoryObject_Listen_InHand_SuccessfulHit
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2530 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_TankStarter::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_WarriorsTabi
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_WarriorsTabi : public UTgInventoryObject_Listen_InHand_SuccessfulHit
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2531 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_WarriorsTabi::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_InHand_Towers
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_InHand_Towers : public UTgInventoryObject_Listen
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2532 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_InHand_Towers::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_InhandMitigation
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_InhandMitigation : public UTgInventoryObject_Listen
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2533 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_InhandMitigation::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_IzanamiDev1
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_IzanamiDev1 : public UTgInventoryObject_Listen
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2534 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_IzanamiDev1::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_IzanamiDev2
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_IzanamiDev2 : public UTgInventoryObject_Listen
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2535 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_IzanamiDev2::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_IzanamiDev3
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_IzanamiDev3 : public UTgInventoryObject_Listen
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2536 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_IzanamiDev3::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_JanusPortalPassThrough
// 0x0008 (0x00A0 - 0x0098)
class UTgInventoryObject_Listen_JanusPortalPassThrough : public UTgInventoryObject_Listen
{
public:
	int                                                m_nSituationalType;                               		// 0x0098 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bUseCooldown : 1;                               		// 0x009C (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bSelfOnly : 1;                                  		// 0x009C (0x0004) [0x0000000000000000] [0x00000002] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2537 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_JanusPortalPassThrough::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_JanusPassive
// 0x0035 (0x00D5 - 0x00A0)
class UTgInventoryObject_Listen_JanusPassive : public UTgInventoryObject_Listen_JanusPortalPassThrough
{
public:
	unsigned long                                      m_bPassiveMagicPowerActive : 1;                   		// 0x00A0 (0x0004) [0x0000000000000000] [0x00000001] 
	TArray< class AActor* >                            m_PowerScalingActors;                             		// 0x00A4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< unsigned char >                            m_DeactivatePassiveOn;                            		// 0x00B0 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	unsigned char                                      m_PassiveActivatedDuring[ 0x19 ];                 		// 0x00BC (0x0019) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2538 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_JanusPassive::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_JanusTransitions
// 0x000C (0x00AC - 0x00A0)
class UTgInventoryObject_Listen_JanusTransitions : public UTgInventoryObject_Listen_JanusPortalPassThrough
{
public:
	TArray< struct FTransitionsEffectGroupInfo >       m_TransitionsInfos;                               		// 0x00A0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2539 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_JanusTransitions::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_JanusUltimate
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_JanusUltimate : public UTgInventoryObject_Listen
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2540 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_JanusUltimate::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_JungleStarter
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_JungleStarter : public UTgInventoryObject_Listen
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2541 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_JungleStarter::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_Apply_On_HitJungle
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_Apply_On_HitJungle : public UTgInventoryObject_Listen_JungleStarter
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2543 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_Apply_On_HitJungle::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_JungleStarter_S4
// 0x0004 (0x009C - 0x0098)
class UTgInventoryObject_Listen_JungleStarter_S4 : public UTgInventoryObject_Listen
{
public:
	unsigned long                                      m_bAssistsAllowed : 1;                            		// 0x0098 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2544 );

		return pClassPointer;
	};

	void HandleJungleCampDied ( class AActor* Victim, unsigned long bAssist, int* xpGain, int* goldGain );
};

UClass* UTgInventoryObject_Listen_JungleStarter_S4::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_Kaldr_Dev2
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_Kaldr_Dev2 : public UTgInventoryObject_Listen
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2545 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_Kaldr_Dev2::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_KaliIncense
// 0x0004 (0x009C - 0x0098)
class UTgInventoryObject_Listen_KaliIncense : public UTgInventoryObject_Listen
{
public:
	int                                                m_nExtraDamageCategoryCode;                       		// 0x0098 (0x0004) [0x0000000000000002]              ( CPF_Const )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2546 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_KaliIncense::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_KaliLash
// 0x0004 (0x009C - 0x0098)
class UTgInventoryObject_Listen_KaliLash : public UTgInventoryObject_Listen
{
public:
	int                                                m_nBleedCategoryCode;                             		// 0x0098 (0x0004) [0x0000000000000002]              ( CPF_Const )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2547 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_KaliLash::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_KaliNimbleStrike
// 0x000C (0x00A4 - 0x0098)
class UTgInventoryObject_Listen_KaliNimbleStrike : public UTgInventoryObject_Listen
{
public:
	TArray< int >                                      m_MissingHealth;                                  		// 0x0098 (0x000C) [0x0000000000502000]              ( CPF_Transient | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2548 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_KaliNimbleStrike::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_KhepriAbduct
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_KhepriAbduct : public UTgInventoryObject_Listen
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2549 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_KhepriAbduct::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_Magi_Blessing
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_Magi_Blessing : public UTgInventoryObject_Listen
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2550 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_Magi_Blessing::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_MedusaDev1
// 0x000C (0x00A4 - 0x0098)
class UTgInventoryObject_Listen_MedusaDev1 : public UTgInventoryObject_Listen
{
public:
	int                                                m_nStacksRemaining;                               		// 0x0098 (0x0004) [0x0000000000000000]              
	int                                                m_nFiringInstance;                                		// 0x009C (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bStimShot : 1;                                  		// 0x00A0 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2551 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_MedusaDev1::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_MedusaStealth
// 0x0004 (0x009C - 0x0098)
class UTgInventoryObject_Listen_MedusaStealth : public UTgInventoryObject_Listen
{
public:
	int                                                m_nRemovableCategoryCode;                         		// 0x0098 (0x0004) [0x0000000000000002]              ( CPF_Const )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2552 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_MedusaStealth::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_Mercury_Num2
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_Mercury_Num2 : public UTgInventoryObject_Listen
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2553 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_Mercury_Num2::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_MissingPoolStack
// 0x0014 (0x00AC - 0x0098)
class UTgInventoryObject_Listen_MissingPoolStack : public UTgInventoryObject_Listen
{
public:
	int                                                m_CurrentStacks;                                  		// 0x0098 (0x0004) [0x0000000000000000]              
	int                                                m_MaxStacks;                                      		// 0x009C (0x0004) [0x0000000000000000]              
	float                                              m_fPercPerStack;                                  		// 0x00A0 (0x0004) [0x0000000000000000]              
	int                                                m_nPoolType;                                      		// 0x00A4 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bInitializedValues : 1;                         		// 0x00A8 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2554 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_MissingPoolStack::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_Monkey_Passive
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_Monkey_Passive : public UTgInventoryObject_Listen
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2555 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_Monkey_Passive::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_NextAbility
// 0x0005 (0x009D - 0x0098)
class UTgInventoryObject_Listen_NextAbility : public UTgInventoryObject_Listen
{
public:
	class UTgMarkComponent*                            m_MarkComponent;                                  		// 0x0098 (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )
	unsigned char                                      m_nNextAbilityItemCooldown;                       		// 0x009C (0x0001) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2556 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_NextAbility::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_NextAttack
// 0x000C (0x00A4 - 0x0098)
class UTgInventoryObject_Listen_NextAttack : public UTgInventoryObject_Listen
{
public:
	class UTgMarkComponent*                            m_MarkComponent;                                  		// 0x0098 (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )
	unsigned char                                      m_nStackedFiringInstance;                         		// 0x009C (0x0001) [0x0000000000000000]              
	unsigned char                                      m_nNextAttackItemCooldown;                        		// 0x009D (0x0001) [0x0000000000000000]              
	int                                                m_nStackedFiringDeviceId;                         		// 0x00A0 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2557 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_NextAttack::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_HydrasLament
// 0x0008 (0x00AC - 0x00A4)
class UTgInventoryObject_Listen_HydrasLament : public UTgInventoryObject_Listen_NextAttack
{
public:
	int                                                m_CurrentStacks;                                  		// 0x00A4 (0x0004) [0x0000000000000000]              
	int                                                m_MaxStacks;                                      		// 0x00A8 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2558 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_HydrasLament::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_NeZhaPassive
// 0x0028 (0x00C0 - 0x0098)
class UTgInventoryObject_Listen_NeZhaPassive : public UTgInventoryObject_Listen
{
public:
	TArray< int >                                      m_nStackBuildingDevices;                          		// 0x0098 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< int >                                      m_nStackConsumingDevices;                         		// 0x00A4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                m_nStackBuildingCategoryCode;                     		// 0x00B0 (0x0004) [0x0000000000000000]              
	int                                                m_nStackConsumedCategorycode;                     		// 0x00B4 (0x0004) [0x0000000000000000]              
	int                                                m_nStackBuildingSituationalType;                  		// 0x00B8 (0x0004) [0x0000000000000000]              
	int                                                m_nStackConsumedSituationalType;                  		// 0x00BC (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2559 );

		return pClassPointer;
	};

	void ConsumePassiveStacks ( );
};

UClass* UTgInventoryObject_Listen_NeZhaPassive::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_NuWaPassive
// 0x000C (0x00A4 - 0x0098)
class UTgInventoryObject_Listen_NuWaPassive : public UTgInventoryObject_Listen
{
public:
	int                                                m_nInHandSwapCategoryCode;                        		// 0x0098 (0x0004) [0x0000000000000002]              ( CPF_Const )
	int                                                m_nInHandBoostCategoryCode;                       		// 0x009C (0x0004) [0x0000000000000002]              ( CPF_Const )
	unsigned long                                      m_bInHandSwapActive : 1;                          		// 0x00A0 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bInHandExtraActive : 1;                         		// 0x00A0 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_bSnakeFormActive : 1;                           		// 0x00A0 (0x0004) [0x0000000000000000] [0x00000004] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2560 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_NuWaPassive::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_OdinRavenShout
// 0x0024 (0x00BC - 0x0098)
class UTgInventoryObject_Listen_OdinRavenShout : public UTgInventoryObject_Listen
{
public:
	int                                                m_nShieldEffectGroupId;                           		// 0x0098 (0x0004) [0x0000000000000000]              
	int                                                m_nShieldExtendDeviceId;                          		// 0x009C (0x0004) [0x0000000000000000]              
	TArray< int >                                      m_ShieldExtendDevices;                            		// 0x00A0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< int >                                      m_ShieldExplodeDevices;                           		// 0x00AC (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	unsigned long                                      RavenShoutTimeChanged : 1;                        		// 0x00B8 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2561 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_OdinRavenShout::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_OffHand
// 0x0010 (0x00A8 - 0x0098)
class UTgInventoryObject_Listen_OffHand : public UTgInventoryObject_Listen
{
public:
	unsigned long                                      m_bProcOncePerCast : 1;                           		// 0x0098 (0x0004) [0x0000000000000002] [0x00000001] ( CPF_Const )
	TArray< struct FCastTrackingInfo >                 m_CastTracking;                                   		// 0x009C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2562 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_OffHand::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_BluestonePendant
// 0x000C (0x00B4 - 0x00A8)
class UTgInventoryObject_Listen_BluestonePendant : public UTgInventoryObject_Listen_OffHand
{
public:
	TArray< int >                                      m_DeviceExceptionList;                            		// 0x00A8 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2563 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_BluestonePendant::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_Offhand_TargetSlowRootCripple
// 0x0000 (0x00A8 - 0x00A8)
class UTgInventoryObject_Listen_Offhand_TargetSlowRootCripple : public UTgInventoryObject_Listen_OffHand
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2564 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_Offhand_TargetSlowRootCripple::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_OffhandOncePerCast
// 0x0000 (0x00A8 - 0x00A8)
class UTgInventoryObject_Listen_OffhandOncePerCast : public UTgInventoryObject_Listen_OffHand
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2565 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_OffhandOncePerCast::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_OffHand_Cast
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_OffHand_Cast : public UTgInventoryObject_Listen
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2566 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_OffHand_Cast::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_Nike_Dev2
// 0x0014 (0x00AC - 0x0098)
class UTgInventoryObject_Listen_Nike_Dev2 : public UTgInventoryObject_Listen_OffHand_Cast
{
public:
	class ATgDevice*                                   m_TrackedDevice;                                  		// 0x0098 (0x0004) [0x0000000000000000]              
	int                                                m_nTrackedFireInstance;                           		// 0x009C (0x0004) [0x0000000000000000]              
	TArray< int >                                      m_NikeDeviceIds;                                  		// 0x00A0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2567 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_Nike_Dev2::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_OffHand_SuccessfulHit
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_OffHand_SuccessfulHit : public UTgInventoryObject_Listen
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2568 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_OffHand_SuccessfulHit::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_BootsOfTheMagi
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_BootsOfTheMagi : public UTgInventoryObject_Listen_OffHand_SuccessfulHit
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2569 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_BootsOfTheMagi::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_OffHand_SuccessfulHitOnGod
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_OffHand_SuccessfulHitOnGod : public UTgInventoryObject_Listen_OffHand_SuccessfulHit
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2570 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_OffHand_SuccessfulHitOnGod::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_VulcanPassive
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_VulcanPassive : public UTgInventoryObject_Listen_OffHand_SuccessfulHit
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2571 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_VulcanPassive::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_On_Spell_Shield
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_On_Spell_Shield : public UTgInventoryObject_Listen
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2572 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_On_Spell_Shield::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_OnCrit
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_OnCrit : public UTgInventoryObject_Listen
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2573 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_OnCrit::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_OnEffectCategoryRemoved
// 0x000C (0x00A4 - 0x0098)
class UTgInventoryObject_Listen_OnEffectCategoryRemoved : public UTgInventoryObject_Listen
{
public:
	TArray< int >                                      m_nEffectGroupCategoryCodes;                      		// 0x0098 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2574 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_OnEffectCategoryRemoved::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_OnExitStore
// 0x0004 (0x009C - 0x0098)
class UTgInventoryObject_Listen_OnExitStore : public UTgInventoryObject_Listen
{
public:
	unsigned long                                      m_bIsInBase : 1;                                  		// 0x0098 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2575 );

		return pClassPointer;
	};

	bool eventOnExitStore ( );
};

UClass* UTgInventoryObject_Listen_OnExitStore::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_JingWei_Passive
// 0x0004 (0x00A0 - 0x009C)
class UTgInventoryObject_Listen_JingWei_Passive : public UTgInventoryObject_Listen_OnExitStore
{
public:
	unsigned long                                      m_QueuedFire : 1;                                 		// 0x009C (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2576 );

		return pClassPointer;
	};

	void eventTryStartFire ( );
	bool ShouldCancelPassive ( class ATgPawn_JingWei* jingwei );
	bool eventOnExitStore ( );
};

UClass* UTgInventoryObject_Listen_JingWei_Passive::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_OnLeaveFountain
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_OnLeaveFountain : public UTgInventoryObject_Listen
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2577 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_OnLeaveFountain::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_OnLifestealAgainst
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_OnLifestealAgainst : public UTgInventoryObject_Listen
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2578 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_OnLifestealAgainst::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_OnRelicFire
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_OnRelicFire : public UTgInventoryObject_Listen
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2579 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_OnRelicFire::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_OnSuccessfulDodge
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_OnSuccessfulDodge : public UTgInventoryObject_Listen
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2580 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_OnSuccessfulDodge::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_OutOfCombat
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_OutOfCombat : public UTgInventoryObject_Listen
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2581 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_OutOfCombat::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_Awilix_FirstStrike
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_Awilix_FirstStrike : public UTgInventoryObject_Listen_OutOfCombat
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2582 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_Awilix_FirstStrike::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_RewardBoots
// 0x000C (0x00A4 - 0x0098)
class UTgInventoryObject_Listen_RewardBoots : public UTgInventoryObject_Listen_OutOfCombat
{
public:
	TArray< struct FRewardHitInfo >                    m_RewardTrackedHit;                               		// 0x0098 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2583 );

		return pClassPointer;
	};

	void GiveOwnerRewards ( );
	void UpdateTracking ( struct FImpactInfo Impact, class ATgDevice* Dev );
	bool ShouldRecordDevice ( class ATgDevice* Dev );
	bool IsValidHit ( struct FImpactInfo Impact );
};

UClass* UTgInventoryObject_Listen_RewardBoots::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_OutOfJungle
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_OutOfJungle : public UTgInventoryObject_Listen
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2584 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_OutOfJungle::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_Proc_At_Health
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_Proc_At_Health : public UTgInventoryObject_Listen
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2585 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_Proc_At_Health::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_Proc_At_HealthPCT
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_Proc_At_HealthPCT : public UTgInventoryObject_Listen
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2586 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_Proc_At_HealthPCT::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_Proc_On_Kill
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_Proc_On_Kill : public UTgInventoryObject_Listen
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2587 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_Proc_On_Kill::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_Proc_On_Assist
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_Proc_On_Assist : public UTgInventoryObject_Listen_Proc_On_Kill
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2588 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_Proc_On_Assist::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_RacerDriftBoost
// 0x0004 (0x009C - 0x0098)
class UTgInventoryObject_Listen_RacerDriftBoost : public UTgInventoryObject_Listen
{
public:
	float                                              m_Timer;                                          		// 0x0098 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2589 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_RacerDriftBoost::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_RangeDamageAdjust
// 0x0004 (0x009C - 0x0098)
class UTgInventoryObject_Listen_RangeDamageAdjust : public UTgInventoryObject_Listen
{
public:
	float                                              m_fCachedRangeMultipler;                          		// 0x0098 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2590 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_RangeDamageAdjust::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_RatatoskrAcornThrow
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_RatatoskrAcornThrow : public UTgInventoryObject_Listen
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2591 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_RatatoskrAcornThrow::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_RatatoskrTailSpin
// 0x0008 (0x00A0 - 0x0098)
class UTgInventoryObject_Listen_RatatoskrTailSpin : public UTgInventoryObject_Listen
{
public:
	unsigned char                                      m_eYellowAcornTween;                              		// 0x0098 (0x0001) [0x0000000000000000]              
	float                                              m_fTweenSpeed;                                    		// 0x009C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2592 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_RatatoskrTailSpin::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_Ravana_Passive
// 0x0010 (0x00A8 - 0x0098)
class UTgInventoryObject_Listen_Ravana_Passive : public UTgInventoryObject_Listen
{
public:
	int                                                m_nPassiveEffectGroupId;                          		// 0x0098 (0x0004) [0x0000000000000000]              
	TArray< unsigned long >                            DeviceAlreadyHit;                                 		// 0x009C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2593 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_Ravana_Passive::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_Reflect
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_Reflect : public UTgInventoryObject_Listen
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2594 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_Reflect::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_RelicCooldown
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_RelicCooldown : public UTgInventoryObject_Listen
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2595 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_RelicCooldown::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_ReliquaryBlade
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_ReliquaryBlade : public UTgInventoryObject_Listen
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2596 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_ReliquaryBlade::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_RemoveTicketsOnDeath
// 0x0004 (0x009C - 0x0098)
class UTgInventoryObject_Listen_RemoveTicketsOnDeath : public UTgInventoryObject_Listen
{
public:
	class ATgPawn*                                     m_LastDamaged;                                    		// 0x0098 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2597 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_RemoveTicketsOnDeath::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_RuneforgedHammer
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_RuneforgedHammer : public UTgInventoryObject_Listen
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2598 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_RuneforgedHammer::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_SerqetCatalyst
// 0x0028 (0x00C0 - 0x0098)
class UTgInventoryObject_Listen_SerqetCatalyst : public UTgInventoryObject_Listen
{
public:
	int                                                m_nExtraEffectSituationalTypes[ 0x6 ];            		// 0x0098 (0x0018) [0x0000000000000000]              
	TArray< int >                                      m_ConsumePoisonsOnHitFrom;                        		// 0x00B0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	unsigned long                                      m_bRemovePoisonEffectGroups : 1;                  		// 0x00BC (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2599 );

		return pClassPointer;
	};

	void ConsumePoisons ( struct FImpactInfo* Impact );
};

UClass* UTgInventoryObject_Listen_SerqetCatalyst::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_SerqetCharm
// 0x0000 (0x00C0 - 0x00C0)
class UTgInventoryObject_Listen_SerqetCharm : public UTgInventoryObject_Listen_SerqetCatalyst
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2600 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_SerqetCharm::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_SerqetLastBreath
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_SerqetLastBreath : public UTgInventoryObject_Listen
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2601 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_SerqetLastBreath::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_SerqetPassive
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_SerqetPassive : public UTgInventoryObject_Listen
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2602 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_SerqetPassive::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_ShockwaveOnAbilityDamage
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_ShockwaveOnAbilityDamage : public UTgInventoryObject_Listen
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2603 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_ShockwaveOnAbilityDamage::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_ShockwaveOnDamagePerc
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_ShockwaveOnDamagePerc : public UTgInventoryObject_Listen
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2604 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_ShockwaveOnDamagePerc::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_Slowed
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_Slowed : public UTgInventoryObject_Listen
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2605 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_Slowed::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_SolDev2
// 0x0004 (0x009C - 0x0098)
class UTgInventoryObject_Listen_SolDev2 : public UTgInventoryObject_Listen
{
public:
	int                                                m_nStacksRemaining;                               		// 0x0098 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2606 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_SolDev2::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_SolUnstable
// 0x0014 (0x00AC - 0x0098)
class UTgInventoryObject_Listen_SolUnstable : public UTgInventoryObject_Listen
{
public:
	TArray< int >                                      m_nInstabilityIgnoreList;                         		// 0x0098 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                m_nInstabilityCategoryCode;                       		// 0x00A4 (0x0004) [0x0000000000000002]              ( CPF_Const )
	int                                                m_nInstabilitySituationalType;                    		// 0x00A8 (0x0004) [0x0000000000000002]              ( CPF_Const )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2607 );

		return pClassPointer;
	};

	void ForceInstabilityToZero ( );
	bool InstigatorIsPartiallyUnstable ( );
};

UClass* UTgInventoryObject_Listen_SolUnstable::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_SoulStone
// 0x0008 (0x00A0 - 0x0098)
class UTgInventoryObject_Listen_SoulStone : public UTgInventoryObject_Listen
{
public:
	class ATgDevice*                                   m_TrackedDevice;                                  		// 0x0098 (0x0004) [0x0000000000000000]              
	int                                                m_nTrackedFireInstance;                           		// 0x009C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2608 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_SoulStone::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_Stack
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_Stack : public UTgInventoryObject_Listen
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2609 );

		return pClassPointer;
	};

	int GetCurrentStacks ( );
	void RemoveStackCount ( int nStackCount );
	void AddStackCount ( int nStackCount );
};

UClass* UTgInventoryObject_Listen_Stack::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_Kill_Stack
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_Kill_Stack : public UTgInventoryObject_Listen_Stack
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2610 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_Kill_Stack::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_Assist_Stack
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_Assist_Stack : public UTgInventoryObject_Listen_Kill_Stack
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2611 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_Assist_Stack::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_GebPassive
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_GebPassive : public UTgInventoryObject_Listen_Kill_Stack
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2612 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_GebPassive::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_Kill_Stack_Remove_On_Death
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_Kill_Stack_Remove_On_Death : public UTgInventoryObject_Listen_Kill_Stack
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2613 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_Kill_Stack_Remove_On_Death::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_TieredStack
// 0x001C (0x00B4 - 0x0098)
class UTgInventoryObject_Listen_TieredStack : public UTgInventoryObject_Listen_Kill_Stack
{
public:
	TArray< int >                                      m_TierSituationalType;                            		// 0x0098 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< int >                                      m_TierStacks;                                     		// 0x00A4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                m_nCurrentTier;                                   		// 0x00B0 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2614 );

		return pClassPointer;
	};

	void UpdateTier ( );
	void RemoveStackCount ( int nStackCount );
	void AddStackCount ( int nStackCount );
};

UClass* UTgInventoryObject_Listen_TieredStack::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_XbalanquePassive
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_XbalanquePassive : public UTgInventoryObject_Listen_Kill_Stack
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2615 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_XbalanquePassive::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_OniHunter
// 0x0004 (0x009C - 0x0098)
class UTgInventoryObject_Listen_OniHunter : public UTgInventoryObject_Listen_Stack
{
public:
	float                                              m_fStackInterval;                                 		// 0x0098 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2616 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_OniHunter::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_SoulEaterS3
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_SoulEaterS3 : public UTgInventoryObject_Listen_Stack
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2617 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_SoulEaterS3::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_SoulStone_S3
// 0x0010 (0x00A8 - 0x0098)
class UTgInventoryObject_Listen_SoulStone_S3 : public UTgInventoryObject_Listen_Stack
{
public:
	TArray< struct FSoulStoneTrackingData >            m_TrackedDevices;                                 		// 0x0098 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                m_DamageType;                                     		// 0x00A4 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2618 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_SoulStone_S3::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_Heartseeker_S3
// 0x0000 (0x00A8 - 0x00A8)
class UTgInventoryObject_Listen_Heartseeker_S3 : public UTgInventoryObject_Listen_SoulStone_S3
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2619 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_Heartseeker_S3::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_StackOutOfCombat
// 0x0004 (0x009C - 0x0098)
class UTgInventoryObject_Listen_StackOutOfCombat : public UTgInventoryObject_Listen_Stack
{
public:
	float                                              s_fOutOfCombatTimer;                              		// 0x0098 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2620 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_StackOutOfCombat::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_SusanoPassive
// 0x0008 (0x00A0 - 0x0098)
class UTgInventoryObject_Listen_SusanoPassive : public UTgInventoryObject_Listen_Stack
{
public:
	class ATgPawn_Susano*                              m_Susano;                                         		// 0x0098 (0x0004) [0x0000000000000000]              
	int                                                m_PassiveValue;                                   		// 0x009C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2621 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_SusanoPassive::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_TalismanOfTheRelentless
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_TalismanOfTheRelentless : public UTgInventoryObject_Listen_Stack
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2622 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_TalismanOfTheRelentless::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_TerraPassive
// 0x0008 (0x00A0 - 0x0098)
class UTgInventoryObject_Listen_TerraPassive : public UTgInventoryObject_Listen_Stack
{
public:
	class ATgPawn_Terra*                               m_OwningTerra;                                    		// 0x0098 (0x0004) [0x0000000000000000]              
	int                                                m_StandingStoneCount;                             		// 0x009C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2623 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_TerraPassive::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_ThothPsv
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_ThothPsv : public UTgInventoryObject_Listen_Stack
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2624 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_ThothPsv::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_Timed_Stack
// 0x0004 (0x009C - 0x0098)
class UTgInventoryObject_Listen_Timed_Stack : public UTgInventoryObject_Listen_Stack
{
public:
	float                                              m_fStackTimer;                                    		// 0x0098 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2625 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_Timed_Stack::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_Staging
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_Staging : public UTgInventoryObject_Listen
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2626 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_Staging::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_ScyllaUltimate
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_ScyllaUltimate : public UTgInventoryObject_Listen_Staging
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2627 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_ScyllaUltimate::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_StoneOfGaia
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_StoneOfGaia : public UTgInventoryObject_Listen
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2628 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_StoneOfGaia::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_SuccessfulHit
// 0x0010 (0x00A8 - 0x0098)
class UTgInventoryObject_Listen_SuccessfulHit : public UTgInventoryObject_Listen
{
public:
	TArray< class ATgDevice* >                         m_AppliedThisFire;                                		// 0x0098 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	unsigned long                                      m_bHitAppliedThisTick : 1;                        		// 0x00A4 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2629 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_SuccessfulHit::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_SobekPassive
// 0x0000 (0x00A8 - 0x00A8)
class UTgInventoryObject_Listen_SobekPassive : public UTgInventoryObject_Listen_SuccessfulHit
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2630 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_SobekPassive::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_XingTianPassive
// 0x0000 (0x00A8 - 0x00A8)
class UTgInventoryObject_Listen_XingTianPassive : public UTgInventoryObject_Listen_SuccessfulHit
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2631 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_XingTianPassive::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_TeamBuff
// 0x0010 (0x00A8 - 0x0098)
class UTgInventoryObject_Listen_TeamBuff : public UTgInventoryObject_Listen
{
public:
	class UTgEffectGroup*                              s_TeamBuffEffectGroup;                            		// 0x0098 (0x0004) [0x0000000000000000]              
	class ATgRepInfo_TaskForce*                        r_TaskForce;                                      		// 0x009C (0x0004) [0x0000000000000000]              
	unsigned long                                      r_bTeamBuffApplied : 1;                           		// 0x00A0 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bBuffTeamOnlyWhenAlive : 1;                     		// 0x00A0 (0x0004) [0x0000000000000000] [0x00000002] 
	int                                                m_nTeamBuffEffectGroupId;                         		// 0x00A4 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2632 );

		return pClassPointer;
	};

	void eventUpdateTaskForce ( );
	void eventRemoveTeamBuff ( );
	void eventApplyTeamBuff ( );
};

UClass* UTgInventoryObject_Listen_TeamBuff::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_XbalanqueBranchingBola
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_XbalanqueBranchingBola : public UTgInventoryObject_Listen
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2633 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_XbalanqueBranchingBola::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_RamaAstralStrike
// 0x0000 (0x0098 - 0x0098)
class UTgInventoryObject_Listen_RamaAstralStrike : public UTgInventoryObject_Listen_XbalanqueBranchingBola
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2634 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_RamaAstralStrike::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_XbalanquePoisonDarts
// 0x0004 (0x009C - 0x0098)
class UTgInventoryObject_Listen_XbalanquePoisonDarts : public UTgInventoryObject_Listen
{
public:
	float                                              m_fAdditionalHitScaling;                          		// 0x0098 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2635 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_XbalanquePoisonDarts::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_RatatoskrBlueAcorn
// 0x000C (0x00A4 - 0x0098)
class UTgInventoryObject_RatatoskrBlueAcorn : public UTgInventoryObject_Listen
{
public:
	struct FPointer                                    VfTable_ITgRatatoskrAcorn;                        		// 0x0098 (0x0004) [0x0000000000801002]              ( CPF_Const | CPF_Native | CPF_NoExport )
	int                                                m_LastHealedDevId;                                		// 0x009C (0x0004) [0x0000000000000000]              
	int                                                m_LastHealedInstance;                             		// 0x00A0 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2636 );

		return pClassPointer;
	};

	unsigned char GetAcornType ( );
};

UClass* UTgInventoryObject_RatatoskrBlueAcorn::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_RatatoskrAcorn
// 0x0004 (0x0098 - 0x0094)
class UTgInventoryObject_RatatoskrAcorn : public UTgInventoryObject_Device
{
public:
	struct FPointer                                    VfTable_ITgRatatoskrAcorn;                        		// 0x0094 (0x0004) [0x0000000000801002]              ( CPF_Const | CPF_Native | CPF_NoExport )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2637 );

		return pClassPointer;
	};

	unsigned char GetAcornType ( );
};

UClass* UTgInventoryObject_RatatoskrAcorn::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_RatatoskrEmeraldAcorn
// 0x0004 (0x0098 - 0x0094)
class UTgInventoryObject_RatatoskrEmeraldAcorn : public UTgInventoryObject_Device
{
public:
	struct FPointer                                    VfTable_ITgRatatoskrAcorn;                        		// 0x0094 (0x0004) [0x0000000000801002]              ( CPF_Const | CPF_Native | CPF_NoExport )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2638 );

		return pClassPointer;
	};

	unsigned char GetAcornType ( );
};

UClass* UTgInventoryObject_RatatoskrEmeraldAcorn::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_RatatoskrOpalAcorn
// 0x0004 (0x0098 - 0x0094)
class UTgInventoryObject_RatatoskrOpalAcorn : public UTgInventoryObject_Device
{
public:
	struct FPointer                                    VfTable_ITgRatatoskrAcorn;                        		// 0x0094 (0x0004) [0x0000000000801002]              ( CPF_Const | CPF_Native | CPF_NoExport )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2639 );

		return pClassPointer;
	};

	unsigned char GetAcornType ( );
};

UClass* UTgInventoryObject_RatatoskrOpalAcorn::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_RatatoskrSapphireAcorn
// 0x0004 (0x0098 - 0x0094)
class UTgInventoryObject_RatatoskrSapphireAcorn : public UTgInventoryObject_Device
{
public:
	struct FPointer                                    VfTable_ITgRatatoskrAcorn;                        		// 0x0094 (0x0004) [0x0000000000801002]              ( CPF_Const | CPF_Native | CPF_NoExport )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2640 );

		return pClassPointer;
	};

	unsigned char GetAcornType ( );
};

UClass* UTgInventoryObject_RatatoskrSapphireAcorn::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_RatatoskrTopazAcorn
// 0x0004 (0x0098 - 0x0094)
class UTgInventoryObject_RatatoskrTopazAcorn : public UTgInventoryObject_Device
{
public:
	struct FPointer                                    VfTable_ITgRatatoskrAcorn;                        		// 0x0094 (0x0004) [0x0000000000801002]              ( CPF_Const | CPF_Native | CPF_NoExport )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2641 );

		return pClassPointer;
	};

	unsigned char GetAcornType ( );
};

UClass* UTgInventoryObject_RatatoskrTopazAcorn::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_RatatoskrYellowAcorn
// 0x0004 (0x0098 - 0x0094)
class UTgInventoryObject_RatatoskrYellowAcorn : public UTgInventoryObject_Device
{
public:
	struct FPointer                                    VfTable_ITgRatatoskrAcorn;                        		// 0x0094 (0x0004) [0x0000000000801002]              ( CPF_Const | CPF_Native | CPF_NoExport )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2642 );

		return pClassPointer;
	};

	unsigned char GetAcornType ( );
};

UClass* UTgInventoryObject_RatatoskrYellowAcorn::pClassPointer = NULL;

// Class TgGame.TgPickupFactory
// 0x001C (0x02E8 - 0x02CC)
class ATgPickupFactory : public APickupFactory
{
public:
	unsigned long                                      bRotatingPickup : 1;                              		// 0x02CC (0x0004) [0x0000000000000000] [0x00000001] 
	float                                              YawRotationRate;                                  		// 0x02D0 (0x0004) [0x0000000000000000]              
	class AController*                                 TeamOwner[ 0x4 ];                                 		// 0x02D4 (0x0010) [0x0000000000000000]              
	class UPrimitiveComponent*                         BaseMesh;                                         		// 0x02E4 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2643 );

		return pClassPointer;
	};

	bool StopsProjectile ( class AProjectile* P );
	void RespawnEffect ( );
	void UpdateHUD ( class ATgHUD* H );
	bool ShouldCamp ( class ATgAIController* B, float MaxWait );
};

UClass* ATgPickupFactory::pClassPointer = NULL;

// Class TgGame.TgRatatoskrAcorn
// 0x0000 (0x003C - 0x003C)
class UTgRatatoskrAcorn : public UInterface
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2644 );

		return pClassPointer;
	};

	unsigned char GetAcornType ( );
};

UClass* UTgRatatoskrAcorn::pClassPointer = NULL;

// Class TgGame.TgSeqAct_AddPercentVitals
// 0x0008 (0x00CC - 0x00C4)
class UTgSeqAct_AddPercentVitals : public USequenceAction
{
public:
	float                                              percentHealth;                                    		// 0x00C4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              percentMana;                                      		// 0x00C8 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2645 );

		return pClassPointer;
	};

};

UClass* UTgSeqAct_AddPercentVitals::pClassPointer = NULL;

// Class TgGame.TgSeqAct_AIAssignLane
// 0x0004 (0x00C8 - 0x00C4)
class UTgSeqAct_AIAssignLane : public USequenceAction
{
public:
	int                                                Lane;                                             		// 0x00C4 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2646 );

		return pClassPointer;
	};

};

UClass* UTgSeqAct_AIAssignLane::pClassPointer = NULL;

// Class TgGame.TgSeqAct_AIFreeze
// 0x0004 (0x00C8 - 0x00C4)
class UTgSeqAct_AIFreeze : public USequenceAction
{
public:
	int                                                TaskForceNumber;                                  		// 0x00C4 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2647 );

		return pClassPointer;
	};

};

UClass* UTgSeqAct_AIFreeze::pClassPointer = NULL;

// Class TgGame.TgSeqAct_AIMoveToActor
// 0x0004 (0x00C8 - 0x00C4)
class UTgSeqAct_AIMoveToActor : public USequenceAction
{
public:
	class AActor*                                      Destination;                                      		// 0x00C4 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2648 );

		return pClassPointer;
	};

};

UClass* UTgSeqAct_AIMoveToActor::pClassPointer = NULL;

// Class TgGame.TgSeqAct_AITargetActor
// 0x0004 (0x00C8 - 0x00C4)
class UTgSeqAct_AITargetActor : public USequenceAction
{
public:
	class AActor*                                      CombatTarget;                                     		// 0x00C4 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2649 );

		return pClassPointer;
	};

};

UClass* UTgSeqAct_AITargetActor::pClassPointer = NULL;

// Class TgGame.TgSeqAct_ArenaTraining_EnableCompletion
// 0x0000 (0x00C4 - 0x00C4)
class UTgSeqAct_ArenaTraining_EnableCompletion : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2650 );

		return pClassPointer;
	};

};

UClass* UTgSeqAct_ArenaTraining_EnableCompletion::pClassPointer = NULL;

// Class TgGame.TgSeqAct_ArenaTraining_UseTickets
// 0x0008 (0x00CC - 0x00C4)
class UTgSeqAct_ArenaTraining_UseTickets : public USequenceAction
{
public:
	int                                                m_nTaskForce;                                     		// 0x00C4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_nTickets;                                       		// 0x00C8 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2651 );

		return pClassPointer;
	};

};

UClass* UTgSeqAct_ArenaTraining_UseTickets::pClassPointer = NULL;

// Class TgGame.TgSeqAct_ClientLoadDevices
// 0x0010 (0x00D4 - 0x00C4)
class UTgSeqAct_ClientLoadDevices : public USequenceAction
{
public:
	TArray< int >                                      m_DeviceIdList;                                   		// 0x00C4 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	unsigned long                                      m_bClearExistingLoads : 1;                        		// 0x00D0 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2652 );

		return pClassPointer;
	};

};

UClass* UTgSeqAct_ClientLoadDevices::pClassPointer = NULL;

// Class TgGame.TgSeqAct_CurrencySpooling
// 0x0000 (0x00C4 - 0x00C4)
class UTgSeqAct_CurrencySpooling : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2653 );

		return pClassPointer;
	};

};

UClass* UTgSeqAct_CurrencySpooling::pClassPointer = NULL;

// Class TgGame.TgSeqAct_DefenseWaveSpawner
// 0x000C (0x00D0 - 0x00C4)
class UTgSeqAct_DefenseWaveSpawner : public USequenceAction
{
public:
	int                                                m_nRoundNumber;                                   		// 0x00C4 (0x0004) [0x0000000000000000]              
	float                                              m_fSpawnFrequency;                                		// 0x00C8 (0x0004) [0x0000000000000000]              
	float                                              m_fNextSpawnTime;                                 		// 0x00CC (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2654 );

		return pClassPointer;
	};

};

UClass* UTgSeqAct_DefenseWaveSpawner::pClassPointer = NULL;

// Class TgGame.TgSeqAct_EndMission
// 0x0000 (0x00C4 - 0x00C4)
class UTgSeqAct_EndMission : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2655 );

		return pClassPointer;
	};

};

UClass* UTgSeqAct_EndMission::pClassPointer = NULL;

// Class TgGame.TgSeqAct_ForceClientTutorialAction
// 0x0002 (0x00C6 - 0x00C4)
class UTgSeqAct_ForceClientTutorialAction : public USequenceAction
{
public:
	unsigned char                                      ForcedAction;                                     		// 0x00C4 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      GameUIElement;                                    		// 0x00C5 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2656 );

		return pClassPointer;
	};

};

UClass* UTgSeqAct_ForceClientTutorialAction::pClassPointer = NULL;

// Class TgGame.TgSeqAct_GetGodRole
// 0x0000 (0x00C4 - 0x00C4)
class UTgSeqAct_GetGodRole : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2657 );

		return pClassPointer;
	};

};

UClass* UTgSeqAct_GetGodRole::pClassPointer = NULL;

// Class TgGame.TgSeqAct_GetMaterialInst
// 0x0014 (0x00D8 - 0x00C4)
class UTgSeqAct_GetMaterialInst : public USequenceAction
{
public:
	class UMaterialInstance*                           MatInst;                                          		// 0x00C4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FString                                     MatInstName;                                      		// 0x00C8 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	int                                                MaterialIndex;                                    		// 0x00D4 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2658 );

		return pClassPointer;
	};

};

UClass* UTgSeqAct_GetMaterialInst::pClassPointer = NULL;

// Class TgGame.TgSeqAct_GetObjectListCount
// 0x0004 (0x00C8 - 0x00C4)
class UTgSeqAct_GetObjectListCount : public USequenceAction
{
public:
	int                                                m_nListCount;                                     		// 0x00C4 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2659 );

		return pClassPointer;
	};

};

UClass* UTgSeqAct_GetObjectListCount::pClassPointer = NULL;

// Class TgGame.TgSeqAct_GetPlayerCount
// 0x0018 (0x00DC - 0x00C4)
class UTgSeqAct_GetPlayerCount : public USequenceAction
{
public:
	int                                                m_nTaskForce;                                     		// 0x00C4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fPlayerCount;                                   		// 0x00C8 (0x0004) [0x0000000000000000]              
	float                                              m_fAssaultCount;                                  		// 0x00CC (0x0004) [0x0000000000000000]              
	float                                              m_fMedicCount;                                    		// 0x00D0 (0x0004) [0x0000000000000000]              
	float                                              m_fReconCount;                                    		// 0x00D4 (0x0004) [0x0000000000000000]              
	float                                              m_fRoboticsCount;                                 		// 0x00D8 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2660 );

		return pClassPointer;
	};

};

UClass* UTgSeqAct_GetPlayerCount::pClassPointer = NULL;

// Class TgGame.TgSeqAct_GetTaskForceCount
// 0x000C (0x00D0 - 0x00C4)
class UTgSeqAct_GetTaskForceCount : public USequenceAction
{
public:
	int                                                taskforce;                                        		// 0x00C4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_nPlayerCount;                                   		// 0x00C8 (0x0004) [0x0000000000000000]              
	int                                                m_nBotCount;                                      		// 0x00CC (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2661 );

		return pClassPointer;
	};

};

UClass* UTgSeqAct_GetTaskForceCount::pClassPointer = NULL;

// Class TgGame.TgSeqAct_GetTaskForceList
// 0x0004 (0x00C8 - 0x00C4)
class UTgSeqAct_GetTaskForceList : public USequenceAction
{
public:
	int                                                taskforce;                                        		// 0x00C4 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2662 );

		return pClassPointer;
	};

};

UClass* UTgSeqAct_GetTaskForceList::pClassPointer = NULL;

// Class TgGame.TgSeqAct_GiveFullVitals
// 0x0000 (0x00C4 - 0x00C4)
class UTgSeqAct_GiveFullVitals : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2663 );

		return pClassPointer;
	};

};

UClass* UTgSeqAct_GiveFullVitals::pClassPointer = NULL;

// Class TgGame.TgSeqAct_GivePercentVitals
// 0x0008 (0x00CC - 0x00C4)
class UTgSeqAct_GivePercentVitals : public USequenceAction
{
public:
	float                                              percentHealth;                                    		// 0x00C4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              percentMana;                                      		// 0x00C8 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2664 );

		return pClassPointer;
	};

};

UClass* UTgSeqAct_GivePercentVitals::pClassPointer = NULL;

// Class TgGame.TgSeqAct_LockCapturePoint
// 0x0004 (0x00C8 - 0x00C4)
class UTgSeqAct_LockCapturePoint : public USequenceAction
{
public:
	unsigned long                                      m_bLock : 1;                                      		// 0x00C4 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2665 );

		return pClassPointer;
	};

};

UClass* UTgSeqAct_LockCapturePoint::pClassPointer = NULL;

// Class TgGame.TgSeqAct_NavIndicator
// 0x0004 (0x00C8 - 0x00C4)
class UTgSeqAct_NavIndicator : public USequenceAction
{
public:
	class AActor*                                      m_NavTarget;                                      		// 0x00C4 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2666 );

		return pClassPointer;
	};

};

UClass* UTgSeqAct_NavIndicator::pClassPointer = NULL;

// Class TgGame.TgSeqAct_PingMinimap
// 0x0004 (0x00C8 - 0x00C4)
class UTgSeqAct_PingMinimap : public USequenceAction
{
public:
	class AActor*                                      m_PingTarget;                                     		// 0x00C4 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2667 );

		return pClassPointer;
	};

};

UClass* UTgSeqAct_PingMinimap::pClassPointer = NULL;

// Class TgGame.TgSeqAct_PlayAnnouncement
// 0x0014 (0x00D8 - 0x00C4)
class UTgSeqAct_PlayAnnouncement : public USequenceAction
{
public:
	unsigned long                                      bPlayImmediately : 1;                             		// 0x00C4 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      bFlushOthers : 1;                                 		// 0x00C4 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	int                                                SoundIndex;                                       		// 0x00C8 (0x0004) [0x0000000020000000]              ( CPF_Deprecated )
	class USoundCue*                                   OptionalCue;                                      		// 0x00CC (0x0004) [0x0000000020000000]              ( CPF_Deprecated )
	class USoundCue*                                   DefaultSoundCue;                                  		// 0x00D0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class USoundCue*                                   ConsoleOverrideCue;                               		// 0x00D4 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2668 );

		return pClassPointer;
	};

	int eventGetObjClassVersion ( );
	void eventActivated ( );
};

UClass* UTgSeqAct_PlayAnnouncement::pClassPointer = NULL;

// Class TgGame.TgSeqAct_PlayFullBodyAnim
// 0x0018 (0x00DC - 0x00C4)
class UTgSeqAct_PlayFullBodyAnim : public USequenceAction
{
public:
	struct FName                                       c_AnimName;                                       		// 0x00C4 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	float                                              c_fRate;                                          		// 0x00CC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              c_fBlendInTime;                                   		// 0x00D0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              c_fBlendOutTime;                                  		// 0x00D4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      c_bLooping : 1;                                   		// 0x00D8 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      c_bOverride : 1;                                  		// 0x00D8 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2669 );

		return pClassPointer;
	};

};

UClass* UTgSeqAct_PlayFullBodyAnim::pClassPointer = NULL;

// Class TgGame.TgSeqAct_ProgressTo
// 0x0004 (0x00F0 - 0x00EC)
class UTgSeqAct_ProgressTo : public USeqAct_Delay
{
public:
	class ATgPawn*                                     m_Instigator;                                     		// 0x00EC (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2670 );

		return pClassPointer;
	};

};

UClass* UTgSeqAct_ProgressTo::pClassPointer = NULL;

// Class TgGame.TgSeqAct_PushMatinee
// 0x000C (0x01B0 - 0x01A4)
class UTgSeqAct_PushMatinee : public USeqAct_Interp
{
public:
	float                                              m_fCheckpoint1Time;                               		// 0x01A4 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	float                                              m_fCheckpoint2Time;                               		// 0x01A8 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	int                                                m_nDefenderTaskForce;                             		// 0x01AC (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2671 );

		return pClassPointer;
	};

};

UClass* UTgSeqAct_PushMatinee::pClassPointer = NULL;

// Class TgGame.TgSeqAct_RequestMission
// 0x0004 (0x00C8 - 0x00C4)
class UTgSeqAct_RequestMission : public USequenceAction
{
public:
	int                                                m_nMapGameId;                                     		// 0x00C4 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2672 );

		return pClassPointer;
	};

};

UClass* UTgSeqAct_RequestMission::pClassPointer = NULL;

// Class TgGame.TgSeqAct_SendPlayerTrackingEvent
// 0x0018 (0x00DC - 0x00C4)
class UTgSeqAct_SendPlayerTrackingEvent : public USequenceAction
{
public:
	int                                                m_nEventId;                                       		// 0x00C4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_nSubEventID;                                    		// 0x00C8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FString                                     m_ReferenceName;                                  		// 0x00CC (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	int                                                m_nReferenceValue;                                		// 0x00D8 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2673 );

		return pClassPointer;
	};

};

UClass* UTgSeqAct_SendPlayerTrackingEvent::pClassPointer = NULL;

// Class TgGame.TgSeqAct_SetCapturePointOwner
// 0x0004 (0x00C8 - 0x00C4)
class UTgSeqAct_SetCapturePointOwner : public USequenceAction
{
public:
	float                                              m_nOwningTaskForce;                               		// 0x00C4 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2674 );

		return pClassPointer;
	};

};

UClass* UTgSeqAct_SetCapturePointOwner::pClassPointer = NULL;

// Class TgGame.TgSeqAct_SetCapturePointPct
// 0x0004 (0x00C8 - 0x00C4)
class UTgSeqAct_SetCapturePointPct : public USequenceAction
{
public:
	float                                              m_fNewPercent;                                    		// 0x00C4 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2675 );

		return pClassPointer;
	};

};

UClass* UTgSeqAct_SetCapturePointPct::pClassPointer = NULL;

// Class TgGame.TgSeqAct_SetHexState
// 0x0004 (0x00C8 - 0x00C4)
class UTgSeqAct_SetHexState : public USequenceAction
{
public:
	unsigned long                                      m_bChallengerWon : 1;                             		// 0x00C4 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2676 );

		return pClassPointer;
	};

};

UClass* UTgSeqAct_SetHexState::pClassPointer = NULL;

// Class TgGame.TgSeqAct_SetMissionTime
// 0x000C (0x00D0 - 0x00C4)
class UTgSeqAct_SetMissionTime : public USequenceAction
{
public:
	float                                              m_fMissionTimeSecs;                               		// 0x00C4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fIncrementSecs;                                 		// 0x00C8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fMissionTimeRemaining;                          		// 0x00CC (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2677 );

		return pClassPointer;
	};

};

UClass* UTgSeqAct_SetMissionTime::pClassPointer = NULL;

// Class TgGame.TgSeqAct_SetObjectList
// 0x0000 (0x00C4 - 0x00C4)
class UTgSeqAct_SetObjectList : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2678 );

		return pClassPointer;
	};

};

UClass* UTgSeqAct_SetObjectList::pClassPointer = NULL;

// Class TgGame.TgSeqAct_SetPlayerLevel
// 0x0004 (0x00C8 - 0x00C4)
class UTgSeqAct_SetPlayerLevel : public USequenceAction
{
public:
	int                                                m_nLevel;                                         		// 0x00C4 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2679 );

		return pClassPointer;
	};

};

UClass* UTgSeqAct_SetPlayerLevel::pClassPointer = NULL;

// Class TgGame.TgSeqAct_SetPlayerMesh
// 0x0004 (0x00C8 - 0x00C4)
class UTgSeqAct_SetPlayerMesh : public USequenceAction
{
public:
	int                                                m_nMeshAsmId;                                     		// 0x00C4 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2680 );

		return pClassPointer;
	};

};

UClass* UTgSeqAct_SetPlayerMesh::pClassPointer = NULL;

// Class TgGame.TgSeqAct_SetUIClock
// 0x0004 (0x00C8 - 0x00C4)
class UTgSeqAct_SetUIClock : public USequenceAction
{
public:
	unsigned long                                      ShowAlarmTexture : 1;                             		// 0x00C4 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      UseProgressBar : 1;                               		// 0x00C4 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      IsCountingDown : 1;                               		// 0x00C4 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2681 );

		return pClassPointer;
	};

};

UClass* UTgSeqAct_SetUIClock::pClassPointer = NULL;

// Class TgGame.TgSeqAct_SetUITextBox
// 0x0009 (0x00CD - 0x00C4)
class UTgSeqAct_SetUITextBox : public USequenceAction
{
public:
	int                                                TextBox_MessageID;                                		// 0x00C4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      TextBox_TargetSecondary : 1;                      		// 0x00C8 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      TextBox_UseDuration : 1;                          		// 0x00C8 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      TextBox_AllowEscape : 1;                          		// 0x00C8 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned char                                      TextBox_MessageType;                              		// 0x00CC (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2682 );

		return pClassPointer;
	};

};

UClass* UTgSeqAct_SetUITextBox::pClassPointer = NULL;

// Class TgGame.TgSeqAct_ShuffleObjectList
// 0x0000 (0x00C4 - 0x00C4)
class UTgSeqAct_ShuffleObjectList : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2683 );

		return pClassPointer;
	};

};

UClass* UTgSeqAct_ShuffleObjectList::pClassPointer = NULL;

// Class TgGame.TgSeqAct_TemporaryAddDevice
// 0x0008 (0x00CC - 0x00C4)
class UTgSeqAct_TemporaryAddDevice : public USequenceAction
{
public:
	int                                                m_nDeviceId;                                      		// 0x00C4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_nEquipPoint;                                    		// 0x00C8 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2684 );

		return pClassPointer;
	};

};

UClass* UTgSeqAct_TemporaryAddDevice::pClassPointer = NULL;

// Class TgGame.TgSeqAct_TemporaryRemoveDevice
// 0x0004 (0x00C8 - 0x00C4)
class UTgSeqAct_TemporaryRemoveDevice : public USequenceAction
{
public:
	int                                                m_nEquipPoint;                                    		// 0x00C4 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2685 );

		return pClassPointer;
	};

};

UClass* UTgSeqAct_TemporaryRemoveDevice::pClassPointer = NULL;

// Class TgGame.TgSeqAct_Training_StartQuest
// 0x0014 (0x00D8 - 0x00C4)
class UTgSeqAct_Training_StartQuest : public USequenceAction
{
public:
	int                                                m_nEventId;                                       		// 0x00C4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_eObjectiveType;                                 		// 0x00C8 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_nQuestCount;                                    		// 0x00CC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UClass*                                      m_KillType;                                       		// 0x00D0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_nQuestMsgID;                                    		// 0x00D4 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2686 );

		return pClassPointer;
	};

};

UClass* UTgSeqAct_Training_StartQuest::pClassPointer = NULL;

// Class TgGame.TgSeqAct_Training_UpdateQuest
// 0x0008 (0x00CC - 0x00C4)
class UTgSeqAct_Training_UpdateQuest : public USequenceAction
{
public:
	int                                                m_nEventId;                                       		// 0x00C4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_nUpdateAmount;                                  		// 0x00C8 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2687 );

		return pClassPointer;
	};

};

UClass* UTgSeqAct_Training_UpdateQuest::pClassPointer = NULL;

// Class TgGame.TgSeqAct_TrainingAwards
// 0x0010 (0x00D4 - 0x00C4)
class UTgSeqAct_TrainingAwards : public USequenceAction
{
public:
	float                                              m_fGoldTime;                                      		// 0x00C4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fSilverTime;                                    		// 0x00C8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fBronzeTime;                                    		// 0x00CC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fPassTime;                                      		// 0x00D0 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2688 );

		return pClassPointer;
	};

};

UClass* UTgSeqAct_TrainingAwards::pClassPointer = NULL;

// Class TgGame.TgSeqAct_TriggerBots
// 0x000C (0x00D0 - 0x00C4)
class UTgSeqAct_TriggerBots : public USequenceAction
{
public:
	unsigned long                                      bUseDestination : 1;                              		// 0x00C4 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	class AActor*                                      TargetActor;                                      		// 0x00C8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class AActor*                                      destActor;                                        		// 0x00CC (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2689 );

		return pClassPointer;
	};

};

UClass* UTgSeqAct_TriggerBots::pClassPointer = NULL;

// Class TgGame.TgSeqAct_TutorialHighlighter
// 0x0001 (0x00C5 - 0x00C4)
class UTgSeqAct_TutorialHighlighter : public USequenceAction
{
public:
	unsigned char                                      GameUIElement;                                    		// 0x00C4 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2690 );

		return pClassPointer;
	};

};

UClass* UTgSeqAct_TutorialHighlighter::pClassPointer = NULL;

// Class TgGame.TgSeqAct_TutorialImage
// 0x0010 (0x00D4 - 0x00C4)
class UTgSeqAct_TutorialImage : public USequenceAction
{
public:
	unsigned char                                      ImageAction;                                      		// 0x00C4 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	int                                                HeaderMsgId;                                      		// 0x00C8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                ImageId;                                          		// 0x00CC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                msgId;                                            		// 0x00D0 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2691 );

		return pClassPointer;
	};

};

UClass* UTgSeqAct_TutorialImage::pClassPointer = NULL;

// Class TgGame.TgSeqAct_TutorialInstruction
// 0x0004 (0x00C8 - 0x00C4)
class UTgSeqAct_TutorialInstruction : public USequenceAction
{
public:
	int                                                nMsgId;                                           		// 0x00C4 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2692 );

		return pClassPointer;
	};

};

UClass* UTgSeqAct_TutorialInstruction::pClassPointer = NULL;

// Class TgGame.TgSeqAct_TutorialTips
// 0x0004 (0x00C8 - 0x00C4)
class UTgSeqAct_TutorialTips : public USequenceAction
{
public:
	int                                                nMsgId;                                           		// 0x00C4 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2693 );

		return pClassPointer;
	};

};

UClass* UTgSeqAct_TutorialTips::pClassPointer = NULL;

// Class TgGame.TgSeqAct_UIAlert
// 0x001C (0x00E0 - 0x00C4)
class UTgSeqAct_UIAlert : public USequenceAction
{
public:
	int                                                nMsgId;                                           		// 0x00C4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	TArray< int >                                      Taskforces;                                       		// 0x00C8 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< unsigned long >                            Broadcast;                                        		// 0x00D4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2694 );

		return pClassPointer;
	};

};

UClass* UTgSeqAct_UIAlert::pClassPointer = NULL;

// Class TgGame.TgSeqAct_UINotify
// 0x0040 (0x0104 - 0x00C4)
class UTgSeqAct_UINotify : public USequenceAction
{
public:
	int                                                nMsgId;                                           		// 0x00C4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                nSubMsgId;                                        		// 0x00C8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                nTextColor;                                       		// 0x00CC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                nSubTextColor;                                    		// 0x00D0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                nTextSize;                                        		// 0x00D4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                nSubTextSize;                                     		// 0x00D8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                nDelay;                                           		// 0x00DC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	TArray< int >                                      Taskforces;                                       		// 0x00E0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< unsigned long >                            Broadcast;                                        		// 0x00EC (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< int >                                      FillInt;                                          		// 0x00F8 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2695 );

		return pClassPointer;
	};

};

UClass* UTgSeqAct_UINotify::pClassPointer = NULL;

// Class TgGame.TgSeqAct_UpdateRoundState
// 0x000C (0x00D0 - 0x00C4)
class UTgSeqAct_UpdateRoundState : public USequenceAction
{
public:
	int                                                m_nRoundNumber;                                   		// 0x00C4 (0x0004) [0x0000000000000000]              
	int                                                m_nTipId;                                         		// 0x00C8 (0x0004) [0x0000000000000000]              
	int                                                m_nTitleId;                                       		// 0x00CC (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2696 );

		return pClassPointer;
	};

};

UClass* UTgSeqAct_UpdateRoundState::pClassPointer = NULL;

// Class TgGame.TgSeqAct_UpdateSiegeBattlePhase
// 0x0004 (0x00C8 - 0x00C4)
class UTgSeqAct_UpdateSiegeBattlePhase : public USequenceAction
{
public:
	unsigned long                                      m_bIsDayPhase : 1;                                		// 0x00C4 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2697 );

		return pClassPointer;
	};

};

UClass* UTgSeqAct_UpdateSiegeBattlePhase::pClassPointer = NULL;

// Class TgGame.TgSeqAct_XpSpooling
// 0x0000 (0x00C4 - 0x00C4)
class UTgSeqAct_XpSpooling : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2698 );

		return pClassPointer;
	};

};

UClass* UTgSeqAct_XpSpooling::pClassPointer = NULL;

// Class TgGame.TgSeqCond_And
// 0x0000 (0x00AC - 0x00AC)
class UTgSeqCond_And : public USequenceCondition
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2699 );

		return pClassPointer;
	};

};

UClass* UTgSeqCond_And::pClassPointer = NULL;

// Class TgGame.TgSeqCond_HasCondition
// 0x0001 (0x00AD - 0x00AC)
class UTgSeqCond_HasCondition : public USequenceCondition
{
public:
	unsigned char                                      ConditionList;                                    		// 0x00AC (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2700 );

		return pClassPointer;
	};

};

UClass* UTgSeqCond_HasCondition::pClassPointer = NULL;

// Class TgGame.TgSeqCond_IsHuman
// 0x0000 (0x00AC - 0x00AC)
class UTgSeqCond_IsHuman : public USequenceCondition
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2701 );

		return pClassPointer;
	};

};

UClass* UTgSeqCond_IsHuman::pClassPointer = NULL;

// Class TgGame.TgSeqCond_IsSecuring
// 0x0000 (0x00AC - 0x00AC)
class UTgSeqCond_IsSecuring : public USequenceCondition
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2702 );

		return pClassPointer;
	};

};

UClass* UTgSeqCond_IsSecuring::pClassPointer = NULL;

// Class TgGame.TgSeqCond_LoginPageSelect
// 0x0000 (0x00AC - 0x00AC)
class UTgSeqCond_LoginPageSelect : public USequenceCondition
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2703 );

		return pClassPointer;
	};

};

UClass* UTgSeqCond_LoginPageSelect::pClassPointer = NULL;

// Class TgGame.TgSeqCond_Or
// 0x0000 (0x00AC - 0x00AC)
class UTgSeqCond_Or : public USequenceCondition
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2704 );

		return pClassPointer;
	};

};

UClass* UTgSeqCond_Or::pClassPointer = NULL;

// Class TgGame.TgSeqCond_WorldDetail
// 0x0004 (0x00B0 - 0x00AC)
class UTgSeqCond_WorldDetail : public USequenceCondition
{
public:
	int                                                MinWorldSetting;                                  		// 0x00AC (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2705 );

		return pClassPointer;
	};

};

UClass* UTgSeqCond_WorldDetail::pClassPointer = NULL;

// Class TgGame.TgSeqEvent_ClientGameOver
// 0x0000 (0x00DC - 0x00DC)
class UTgSeqEvent_ClientGameOver : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2706 );

		return pClassPointer;
	};

};

UClass* UTgSeqEvent_ClientGameOver::pClassPointer = NULL;

// Class TgGame.TgSeqEvent_DeployableFired
// 0x0000 (0x00DC - 0x00DC)
class UTgSeqEvent_DeployableFired : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2707 );

		return pClassPointer;
	};

};

UClass* UTgSeqEvent_DeployableFired::pClassPointer = NULL;

// Class TgGame.TgSeqEvent_Escort_Despawn_Success
// 0x0004 (0x00E0 - 0x00DC)
class UTgSeqEvent_Escort_Despawn_Success : public USequenceEvent
{
public:
	int                                                DefendersTaskForce;                               		// 0x00DC (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2708 );

		return pClassPointer;
	};

};

UClass* UTgSeqEvent_Escort_Despawn_Success::pClassPointer = NULL;

// Class TgGame.TgSeqEvent_FiringDevice
// 0x0000 (0x00DC - 0x00DC)
class UTgSeqEvent_FiringDevice : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2709 );

		return pClassPointer;
	};

};

UClass* UTgSeqEvent_FiringDevice::pClassPointer = NULL;

// Class TgGame.TgSeqEvent_LevelFadedIn
// 0x0000 (0x00DC - 0x00DC)
class UTgSeqEvent_LevelFadedIn : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2710 );

		return pClassPointer;
	};

};

UClass* UTgSeqEvent_LevelFadedIn::pClassPointer = NULL;

// Class TgGame.TgSeqEvent_MissionTimer
// 0x0000 (0x00DC - 0x00DC)
class UTgSeqEvent_MissionTimer : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2711 );

		return pClassPointer;
	};

	void UpdateTaskForceWonValue ( int iValue );
	void UpdateChallengerWonValue ( unsigned long bValue );
};

UClass* UTgSeqEvent_MissionTimer::pClassPointer = NULL;

// Class TgGame.TgSeqEvent_MissionTimeRemaining
// 0x0004 (0x00E0 - 0x00DC)
class UTgSeqEvent_MissionTimeRemaining : public USequenceEvent
{
public:
	float                                              SecsRemaining;                                    		// 0x00DC (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2712 );

		return pClassPointer;
	};

};

UClass* UTgSeqEvent_MissionTimeRemaining::pClassPointer = NULL;

// Class TgGame.TgSeqEvent_Named
// 0x0001 (0x00DD - 0x00DC)
class UTgSeqEvent_Named : public USequenceEvent
{
public:
	unsigned char                                      NamedEvent;                                       		// 0x00DC (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2713 );

		return pClassPointer;
	};

};

UClass* UTgSeqEvent_Named::pClassPointer = NULL;

// Class TgGame.TgSeqEvent_PVEDifficultySet
// 0x0000 (0x00DC - 0x00DC)
class UTgSeqEvent_PVEDifficultySet : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2714 );

		return pClassPointer;
	};

	void UpdateDifficulty ( int Difficulty );
};

UClass* UTgSeqEvent_PVEDifficultySet::pClassPointer = NULL;

// Class TgGame.TgSeqEvent_SpawnLanePusher
// 0x0004 (0x00E0 - 0x00DC)
class UTgSeqEvent_SpawnLanePusher : public USequenceEvent
{
public:
	int                                                taskforce;                                        		// 0x00DC (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2715 );

		return pClassPointer;
	};

};

UClass* UTgSeqEvent_SpawnLanePusher::pClassPointer = NULL;

// Class TgGame.TgSeqEvent_SpawnWise
// 0x0004 (0x00E0 - 0x00DC)
class UTgSeqEvent_SpawnWise : public USequenceEvent
{
public:
	int                                                taskforce;                                        		// 0x00DC (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2716 );

		return pClassPointer;
	};

};

UClass* UTgSeqEvent_SpawnWise::pClassPointer = NULL;

// Class TgGame.TgSeqEvent_TaskForceInactive
// 0x0000 (0x00DC - 0x00DC)
class UTgSeqEvent_TaskForceInactive : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2717 );

		return pClassPointer;
	};

};

UClass* UTgSeqEvent_TaskForceInactive::pClassPointer = NULL;

// Class TgGame.TgSeqEvent_TeamInactive
// 0x0000 (0x00DC - 0x00DC)
class UTgSeqEvent_TeamInactive : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2718 );

		return pClassPointer;
	};

};

UClass* UTgSeqEvent_TeamInactive::pClassPointer = NULL;

// Class TgGame.TgSeqEvent_TicketCountUpdated
// 0x0000 (0x00DC - 0x00DC)
class UTgSeqEvent_TicketCountUpdated : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2719 );

		return pClassPointer;
	};

};

UClass* UTgSeqEvent_TicketCountUpdated::pClassPointer = NULL;

// Class TgGame.TgSeqEvent_UpdateLanePusherCount
// 0x0004 (0x00E0 - 0x00DC)
class UTgSeqEvent_UpdateLanePusherCount : public USequenceEvent
{
public:
	int                                                taskforce;                                        		// 0x00DC (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2720 );

		return pClassPointer;
	};

};

UClass* UTgSeqEvent_UpdateLanePusherCount::pClassPointer = NULL;

// Class TgGame.TgSeqEvent_Used
// 0x0000 (0x00DC - 0x00DC)
class UTgSeqEvent_Used : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2721 );

		return pClassPointer;
	};

};

UClass* UTgSeqEvent_Used::pClassPointer = NULL;

// Class TgGame.TgSeqOp_MathCalc
// 0x0004 (0x00B0 - 0x00AC)
class UTgSeqOp_MathCalc : public USequenceCondition
{
public:
	float                                              m_fResult;                                        		// 0x00AC (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2722 );

		return pClassPointer;
	};

};

UClass* UTgSeqOp_MathCalc::pClassPointer = NULL;

// Class TgGame.TgSeqVar_Player
// 0x003C (0x00DC - 0x00A0)
class UTgSeqVar_Player : public USeqVar_Player
{
public:
	TArray< class UObject* >                           HumanPlayers;                                     		// 0x00A0 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	TArray< class UObject* >                           BotPlayers;                                       		// 0x00AC (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	TArray< class UObject* >                           PetPlayers;                                       		// 0x00B8 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	TArray< class UObject* >                           RolePlayers;                                      		// 0x00C4 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	unsigned long                                      bAllBots : 1;                                     		// 0x00D0 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      bAllHumans : 1;                                   		// 0x00D0 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      bAllHumansAndPets : 1;                            		// 0x00D0 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      bSingleBot : 1;                                   		// 0x00D0 (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )
	unsigned char                                      DesiredRole;                                      		// 0x00D4 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	int                                                nTaskForceNumber;                                 		// 0x00D8 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2723 );

		return pClassPointer;
	};

};

UClass* UTgSeqVar_Player::pClassPointer = NULL;

// Class TgGame.TgSeqVar_RouteNumber
// 0x0000 (0x0074 - 0x0074)
class UTgSeqVar_RouteNumber : public USeqVar_Int
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2724 );

		return pClassPointer;
	};

};

UClass* UTgSeqVar_RouteNumber::pClassPointer = NULL;

// Class TgGame.TgTrigger_Instance
// 0x0014 (0x0210 - 0x01FC)
class ATgTrigger_Instance : public ATrigger
{
public:
	int                                                m_nMapId;                                         		// 0x01FC (0x0004) [0x0000000004000001]              ( CPF_Edit | CPF_EditInline )
	unsigned long                                      m_nPreload : 1;                                   		// 0x0200 (0x0004) [0x0000000004000001] [0x00000001] ( CPF_Edit | CPF_EditInline )
	unsigned long                                      m_nTaskForce : 1;                                 		// 0x0200 (0x0004) [0x0000000004000001] [0x00000002] ( CPF_Edit | CPF_EditInline )
	struct FString                                     m_SpawnPointName;                                 		// 0x0204 (0x000C) [0x0000000004400001]              ( CPF_Edit | CPF_NeedCtorLink | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2725 );

		return pClassPointer;
	};

	void eventTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void HandleTouch ( class AActor* Other, struct FVector HitLocation, struct FVector HitNormal );
};

UClass* ATgTrigger_Instance::pClassPointer = NULL;

// Class TgGame.TgTrigger_Use
// 0x0028 (0x0224 - 0x01FC)
class ATgTrigger_Use : public ATrigger
{
public:
	struct FString                                     m_sDisplayText;                                   		// 0x01FC (0x000C) [0x0000000004400001]              ( CPF_Edit | CPF_NeedCtorLink | CPF_EditInline )
	struct FString                                     m_sInactiveText;                                  		// 0x0208 (0x000C) [0x0000000004400001]              ( CPF_Edit | CPF_NeedCtorLink | CPF_EditInline )
	int                                                m_nInteractDistance;                              		// 0x0214 (0x0004) [0x0000000004000001]              ( CPF_Edit | CPF_EditInline )
	unsigned long                                      m_bAimToInteract : 1;                             		// 0x0218 (0x0004) [0x0000000004000001] [0x00000001] ( CPF_Edit | CPF_EditInline )
	int                                                m_nDisplayMsgId;                                  		// 0x021C (0x0004) [0x0000000004000001]              ( CPF_Edit | CPF_EditInline )
	int                                                m_nInactiveMsgId;                                 		// 0x0220 (0x0004) [0x0000000004000001]              ( CPF_Edit | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2726 );

		return pClassPointer;
	};

	void eventUnTouch ( class AActor* Other );
	void eventTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	int GetMsgIdToDisplay ( );
	bool IsUsedEnabled ( );
	void UsedByPawn ( class ATgPawn* User );
};

UClass* ATgTrigger_Use::pClassPointer = NULL;

// Class TgGame.TgLanePylon
// 0x0004 (0x037C - 0x0378)
class ATgLanePylon : public APylon
{
public:
	int                                                m_nLane;                                          		// 0x0378 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2727 );

		return pClassPointer;
	};

};

UClass* ATgLanePylon::pClassPointer = NULL;

// Class TgGame.TgTeamBlocker
// 0x0004 (0x0204 - 0x0200)
class ATgTeamBlocker : public ATgMeshAssembly
{
public:
	unsigned long                                      m_bBlockFlagCarrier : 1;                          		// 0x0200 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_bBlockFriendlyFire : 1;                         		// 0x0200 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2728 );

		return pClassPointer;
	};

};

UClass* ATgTeamBlocker::pClassPointer = NULL;

// Class TgGame.TgDoorMarker
// 0x0018 (0x021C - 0x0204)
class ATgDoorMarker : public ATgTeamBlocker
{
public:
	unsigned char                                      r_eStatus;                                        		// 0x0204 (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      m_eInitStatus;                                    		// 0x0205 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	class ATgCollisionProxy*                           s_CollisionProxy;                                 		// 0x0208 (0x0004) [0x0000000000000000]              
	float                                              m_fProximity;                                     		// 0x020C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_nTeamThatControlsDoor;                          		// 0x0210 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_nMeshAssemblyId;                                		// 0x0214 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class USkeletalMeshComponent*                      m_DoorSMC;                                        		// 0x0218 (0x0004) [0x0000000004080009]              ( CPF_Edit | CPF_ExportObject | CPF_Component | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2729 );

		return pClassPointer;
	};

	void SetDoorStatus ( unsigned char eStatus );
	void CalculateDoorStatus ( );
	bool ShouldDoorBeClosed ( );
	bool ShouldDoorBeOpened ( );
	void eventUnTouch ( class AActor* Other );
	void eventTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void ClientOnStatusChange ( );
	void PostBeginPlay ( );
	void eventReplicatedEvent ( struct FName VarName );
	void LoadMesh ( );
};

UClass* ATgDoorMarker::pClassPointer = NULL;

// Class TgGame.TgNavigationPoint
// 0x0004 (0x02B4 - 0x02B0)
class ATgNavigationPoint : public ANavigationPoint
{
public:
	int                                                m_nMapObjectId;                                   		// 0x02B0 (0x0004) [0x0000000000020001]              ( CPF_Edit | CPF_EditConst )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2730 );

		return pClassPointer;
	};

};

UClass* ATgNavigationPoint::pClassPointer = NULL;

// Class TgGame.TgActionPoint
// 0x0008 (0x02BC - 0x02B4)
class ATgActionPoint : public ATgNavigationPoint
{
public:
	unsigned char                                      ActionType;                                       		// 0x02B4 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      nObjectiveNum;                                    		// 0x02B5 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      nTaskForce;                                       		// 0x02B6 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      bUseRotation : 1;                                 		// 0x02B8 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2731 );

		return pClassPointer;
	};

};

UClass* ATgActionPoint::pClassPointer = NULL;

// Class TgGame.TgCoverPoint
// 0x002C (0x02E0 - 0x02B4)
class ATgCoverPoint : public ATgNavigationPoint
{
public:
	unsigned long                                      m_bLeanLeft : 1;                                  		// 0x02B4 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_bLeanRight : 1;                                 		// 0x02B4 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_bAllowPopup : 1;                                		// 0x02B4 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      m_bAllowMantle : 1;                               		// 0x02B4 (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )
	struct FVector                                     m_vLeanLeft;                                      		// 0x02B8 (0x000C) [0x0000000000000000]              
	struct FVector                                     m_vLeanRight;                                     		// 0x02C4 (0x000C) [0x0000000000000000]              
	struct FVector                                     m_vPopUp;                                         		// 0x02D0 (0x000C) [0x0000000000000000]              
	class APawn*                                       m_pClaimedBy;                                     		// 0x02DC (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2732 );

		return pClassPointer;
	};

	void PostBeginPlay ( );
	void Claim ( class APawn* pClaimedBy );
	class APawn* GetClaimedBy ( );
};

UClass* ATgCoverPoint::pClassPointer = NULL;

// Class TgGame.TgNavigationPointSpawnable
// 0x0000 (0x02B4 - 0x02B4)
class ATgNavigationPointSpawnable : public ATgNavigationPoint
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2733 );

		return pClassPointer;
	};

};

UClass* ATgNavigationPointSpawnable::pClassPointer = NULL;

// Class TgGame.TgPointOfInterest
// 0x0010 (0x02C4 - 0x02B4)
class ATgPointOfInterest : public ATgNavigationPoint
{
public:
	int                                                m_nNameMsgId;                                     		// 0x02B4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FString                                     m_sDebugName;                                     		// 0x02B8 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2734 );

		return pClassPointer;
	};

};

UClass* ATgPointOfInterest::pClassPointer = NULL;

// Class TgGame.TgNavMeshPath_AlongLane
// 0x0004 (0x0054 - 0x0050)
class UTgNavMeshPath_AlongLane : public UNavMeshPathConstraint
{
public:
	int                                                m_nLane;                                          		// 0x0050 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2735 );

		return pClassPointer;
	};

	void Recycle ( );
	bool AlongLane ( class UNavigationHandle* NavHandle, int nLane );
};

UClass* UTgNavMeshPath_AlongLane::pClassPointer = NULL;

// Class TgGame.TgPathfinder
// 0x0034 (0x0224 - 0x01F0)
class ATgPathfinder : public AActor
{
public:
	struct FPointer                                    VfTable_IInterface_NavigationHandle;              		// 0x01F0 (0x0004) [0x0000000000801002]              ( CPF_Const | CPF_Native | CPF_NoExport )
	float                                              m_fMaxSpeed;                                      		// 0x01F4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	TArray< struct FVector >                           m_vWaypoints;                                     		// 0x01F8 (0x000C) [0x0000000000500000]              ( CPF_NeedCtorLink )
	float                                              m_fPathCheckRadius;                               		// 0x0204 (0x0004) [0x0000000000000000]              
	class UNavigationHandle*                           m_NavigationHandle;                               		// 0x0208 (0x0004) [0x0000000000000000]              
	class ASplineActor*                                m_Spline;                                         		// 0x020C (0x0004) [0x0000000000000000]              
	class ASplineActor*                                m_CurrentSpline;                                  		// 0x0210 (0x0004) [0x0000000000000000]              
	float                                              m_fCurrentSplineDist;                             		// 0x0214 (0x0004) [0x0000000000000000]              
	struct FScriptDelegate                             __OnFinishedPathing__Delegate;                    		// 0x0218 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2736 );

		return pClassPointer;
	};

	void eventDestroyed ( );
	void eventNotifyPathChanged ( );
	void eventFindNavHandlePath ( class AActor* destActor, float Dist );
	void SetupPathProperties ( float PathCheckRadius, float PathSpeed );
	void eventPostBeginPlay ( );
	bool SetRouteTo ( class AActor* destActor, unsigned long bDrawDebugPath );
	void OnFinishedPathing ( );
};

UClass* ATgPathfinder::pClassPointer = NULL;

// Class TgGame.TgSkeletalMeshActor
// 0x0034 (0x0268 - 0x0234)
class ATgSkeletalMeshActor : public ASkeletalMeshActor
{
public:
	struct FMeshAssets                                 c_MeshAssets;                                     		// 0x0234 (0x0030) [0x0000000000400000]              ( CPF_NeedCtorLink )
	unsigned long                                      c_bLoadMeshAssetts : 1;                           		// 0x0264 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2737 );

		return pClassPointer;
	};

	void DoKismetAttachment ( class AActor* Attachment, class USeqAct_AttachToActor* Action );
	void OnParentAnimComponent ( class UTgSeqAct_ParentAnimComponent* Action );
	void LoadClientOnlyMeshAssets ( );
	class UMeshComponent* CreateMeshComponent ( int MeshAsmId, class UMeshComponent* DestComponent, unsigned long bPartialFixup );
	class UTgStaticMeshComponent* CreateStaticMeshComponent ( int MeshAsmId, class UTgStaticMeshComponent* DestComponent );
	class UTgSkeletalMeshComponent* CreateSkeletalMeshComponent ( int MeshAsmId, class UTgSkeletalMeshComponent* DestComponent, unsigned long bPartialFixup );
	bool AttachToSocket ( class AActor* Attachment, struct FName BoneName );
};

UClass* ATgSkeletalMeshActor::pClassPointer = NULL;

// Class TgGame.TgSkeletalMeshActorSpawnable
// 0x0000 (0x0268 - 0x0268)
class ATgSkeletalMeshActorSpawnable : public ATgSkeletalMeshActor
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2738 );

		return pClassPointer;
	};

};

UClass* ATgSkeletalMeshActorSpawnable::pClassPointer = NULL;

// Class TgGame.TgNavRouteIndicator
// 0x0034 (0x029C - 0x0268)
class ATgNavRouteIndicator : public ATgSkeletalMeshActorSpawnable
{
public:
	struct FPointer                                    VfTable_IInterface_NavigationHandle;              		// 0x0268 (0x0004) [0x0000000000801002]              ( CPF_Const | CPF_Native | CPF_NoExport )
	TArray< struct FVector >                           WayPoints;                                        		// 0x026C (0x000C) [0x0000000000500000]              ( CPF_NeedCtorLink )
	int                                                Position;                                         		// 0x0278 (0x0004) [0x0000000000000000]              
	float                                              m_fPositionStartTime;                             		// 0x027C (0x0004) [0x0000000000000000]              
	float                                              m_fPositionMaxSeekTime;                           		// 0x0280 (0x0004) [0x0000000000000000]              
	float                                              m_fSpinUpTime;                                    		// 0x0284 (0x0004) [0x0000000000000000]              
	float                                              m_fSpinDownTime;                                  		// 0x0288 (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                m_SpinUpFx;                                       		// 0x028C (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                m_PathingFx;                                      		// 0x0290 (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                m_SpinDownFx;                                     		// 0x0294 (0x0004) [0x0000000000000000]              
	class UNavigationHandle*                           NavigationHandle;                                 		// 0x0298 (0x0004) [0x0000000004000000]              ( CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2739 );

		return pClassPointer;
	};

	void eventNotifyPathChanged ( );
	float GetMaxSpeed ( );
	void StartNextPath ( );
	void StartSeeking ( );
	void eventFindNavHandlePath ( class AActor* destActor, float Dist );
	unsigned char SetRouteTo ( class AActor* destActor );
	void Destroyed ( );
	void eventPostBeginPlay ( );
	void UpdateRotation ( float fDeltaSeconds );
	bool AdvanceWayPoint ( );
	struct FVector GetCurrentWayPoint ( );
	unsigned char SetRoute ( class AActor* destActor );
	void DeactivatePathingFx ( );
	void DeactivateFx ( );
	void ActivatePathingFx ( );
	void ActivateSpinDownFx ( );
	void ActivateSpinUpFx ( );
};

UClass* ATgNavRouteIndicator::pClassPointer = NULL;

// Class TgGame.TgStartPoint
// 0x002C (0x02EC - 0x02C0)
class ATgStartPoint : public APlayerStart
{
public:
	int                                                m_nMapObjectId;                                   		// 0x02C0 (0x0004) [0x0000000000020001]              ( CPF_Edit | CPF_EditConst )
	int                                                m_nStartGroup;                                    		// 0x02C4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_nReturnMapType;                                 		// 0x02C8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fStartRating;                                   		// 0x02CC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fCurrentRating;                                 		// 0x02D0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fResetRating;                                   		// 0x02D4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fDecreaseRate;                                  		// 0x02D8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	TArray< class UClass* >                            m_ArrayOfFloats;                                  		// 0x02DC (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	class ATgTeleporter*                               m_TgTeleporter;                                   		// 0x02E8 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2740 );

		return pClassPointer;
	};

	int GetStartGroupNumber ( );
	void AdjustRating ( );
	float GetRating ( class AController* Player );
	void PreBeginPlay ( );
	void LoadObjectConfig ( );
};

UClass* ATgStartPoint::pClassPointer = NULL;

// Class TgGame.TgTeamPlayerStart
// 0x0014 (0x0300 - 0x02EC)
class ATgTeamPlayerStart : public ATgStartPoint
{
public:
	unsigned char                                      m_nTaskForce;                                     		// 0x02EC (0x0001) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_nPriority;                                      		// 0x02F0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                nPrevPriority;                                    		// 0x02F4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_nTeamIndex;                                     		// 0x02F8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_nMinLevel;                                      		// 0x02FC (0x0004) [0x0000000000020000]              ( CPF_EditConst )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2741 );

		return pClassPointer;
	};

	float GetRating ( class AController* Player );
	void LoadObjectConfig ( );
};

UClass* ATgTeamPlayerStart::pClassPointer = NULL;

// Class TgGame.TgTeleporter
// 0x000E (0x02E6 - 0x02D8)
class ATgTeleporter : public ATeleporter
{
public:
	int                                                m_nMapObjectId;                                   		// 0x02D8 (0x0004) [0x0000000000020001]              ( CPF_Edit | CPF_EditConst )
	int                                                m_nMapId;                                         		// 0x02DC (0x0004) [0x0000000000020001]              ( CPF_Edit | CPF_EditConst )
	unsigned long                                      m_nPreload : 1;                                   		// 0x02E0 (0x0004) [0x0000000000020001] [0x00000001] ( CPF_Edit | CPF_EditConst )
	unsigned long                                      m_bSetTaskForce : 1;                              		// 0x02E0 (0x0004) [0x0000000000020001] [0x00000002] ( CPF_Edit | CPF_EditConst )
	unsigned long                                      m_bBalanceTaskForce : 1;                          		// 0x02E0 (0x0004) [0x0000000000020001] [0x00000004] ( CPF_Edit | CPF_EditConst )
	unsigned long                                      m_bIgnoreNonMembers : 1;                          		// 0x02E0 (0x0004) [0x0000000000020001] [0x00000008] ( CPF_Edit | CPF_EditConst )
	unsigned long                                      m_bUsePlayerStart : 1;                            		// 0x02E0 (0x0004) [0x0000000000020001] [0x00000010] ( CPF_Edit | CPF_EditConst )
	unsigned long                                      m_bRequestMission : 1;                            		// 0x02E0 (0x0004) [0x0000000000020001] [0x00000020] ( CPF_Edit | CPF_EditConst )
	unsigned char                                      m_nStartGroup;                                    		// 0x02E4 (0x0001) [0x0000000000020001]              ( CPF_Edit | CPF_EditConst )
	unsigned char                                      m_nTaskForce;                                     		// 0x02E5 (0x0001) [0x0000000000020001]              ( CPF_Edit | CPF_EditConst )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2742 );

		return pClassPointer;
	};

	bool eventUsePlayerStart ( class AActor* Other );
	void PostTouch ( class AActor* Other );
	void PostBeginPlay ( );
	void PreBeginPlay ( );
	void LoadObjectConfig ( );
	bool HandlePostTouch ( class AActor* Other );
};

UClass* ATgTeleporter::pClassPointer = NULL;

// Class TgGame.TgFadingStaticMeshActor
// 0x0018 (0x0214 - 0x01FC)
class ATgFadingStaticMeshActor : public AStaticMeshActor
{
public:
	unsigned long                                      m_bFaded : 1;                                     		// 0x01FC (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	unsigned long                                      bShowFadedInEditor : 1;                           		// 0x01FC (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	float                                              m_fFadeProgress;                                  		// 0x0200 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              FadeOutTime;                                      		// 0x0204 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	float                                              FadeInTime;                                       		// 0x0208 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	class UMaterialInterface*                          FadingMaterial;                                   		// 0x020C (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	class UStaticMeshComponent*                        m_FadingStaticMeshComponent;                      		// 0x0210 (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2743 );

		return pClassPointer;
	};

	void SetFading ( unsigned long bShouldBeFaded, unsigned long bImmediate );
	void UpdateFadeStatus ( float DeltaTime );
};

UClass* ATgFadingStaticMeshActor::pClassPointer = NULL;

// Class TgGame.TgPawn
// 0x16A4 (0x1B28 - 0x0484)
class ATgPawn : public AGamePawn
{
public:
	int                                                r_nMovementState;                                 		// 0x0484 (0x0004) [0x0000000000000020]              ( CPF_Net )
	struct FVector                                     r_vPhysTweenTarget;                               		// 0x0488 (0x000C) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      r_eTweenState;                                    		// 0x0494 (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      m_eLocalTweenState;                               		// 0x0495 (0x0001) [0x0000000000000000]              
	unsigned char                                      r_LevitationType;                                 		// 0x0496 (0x0001) [0x0000000000002020]              ( CPF_Net | CPF_Transient )
	unsigned char                                      s_BitPackedHitReaction;                           		// 0x0497 (0x0001) [0x0000000000000000]              
	unsigned char                                      r_eGrabState;                                     		// 0x0498 (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      m_eLocalGrabState;                                		// 0x0499 (0x0001) [0x0000000000000000]              
	unsigned char                                      r_eChargeState;                                   		// 0x049A (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      m_nBlockingBitCounter[ 0x8 ];                     		// 0x049B (0x0008) [0x0000000000000000]              
	unsigned char                                      r_bIgnoreBlockingFlags;                           		// 0x04A3 (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      s_eCollisionTransition;                           		// 0x04A4 (0x0001) [0x0000000000000000]              
	unsigned char                                      r_nSkinLevel;                                     		// 0x04A5 (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      c_SkinLevelMechanic;                              		// 0x04A6 (0x0001) [0x0000000000000000]              
	unsigned char                                      r_eDeathReason;                                   		// 0x04A7 (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      r_eDesiredInHand;                                 		// 0x04A8 (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      m_eEquippedInHand;                                		// 0x04A9 (0x0001) [0x0000000000000000]              
	unsigned char                                      c_GroundTargetPreviewStyle;                       		// 0x04AA (0x0001) [0x0000000000000000]              
	unsigned char                                      c_GroundTargetRulerStyle;                         		// 0x04AB (0x0001) [0x0000000000000000]              
	unsigned char                                      m_byFlashNextUpValue;                             		// 0x04AC (0x0001) [0x0000000000000000]              
	unsigned char                                      r_eIsStealthed;                                   		// 0x04AD (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      m_ePosture;                                       		// 0x04AE (0x0001) [0x0000000000000000]              
	unsigned char                                      m_byPushbackCompletedCounter;                     		// 0x04AF (0x0001) [0x0000000000000000]              
	unsigned char                                      r_eCurrentStunType;                               		// 0x04B0 (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      m_OverlayCurrentType;                             		// 0x04B1 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_HitReactionType;                                		// 0x04B2 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_MegaKillTweenState;                             		// 0x04B3 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_MegaKillDeathReason;                            		// 0x04B4 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_nIsInIntroState;                                		// 0x04B5 (0x0001) [0x0000000000000000]              
	float                                              m_fPhysTweenDist;                                 		// 0x04B8 (0x0004) [0x0000000000000000]              
	float                                              r_fPhysTweenDuration;                             		// 0x04BC (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                m_nPhysTweenPostureId;                            		// 0x04C0 (0x0004) [0x0000000000000000]              
	unsigned long                                      r_bPhysTweenInterrupted : 1;                      		// 0x04C4 (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )
	unsigned long                                      m_InLevitation : 1;                               		// 0x04C4 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      s_bIsKnockedUp : 1;                               		// 0x04C4 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      s_bIsHercSpecialKnockedUp : 1;                    		// 0x04C4 (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      r_bGrabInterrupted : 1;                           		// 0x04C4 (0x0004) [0x0000000000000020] [0x00000010] ( CPF_Net )
	unsigned long                                      m_PreGrabCollideActors : 1;                       		// 0x04C4 (0x0004) [0x0000000000000000] [0x00000020] 
	unsigned long                                      m_PreGrabBlockActors : 1;                         		// 0x04C4 (0x0004) [0x0000000000000000] [0x00000040] 
	unsigned long                                      s_bIsMidStartGrab : 1;                            		// 0x04C4 (0x0004) [0x0000000000000000] [0x00000080] 
	unsigned long                                      r_bChargeIgnoreHumanoidBlocking : 1;              		// 0x04C4 (0x0004) [0x0000000000000020] [0x00000100] ( CPF_Net )
	unsigned long                                      m_bWantsCharge : 1;                               		// 0x04C4 (0x0004) [0x0000000000000000] [0x00000200] 
	unsigned long                                      m_bHasDestroyedMesh : 1;                          		// 0x04C4 (0x0004) [0x0000000000000000] [0x00000400] 
	unsigned long                                      c_bSkinLevelFxPlayed : 1;                         		// 0x04C4 (0x0004) [0x0000000000000000] [0x00000800] 
	unsigned long                                      c_bGlobalEmoteUsed : 1;                           		// 0x04C4 (0x0004) [0x0000000000000000] [0x00001000] 
	unsigned long                                      m_bVXGUsesSupress : 1;                            		// 0x04C4 (0x0004) [0x0000000000000000] [0x00002000] 
	unsigned long                                      m_bAffectedByVortices : 1;                        		// 0x04C4 (0x0004) [0x0000000000000000] [0x00004000] 
	unsigned long                                      s_LoadMeshServerSide : 1;                         		// 0x04C4 (0x0004) [0x0000000000000000] [0x00008000] 
	unsigned long                                      c_bDeviceHiddenDueToFullBodyAnim : 1;             		// 0x04C4 (0x0004) [0x0000000000000000] [0x00010000] 
	unsigned long                                      c_bMeshHiddenDueToDeath : 1;                      		// 0x04C4 (0x0004) [0x0000000000000000] [0x00020000] 
	unsigned long                                      c_bHideMeshFromCameraPenetration : 1;             		// 0x04C4 (0x0004) [0x0000000000000000] [0x00040000] 
	unsigned long                                      c_bMeshHiddenDueToAbility : 1;                    		// 0x04C4 (0x0004) [0x0000000000000000] [0x00080000] 
	unsigned long                                      r_bInGlobalOffhandCooldown : 1;                   		// 0x04C4 (0x0004) [0x0000000000000020] [0x00100000] ( CPF_Net )
	unsigned long                                      bInGlobalOffhandCooldownClient : 1;               		// 0x04C4 (0x0004) [0x0000000000000000] [0x00200000] 
	unsigned long                                      m_bInFireLock : 1;                                		// 0x04C4 (0x0004) [0x0000000000000000] [0x00400000] 
	unsigned long                                      bCanLeavePathNetwork : 1;                         		// 0x04C4 (0x0004) [0x0000000000000000] [0x00800000] 
	unsigned long                                      m_bPreProcessPendingHits : 1;                     		// 0x04C4 (0x0004) [0x0000000000000000] [0x01000000] 
	unsigned long                                      r_bIsVolumeStealthed : 1;                         		// 0x04C4 (0x0004) [0x0000000000000020] [0x02000000] ( CPF_Net )
	unsigned long                                      r_bIsVolumeStealthFading : 1;                     		// 0x04C4 (0x0004) [0x0000000000000020] [0x04000000] ( CPF_Net )
	unsigned long                                      m_bPlayingStealth : 1;                            		// 0x04C4 (0x0004) [0x0000000000000000] [0x08000000] 
	unsigned long                                      m_bPlayingDetected : 1;                           		// 0x04C4 (0x0004) [0x0000000000000000] [0x10000000] 
	unsigned long                                      c_bHiddenDueToStealth : 1;                        		// 0x04C4 (0x0004) [0x0000000000000000] [0x20000000] 
	unsigned long                                      m_bApplyDistanceFade : 1;                         		// 0x04C4 (0x0004) [0x0000000000000000] [0x40000000] 
	unsigned long                                      r_bIsBot : 1;                                     		// 0x04C4 (0x0004) [0x0000000000000020] [0x80000000] ( CPF_Net )
	unsigned long                                      s_bInvisibleToPets : 1;                           		// 0x04C8 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      s_bCanSeePets : 1;                                		// 0x04C8 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      c_bIsFrametestZombie : 1;                         		// 0x04C8 (0x0004) [0x0000000000002000] [0x00000004] ( CPF_Transient )
	unsigned long                                      m_bTargetModifierReached : 1;                     		// 0x04C8 (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      m_bIgnoreSpeedDiminishingReturns : 1;             		// 0x04C8 (0x0004) [0x0000000000000000] [0x00000010] 
	unsigned long                                      r_bIsAnimInStrafeMode : 1;                        		// 0x04C8 (0x0004) [0x0000000000000020] [0x00000020] ( CPF_Net )
	unsigned long                                      m_ReachedTargetSoKillRootMotion : 1;              		// 0x04C8 (0x0004) [0x0000000000000000] [0x00000040] 
	unsigned long                                      s_bCanApplyEffects : 1;                           		// 0x04C8 (0x0004) [0x0000000000000000] [0x00000080] 
	unsigned long                                      m_bInitialized : 1;                               		// 0x04C8 (0x0004) [0x0000000000000000] [0x00000100] 
	unsigned long                                      m_bWantsDeathAim : 1;                             		// 0x04C8 (0x0004) [0x0000000000000000] [0x00000200] 
	unsigned long                                      m_bUseInterrupted : 1;                            		// 0x04C8 (0x0004) [0x0000000000000000] [0x00000400] 
	unsigned long                                      c_bIgnoreInterruption : 1;                        		// 0x04C8 (0x0004) [0x0000000000000000] [0x00000800] 
	unsigned long                                      r_bNoEnergyCost : 1;                              		// 0x04C8 (0x0004) [0x0000000000000020] [0x00001000] ( CPF_Net )
	unsigned long                                      r_bCheatUseNoEnergy : 1;                          		// 0x04C8 (0x0004) [0x0000000000000020] [0x00002000] ( CPF_Net )
	unsigned long                                      m_bCheatNoRecharge : 1;                           		// 0x04C8 (0x0004) [0x0000000000000000] [0x00004000] 
	unsigned long                                      m_bIsInvisibleToAI : 1;                           		// 0x04C8 (0x0004) [0x0000000000000000] [0x00008000] 
	unsigned long                                      m_bIsHittableToAI : 1;                            		// 0x04C8 (0x0004) [0x0000000000000000] [0x00010000] 
	unsigned long                                      r_bInCombatFlag : 1;                              		// 0x04C8 (0x0004) [0x0000000000000020] [0x00020000] ( CPF_Net )
	unsigned long                                      r_bIsAFK : 1;                                     		// 0x04C8 (0x0004) [0x0000000000000020] [0x00040000] ( CPF_Net )
	unsigned long                                      c_bHandIKEnabledFromAnimSet : 1;                  		// 0x04C8 (0x0004) [0x0000000000000000] [0x00080000] 
	unsigned long                                      c_bCanDoTurnInPlaceAnim : 1;                      		// 0x04C8 (0x0004) [0x0000000000000000] [0x00100000] 
	unsigned long                                      c_bIsPlayingTurnAnim : 1;                         		// 0x04C8 (0x0004) [0x0000000000000000] [0x00200000] 
	unsigned long                                      m_bCanBeKnockedBack : 1;                          		// 0x04C8 (0x0004) [0x0000000000000000] [0x00400000] 
	unsigned long                                      m_bCanBePushedBack : 1;                           		// 0x04C8 (0x0004) [0x0000000000000000] [0x00800000] 
	unsigned long                                      m_bCausesPushblock : 1;                           		// 0x04C8 (0x0004) [0x0000000000000000] [0x01000000] 
	unsigned long                                      m_bPushblockAffectsFriendlies : 1;                		// 0x04C8 (0x0004) [0x0000000000000000] [0x02000000] 
	unsigned long                                      m_bPushblockAffectsEnemies : 1;                   		// 0x04C8 (0x0004) [0x0000000000000000] [0x04000000] 
	unsigned long                                      m_bUseSmoothNetReceiveRotation : 1;               		// 0x04C8 (0x0004) [0x0000000000000000] [0x08000000] 
	unsigned long                                      c_bUpdateSkelMeshWhenNotRendered : 1;             		// 0x04C8 (0x0004) [0x0000000000000000] [0x10000000] 
	unsigned long                                      r_bSilenced : 1;                                  		// 0x04C8 (0x0004) [0x0000000000000020] [0x20000000] ( CPF_Net )
	unsigned long                                      r_bDisarmed : 1;                                  		// 0x04C8 (0x0004) [0x0000000000000020] [0x40000000] ( CPF_Net )
	unsigned long                                      r_bCrippled : 1;                                  		// 0x04C8 (0x0004) [0x0000000000000020] [0x80000000] ( CPF_Net )
	unsigned long                                      r_bIsInStasis : 1;                                		// 0x04CC (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )
	unsigned long                                      r_bCanBePulled : 1;                               		// 0x04CC (0x0004) [0x0000000000000020] [0x00000002] ( CPF_Net )
	unsigned long                                      r_bCanBeVortexed : 1;                             		// 0x04CC (0x0004) [0x0000000000000020] [0x00000004] ( CPF_Net )
	unsigned long                                      r_bImmortal : 1;                                  		// 0x04CC (0x0004) [0x0000000000000020] [0x00000008] ( CPF_Net )
	unsigned long                                      r_bCannotUseAutoPortal : 1;                       		// 0x04CC (0x0004) [0x0000000000000020] [0x00000010] ( CPF_Net )
	unsigned long                                      s_bHasCrippleEffect : 1;                          		// 0x04CC (0x0004) [0x0000000000000000] [0x00000020] 
	unsigned long                                      c_bEnemyMatLoaded : 1;                            		// 0x04CC (0x0004) [0x0000000000000000] [0x00000040] 
	unsigned long                                      r_bIsJumping : 1;                                 		// 0x04CC (0x0004) [0x0000000000000020] [0x00000080] ( CPF_Net )
	unsigned long                                      s_bApplyHealthCap : 1;                            		// 0x04CC (0x0004) [0x0000000000000000] [0x00000100] 
	unsigned long                                      r_bIsIntoxicated : 1;                             		// 0x04CC (0x0004) [0x0000000000000020] [0x00000200] ( CPF_Net )
	unsigned long                                      r_bIsSliding : 1;                                 		// 0x04CC (0x0004) [0x0000000000000020] [0x00000400] ( CPF_Net )
	unsigned long                                      c_bServerEndedSlide : 1;                          		// 0x04CC (0x0004) [0x0000000000000000] [0x00000800] 
	unsigned long                                      bHasPlayedDeathAnimation : 1;                     		// 0x04CC (0x0004) [0x0000000000000000] [0x00001000] 
	unsigned long                                      r_bApplyWhiteoutHUDFx : 1;                        		// 0x04CC (0x0004) [0x0000000000000020] [0x00002000] ( CPF_Net )
	unsigned long                                      r_bTeleportIncoming : 1;                          		// 0x04CC (0x0004) [0x0000000000000020] [0x00004000] ( CPF_Net )
	unsigned long                                      c_bHiddenDueToRelevancy : 1;                      		// 0x04CC (0x0004) [0x0000000000002000] [0x00008000] ( CPF_Transient )
	unsigned long                                      m_bForceDeathAnim : 1;                            		// 0x04CC (0x0004) [0x0000000000000000] [0x00010000] 
	unsigned long                                      m_bDestroyOnOwnerDeathFlag : 1;                   		// 0x04CC (0x0004) [0x0000000000000000] [0x00020000] 
	unsigned long                                      r_bNeedPlaySpawnFx : 1;                           		// 0x04CC (0x0004) [0x0000000000000020] [0x00040000] ( CPF_Net )
	unsigned long                                      c_bSpawnFxPlayed : 1;                             		// 0x04CC (0x0004) [0x0000000000000000] [0x00080000] 
	unsigned long                                      c_bTargeted : 1;                                  		// 0x04CC (0x0004) [0x0000000000000000] [0x00100000] 
	unsigned long                                      c_bTargetedLightup : 1;                           		// 0x04CC (0x0004) [0x0000000000000000] [0x00200000] 
	unsigned long                                      c_bShowDecalRing : 1;                             		// 0x04CC (0x0004) [0x0000000000000000] [0x00400000] 
	unsigned long                                      c_bShowTargetedRing : 1;                          		// 0x04CC (0x0004) [0x0000000000000000] [0x00800000] 
	unsigned long                                      c_bTargetedRingActive : 1;                        		// 0x04CC (0x0004) [0x0000000000000000] [0x01000000] 
	unsigned long                                      c_bApplyDropShadow : 1;                           		// 0x04CC (0x0004) [0x0000000000000000] [0x02000000] 
	unsigned long                                      m_bShowNameplate : 1;                             		// 0x04CC (0x0004) [0x0000000000000000] [0x04000000] 
	unsigned long                                      r_bShowAhMuzenCabUltSphere : 1;                   		// 0x04CC (0x0004) [0x0000000000000020] [0x08000000] ( CPF_Net )
	unsigned long                                      r_bHiddenDueToRevive : 1;                         		// 0x04CC (0x0004) [0x0000000000000020] [0x10000000] ( CPF_Net )
	unsigned long                                      r_bInitialIsEnemy : 1;                            		// 0x04CC (0x0004) [0x0000000000000020] [0x20000000] ( CPF_Net )
	unsigned long                                      c_bNeedsAssetLoad : 1;                            		// 0x04CC (0x0004) [0x0000000000000000] [0x40000000] 
	unsigned long                                      r_bDebugShowAIDebug : 1;                          		// 0x04CC (0x0004) [0x0000000000000020] [0x80000000] ( CPF_Net )
	unsigned long                                      m_bDebugShowVisionRange : 1;                      		// 0x04D0 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_SwapToDestroyedMeshOnTick : 1;                  		// 0x04D0 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_bBlockCamera : 1;                               		// 0x04D0 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      m_bOverlaysVisible : 1;                           		// 0x04D0 (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      m_bForceFullOverlayMesh : 1;                      		// 0x04D0 (0x0004) [0x0000000000000000] [0x00000010] 
	unsigned long                                      m_bIgnoreTearOffMomentum : 1;                     		// 0x04D0 (0x0004) [0x0000000000000001] [0x00000020] ( CPF_Edit )
	unsigned long                                      m_bAcceptsHitReactions : 1;                       		// 0x04D0 (0x0004) [0x0000000000000001] [0x00000040] ( CPF_Edit )
	unsigned long                                      m_bIsFadingOut : 1;                               		// 0x04D0 (0x0004) [0x0000000000000000] [0x00000080] 
	unsigned long                                      m_bUseDamageTypeForDeathAnim : 1;                 		// 0x04D0 (0x0004) [0x0000000000000000] [0x00000100] 
	unsigned long                                      r_bDemoCanPurchaseItems : 1;                      		// 0x04D0 (0x0004) [0x0000000000000020] [0x00000200] ( CPF_Net )
	unsigned long                                      s_bHasInteractedWithStore : 1;                    		// 0x04D0 (0x0004) [0x0000000000000000] [0x00000400] 
	unsigned long                                      m_bDoSmoothCorrectionThisTick : 1;                		// 0x04D0 (0x0004) [0x0000000000000000] [0x00000800] 
	unsigned long                                      m_bShouldCommunicateWithBotFactory : 1;           		// 0x04D0 (0x0004) [0x0000000000000002] [0x00001000] ( CPF_Const )
	unsigned long                                      m_bInMegaKill : 1;                                		// 0x04D0 (0x0004) [0x0000000000000000] [0x00002000] 
	unsigned long                                      m_bMegaKillShouldKill : 1;                        		// 0x04D0 (0x0004) [0x0000000000000000] [0x00004000] 
	unsigned long                                      r_bFirstSpawnWave : 1;                            		// 0x04D0 (0x0004) [0x0000000000000020] [0x00008000] ( CPF_Net )
	unsigned long                                      m_bWaitForIntroAnimToEnd : 1;                     		// 0x04D0 (0x0004) [0x0000000000000000] [0x00010000] 
	unsigned long                                      m_bIntroAnimFinished : 1;                         		// 0x04D0 (0x0004) [0x0000000000000000] [0x00020000] 
	unsigned long                                      m_bAllowIntroWhiteOut : 1;                        		// 0x04D0 (0x0004) [0x0000000000000000] [0x00040000] 
	unsigned long                                      m_bIntroWhiteOutActive : 1;                       		// 0x04D0 (0x0004) [0x0000000000000000] [0x00080000] 
	unsigned long                                      m_bTutorialPlayerKillOnly : 1;                    		// 0x04D0 (0x0004) [0x0000000000000000] [0x00100000] 
	unsigned long                                      m_bSpectatorHideOverlayMesh : 1;                  		// 0x04D0 (0x0004) [0x0000000000000000] [0x00200000] 
	class AActor*                                      r_TweenTarget;                                    		// 0x04D4 (0x0004) [0x0000000000000020]              ( CPF_Net )
	struct FVector                                     r_vInitialCircularTweenDir;                       		// 0x04D8 (0x000C) [0x0000000000000000]              
	class ATgPawn*                                     s_KnockUpInitiator;                               		// 0x04E4 (0x0004) [0x0000000000000000]              
	struct FGravityModifierInfo                        r_HercSmashGravityModifier;                       		// 0x04E8 (0x0008) [0x0000000000000020]              ( CPF_Net )
	class ATgPawn*                                     s_DeathCachedKnockupInitiator;                    		// 0x04F0 (0x0004) [0x0000000000000000]              
	class ATgPawn*                                     r_GrabSource;                                     		// 0x04F4 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              r_fGrabDuration;                                  		// 0x04F8 (0x0004) [0x0000000000000020]              ( CPF_Net )
	struct FName                                       r_GrabAttachSocket;                               		// 0x04FC (0x0008) [0x0000000000000020]              ( CPF_Net )
	struct FVector                                     r_vGrabLocationOffset;                            		// 0x0504 (0x000C) [0x0000000000000020]              ( CPF_Net )
	struct FRotator                                    r_rGrabRotationOffset;                            		// 0x0510 (0x000C) [0x0000000000000020]              ( CPF_Net )
	struct FVector                                     m_vGrabDestRelLocation;                           		// 0x051C (0x000C) [0x0000000000000000]              
	struct FRotator                                    m_rGrabDestRelRotation;                           		// 0x0528 (0x000C) [0x0000000000000000]              
	int                                                m_nPhysGrabPostureId;                             		// 0x0534 (0x0004) [0x0000000000000000]              
	TArray< class ATgPawn* >                           s_GrabbedTargets;                                 		// 0x0538 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                r_nCannotBeGrabSource;                            		// 0x0544 (0x0004) [0x0000000000000020]              ( CPF_Net )
	struct FVector                                     m_vLastValidGrabLoc;                              		// 0x0548 (0x000C) [0x0000000000000000]              
	TArray< class AActor* >                            m_TeleportNotifyList;                             		// 0x0554 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	float                                              r_fChargeInitialYaw;                              		// 0x0560 (0x0004) [0x0000000000000020]              ( CPF_Net )
	struct FVector                                     r_vChargeInitialLocation;                         		// 0x0564 (0x000C) [0x0000000000000020]              ( CPF_Net )
	float                                              r_fChargeSpeed;                                   		// 0x0570 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              r_fChargeRange;                                   		// 0x0574 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                m_nBodyMeshAsmId;                                 		// 0x0578 (0x0004) [0x0000000000000000]              
	struct FPointer                                    m_BodyMeshAssembly;                               		// 0x057C (0x0004) [0x0000000000001000]              ( CPF_Native )
	struct FPointer                                    m_DestroyedMeshAssembly;                          		// 0x0580 (0x0004) [0x0000000000001000]              ( CPF_Native )
	int                                                r_nPawnId;                                        		// 0x0584 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              c_fLastUpdateTime;                                		// 0x0588 (0x0004) [0x0000000000000000]              
	class ATgEffectManager*                            r_EffectManager;                                  		// 0x058C (0x0004) [0x0000000000000020]              ( CPF_Net )
	TArray< class UTgProperty* >                       m_Properties;                                     		// 0x0590 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class UTgEffectGroup*                              s_ProcessingDamageEffectGroup;                    		// 0x059C (0x0004) [0x0000000000000000]              
	float                                              r_CurrentPropValues[ 0x5A ];                      		// 0x05A0 (0x0168) [0x0000000000000020]              ( CPF_Net )
	float                                              s_DefaultPropValues[ 0x5A ];                      		// 0x0708 (0x0168) [0x0000000000000000]              
	float                                              r_fCachedMaxHealth;                               		// 0x0870 (0x0004) [0x0000000000000020]              ( CPF_Net )
	TArray< int >                                      m_nAdditionalAttackProperties;                    		// 0x0874 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	float                                              s_fGodKillEmoteTime;                              		// 0x0880 (0x0004) [0x0000000000000000]              
	int                                                r_nProfileId;                                     		// 0x0884 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nSettingsOverrideId;                            		// 0x0888 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                c_nSavedSkinId;                                   		// 0x088C (0x0004) [0x0000000000000000]              
	int                                                c_nSavedSkinLevel;                                		// 0x0890 (0x0004) [0x0000000000000000]              
	int                                                r_nSkinId;                                        		// 0x0894 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nWardSkinId;                                    		// 0x0898 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nRecallSkinId;                                  		// 0x089C (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              m_fSkinLevelDelay;                                		// 0x08A0 (0x0004) [0x0000000000000000]              
	float                                              m_fSkinLevelWindTime;                             		// 0x08A4 (0x0004) [0x0000000000000000]              
	float                                              m_fSkinLevelFxPoint;                              		// 0x08A8 (0x0004) [0x0000000000000000]              
	float                                              c_fSkinLevelDelayProgress;                        		// 0x08AC (0x0004) [0x0000000000000000]              
	struct FName                                       m_SkinLevelMaterialParamName;                     		// 0x08B0 (0x0008) [0x0000000000000000]              
	int                                                c_nSkinLevelUpFxId;                               		// 0x08B8 (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                c_SkinLevelUpFx;                                  		// 0x08BC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FGlobalEmoteInfo                            c_NextGlobalEmoteInfo;                            		// 0x08C0 (0x0008) [0x0000000000000000]              
	struct FGlobalEmoteInfo                            r_GlobalEmoteInfo;                                		// 0x08C8 (0x0008) [0x0000000000000020]              ( CPF_Net )
	class UTgSpecialFx*                                c_GlobalEmoteFx;                                  		// 0x08D0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_fGlobalEmoteSupressTime;                        		// 0x08D4 (0x0004) [0x0000000000000002]              ( CPF_Const )
	float                                              m_fGlobalEmoteNextCastTime;                       		// 0x08D8 (0x0004) [0x0000000000000000]              
	float                                              m_fVXGNextCastTime;                               		// 0x08DC (0x0004) [0x0000000000000000]              
	float                                              m_fVXGSupressTime;                                		// 0x08E0 (0x0004) [0x0000000000000000]              
	int                                                r_nAnnouncerPackId;                               		// 0x08E4 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              s_nSpawnTime;                                     		// 0x08E8 (0x0004) [0x0000000000000000]              
	int                                                r_nPhysicalType;                                  		// 0x08EC (0x0004) [0x0000000000000020]              ( CPF_Net )
	TArray< class ATgCollisionProxy_Vortex* >          m_CurrentVortexList;                              		// 0x08F0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class ATgCollisionProxy_PawnListener* >    CurrentProxyListenerList;                         		// 0x08FC (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< struct FDeployWallPushingInfo >            m_OverlappingDeployableWalls;                     		// 0x0908 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	float                                              m_fOverlappingWallPushoutAccel;                   		// 0x0914 (0x0004) [0x0000000000000000]              
	class UClass*                                      m_DeathDamageType;                                		// 0x0918 (0x0004) [0x0000000000000000]              
	struct FVector                                     m_DeathHitLocation;                               		// 0x091C (0x000C) [0x0000000000000000]              
	struct FEquipDeviceInfo                            r_EquipDeviceInfo[ 0x19 ];                        		// 0x0928 (0x012C) [0x0000000000000020]              ( CPF_Net )
	class ATgDevice*                                   m_EquippedDevices[ 0x19 ];                        		// 0x0A54 (0x0064) [0x0000000000000000]              
	class UTgDeviceForm*                               c_EquipForm[ 0x19 ];                              		// 0x0AB8 (0x0064) [0x0000000000000000]              
	struct FName                                       c_EquipFormState[ 0x19 ];                         		// 0x0B1C (0x00C8) [0x0000000000000000]              
	struct FName                                       c_nmInHandSocket;                                 		// 0x0BE4 (0x0008) [0x0000000000000000]              
	int                                                m_nAttackDamageMode;                              		// 0x0BEC (0x0004) [0x0000000000000002]              ( CPF_Const )
	class ATgDevice*                                   c_CurrentTargetingDevice;                         		// 0x0BF0 (0x0004) [0x0000000000000000]              
	class ATgDevice*                                   c_CurrentStartActionDevice;                       		// 0x0BF4 (0x0004) [0x0000000000000000]              
	float                                              c_fShouldStartActionTimeStamp;                    		// 0x0BF8 (0x0004) [0x0000000000000000]              
	class ATgDevice*                                   m_CurrentInHandDevice;                            		// 0x0BFC (0x0004) [0x0000000000000000]              
	int                                                c_nLockInHandToTargetingDevice;                   		// 0x0C00 (0x0004) [0x0000000000000000]              
	class ATgSkeletalMeshActor*                        c_GroundTargetPreviewActor;                       		// 0x0C04 (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                c_GroundTargetPreviewFX;                          		// 0x0C08 (0x0004) [0x0000000000000000]              
	class ATgSkeletalMeshActor*                        c_GroundTargetRulerActor;                         		// 0x0C0C (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                c_GroundTargetRulerFX;                            		// 0x0C10 (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                c_WorldBracketFX;                                 		// 0x0C14 (0x0004) [0x0000000000000000]              
	class ATgSkeletalMeshActor*                        c_GroundTargetContextNotifyActor;                 		// 0x0C18 (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                c_GroundTargetContextNotifyFX;                    		// 0x0C1C (0x0004) [0x0000000000000000]              
	struct FTG_HUD_INFO                                c_ReticlePreviewEndHudInfo;                       		// 0x0C20 (0x0130) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FTG_HUD_INFO                                c_ReticlePreviewLockHudInfo;                      		// 0x0D50 (0x0130) [0x0000000000400000]              ( CPF_NeedCtorLink )
	float                                              r_fHUDOverlayHeightOverride;                      		// 0x0E80 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgVisibilityVolume*                         r_CurrentVisibilityVolumes[ 0x2 ];                		// 0x0E84 (0x0008) [0x0000000000000020]              ( CPF_Net )
	class ATgDeployable*                               r_VisionRestrictionDeployables[ 0xA ];            		// 0x0E8C (0x0028) [0x0000000000000020]              ( CPF_Net )
	float                                              r_fPetLifetime;                                   		// 0x0EB4 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              c_fPetLifeRemaining;                              		// 0x0EB8 (0x0004) [0x0000000000000000]              
	int                                                r_nFlashQueIndex;                                 		// 0x0EBC (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                c_nFlashPriorEvent[ 0x20 ];                       		// 0x0EC0 (0x0080) [0x0000000000000000]              
	int                                                r_nFlashEvent[ 0x20 ];                            		// 0x0F40 (0x0080) [0x0000000000000020]              ( CPF_Net )
	struct FVector                                     r_vFlashLocation[ 0x20 ];                         		// 0x0FC0 (0x0180) [0x0000000000000020]              ( CPF_Net )
	struct FVector                                     r_vFlashRayDir[ 0x20 ];                           		// 0x1140 (0x0180) [0x0000000000000020]              ( CPF_Net )
	float                                              r_vFlashRefireTime[ 0x20 ];                       		// 0x12C0 (0x0080) [0x0000000000000020]              ( CPF_Net )
	class AActor*                                      r_pFlashTarget[ 0x20 ];                           		// 0x1340 (0x0080) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nFlashFireInfo[ 0x20 ];                         		// 0x13C0 (0x0080) [0x0000000000000020]              ( CPF_Net )
	float                                              s_fTauntAmount;                                   		// 0x1440 (0x0004) [0x0000000000000000]              
	float                                              m_fLastPainSound;                                 		// 0x1444 (0x0004) [0x0000000000000000]              
	class ULightEnvironmentComponent*                  LightEnvironment;                                 		// 0x1448 (0x0004) [0x000000000408000B]              ( CPF_Edit | CPF_Const | CPF_ExportObject | CPF_Component | CPF_EditInline )
	struct FVector                                     FireLocationOffsets[ 0x19 ];                      		// 0x144C (0x012C) [0x0000000000000000]              
	float                                              r_fAttackSpeed;                                   		// 0x1578 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              r_fStealthFadeRate;                               		// 0x157C (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              s_fLastVolumeAttackTime;                          		// 0x1580 (0x0004) [0x0000000000000000]              
	float                                              c_fVolumeFadeValue;                               		// 0x1584 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              c_fDistanceFadeValue;                             		// 0x1588 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              c_fStealthFadeValue;                              		// 0x158C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              c_fCurrentFadeValue;                              		// 0x1590 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              c_fDistanceLastCollidingVisionRange;              		// 0x1594 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              c_fLocalStealthFadeRate;                          		// 0x1598 (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                c_TeleporterEnterFX;                              		// 0x159C (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                c_TeleporterExitFX;                               		// 0x15A0 (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                c_BlinkEnterFX;                                   		// 0x15A4 (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                c_BlinkExitFX;                                    		// 0x15A8 (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                c_TeleportRelicEnterFX;                           		// 0x15AC (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                c_TeleportRelicExitFX;                            		// 0x15B0 (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                c_DetectedFx;                                     		// 0x15B4 (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                c_SiegeTeleportExitFX;                            		// 0x15B8 (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                c_BasicAttackAbsorbFX;                            		// 0x15BC (0x0004) [0x0000000000000000]              
	float                                              m_fLifeAfterDeathSecs;                            		// 0x15C0 (0x0004) [0x0000000000000000]              
	class AActor*                                      r_aDebugTarget;                                   		// 0x15C4 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class AActor*                                      r_aDebugDestination;                              		// 0x15C8 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class AActor*                                      r_aDebugNextNav;                                  		// 0x15CC (0x0004) [0x0000000000000020]              ( CPF_Net )
	struct FVector                                     r_vDebugNextNavMeshPoint;                         		// 0x15D0 (0x000C) [0x0000000000000020]              ( CPF_Net )
	struct FVector                                     r_vDebugSpreadoutLocation;                        		// 0x15DC (0x000C) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nDebugHearingRange;                             		// 0x15E8 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nDebugSightRange;                               		// 0x15EC (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nDebugFOV;                                      		// 0x15F0 (0x0004) [0x0000000000000020]              ( CPF_Net )
	struct FString                                     r_sDebugAction;                                   		// 0x15F4 (0x000C) [0x0000000000400020]              ( CPF_Net | CPF_NeedCtorLink )
	struct FString                                     r_sDebugName;                                     		// 0x1600 (0x000C) [0x0000000000400020]              ( CPF_Net | CPF_NeedCtorLink )
	struct FString                                     r_sDebugFactory;                                  		// 0x160C (0x000C) [0x0000000000400020]              ( CPF_Net | CPF_NeedCtorLink )
	struct FVector                                     s_vOneWayMovement;                                		// 0x1618 (0x000C) [0x0000000000000000]              
	struct FVector                                     r_vDown;                                          		// 0x1624 (0x000C) [0x0000000000000020]              ( CPF_Net )
	float                                              m_fBackpedalPct;                                  		// 0x1630 (0x0004) [0x0000000000000000]              
	float                                              m_fBaseModifier;                                  		// 0x1634 (0x0004) [0x0000000000000000]              
	float                                              m_fTargetModifier;                                		// 0x1638 (0x0004) [0x0000000000000000]              
	float                                              m_fModifierTweenRate;                             		// 0x163C (0x0004) [0x0000000000000000]              
	float                                              r_fDeployRate;                                    		// 0x1640 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class AActor*                                      r_TargetActor;                                    		// 0x1644 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class AActor*                                      r_LockedTarget;                                   		// 0x1648 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                c_TargetMethod;                                   		// 0x164C (0x0004) [0x0000000000000000]              
	class ATgPawn*                                     r_Pet;                                            		// 0x1650 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class AActor*                                      s_LastAttacker;                                   		// 0x1654 (0x0004) [0x0000000000000000]              
	class AActor*                                      s_LastAttacked;                                   		// 0x1658 (0x0004) [0x0000000000000000]              
	class AActor*                                      m_CurrentMeleeTarget;                             		// 0x165C (0x0004) [0x0000000000000000]              
	class ATgPawn*                                     r_Owner;                                          		// 0x1660 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                s_nSpawnerDeviceInstId;                           		// 0x1664 (0x0004) [0x0000000000000000]              
	int                                                s_nSpawnerDeviceModeId;                           		// 0x1668 (0x0004) [0x0000000000000000]              
	int                                                r_nReplicateDying;                                		// 0x166C (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nResetCharacter;                                		// 0x1670 (0x0004) [0x0000000000000020]              ( CPF_Net )
	struct FName                                       DyingStateName;                                   		// 0x1674 (0x0008) [0x0000000000000000]              
	int                                                m_nSpawnLocationId;                               		// 0x167C (0x0004) [0x0000000000000000]              
	int                                                m_nSpawnTableId;                                  		// 0x1680 (0x0004) [0x0000000000000000]              
	int                                                m_nSpawnTableDetailId;                            		// 0x1684 (0x0004) [0x0000000000000000]              
	int                                                r_nReplicateHit;                                  		// 0x1688 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              m_fStandingHeight;                                		// 0x168C (0x0004) [0x0000000000000000]              
	float                                              m_fStandingRadius;                                		// 0x1690 (0x0004) [0x0000000000000000]              
	float                                              m_fTargetCylinderHeight;                          		// 0x1694 (0x0004) [0x0000000000000000]              
	float                                              m_fTargetCylinderRadius;                          		// 0x1698 (0x0004) [0x0000000000000000]              
	int                                                r_nPacingType;                                    		// 0x169C (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              m_CurrentAccuracy;                                		// 0x16A0 (0x0004) [0x0000000000000000]              
	class AActor*                                      m_CurrentUseActor;                                		// 0x16A4 (0x0004) [0x0000000000000000]              
	class ATgDevice*                                   m_ActiveDevice;                                   		// 0x16A8 (0x0004) [0x0000000000000000]              
	float                                              m_fBaseTranslationOffset;                         		// 0x16AC (0x0004) [0x0000000000000000]              
	float                                              m_fCrouchTranslationOffset;                       		// 0x16B0 (0x0004) [0x0000000000000000]              
	float                                              m_fPhaseChangeTime;                               		// 0x16B4 (0x0004) [0x0000000000000000]              
	float                                              m_fPhaseChangedTimeStamp;                         		// 0x16B8 (0x0004) [0x0000000000000000]              
	float                                              m_PhaseChangeRemainingTime;                       		// 0x16BC (0x0004) [0x0000000000000000]              
	int                                                r_nPhase;                                         		// 0x16C0 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                c_PreviousPhase;                                  		// 0x16C4 (0x0004) [0x0000000000000000]              
	TArray< class UTgAnimNodeSimpleTransitioner* >     m_SimpleTransitionerNodes;                        		// 0x16C8 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UTgAnimNodeStanceTransitioner* >     m_StanceTransitionerNodes;                        		// 0x16D4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UTgAnimNodeFitToDuration* >          m_AttackAnimFitToDurationNodes;                   		// 0x16E0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UTgAnimBlendByFire* >                m_FireBlendNodes;                                 		// 0x16EC (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UTgAnimNodeBlendByCombatWariness* >  m_CombatWarinessBlendNodes;                       		// 0x16F8 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UTgAnimBlendByPosture* >             m_PostureBlendNodes;                              		// 0x1704 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UAnimNodeBlendList* >                m_HitOrMissBlendNodes;                            		// 0x1710 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UTgAnimNodeEmoteSwitch* >            m_AnimNodeEmoteSwitches;                          		// 0x171C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UTgAnimBlendByEmote* >               m_EmoteBlendNodes;                                		// 0x1728 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UTgAnimNodeEmoteSequence* >          m_EmoteSequenceNodes;                             		// 0x1734 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UTgAnimNodeBlendByIntroduction* >    m_AnimNodeBlendByIntroductions;                   		// 0x1740 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UTgAnimNodeBlendByHitReaction* >     m_AnimNodeBlendByHitReactions;                    		// 0x174C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UTgAnimBlendByFireMode* >            m_DeviceModeBlendNodes;                           		// 0x1758 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UTgAnimBlendByFall* >                m_FallBlendNodes;                                 		// 0x1764 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UTgAnimBlendByCharge* >              m_ChargeBlendNodes;                               		// 0x1770 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UTgAnimNodeBlendList_Staging_Multi* > m_StagingMultiBlendNodes;                         		// 0x177C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class USkelControlBase* >                  m_SkelControlLocks;                               		// 0x1788 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< struct FName >                             m_SkelControlLockNames;                           		// 0x1794 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class UAnimNodeBlend*                              m_UpperBodyAnimBlendNode;                         		// 0x17A0 (0x0004) [0x0000000000000000]              
	class UAnimNodeSequence*                           m_UpperBodyAnimNodeSequence;                      		// 0x17A4 (0x0004) [0x0000000000000000]              
	class UTgAnimNodeSlot*                             m_FullBodyAnimNode;                               		// 0x17A8 (0x0004) [0x0000000000000000]              
	int                                                m_nYawOffset;                                     		// 0x17AC (0x0004) [0x0000000000002002]              ( CPF_Const | CPF_Transient )
	struct FPostureStack                               m_PostureStack;                                   		// 0x17B0 (0x001C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FName                                       PelvisBoneName;                                   		// 0x17CC (0x0008) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fKnockbackMultiplier;                           		// 0x17D4 (0x0004) [0x0000000000000000]              
	float                                              r_DistanceToPushback;                             		// 0x17D8 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              f_RemainingDistanceToPushback;                    		// 0x17DC (0x0004) [0x0000000000000000]              
	struct FVector                                     r_PushbackDirection;                              		// 0x17E0 (0x000C) [0x0000000000000020]              ( CPF_Net )
	float                                              m_PushbackSpeed;                                  		// 0x17EC (0x0004) [0x0000000000000000]              
	float                                              m_fPushbackMultiplier;                            		// 0x17F0 (0x0004) [0x0000000000000000]              
	class ATgBotFactorySpawnable*                      s_PetBotFactory;                                  		// 0x17F4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	TArray< class ATgNavigationPointSpawnable* >       s_PetLocationList;                                		// 0x17F8 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	float                                              m_fTimeBetweenPetSpawns;                          		// 0x1804 (0x0004) [0x0000000000000000]              
	TArray< struct FName >                             m_DeployPetsSocketNames;                          		// 0x1808 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	float                                              m_ValidPetSpawnPointDistance;                     		// 0x1814 (0x0004) [0x0000000000000000]              
	float                                              m_fRBPushStrengthMultiplier;                      		// 0x1818 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FVector2D                                   m_fRBPushStrengthRange;                           		// 0x181C (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FRotator                                    m_PreviousNetReceiveRotation;                     		// 0x1824 (0x000C) [0x0000000000000000]              
	struct FRotator                                    m_TargetNetReceiveRotation;                       		// 0x1830 (0x000C) [0x0000000000000000]              
	float                                              m_RotationInterpRate;                             		// 0x183C (0x0004) [0x0000000000000000]              
	int                                                m_nNetRotationCount;                              		// 0x1840 (0x0004) [0x0000000000000000]              
	int                                                m_nSmoothedRemoteViewPitch;                       		// 0x1844 (0x0004) [0x0000000000000000]              
	int                                                m_nPreviousReceivedRemoteViewPitch;               		// 0x1848 (0x0004) [0x0000000000000000]              
	int                                                m_nTargetRemoteViewPitch;                         		// 0x184C (0x0004) [0x0000000000000000]              
	float                                              m_PitchInterpRate;                                		// 0x1850 (0x0004) [0x0000000000000000]              
	int                                                m_nNetViewPitchCount;                             		// 0x1854 (0x0004) [0x0000000000000000]              
	float                                              m_fSmoothCorrectionRate;                          		// 0x1858 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FPointer                                    m_pStatsTracker;                                  		// 0x185C (0x0004) [0x0000000000001000]              ( CPF_Native )
	class ATgPawn*                                     s_RevengeTarget;                                  		// 0x1860 (0x0004) [0x0000000000000000]              
	class ATgPawn*                                     m_LastDamager;                                    		// 0x1864 (0x0004) [0x0000000000000000]              
	int                                                m_LastDamagerTimeStamp;                           		// 0x1868 (0x0004) [0x0000000000000000]              
	TArray< struct FPawnDamagerStruct >                s_Damagers;                                       		// 0x186C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                s_nTowerDamageTaken;                              		// 0x1878 (0x0004) [0x0000000000000000]              
	float                                              m_fJumpLandingTime;                               		// 0x187C (0x0004) [0x0000000000000000]              
	class ATgPawn*                                     r_FallingCollideOverridePawn;                     		// 0x1880 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              m_fIntoxicatedStartTime;                          		// 0x1884 (0x0004) [0x0000000000000000]              
	float                                              m_fIntoxicatedDuration;                           		// 0x1888 (0x0004) [0x0000000000000000]              
	float                                              m_fIntoxicatedInterval;                           		// 0x188C (0x0004) [0x0000000000000000]              
	int                                                m_iIntoxicatedOrder;                              		// 0x1890 (0x0004) [0x0000000000000002]              ( CPF_Const )
	int                                                m_iIntoxicatedNumControlPoints;                   		// 0x1894 (0x0004) [0x0000000000000000]              
	TArray< float >                                    m_IntoxicationKnots;                              		// 0x1898 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< struct FVector2D >                         m_IntoxicationRotatorControl;                     		// 0x18A4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FVector2D                                   m_vIntoxicatedMaxRotator;                         		// 0x18B0 (0x0008) [0x0000000000000000]              
	float                                              m_fIntoxicatedStrafeStartDirection;               		// 0x18B8 (0x0004) [0x0000000000000000]              
	TArray< float >                                    m_IntoxicationStrafeChangeTimes;                  		// 0x18BC (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FVector2D                                   m_vIntoxicatedMinMaxStrafeDuration;               		// 0x18C8 (0x0008) [0x0000000000000000]              
	class UMaterialInstanceConstant*                   m_IntoxicatedWineMIC;                             		// 0x18D0 (0x0004) [0x0000000000000000]              
	class AActor*                                      r_StunTauntTarget;                                		// 0x18D4 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                c_WhiteoutHUDFxId;                                		// 0x18D8 (0x0004) [0x0000000000000000]              
	class UMaterialInstanceConstant*                   m_WhiteoutHUDFxMIC;                               		// 0x18DC (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                c_TeleportIncomingFx;                             		// 0x18E0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                s_nTeleportsIncoming;                             		// 0x18E4 (0x0004) [0x0000000000000000]              
	float                                              s_fMaxRelevancyDistanceSquared;                   		// 0x18E8 (0x0004) [0x0000000000000000]              
	float                                              m_fLastCameraValueTimeStamp;                      		// 0x18EC (0x0004) [0x0000000000000000]              
	struct FRotator                                    m_CachedBaseAimRotation;                          		// 0x18F0 (0x000C) [0x0000000000000000]              
	float                                              m_fLastBaseAimRotationTimeStamp;                  		// 0x18FC (0x0004) [0x0000000000000000]              
	float                                              m_fPushBlockPressure;                             		// 0x1900 (0x0004) [0x0000000000000000]              
	float                                              m_fSlowVelSizeSquard;                             		// 0x1904 (0x0004) [0x0000000000000000]              
	float                                              m_fPushBlockVelMultiplier;                        		// 0x1908 (0x0004) [0x0000000000000000]              
	struct FLinearColor                                c_LastRimColor;                                   		// 0x190C (0x0010) [0x0000000000000000]              
	class UTgDropShadowDecalComponent*                 c_PlayerCircle;                                   		// 0x191C (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class UMaterialInstanceConstant*                   c_PlayerCircleMIC;                                		// 0x1920 (0x0004) [0x0000000000000000]              
	class UMaterial*                                   c_CircleTemplate;                                 		// 0x1924 (0x0004) [0x0000000000000000]              
	class UMaterial*                                   c_CircleTemplateSpectator;                        		// 0x1928 (0x0004) [0x0000000000000000]              
	class UTgDropShadowDecalComponent*                 c_PlayerDropShadow;                               		// 0x192C (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class UMaterial*                                   c_PlayerDropShadowTemplate;                       		// 0x1930 (0x0004) [0x0000000000000000]              
	class UMaterialInstanceConstant*                   c_PlayerDropShadowMIC;                            		// 0x1934 (0x0004) [0x0000000000000000]              
	float                                              c_fPlayerDropShadowFade;                          		// 0x1938 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FName                                       c_PlayerDropShadowSocketName;                     		// 0x193C (0x0008) [0x0000000000000000]              
	class ATgAttachPoint*                              c_GroundAttachPoint;                              		// 0x1944 (0x0004) [0x0000000000000000]              
	float                                              m_fLastGroundZ;                                   		// 0x1948 (0x0004) [0x0000000000000000]              
	float                                              m_fFaceRotationInterpTime;                        		// 0x194C (0x0004) [0x0000000000000000]              
	float                                              m_fRemainingFaceRotationInterpTime;               		// 0x1950 (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                m_AhMuzenCabUltSphereFx;                          		// 0x1954 (0x0004) [0x0000000000000000]              
	int                                                r_nBigTeleportCount;                              		// 0x1958 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                c_nTickCheckingState;                             		// 0x195C (0x0004) [0x0000000000000000]              
	class UTgManifestGroup*                            c_AssetManifestGroup;                             		// 0x1960 (0x0004) [0x0000000004400008]              ( CPF_ExportObject | CPF_NeedCtorLink | CPF_EditInline )
	class UTgSpecialFx*                                c_LevelUpFX;                                      		// 0x1964 (0x0004) [0x0000000000000000]              
	int                                                c_nLevelUpFxId;                                   		// 0x1968 (0x0004) [0x0000000000000000]              
	int                                                s_nKillCombo;                                     		// 0x196C (0x0004) [0x0000000000000000]              
	int                                                s_nKillStreak;                                    		// 0x1970 (0x0004) [0x0000000000000000]              
	struct FPointer                                    m_pAmBot;                                         		// 0x1974 (0x0004) [0x0000000000001002]              ( CPF_Const | CPF_Native )
	struct FPointer                                    m_pAmSettingsBot;                                 		// 0x1978 (0x0004) [0x0000000000001002]              ( CPF_Const | CPF_Native )
	struct FPointer                                    m_pAmSkin;                                        		// 0x197C (0x0004) [0x0000000000001002]              ( CPF_Const | CPF_Native )
	int                                                c_StunnedPostureID;                               		// 0x1980 (0x0004) [0x0000000000000000]              
	int                                                c_PanickedOrFearedPostureID;                      		// 0x1984 (0x0004) [0x0000000000000000]              
	TArray< class APlayerController* >                 s_Viewers;                                        		// 0x1988 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class ATgCarriedFlag*                              m_CurrentFlag;                                    		// 0x1994 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_fLastCTFVolumeTimestamp;                        		// 0x1998 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	TArray< struct FOverlayInfo >                      m_OverlayInfos;                                   		// 0x199C (0x000C) [0x0000000000480001]              ( CPF_Edit | CPF_Component | CPF_NeedCtorLink )
	class UMaterialInstanceConstant*                   m_OverlayMaterial;                                		// 0x19A8 (0x0004) [0x0000000000000002]              ( CPF_Const )
	class UMaterialInstanceConstant*                   m_OutlineOverlayMaterial;                         		// 0x19AC (0x0004) [0x0000000000000002]              ( CPF_Const )
	class UMaterialInstanceConstant*                   m_FadeOverlayMaterial;                            		// 0x19B0 (0x0004) [0x0000000000000002]              ( CPF_Const )
	class UMaterialInstanceConstant*                   m_AthenaTargetOverlayMaterial;                    		// 0x19B4 (0x0004) [0x0000000000000002]              ( CPF_Const )
	class UMaterialInstanceConstant*                   m_HitPulseOverlayMaterial;                        		// 0x19B8 (0x0004) [0x0000000000000002]              ( CPF_Const )
	class UMaterialInstanceConstant*                   m_ThanatosHarvesterMaterial;                      		// 0x19BC (0x0004) [0x0000000000000002]              ( CPF_Const )
	class UClass*                                      m_SilhouetteOverlayClass;                         		// 0x19C0 (0x0004) [0x0000000000000002]              ( CPF_Const )
	TArray< int >                                      m_IgnoredHitPulseIndicies;                        		// 0x19C4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	float                                              m_fFinalBlowAdditionalZ;                          		// 0x19D0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fFinalBlowMomentumMultiplier;                   		// 0x19D4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fHitReactionTweenDistancePct;                   		// 0x19D8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fHitReactionAIPauseTime;                        		// 0x19DC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fHitReactionBlendOutTime;                       		// 0x19E0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fHitReactionTweenTime;                          		// 0x19E4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fFadeOutTime;                                   		// 0x19E8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fFadeOutSpeed;                                  		// 0x19EC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UTgSpecialFx*                                m_DeathAnimFX;                                    		// 0x19F0 (0x0004) [0x0000000000000000]              
	float                                              m_fBasicAttackHitReactionDistance;                		// 0x19F4 (0x0004) [0x0000000000000000]              
	TArray< class UTgSkelCon_HitReaction* >            m_HitReactionSkelControls;                        		// 0x19F8 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	float                                              m_fRemainingHitReactionPulseTime;                 		// 0x1A04 (0x0004) [0x0000000000000000]              
	float                                              m_fHitReactionPulseTime;                          		// 0x1A08 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fDisorientSpinRate;                             		// 0x1A0C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fMaxSmoothNetUpdateDist;                        		// 0x1A10 (0x0004) [0x0000000000000000]              
	float                                              m_fNoSmoothNetUpdateDist;                         		// 0x1A14 (0x0004) [0x0000000000000000]              
	float                                              m_fSmoothNetUpdateTime;                           		// 0x1A18 (0x0004) [0x0000000000000000]              
	struct FVector                                     m_vMeshTranslationOffset;                         		// 0x1A1C (0x000C) [0x0000000000000000]              
	TArray< class UPrimitiveComponent* >               m_SmoothableComponents;                           		// 0x1A28 (0x000C) [0x0000000004480008]              ( CPF_ExportObject | CPF_Component | CPF_NeedCtorLink | CPF_EditInline )
	float                                              m_fInitialHealthPercent;                          		// 0x1A34 (0x0004) [0x0000000000000000]              
	float                                              m_fDamageDealtPercent;                            		// 0x1A38 (0x0004) [0x0000000000000000]              
	float                                              m_fDamageTakenPercent;                            		// 0x1A3C (0x0004) [0x0000000000000000]              
	TArray< struct FHealingInfo >                      m_RecentHealList;                                 		// 0x1A40 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	float                                              m_fRecentHealExpireTime;                          		// 0x1A4C (0x0004) [0x0000000000000002]              ( CPF_Const )
	int                                                m_nCloneExpirationAttacksCount;                   		// 0x1A50 (0x0004) [0x0000000000000000]              
	float                                              m_fCloneLeashRange;                               		// 0x1A54 (0x0004) [0x0000000000000000]              
	float                                              m_fCloneExpirationTime;                           		// 0x1A58 (0x0004) [0x0000000000000000]              
	class ATgRepInfo_Player*                           r_CloneParentPRI;                                 		// 0x1A5C (0x0004) [0x0000000000000020]              ( CPF_Net )
	struct FFloorPortalTweenInfo                       r_FloorPortalTween;                               		// 0x1A60 (0x0014) [0x0000000000000020]              ( CPF_Net )
	TArray< struct FName >                             c_PostRecallParticleKillExceptions;               		// 0x1A74 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	TArray< class UAudioComponent* >                   c_RecallAudios;                                   		// 0x1A80 (0x000C) [0x0000000004482008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_NeedCtorLink | CPF_EditInline )
	TArray< class UAudioComponent* >                   c_ManagedAudios;                                  		// 0x1A8C (0x000C) [0x0000000004482008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_NeedCtorLink | CPF_EditInline )
	TArray< class UParticleSystemComponent* >          c_ManagedPSCs;                                    		// 0x1A98 (0x000C) [0x0000000004482008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_NeedCtorLink | CPF_EditInline )
	class ATgRepInfo_Factory*                          r_FactoryInfo;                                    		// 0x1AA4 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgRepInfo_Factory*                          m_LocalFactoryInfo;                               		// 0x1AA8 (0x0004) [0x0000000000000000]              
	class AActor*                                      m_MegaKillInstigator;                             		// 0x1AAC (0x0004) [0x0000000000000000]              
	class UTgDeviceFire*                               m_MegaKillDeviceMode;                             		// 0x1AB0 (0x0004) [0x0000000000000000]              
	class UTgEffectGroup*                              m_MegaKillStunProperty;                           		// 0x1AB4 (0x0004) [0x0000000000000000]              
	class UTgEffectGroup*                              m_MegaKillDamageImmunity;                         		// 0x1AB8 (0x0004) [0x0000000000000000]              
	float                                              m_fMegaKillTweenDelay;                            		// 0x1ABC (0x0004) [0x0000000000000000]              
	struct FVector                                     m_vMegaKillTweenLocation;                         		// 0x1AC0 (0x000C) [0x0000000000000000]              
	float                                              m_fMegaKillMinDamage;                             		// 0x1ACC (0x0004) [0x0000000000000000]              
	int                                                m_IntroPostureID;                                 		// 0x1AD0 (0x0004) [0x0000000000000000]              
	float                                              r_fIntroTime;                                     		// 0x1AD4 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              r_fIntroOffset;                                   		// 0x1AD8 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              s_fIntroStartTime;                                		// 0x1ADC (0x0004) [0x0000000000000000]              
	float                                              m_fIntroProgress;                                 		// 0x1AE0 (0x0004) [0x0000000000000000]              
	struct FName                                       r_ReplicatedState;                                		// 0x1AE4 (0x0008) [0x0000000000000020]              ( CPF_Net )
	TArray< class UAnimNodeSequence* >                 m_RespawnNodes;                                   		// 0x1AEC (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UTgAnimBlendByBuffMonsterIntro* >    m_BuffCampIntroNodes;                             		// 0x1AF8 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FName                                       m_IntialIntroState;                               		// 0x1B04 (0x0008) [0x0000000000000000]              
	struct FName                                       m_nmIntroWhiteOutParamName;                       		// 0x1B0C (0x0008) [0x0000000000000000]              
	float                                              m_fIntroWhiteOutScale;                            		// 0x1B14 (0x0004) [0x0000000000000000]              
	float                                              m_fIntroWhiteOutUpTime;                           		// 0x1B18 (0x0004) [0x0000000000000000]              
	float                                              m_fIntroWhiteOutDownTime;                         		// 0x1B1C (0x0004) [0x0000000000000000]              
	class ATgObjectiveVolume*                          c_ObjectiveVolume;                                		// 0x1B20 (0x0004) [0x0000000000000000]              
	int                                                s_nOriginalQueueId;                               		// 0x1B24 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2744 );

		return pClassPointer;
	};

	void eventFinishedIntroAnim ( class UAnimNode* IntroAnimNode );
	void ExitIntroPosture ( unsigned long bForceAnimTreeOut );
	void EnterIntroPosture ( );
	void SetupIntroAnimNodesAndTimers ( );
	void eventDoIntroduction ( unsigned long bUseInitialIntro );
	bool eventIsPlayingIntro ( );
	void BeginWhiteOutScaleUp ( );
	void SetWhiteOutStartTimer ( );
	void IntroTimer ( );
	void EndWhiteOut ( );
	void UpdateWhiteOut ( );
	bool StopFiring ( );
	void RemoveAttachedBuffCampDevice ( );
	void eventSetCustomLightingChannels ( );
	void eventSetFactoryInfo ( class ATgRepInfo_Factory* FactoryInfo );
	void eventSetMeshHiddenDueToAbility ( unsigned long bMeshHiddenDueToAbility );
	void eventSetHiddenInDeath ( unsigned long bHiddenDueToDeath );
	void ProcessChargeNumber ( unsigned char nChargeNumber );
	unsigned char GetChargeNumber ( );
	bool eventCanApplyShield ( );
	void UpdateTeleportFX ( );
	void RemoveIncomingTeleport ( );
	void AddIncomingTeleport ( );
	bool InputLockedDueToFiring ( );
	bool IsInputLocked ( );
	void eventOnCameraCutAnimNotify ( class UTgAnimNotify_CameraCut* CameraCutNotify );
	void KillCloneTimer ( );
	bool eventCanPlayHitReaction ( );
	void SetMeshDepthPriority ( unsigned char NewDepth );
	void eventShowAhMuzenCabUltSphere ( unsigned long bShow );
	unsigned char OverrideOffhandSlot ( unsigned char eqp );
	void InterruptInhand ( class ATgDevice* InterruptingDevice );
	void OnRightMousePressed ( );
	void OnTargetSpeedModifierReached ( );
	void TickMaxSpeedModifier ( float DeltaSeconds );
	void ClientStartMaxSpeedModifierTween ( float fTweenToStrength, float fTweenTime );
	void eventStartMaxSpeedModifierTween ( float fTweenToStrength, float fTweenTime );
	void eventOnRedirectedDamageOriginUpdated ( struct FVector Origin );
	bool IsInClassSpecificMovement ( );
	bool eventIsInJumpLanding ( );
	bool CannotJumpNow ( );
	void eventClientUpdateAttackSpeed ( float fAttackSpeed );
	void AdjustDevicesForNewDilation ( float fPrevDilation, float fNewDilation );
	void eventTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void eventPostDemoRewind ( );
	void eventPreDemoRewind ( );
	void EmptyRecallAudios ( unsigned long bDoDetach );
	void CleanUpManagedFX ( );
	void ManagedParticleSystemFinished ( class UParticleSystemComponent* PSC );
	bool eventPlayParticleEffect ( class UAnimNotify_PlayParticleEffect* AnimNotifyData );
	bool ShouldManageParticleFX ( class UAnimNotify_PlayParticleEffect* AnimNotifyData );
	void ManagedAudioFinished ( class UAudioComponent* AC );
	void PlaySelfManagedSound ( class USoundCue* Cue, class UAnimNodeSequence* OwningNode, float VolumeMultipler, float PitchMultipler );
	bool eventAnimNotifySound ( class USoundCue* Cue, class UAnimNodeSequence* OwningNode, float VolumeMultipler, float PitchMultipler );
	void eventUpdateLocalGlobalEmoteInfo ( );
	void OnAuthorityPlayGlobalEmote ( );
	bool eventWantsLoopingEmote ( unsigned char Emote );
	void eventClientPlayEmote ( unsigned char Emote, int nExtraInfo );
	void eventPlayEmote ( unsigned char Emote, int nExtraInfo );
	bool CanPlayEmote ( unsigned char Emote, unsigned char* failType );
	struct FString GetVGSCustomSuffix ( int nPreferredVPSetting );
	struct FString GetEmoteCustomSuffix ( unsigned char Emote, int ExtraInfo );
	struct FString GetEmoteSuffix ( unsigned char Emote, int ExtraInfo );
	class USoundCue* GetEmoteSoundCue ( int BotID, unsigned char Emote, int ExtraInfo );
	int GetBotId ( );
	void PostBigTeleport ( );
	void PostTeleport ( class ATeleporter* OutTeleporter );
	bool PreTeleport ( class ATeleporter* InTeleporter );
	void OnTeleportNotify ( class AActor* TeleportingActor );
	void OnTeleportToBaseNotify ( class AActor* TeleportingActor );
	void eventTeleportToBaseNotify ( );
	void eventTeleportNotify ( );
	void eventRemoveFromTeleportNotify ( class AActor* RemoveActor );
	void eventAddToTeleportNotify ( class AActor* ToBeNotified );
	void ServerChangePhase ( int NewPhase );
	void ChangePhase ( int NewPhase );
	void Perf2 ( unsigned long bEnabled );
	void ServerSetPushBlockParam ( float fPushBlockPressure, float fSlowVelSizeSquard, float fVelModifier );
	void SetPushBlockParam ( float fPushBlockPressure, float fSlowVelSizeSquard, float fVelModifier );
	void SetPushBlockParamHelper ( float fPushBlockPressure, float fSlowVelSizeSquard, float fVelModifier );
	void OnPhaseTransitionComplete ( );
	void eventOnPhaseChange ( );
	void eventOnPhaseEnded ( int nPhaseThatEnded );
	void eventBaseChange ( );
	bool CanPickupDroppedItem ( );
	bool IsValidMeleeTarget ( class ATgPawn* ProspectiveMeleeTarget );
	void eventSaveDeathInfoForZoomCam ( class ATgPawn* KillerOwner, class ATgPawn* Killer, int DeviceID, unsigned long bPetKill );
	void eventUpdateCooldownsOnDevices ( );
	void eventStun ( unsigned long bStunController, unsigned char eType );
	bool CanFireDeviceWhenInvulnerable ( class ATgDevice* Dev );
	bool CanFireDeviceInStasis ( class ATgDevice* Dev );
	bool eventIsPet ( );
	void eventTeleport ( struct FVector vDest, struct FRotator rDest, unsigned long bPlayFx, int TeleportEnterState, int TeleportExitState, unsigned long bMaintainControllerPitch );
	bool TeleportTraceCheck ( struct FVector vTestLoc, struct FVector vDestLoc );
	void KillPets ( );
	class ATgPawn* GetCurrentOwnerPawn ( );
	bool WasPlayerSpawned ( );
	bool eventIsTargetWithInCone ( class AActor* Target );
	void UpdateContextNotifyGroundTargetPreviewer ( int TargeterContextId );
	void AddTargetingAidHudInfos ( class ATgPlayerController* PC, struct FVector* CamLoc, struct FVector* CamRot );
	void UpdateTargetingAidReticle ( unsigned char reticleStyle, unsigned char highlightStyle );
	void UpdateTargetingAidGroundTarget ( unsigned char targetStyle );
	void UpdateTargetingAidLine ( unsigned char lineStyle );
	void UpdateTargetingAid ( );
	bool IsCinematicMode ( );
	void SelectDeathDevices ( );
	void eventTickTargeting ( float DeltaSeconds );
	void Tick ( float DeltaSeconds );
	void DoubleCheckSimulatedProxy ( );
	void TickFriendlyPush ( );
	bool eventShouldRecharge ( );
	void FPT ( float X, float Y, float Z );
	void DisplayMessage ( struct FString sMessage );
	void eventModifyPawnPropertiesVolumeChanged ( );
	void eventOnRigidBodySpringOverextension ( class URB_BodyInstance* BodyInstance );
	void SetUsePhysicsWithAnimation ( unsigned long Enable );
	class ATgPawn* FindLocalPlayerPawn ( );
	void BlendPawnAnimtreeToMatchInHandDevice ( );
	void BlendToAnimTreeDeviceType ( float fDeviceType, float BlendTime );
	void SetVar ( int varId );
	void ServerSetVar ( int varId );
	void OnTeleport ( class USeqAct_Teleport* Action );
	void eventResetChainedAttack ( unsigned char eqpPoint );
	bool DoJump ( unsigned long bUpdating );
	void eventClientCancelJump ( );
	void ServerCancelJump ( );
	void eventStartCrouch ( float HeightAdjust );
	void eventEndCrouch ( float HeightAdjust );
	bool IsInForcedConsoleRestrictedPitch ( );
	float ApplyPitchLimit ( float fPitch );
	struct FRotator GetBaseAimRotation ( class AWeapon* W, unsigned long bIgnoreAutoLock );
	void eventGetAdjustedAimNative ( class AWeapon* W, struct FVector StartFireLoc, struct FRotator* Rot );
	void eventGetBaseAimRotationNative ( class AWeapon* W, unsigned long bIgnoreAutoLock, struct FRotator* Rot );
	struct FVector eventGetWeaponStartTraceLocation ( class ATgDevice* Dev );
	struct FVector GetFireLocationOffset ( class ATgDevice* Dev );
	void HideWeaponSwitchProgressBar ( );
	void DisplayWeaponSwitchProgressBar ( float Duration );
	void eventCheckUseDuration ( float* fDuration );
	void ClientSetTriggerMessage ( class ATgTrigger_Use* newTrigger, int msgId );
	void SetTriggerToUse ( class ATgTrigger_Use* Trigger, unsigned long bEnable );
	void eventInterruptAllDevices ( );
	bool eventIsUseInterrupted ( );
	void eventInterruptUse ( );
	void eventEnableFootControls ( int foot, unsigned long bDisable );
	void eventHitWall ( struct FVector HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp );
	bool eventCanBeVortexed ( );
	bool eventCanBePulled ( );
	void DrawHUD ( class AHUD* H );
	int GetStunPropertyIdFromType ( unsigned char StunType );
	void OnTargetEscapedMegaKill ( class ATgPawn* Target );
	void eventCancelDelayedMegaDeath ( );
	void EndDelayedMegaKill ( );
	bool DoMegaKill ( );
	struct FVector CalcMegaKillTweenVelocity ( struct FVector EndLocation, struct FVector StartLocation, float TweenTime );
	bool BeginMegaKillTween ( );
	bool eventBeginDelayedMegaKill ( class AActor* KillInstigator, class UTgDeviceFire* KillingMode, float fStunDelay, unsigned char StunType, float fTweenDelay, unsigned char TweenType, struct FVector TweenLocation, unsigned long bShouldKill, unsigned char DeathReason, float fMinDamage );
	void OnStasis ( class UTgSeqAct_Stasis* StasisAction );
	void eventCannotUseAutoPortal ( unsigned long bOn );
	void eventDeathPreventedFrom ( class APawn* attacker );
	void eventImmortal ( unsigned long bImmortal );
	void eventEnamored ( class ATgPawn* Lover );
	void ClientSlide ( unsigned long bSliding, struct FRotator rSlideDir );
	void eventSlide ( unsigned long bSliding );
	void ClientSetWhiteoutHUDFx ( unsigned long IsActive );
	void eventSetWhiteoutHUDFx ( unsigned long IsActive );
	void ClientIntoxicate ( unsigned long bIntoxicated, float Duration, int FxId );
	void eventTremble ( unsigned long bIntoxicated, float Duration, int FxId );
	void eventIntoxicate ( unsigned long bIntoxicated, float Duration, int FxId );
	void eventStasis ( unsigned long bStasised );
	void eventCripple ( unsigned long bCrippled );
	void eventDisarm ( unsigned long bDisarmed );
	void eventSilence ( unsigned long bSilenced );
	void ResetStunnedBehavior ( class ATgPlayerController* PC, class ATgAIController* aic );
	void ClientSetStun ( );
	void StopFullBodyAnimation ( float BlendOutTime );
	void eventOnAnimEnd ( class UAnimNodeSequence* SeqNode, float PlayedTime, float ExcessTime );
	void eventOnAnimPlay ( class UAnimNodeSequence* SeqNode );
	void gibbedBy ( class AActor* Other );
	void DetachConeComponent ( class UDrawConeComponent* ConeComponent );
	class UDrawConeComponent* AttachConeComponent ( class UDrawConeComponent* ConeComponent, float fRadius, float fAngle );
	void PlayInitialSpawnFX ( );
	void TriggerKismetPlayerInitialized ( );
	void eventOnPawnInitialized ( );
	void OnWaitingForPawnDone ( );
	void eventWaitForInventoryThenDoPostPawnSetup ( );
	void eventHandleClientPostPawnSetup ( );
	void eventPropertySet ( int nPropertyId, float fPreviousValue, float fNewValue );
	void eventAttachDevice ( );
	void eventDetachDevice ( );
	void OnFadeOutTimerExpired ( );
	void OnLifeAfterDeathTimerExpired ( );
	void BeginFadeOut ( );
	void eventDropFlag ( class AController* C );
	void eventHoldFlag ( class ATgCarriedFlag* NewFlag );
	bool InitRagdoll ( );
	void TurnOff ( );
	void eventKilledBy ( class APawn* EventInstigator );
	void eventOutsideWorldBounds ( );
	void eventFellOutOfWorld ( class UClass* dmgType );
	void FlushDebug ( );
	void PlayHit ( float Damage, class AController* InstigatedBy, struct FVector HitLocation, class UClass* dmgType, struct FVector Momentum, struct FTraceHitInfo HitInfo );
	void eventLanded ( struct FVector HitNormal, class AActor* FloorActor );
	bool eventIsDying ( );
	void ResetPawnShadows ( );
	void ApplyPawnShadows ( unsigned long bOn );
	float eventGetEnergyPercent ( );
	bool eventInCombat ( );
	void eventCombat ( unsigned long bInCombat );
	void InCombatTimer ( );
	void ExitCombat ( );
	void eventEnterCombat ( class AActor* aInstigator, class AActor* ATarget, float fLength );
	void RemoveVisionRestrictionDeployable ( class ATgDeployable* dep );
	void AddVisionRestrictionDeployable ( class ATgDeployable* dep );
	void VolumeStealthFadeComplete ( );
	void RemoveVisibilityVolume ( class ATgVisibilityVolume* Vol );
	void AddVisibilityVolume ( class ATgVisibilityVolume* Vol );
	bool eventForceHideDropShadow ( );
	void eventApplyStealthClient ( );
	bool ShouldShowAsStealthed ( unsigned long bDetected );
	void eventApplyStealthServer ( unsigned char eStealthed, float fRate );
	void eventReceivedCachedMaxHealth ( );
	void eventReceivedPropValues ( );
	void eventReplicatedEvent ( struct FName VarName );
	void TgPawnControllerSet ( );
	void DisplayDebug ( class AHUD* HUD, float* out_YL, float* out_YPos );
	void UpdateCameraAttachPoint ( );
	struct FName GetDefaultCameraMode ( class APlayerController* RequestedBy );
	void eventLockTargetingDeviceToInHand ( unsigned long bEnable );
	void eventSetTargetingDevice ( class ATgDevice* Dev );
	bool eventSetActiveWeapon ( class AWeapon* NewWeapon, unsigned long bForceFastClear );
	void SetPawnState ( struct FName NewState );
	void RemoveDeathEffects ( );
	void OnRespawn ( );
	void TimerDestroy ( );
	void CleanupParamsForDying ( );
	void StopAllAnimations ( );
	bool eventVerifyChargeHit ( struct FVector HitLocation, struct FVector HitNormal, struct FVector TargetLocation, class AActor* Other );
	bool eventPredictChargeHit ( struct FVector ChargeDir, struct FVector ChargeStart, float fChargeRange, struct FVector HitLocation, struct FVector HitNormal, struct FVector TargetLocation, class AActor* Other );
	void GetHitLocationForProximityTouch ( class AActor* Target, struct FVector* HitLocation, struct FVector* HitNormal );
	void eventEndPhysCharge ( unsigned long bInterrupted );
	void eventStartPhysCharge ( unsigned char newChargeType, struct FRotator InitialDirection, struct FVector InitialLocation, float fChargeSpeed, float fChargeRange, unsigned long bIngoreHumanoidBlocking, int NewMoveState );
	float GetChargeTurnRate ( );
	bool eventIsGrabSourceValid ( class ATgPawn* Target, unsigned long bAllowTurrets, unsigned long bAllowStealthed );
	bool IsInNonStackableGrab ( );
	void eventDecrementCannotBeGrabSource ( );
	void eventIncrementCannotBeGrabSource ( unsigned long bBreakGrabs );
	void TickGrab ( float DeltaSeconds );
	void SetMovementPhysics ( );
	bool CanBeBaseForPawn ( class APawn* aPawn );
	bool IsInMovement ( );
	bool IsGrabSourceInMovement ( );
	void XingTianSweepGrabEnd ( unsigned long bInterrupted );
	void XingTianSweepGrabStart ( );
	void KhepriReviveGrabEnd ( );
	void KhepriGrabEnd ( unsigned long bInterrupted );
	void KhepriGrabStart ( );
	void FenrirBiteEnd ( unsigned long bInterrupted );
	void TyrGrabEnd ( unsigned long bInterrupted );
	void TyrGrabStart ( unsigned long bRemoveRoots );
	void eventAddVelocity ( struct FVector NewVelocity, struct FVector HitLocation, class UClass* DamageType, struct FTraceHitInfo HitInfo );
	void BaselessGrabEnd ( unsigned long bInterrupted );
	void BaselessGrabStart ( unsigned long bRemoveRoots );
	void DefaultGrabEnd ( unsigned long bInterrupted );
	void DefaultGrabStart ( unsigned long bRemoveRoots );
	void EndGrab ( unsigned char endingGrabState, unsigned long bInterrupted );
	void BeginGrab ( unsigned char newGrabState );
	bool CanInterpolateToGrabRotation ( unsigned char grabState );
	bool CanInterpolateToGrabLocation ( unsigned char grabState );
	bool eventIsBaselessGrab ( unsigned char grabState );
	bool eventShouldGrabBreakStealth ( unsigned char grabState );
	void OnGrabTargetDetach ( unsigned char endingGrabState, class ATgPawn* Target, unsigned long bInterrupted );
	void OnGrabTargetAttach ( unsigned char newGrabState, class ATgPawn* Target );
	void eventForceAllGrabTargetsDetach ( unsigned char State );
	void NotifyGrabEndIgnored ( );
	bool ShouldGrabEnd ( unsigned long bInterrupted );
	void eventEndPhysGrab ( unsigned long bInterrupted );
	void eventStartPhysGrab ( class ATgPawn* Source, float fTime, unsigned char grabState, struct FName grabSocket, struct FVector grabLocOffset, struct FRotator grabRotOffset );
	class ATgPawn* GetGrabRoot ( );
	void eventSetHercSmashGravity ( unsigned long bEnable, float fMultipler );
	void eventEndLevitation ( struct FVector TargetLocation, float TweenTime );
	void eventBeginLevitation ( unsigned char LevitateType, struct FVector TweenOffset, float TweenTime, float fLevitateTime, unsigned long bUnbreakable );
	float CalcFloorPortalMinStartVelocityZ ( float FallTime );
	float CalcFloorPortalMaxStartVelocityZ ( float FinalLocationZ, float FallTime );
	void FloorPortalTweenEnd ( unsigned long bInterrupted );
	void SinkTweenEnd ( unsigned long bInterrupted );
	void MegaKillTweenEnd ( unsigned long bInterrupted );
	void LevitateTweenEnd ( unsigned long bInterrupted );
	void DefaultTweenEnd ( unsigned long bInterrupted );
	void EndTween ( unsigned char endingTweenState, unsigned long bInterrupted );
	void MinionKnockbackTweenStart ( unsigned long bIsMelee );
	void eventPlayHitReaction ( int BitPackedHitReaction );
	void eventSendHitReaction ( unsigned long bIsMelee, unsigned char HitDirection );
	void ArachnePullTweenStart ( );
	void DefaultTweenStart ( unsigned long bRemoveRoots );
	void BeginTween ( unsigned char newTweenState );
	void eventEndPhysTween ( unsigned long bInterrupted );
	void eventStartPhysTween ( struct FVector Target, float fTime, unsigned char tweenState, int NewMoveState );
	struct FVector eventGetPhysTweenTargetLocation ( );
	bool eventIsDashing ( );
	bool eventIsLeaping ( );
	void RemoveAllEffectsOnDeath ( );
	void CleanUpDyingEffects ( );
	void OnSwapToDestroyedMesh ( );
	void AttachDeathAnimationFX ( int SpecialFXId, struct FName SocketName );
	bool CanDespawn ( );
	bool HasDespawnAnim ( );
	struct FName eventGetDespawnAnimName ( );
	struct FName eventGetDeathAnimName ( );
	void eventPlayDeathAnimation ( );
	void PlayDyingEffects ( );
	void FindNewTargetTimer ( );
	float GetNewTargetTimerLength ( );
	void PlayNearDeathCleanup ( );
	void PlayDying ( class UClass* dmgType, struct FVector HitLoc );
	void eventClientTriggerGlobalEventClass ( class UClass* InEventClass, class AActor* InInstigator, int ActivateIndex );
	void eventPlayFootStepSound ( int FootDown, unsigned char FootStepType );
	struct FString GetDebugName ( );
	void eventPostureTransitionEnded ( unsigned char PostureThatEnded );
	void FaceRotation ( struct FRotator NewRotation, float DeltaTime );
	bool IgnoreFaceRotationWithInterp ( );
	void GetCameraZoomOverride ( float* fZoom, float* fTweenSpeed );
	bool CalcCamera ( float fDeltaTime, struct FVector* out_CamLoc, struct FRotator* out_CamRot, float* out_FOV );
	void eventEndViewTarget ( class APlayerController* PC );
	void eventBecomeViewTarget ( class APlayerController* PC );
	float eventGetPlayerHealthForRender ( );
	struct FString eventGetPlayerTagForRender ( );
	struct FString eventGetPlayerNameForRender ( );
	struct FColor GetTargetBoxColor ( class ATgPawn* LocalPlayerPawn );
	void eventOnGroupChange ( );
	void NotifyLocalPlayerTeamReceived ( );
	void NotifyTeamChanged ( );
	int GetColumnBasedOnIndex ( int nIndex );
	int GetRowBasedOnIndex ( int nIndex );
	int GetY2CoordBasedOnIndex ( int nIndex );
	int GetX2CoordBasedOnIndex ( int nIndex );
	int GetY1CoordBasedOnIndex ( int nIndex );
	int GetX1CoordBasedOnIndex ( int nIndex );
	class ATgPawn* GetLocalPlayerPawn ( );
	bool LoadPlayerIcons ( );
	void eventDrawMultiLineText ( class UCanvas* Canvas, struct FString Text, int X, int Y, int LineHeight );
	void eventModifyHealthProp ( int nDamage );
	void AdjustDamage ( class AController* InstigatedBy, struct FVector HitLocation, class UClass* DamageType, struct FTraceHitInfo HitInfo, class AActor* DamageCauser, int* InDamage, struct FVector* Momentum );
	void eventTakeDamage ( int Damage, class AController* InstigatedBy, struct FVector HitLocation, struct FVector Momentum, class UClass* DamageType, struct FTraceHitInfo HitInfo, class AActor* DamageCauser );
	class AController* OverrideKillInstigator ( );
	class AController* SetKillInstigator ( class AController* InstigatedBy, class UClass* DamageType );
	bool WillOverrideTakeDamage ( class APawn* Victim, int Damage, class AController* InstigatedBy, struct FVector HitLocation, struct FVector Momentum, class UClass* DamageType, struct FTraceHitInfo HitInfo, class AActor* DamageCauser );
	bool TakeDamageSpecial ( int Damage, class AController* InstigatedBy, struct FVector HitLocation, struct FVector Momentum, class UClass* DamageType, struct FTraceHitInfo HitInfo, class AActor* DamageCauser );
	void eventDrawVisionRangeDebug ( class UCanvas* Canvas );
	struct FString eventAIDebugString ( );
	void eventDrawAIDebug ( class UCanvas* Canvas, struct FVector ScreenLoc );
	void NotifyTakeHit ( class AController* InstigatedBy, struct FVector HitLocation, int Damage, class UClass* DamageType, struct FVector Momentum, class AActor* DamageCauser );
	void eventSendNotifyTakeHit ( class AController* InstigatedBy, struct FVector HitLocation, int Damage, class UClass* DamageType, struct FVector Momentum );
	void PlayTakeHit ( int Damage, class UClass* dmgType );
	void eventPlayHitReactionMaterialPulse ( );
	void RememberPlayerAttackerExpired ( );
	void StopPlayFiring ( );
	void ClearFlashLocation ( class AWeapon* Who );
	void ClearFlashCount ( class AWeapon* Who );
	void IncrementFlashCount ( class AWeapon* Who, unsigned char FireModeNum );
	bool eventCanApplyEffects ( );
	void OnDeviceFormInterruptFire ( int nEquipSlot );
	void OnDeviceFormStopFire ( int nEquipSlot );
	void PostRecallTimerToKillParticles ( );
	void FixInHandProgressionAnims ( int nNewMode, float NewDesiredDuration );
	void OnDeviceFormSetStagingMultiAnimIndex ( int nEquipSlot, int nChild );
	void OnDeviceFormInterruptCharge ( int nEquipSlot );
	void OnDeviceFormEndCharge ( int nEquipSlot, unsigned long bHit );
	void OnDeviceFormBeginCharge ( int nEquipSlot );
	void OnDeviceFormHit ( int nEquipSlot, class ATgPawn* TargetPawn );
	void OnDeviceFormFire ( int nEquipSlot );
	void OnDeviceFormStartFire ( int nEquipSlot, float FireDuration, int nFireMode );
	void OnDeviceFormBuildup ( int nEquipSlot, float fBuildupTime );
	bool eventDeviceOverrideLockedDown ( class ATgDevice* Device );
	bool DeviceCausesWariness ( int nEquipSlot );
	void SyncDeviceTimers ( class ATgDevice* SourceDevice, class ATgDevice* DestinationDevice );
	void PopEquippedDevice ( class ATgDevice* newDev, int nEqpSlot );
	void PushEquippedDevice ( class ATgDevice* newDev, int nEqpSlot );
	void SwapEquippedDevices ( class ATgDevice* newDev, int nEqpSlot );
	void SwapDeviceEquipPoints ( int nEqpSlot1, int nEqpSlot2 );
	int eventGetDeviceFormFXIndex ( class UTgDeviceForm* form );
	void eventRestartAllDevices ( );
	void ClientStopFiringAllDevices ( unsigned long bClearEquipEffectFlag, unsigned long bResetCooldowns );
	void eventStopFiringAllDevices ( unsigned long bClearEquipEffectFlag, unsigned long bResetCooldowns );
	void eventStopAction ( class ATgDevice* Dev );
	bool eventStartAction ( class ATgDevice* Dev, unsigned long bUpdateTimeStamp, unsigned char* failType );
	void eventAnimSwapDevice ( );
	void UIH ( );
	void eventUpdateInHand ( unsigned long bForceFastClear );
	void OnDeviceFormExitedTargetingMode ( class UTgDeviceForm* form );
	void OnDeviceFormEnteredTargetingMode ( class UTgDeviceForm* form );
	void EquipPendingDeviceTimer ( unsigned long SkipPlayAnim );
	void ShowAnimSets ( );
	void eventPutInHandDeviceAwayFast ( class UTgDeviceForm* form );
	bool CanChangeInHandDeviceOrMode ( );
	void eventKillAllOwnedPets ( );
	void eventDestroyed ( );
	bool eventDied ( class AController* Killer, class UClass* dmgType, struct FVector HitLocation );
	void TakeFallingDamage ( );
	void OnJoinTeam ( class UTgSeqAct_JoinTeam* Action );
	void eventDespawnOnReconnect ( );
	void eventDespawn ( );
	void eventSuicide ( );
	void SetDeathZoomInfo ( class ATgPawn* theKiller, class ATgRepInfo_Player* theKillerPRI, int nHealthPct, int nDeviceId, class ATgRepInfo_Player* OwnerPRI );
	void PreRender ( class UCanvas* Canvas );
	bool eventIsCustomCharacter ( );
	void MissionTimeUpdate ( );
	bool eventPostPawnSetup ( );
	void CrushedBy ( class APawn* OtherPawn );
	void ClearSpawnFxTimer ( );
	void PostBeginPlay ( );
	void eventPreBeginPlay ( );
	void AllManifestsLoaded ( );
	void ToggleSkelControlLocks ( unsigned long bOn );
	void CacheSkelControlLocks ( class UTgSkeletalMeshComponent* smcomp );
	void CacheMultiMeshAnimNodeReferences ( class UTgSkeletalMeshComponent* smcomp );
	void ClearMultiMeshAnimNodeReferences ( );
	void CacheMainMeshReferences ( class UTgSkeletalMeshComponent* smcomp );
	void eventPostInitAnimTree ( class USkeletalMeshComponent* SkelComp );
	void eventSpecialFXAttached ( class UTgSpecialFx* NewFX, int FxId );
	void DebugFireDevice ( int eEqPoint );
	void OnResetCooldown ( class UTgSeqAct_ResetCooldown* inAction );
	void OnDespawnBots ( class UTgSeqAct_DespawnBots* inAction );
	void OnDoDamageToPawn ( class UTgSeqAct_DoDamageToPawn* Action );
	void OnKillpawns ( class UTgSeqAct_Killpawns* Action );
	void eventReflectChargeDirection ( struct FVector HitNormal );
	void eventBumpLevel ( struct FVector HitLocation, struct FVector HitNormal );
	void eventBump ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitNormal );
	void eventFalling ( );
	void eventOnPhysChange ( unsigned char NewPhysState );
	void eventCollisionChanged ( );
	void OnUIAlert ( class UTgSeqAct_UIAlert* Action );
	void OnSetTaskforce ( class UTgSeqAct_SetTaskforce* Action );
	void OnGetTaskForceNumber ( class UTgSeqAct_GetTaskForceNumber* Action );
	void OnGetTeamIndex ( class UTgSeqAct_GetTeamIndex* Action );
	void UnPossessed ( );
	void PossessedBy ( class AController* C, unsigned long bVehicleTransition );
	void ServerTestPushBack ( float Distance );
	void TestPushBack ( float Distance );
	bool InitializeTeleportIncomingFx ( );
	void ToggleOverlayVisibility ( unsigned long bVisible, unsigned long bDead );
	void SetOverlayState ( class USkeletalMeshComponent* ParentMesh, unsigned char NewState );
	void SetForceFullOverlayMesh ( unsigned long bEnable );
	bool ShouldUseFadeOverlay ( );
	void AdjustFadeOverlay ( float fFadeValue );
	void AdjustHitPulseOverlay ( float fBrightness );
	void SwapOverlayMICs ( unsigned char Type );
	int FindOverlayInfo ( class USkeletalMeshComponent* ParentMesh );
	void ReinitializeOverlays ( );
	int InitializeOverlayMeshComponent ( class USkeletalMeshComponent* InMesh, unsigned long bMakePhysAsset );
	void CacheHitReactionSkelControls ( );
	void PostPawnSetupServer ( );
	void OnMeshSwapped ( );
	void SwapToLiveMesh ( );
	void SwapToDestroyedMesh ( );
	void RetouchAllVolumes ( );
	void OnSilenceOther ( class ATgPawn* Other, class UTgEffectGroup* effectGroup );
	void OnKnockupEnd ( class AActor* Target );
	void OnSpecialKnockback ( class AActor* Target, class AActor* BlockingActor );
	void EffectGroupOnApplied ( class UTgEffectGroup* effectGroup, unsigned long bInterval );
	void EffectGroupOnSetActive ( unsigned long bActive, unsigned long bRemoving, class UTgEffectGroup* effectGroup );
	class UClass* DeviceOnOverrideDamageType ( class ATgDevice* Dev, class UTgEffectGroup* effectGroup );
	void DeviceOnModifyEffectLifeTime ( class ATgDevice* Dev, class UTgEffectGroup* effectGroup, float* fLifeTime );
	bool DeviceIsTargetingModeReady ( class ATgDevice* Dev, unsigned char* failType );
	bool DeviceOverrideManaUseVitals ( class ATgDevice* Dev, class ATgPlayerController* PC );
	bool DeviceOverrideTargetingAim ( class ATgDevice* Dev, struct FAimData* Aim, TArray< struct FImpactInfo >* ImpactList );
	void DeviceOnSetFireMode ( class ATgDevice* Dev );
	bool DeviceHasEnoughPowerPool ( class ATgDevice* Dev, unsigned char FireModeNum );
	void DeviceAdjustPowerScaling ( class ATgDevice* Dev, int nScalingType, struct FImpactInfo* Impact, float* fPhysicalPower, float* fMagicPower );
	bool DeviceOnCanDeviceCriticalStrike ( class ATgDevice* Dev, int nPropertyId, int nDamageType, struct FImpactInfo* Impact, float* fCritChance );
	bool DeviceOnCanDeviceFireNow ( class ATgDevice* Dev, unsigned char FireModeNum, unsigned long bDeviceFailLog, struct FAimData* Aim );
	void DeviceAdjustHeal ( class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fHeal );
	void DeviceOnProjShutdown ( class ATgDevice* Dev );
	void DeviceAdjustDamage ( class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage );
	void DeviceOnKilled ( class ATgDevice* Dev, float fDamage, struct FImpactInfo* Impact );
	void DeviceOnHealed ( struct FOnHealedParams* Params );
	void DeviceOnDodged ( struct FOnDodgedParams* Params );
	void DeviceOnAbsorbHit ( struct FOnAbsorbHitParams* Params );
	void DeviceOnDamaged ( struct FOnDamagedParams* Params );
	void DeviceOnHitSpecial ( class ATgDevice* Dev, int nHitSpecialSituationalType, struct FImpactInfo* Impact );
	void DeviceOnHit ( class ATgDevice* Dev, struct FImpactInfo* Impact );
	void DeviceOnPostHit ( class ATgDevice* Dev );
	void DeviceOnStopCooldown ( class ATgDevice* Dev );
	void DeviceOnStartCooldown ( class ATgDevice* Dev, float fCooldownTime );
	void DeviceOnStopFire ( class ATgDevice* Dev, unsigned long WasInterrupted );
	void DeviceOnStartFire ( class ATgDevice* Dev );
	void DeviceOnFire ( class ATgDevice* Dev );
	void DeviceOnAboutToFire ( class ATgDevice* Dev );
	void DeviceOnStopBuildup ( class ATgDevice* Dev, unsigned long WasInterrupted );
	void DeviceOnStartBuildup ( class ATgDevice* Dev );
	void PawnOnSpecialReset ( );
	void PawnOnDeliverHits ( TArray< struct FImpactInfo >* PendingHits );
	bool PawnCanDisplayImmuneMessage ( );
	bool PawnOnDidBreakableGrabHit ( );
	bool PawnOnDidBreakableTweenHit ( );
	void PawnOnLifesteal ( class ATgPawn* attacker, class UTgEffectGroup* effectGroup, float* lifestealAmount );
	void PawnOnObjectiveSteal ( struct FScoreKillData* Data );
	void PawnOnModifyEffectLifeTime ( class UTgEffectGroup* eg, float* fLifeTime );
	void PawnOnTaskforceAdd ( class ATgRepInfo_TaskForce* tf );
	void PawnOnTaskforceRemove ( class ATgRepInfo_TaskForce* tf );
	void PawnOnReduceActiveCooldowns ( float fValue, unsigned long bPercentage );
	void PawnOnDodged ( struct FOnDodgedParams* Params );
	void PawnOnAbsorbHit ( struct FOnAbsorbHitParams* Params );
	void PawnOnCurrency ( class AActor* Source, int* nCurrency );
	void PawnOnXp ( class AActor* Source, int* nXp );
	void PawnOnSlowed ( struct FImpactInfo* Impact );
	void PawnOnHardCCed ( struct FImpactInfo Impact, class UTgEffectGroup* eg );
	void PawnOnCCed ( struct FImpactInfo Impact, class UTgEffectGroup* eg );
	void PawnOnSpellShieldProc ( );
	void PawnOnGodCombatEvent ( );
	void PawnOnCombatEvent ( );
	void PawnOnExitCombat ( );
	void PawnOnEnterCombat ( );
	void PawnOnRevive ( );
	void PawnOnAssisted ( class AActor* Victim, int* xpGain, int* goldGain );
	void PawnOnKilled ( class AActor* Victim, int* xpGain, int* goldGain );
	void PawnAdjustHeal ( class ATgPawn* InstigatorPawn, int nPropertyId, struct FImpactInfo* Impact, float* fHeal );
	void PawnOnHealed ( struct FOnHealedParams* Params );
	float PawnOnConditionalDamageTakenPerc ( );
	void PawnOnDamageMitigation ( class ATgPawn* attacker, class UTgEffectGroup* eg, int nPropertyId, float* fDamage );
	void PawnOnPreDamageMitigation ( class ATgPawn* attacker, class UTgEffectGroup* eg, int nPropertyId, float* fDamage );
	void PawnOnDamaged ( struct FOnDamagedParams* Params );
	void SetSpawnEnergy ( );
	void SetSpawnMana ( );
	void SetSpawnHealth ( );
	void OnAttackDamagePropertyChange ( );
	void OnOwnerGroundSpeedChange ( );
	void OnUtilityPowerChange ( );
	float GetManaCostModifier ( );
	float GetBasicAttackDamage ( );
	float GetUIGroundSpeed ( );
	float GetStrafePercent ( );
	float GetBackpedalPercent ( );
	float GetMinimapWardVisionPercent ( );
	bool GetMinimapRequireLOS ( );
	float GetDamageDealtPercBasicAttack ( );
	float GetDamageDealtPerc ( );
	float GetDamageTakenPercMag ( );
	float GetDamageTakenPercPhys ( );
	float GetDamageTakenPerc ( );
	float GetHealingTakenPerc ( );
	float GetVisionRange ( );
	float GetAttackSpeed ( );
	float GetMaxShieldHealth ( );
	float GetMaxHealthWithoutPercentBuff ( );
	float GetMaxHealth ( );
	float GetMaxEnergy ( );
	float GetMaxMana ( );
	float GetShieldHealth ( );
	float GetHealth ( );
	float GetSmoothEnergy ( );
	float GetEnergy ( );
	float GetMana ( );
	float GetEnergyRegen ( );
	float GetManaRegen ( );
	float GetHealthRegen ( );
	float GetGoldPer5 ( );
	float GetGoldPer5Gain ( );
	float GetGoldGain ( );
	float GetXPGain ( );
	float GetReviveReduction ( );
	float GetCooldownReduction ( );
	float GetPercReduction ( int nPropIndex );
	float GetFlatReduction ( int nPropIndex );
	float GetPercPenetration ( int nProtectionType, class AActor* Target );
	float GetFlatPenetration ( int nProtectionType, class AActor* Target );
	float GetProtection ( int nPropIndex );
	float GetSpellVamp ( );
	float GetLifeSteal ( );
	float GetCriticalDamage ( );
	float GetCriticalStrike ( );
	float GetMagicalProtection ( );
	float GetPhysicalProtection ( );
	float GetHealingPowerItem ( );
	float GetUtilityPowerItem ( );
	float GetMagicalPowerItem ( struct FImpactInfo Impact, float PowerScaling );
	float GetPhysicalPowerItem ( struct FImpactInfo Impact, float PowerScaling );
	float GetHealingPowerBot ( );
	float GetUtilityPowerBot ( );
	float GetMagicalPowerBot ( );
	float GetPhysicalPowerBot ( );
	float GetHealingPower ( );
	float GetUtilityPower ( );
	float GetMagicalPower ( struct FImpactInfo Impact );
	float GetPhysicalPower ( struct FImpactInfo Impact );
	bool HasDeathPostureAnimation ( );
	class ATgDevice* GetEquippedDevice ( int nDeviceId );
	bool ServerUpdateLockedTarget ( class AActor* Locked );
	bool DoServerDetonate ( );
	class ATgPawn* GetLocalTgPawn ( );
	float GetMaxPowerPoolValue ( int nPacingType );
	float GetCurrentPowerPoolValue ( int nPacingType );
	void ConsumePowerPool ( class ATgDevice* Dev, int nPacingType, float fAmount );
	bool IsInFireLock ( );
	float GetAirControl ( );
	void UpdatePRIAssetRefs ( );
	void OnSetPlayerLevel ( class UTgSeqAct_SetPlayerLevel* Action );
	struct FVector GetLocationOfFeet ( unsigned long bAllowGroundTrace, struct FVector LocationSubstitute );
	float NativeGetCollisionRadius ( );
	float NativeGetCollisionHeight ( );
	void OnPostureChange ( );
	void OnProjectileExploded ( class ATgProjectile* ExplodedProjectile, class AActor* HitActor );
	void RemoveSpawnFadeOutFx ( );
	void OnLevelUp ( );
	void ClearEquippedDevice ( );
	bool NativeReplicatedEvent ( struct FName VarName );
	void InitSpawnPets ( int SpawnTableID );
	void OnPetSpawned ( class ATgPawn* Pet );
	struct FVector GetTargetCenter ( );
	void CheckUiVolumeTriggers ( );
	bool eventPopPosture ( int PostureID );
	int eventPushPosture ( unsigned char Posture );
	void eventOnRefireTimeout ( );
	void eventOnAttackComboTimeout ( );
	void SetJustTeleported ( unsigned long bInJustTeleported );
	void PlaySeasonalDyingEffects ( );
	void FixRelativeRotation ( );
	void RemoveOverlappingWallInfo ( class ATgDeploy_Wall* DeployWall );
	void AddOverlappingWallInfo ( class ATgDeploy_Wall* DeployWall, struct FVector PushingVector );
	int GetCustomParticleSystemFilter ( );
	void EndSkinLevelUp ( );
	void PlaySkinLevelUpFx ( );
	void OnSkinLevelChanged ( );
	void LevelUpSkin ( unsigned char NewSkinLevel );
	bool UsesSkinLeveling ( );
	void FillChargeDeviceArray ( TArray< class ATgDevice_Charge* >* ChargeList );
	void RemoveIgnoreBlockingFlags ( unsigned char NewFlags );
	void AddIgnoreBlockingFlags ( unsigned char NewFlags );
	bool FindBestEndGrabLocation ( struct FVector Extent, class AActor* TestActor, struct FVector* finalLocation, struct FRotator* finalRotation );
	bool IsInOffensiveTween ( );
	bool IsTweenBreakable ( unsigned char tweenState );
	bool IsPerformingOffensiveGrab ( );
	bool IsInOffensiveGrab ( );
	bool IsGrabBreakable ( unsigned char tweenState );
	void ResetSkelControls ( class USkeletalMeshComponent* SkelComp );
	void CalcSocketWorldGrabLocationRotation ( class ATgPawn* Source, struct FName SocketName, struct FVector relLoc, struct FRotator RelRot, struct FVector* WorldLoc, struct FRotator* WorldRot );
	void CalcWorldGrabLocationRotation ( class ATgPawn* Source, struct FVector relLoc, struct FRotator RelRot, struct FVector* WorldLoc, struct FRotator* WorldRot );
	struct FRotator TweenRelRotation ( float fDeltaSeconds, struct FRotator currRel, struct FRotator targetRel );
	class AActor* FindCharmTarget ( float fRadius );
	bool IsStructure ( );
	bool IsObjective ( );
	bool IsGodDecoy ( );
	bool IsGod ( );
	float AdjustRespawnTime ( float InRespawnTime );
	void ForceUpdateComponents ( unsigned long bCollisionUpdate, unsigned long bTransformOnly );
	void UpdateSpectatorStatUI ( );
	void UpdatePlayerStatUI ( );
	void PlayCustomAnimation ( int nAnimResId, unsigned long bFullBody, float fTime );
	void GetCurrentUsedResourceList ( TArray< struct FString > List );
	void LoadWhiteoutHUDFxMIC ( int FxId );
	struct FVector2D IntoxicationRotatorOffset ( float OffsetFromWorldTime );
	float IntoxicationStrafeOffset ( float OffsetFromWorldTime );
	void LoadIntoxicationMIC ( int FxId );
	bool IsNonCombat ( );
	bool CanMove ( );
	void PlayUpperBodyAnim ( struct FName AnimName, float Rate, float BlendInTime, unsigned long bLooping );
	float PlayFullBodyLoopingAnimWithTransition ( struct FName TransitionAnimName, struct FName LoopingAnimName, float Rate, float BlendInTime, float BlendOutTime );
	bool PlayFullBodyAnim ( struct FName AnimName, float Rate, float BlendInTime, float BlendOutTime, unsigned long bLooping, unsigned long bOverride, unsigned long bBlendOutIfVelocityIsGreaterThanZero, unsigned long bHideInHandDevice );
	bool IsFriendlyWithLocalPawn ( );
	class ATgPawn_Courier* GetAvailableCourier ( );
	bool HasAvailableCourier ( );
	void CourierPhaseChanged ( unsigned char Phase );
	void CourierDied ( );
	void CourierDropOff ( );
	void ForceUpdateEquippedDevices ( );
	void RegainEnergyPool ( float fDelta );
	void RegainManaPool ( float fDelta );
	void RegainPools ( float fDelta );
	struct FVector GetSeekingTargetLocation ( );
	void SyncMana ( );
	float GetManaPercent ( );
	float GetHealthPercent ( );
	void SetMeshComponentVectorValue ( class UMeshComponent* theMesh, struct FName ScalarParam, struct FLinearColor* ColorValue );
	void SetMeshComponentScalarValue ( class UMeshComponent* theMesh, struct FName ScalarParam, float ScalarValue );
	void SetMeshVectorValue ( struct FName ScalarParam, struct FLinearColor* ColorValue );
	void SetMeshScalarValue ( struct FName ScalarParam, float ScalarValue );
	bool MoveCloseTo ( struct FVector vDesiredLocation );
	void KillDeployables ( unsigned long bAll );
	int DrawMatString ( class UCanvas* CanvasToUse, float StartX, float StartY, float XScale, float YScale, struct FString NameString, class UFont* NameFont, class UMaterialInstanceConstant* FontMIC );
	void SwapAttachedDeviceMaterials ( class UMaterialInstanceConstant* NewMaterial, unsigned long bIgnoreParams );
	void SwapSkinMaterials ( TArray< struct FFx_Material > MaterialList, unsigned long bIgnoreParams, unsigned long bIsFriendly );
	void SetSkin ( class UTgSpecialFx* NewSpecialFx, unsigned long bIgnoreParams, unsigned long bForceSetSkin );
	bool IsVisibleThroughRestrictionDeployablesBy ( class ATgPawn* Other );
	int FindVisionRestrictionDeployable ( class ATgDeployable* deployable );
	int NumVisionRestrictionDeployablesTouching ( );
	class ATgVisibilityVolume* GetATouchingVisibilityVolume ( );
	bool IsInSameVisibilityVolume ( class ATgPawn* Other );
	int FindVisibilityVolume ( class ATgVisibilityVolume* VisVolume );
	int NumVisibilityVolumesTouching ( );
	void RemoveDetectedFx ( );
	void PlayDetectedFx ( );
	bool IsDetector ( );
	bool IsHardStealthed ( );
	bool IsStealthed ( class ATgRepInfo_Player* Viewer );
	class ATgDevice* GetDeviceById ( int nDeviceId );
	class ATgDevice* GetDeviceByInstanceId ( int nDeviceInstanceId );
	struct FString GetDeviceNameByID ( int DeviceID );
	void OnPawnDied ( );
	void ApplyAnyPushback ( float DeltaTime );
	bool Pushback ( struct FVector Distance );
	void PlaySpawnFx ( );
	void PrepareIntro ( );
	void PlayBasicAttackAbsorbFx ( int nCategoryCode );
	void PlayTeleportFx ( int nTeleportState, struct FVector vLoc );
	void PlayCurrencyFx ( class ATgRepInfo_Player* sourcePRI, int nCurrency, int nMsgId );
	float GetTerminalVelocity ( );
	float GetDropShadowFadeAmount ( );
	void UpdateDropShadow ( );
	void RecalculateMaterial ( unsigned long bIsFriendlyWithLocalPawn, unsigned long bForce );
	void ForceRecalculateMaterial ( );
	bool CanBeAffectedByVortices ( );
	bool OverrideDistanceFadeRange ( );
	void CalcStealthFadeValue ( float fDeltaTime );
	void CalcDistanceFadeValue ( float fDeltaTime );
	void CalcVolumeFadeValue ( float fDeltaTime );
	bool IsHittableToAI ( );
	bool IsInvisible ( );
	bool ShouldInHandDeviceBeHiddenThisTick ( );
	bool ShouldPawnMeshBeHiddenThisTick ( );
	class UFont* GetFont ( int nResId );
	class UMaterialInstanceConstant* GetMIC ( int nResId );
	void PlaySoundCue ( int nSoundCueId );
	void SetPhase ( int nNewPhase );
	void UpdateHUDScores ( );
	void WardPlaced ( );
	void TrackDeath ( );
	void TrackKill ( class ATgPawn* Killer );
	void UpdateEnemyAssists ( class ATgPawn* Assister );
	void UpdateDamagers ( class ATgPawn* Damager );
	void TrackDamageMitigated ( class ATgPawn* theInstigator, int nAmount );
	void TrackDamageTaken ( class ATgPawn* theInstigator, int nDamage, int nDamageType );
	void TrackSelfKill ( int nDeviceModeID );
	void TrackTeamKill ( int nDeviceModeID );
	void TrackSelfDamage ( int nDeviceModeID, int nDamage );
	void TrackTeamDamage ( int nDeviceModeID, int nDamage );
	void TrackReleaseTime ( int nDeviceModeID, float fReleaseTime );
	void TrackHit ( int nDeviceModeID, float fDistance, unsigned long bHitPlayer );
	void RemoveTrackFired ( int nDeviceModeID );
	void TrackCompleteKillInfo ( int nKillerCharacterID, int nKillerDeviceModeID, int nVictimCharacterID, int nVictimDeviceModeID, struct FVector KillerLocation, struct FVector VictimLocation, struct FVector PetLocation, unsigned long bPetKill );
	void TrackFired ( int nDeviceModeID );
	void TrackBotHealing ( int nDeviceModeID, float fDamage, float fMissingHealth, int nMaxHealth );
	void TrackSelfHealing ( float fHealing, float fMissingHealth, int nMaxHealth );
	void TrackHealing ( int nDeviceModeID, float fDamage, float fMissingHealth, int nMaxHealth );
	void TrackKilledBot ( int nDeviceModeID );
	void TrackFromPlayerDeath ( int nDeviceModeID );
	void TrackKilledPlayer ( int nDeviceModeID );
	void TrackDamagedBot ( class ATgPawn* TargetPawn, int nDeviceModeID, int nDamage, int nDamageType, unsigned long bIsGod );
	void TrackDamagedPlayer ( class ATgPawn* TargetPawn, int nDeviceModeID, int nDamage, int nDamageType, unsigned long bInHand );
	void UpdateStatsTracker ( );
	void EndStats ( );
	void BeginStats ( );
	void StatsCleanup ( );
	void ValidateStatsTracker ( );
	class APawn* FindBestKiller ( class AController* Killer );
	bool IsShooterTargetValid ( class ATgPawn* PawnTarget, class ATgDevice* Dev );
	class ATgPawn* FindPlayerPawn ( struct FString fsName );
	class ATgRepInfo_Player* GetPRI ( );
	void RemoveAllAnimationSets ( );
	unsigned char GetEquipPointByType ( int nDeviceType );
	unsigned char GetTaskForceNumber ( );
	void SetTaskForceNumber ( int nTaskForce );
	float CheckTargetDistance ( class AActor* TargetActor );
	void AdjustMeshTranslation ( );
	void KillOwnedBots ( );
	void KillPet ( );
	void SetPet ( class ATgPawn* PetPawn );
	struct FString GetResourceFromGAssembly ( int ResId );
	void ReplaceMeshComponent ( int nNewMeshId, class UMeshComponent* DestComponent );
	int GetSkinnedSpecialFxId ( int nSpecialFxId );
	int GetSkinnedMeshId ( int nMeshId );
	class UMeshComponent* CreateMeshComponent ( int nMeshId );
	class UTgSpecialFx* GetSpecialFx ( int nSpecialFxId );
	void SetDeviceVisibility ( unsigned long bVisible );
	void SetMeshVisibility ( unsigned long bVisible );
	bool CanSeeActor ( class AActor* Other );
	bool IsJumpDisabled ( );
	bool IsPhysicalLadderInFrontOfPawn ( unsigned long bTraceFromTopOfCylinder );
	float GetGravityZ ( );
	void AddRemoveAnimSetList ( TArray< class UAnimSet* > AnimSetList, unsigned long bAdd );
	void PlayGlobalEmoteFx ( );
	bool IsEmoteMuted ( );
	void CancelEmote ( unsigned long bVerifyNoRelevantEmotes, class UTgAnimNodeEmoteSequence* Exclude );
	void PlaySoundEmote ( );
	void PlayAnimEmote ( );
	bool TermRagdoll ( );
	void LogPawnAnim ( );
	bool IsPointInsideCollisionCylinder ( struct FVector Point, float AddHeight, float AddRadius );
	void DrawClientDebug ( );
	bool bIsEditor ( );
	void ReapplyLoadoutEffects ( );
	void ReapplyLevelEffectGroups ( int nPrevLevel, int nCurrentLevel, unsigned long bPreserveParams );
	bool ShouldAllowSkillUp ( unsigned long bIsAutoSkillUp );
	void FlashRadialSweep ( int nDeviceInstanceId, int nFireModeNum, int nYaw, float fDuration );
	void FlashReflect ( int nDeviceInstanceId, int nFireModeNum, struct FVector vNewLoc );
	void FlashInterruptCharge ( int nDeviceInstanceId );
	void FlashEndCharge ( int nDeviceInstanceId, unsigned long bHitTarget );
	void FlashBeginCharge ( int nDeviceInstanceId );
	void FlashGuanYuV2UltSwing ( );
	void FlashGuanYuV2Dismount ( );
	void FlashFreyaLevitateEnd ( );
	void FlashLevelupFx ( );
	void FlashBasicAttackAbsorb ( int nCategoryCode );
	void FlashTeleportFx ( int nTeleportState, struct FVector vLocation );
	void FlashChangeMesh ( );
	void FlashDestruct ( int nDeviceInstanceId, struct FVector vLocation );
	void FlashHitReaction ( );
	void FlashResyncClient ( );
	void FlashModeEquipDone ( int nDeviceInstanceId, int nFireModeNum );
	void FlashEventUpdate ( );
	void FlashResetChainAttack ( int nDeviceInstanceId );
	void FlashSuccessfulHit ( int nDeviceInstanceId, int nFireModeNum, class AActor* Target );
	void FlashInterrupt ( int nDeviceInstanceId );
	void FlashBlockDone ( int nDeviceInstanceId, int nFireModeNum );
	void FlashBlockFx ( int nDeviceInstanceId, int nFireModeNum );
	void FlashBlock ( int nDeviceInstanceId, int nFireModeNum );
	void FlashCooldownDone ( int nDeviceInstanceId, int nFireModeNum );
	void FlashCooldown ( int nDeviceInstanceId, int nFireModeNum );
	void FlashStartFireNoSim ( int nDeviceInstanceId, int nFireModeNum, float RefireTime, class AActor* Target );
	void FlashStartFire ( int nDeviceInstanceId, int nFireModeNum, float RefireTime, class AActor* Target );
	void FlashStopFire ( int nDeviceInstanceId, int nFireModeNum );
	void FlashArcing ( int nDeviceInstanceId, int nFireModeNum, struct FVector vNewLoc, struct FVector vOldLoc, int nEquipSlot, int nSocketIndex, unsigned long bsuccesfulhit );
	void FlashFireNoSim ( int nDeviceInstanceId, int nFireModeNum, struct FVector vNewLoc, int nEquipSlot, int nSocketIndex, unsigned long bsuccesfulhit, float RefireTime );
	void FlashFire ( int nDeviceInstanceId, int nFireModeNum, struct FVector vNewLoc, int nEquipSlot, int nSocketIndex, unsigned long bsuccesfulhit, float RefireTime );
	void FlashPlayEmote ( unsigned char Emote, int ExtraInfo );
	void FlashPlayOffhandFx ( int nDeviceInstanceId, struct FVector vNewLoc, struct FVector vNewDirection, int nSocketIndex );
	void FlashBuildUp ( int nDeviceInstanceId, int nFireModeNum, int nEquipSlot, int nSocketIndex, float fBuildupTime );
	void FlashFireMode ( int nDeviceInstanceId, int nFireModeNum );
	void FlashResetReplication ( );
	struct FVector NativeCanvasProject ( class UCanvas* CanvasToUse, struct FVector vLocation );
	int DrawNameText ( class UCanvas* CanvasToUse, float StartX, float StartY, struct FString NameString, class UFont* NameFont, struct FColor NameColor, float Scale );
	int DrawScaledString ( class UCanvas* CanvasToUse, float StartX, float StartY, struct FString NameString, class UFont* NameFont, struct FColor NameColor, float Scale );
	void CrowdControlBreak ( );
	bool IsCrowdControlImmune ( );
	bool ShowImmunityHighlight ( );
	float GetAttackSlow ( );
	float GetGroundSpeed ( unsigned long bIgnoreSlowDiminishing );
	float GetSlowDiminishing ( );
	void ResetProperties ( );
	void SetPropCurrentValue ( int nPropIndex, float nNewValue );
	float GetPropDisplayValue ( int nPropIndex );
	float GetPropCurrentValue ( int nPropId );
	void SetProperty ( int nPropIndex, float fNewValue );
	class UTgProperty* GetProperty ( int nPropIndex );
	void AddProperty ( int nPropId, float fBase, float fRaw, float FMin, float FMax );
	void InitializeDefaultProps ( );
	bool ApplyPawnSetup ( );
	void DoBlend ( struct FName BlendName, float BlendTarget, float BlendTime, class USkeletalMeshComponent* SkelMesh );
	void DeviceFormChanged ( unsigned long bForceReload );
	class UTgDeviceForm* CreateDeviceForm ( struct FEquipDeviceInfo Info );
	class ATgDevice* GetDeviceByEqPoint ( int eEqPoint );
	void UpdateClientDevices ( unsigned long bForce );
	bool AreAnyOtherOffhandsLockingFiring ( class ATgDevice* CurrentDevice );
	void BeginEquipOffhandCooldown ( );
	void SetTargetActor ( class AActor* Target );
	class ATgPawn* GetTargetPawn ( );
	class AActor* GetTargetActor ( );
};

UClass* ATgPawn::pClassPointer = NULL;

// Class TgGame.TgPawn_Biped
// 0x00F4 (0x1C1C - 0x1B28)
class ATgPawn_Biped : public ATgPawn
{
public:
	struct FName                                       m_nmLeftFootBone;                                 		// 0x1B28 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_nmRightFootBone;                                		// 0x1B30 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_nmLeftFootControlName;                          		// 0x1B38 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_nmRightFootControlName;                         		// 0x1B40 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fOldLocationZ;                                  		// 0x1B48 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bEnableRightFootPlacement : 1;                  		// 0x1B4C (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bEnableLeftFootPlacement : 1;                   		// 0x1B4C (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_bMayDisableFootIKFromAnimNodes : 1;             		// 0x1B4C (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_bInitializedFootIKCachedNodeList : 1;           		// 0x1B4C (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      m_bApplyLeftHandWeaponIK : 1;                     		// 0x1B4C (0x0004) [0x0000000000000000] [0x00000010] 
	unsigned long                                      m_bSetHandIKStrengthFromAnimNodes : 1;            		// 0x1B4C (0x0004) [0x0000000000000000] [0x00000020] 
	unsigned long                                      m_bInitializedHandIKCachedNodeList : 1;           		// 0x1B4C (0x0004) [0x0000000000000000] [0x00000040] 
	unsigned long                                      c_bPlayingRefire : 1;                             		// 0x1B4C (0x0004) [0x0000000000000000] [0x00000080] 
	unsigned long                                      c_bRefireIsUpperBody : 1;                         		// 0x1B4C (0x0004) [0x0000000000000000] [0x00000100] 
	float                                              m_fZSmoothingRate;                                		// 0x1B50 (0x0004) [0x0000000000000002]              ( CPF_Const )
	float                                              m_fMaxFootPlacementDistSquared;                   		// 0x1B54 (0x0004) [0x0000000000000000]              
	class USkelControlFootPlacement*                   m_LeftLegControl;                                 		// 0x1B58 (0x0004) [0x0000000000000000]              
	class USkelControlFootPlacement*                   m_RightLegControl;                                		// 0x1B5C (0x0004) [0x0000000000000000]              
	TArray< struct FName >                             m_FootIKZeroStrengthAnimNodeNameList;             		// 0x1B60 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UAnimNode* >                         m_FootIKZeroStrengthCachedNodeList;               		// 0x1B6C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FVector                                     m_vPreviousRightFootPosition;                     		// 0x1B78 (0x000C) [0x0000000000000000]              
	struct FVector                                     m_vPreviousLeftFootPosition;                      		// 0x1B84 (0x000C) [0x0000000000000000]              
	float                                              m_fCachedRightTracedFloor;                        		// 0x1B90 (0x0004) [0x0000000000000000]              
	float                                              m_fCachedLeftTracedFloor;                         		// 0x1B94 (0x0004) [0x0000000000000000]              
	float                                              m_fCachedRightFloorNormalZ;                       		// 0x1B98 (0x0004) [0x0000000000000000]              
	float                                              m_fCachedLeftFloorNormalZ;                        		// 0x1B9C (0x0004) [0x0000000000000000]              
	int                                                m_nCachedLeftFootBoneIndex;                       		// 0x1BA0 (0x0004) [0x0000000000000000]              
	int                                                m_nCachedRightFootBoneIndex;                      		// 0x1BA4 (0x0004) [0x0000000000000000]              
	struct FName                                       m_SkelControl_LeftHandName;                       		// 0x1BA8 (0x0008) [0x0000000000000000]              
	class USkelControlLimb*                            m_SkelControl_LeftHand;                           		// 0x1BB0 (0x0004) [0x0000000000000000]              
	class USkelControlSingleBone*                      m_SkelControl_LeftHandRotate;                     		// 0x1BB4 (0x0004) [0x0000000000000000]              
	struct FName                                       m_SkelControl_RightHandName;                      		// 0x1BB8 (0x0008) [0x0000000000000000]              
	class USkelControlLimb*                            m_SkelControl_RightHand;                          		// 0x1BC0 (0x0004) [0x0000000000000000]              
	class USkelControlSingleBone*                      m_SkelControl_RightHandRotate;                    		// 0x1BC4 (0x0004) [0x0000000000000000]              
	class USkelControlSingleBone*                      m_SkelControl_RightToLeftPropSwitch;              		// 0x1BC8 (0x0004) [0x0000000000000000]              
	TArray< struct FName >                             m_HandIKFullStrengthAnimNodeNameList;             		// 0x1BCC (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< struct FName >                             m_HandIKZeroStrengthAnimNodeNameList;             		// 0x1BD8 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UAnimNode* >                         m_HandIKFullStengthCachedNodeList;                		// 0x1BE4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UAnimNode* >                         m_HandIKZeroStrengthCachedNodeList;               		// 0x1BF0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class UMaterialInstanceConstant*                   m_FadeMaterialControllerBody;                     		// 0x1BFC (0x0004) [0x0000000000000000]              
	struct FName                                       c_RefireBeginBlendAnimationName;                  		// 0x1C00 (0x0008) [0x0000000000000000]              
	struct FName                                       c_RefireEndBlendAnimationName;                    		// 0x1C08 (0x0008) [0x0000000000000000]              
	class UAnimSet*                                    c_RefireAnimSet;                                  		// 0x1C10 (0x0004) [0x0000000000000000]              
	float                                              c_fRefireDuration;                                		// 0x1C14 (0x0004) [0x0000000000000000]              
	float                                              c_fRefireEndDuration;                             		// 0x1C18 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2745 );

		return pClassPointer;
	};

	void eventLanded ( struct FVector HitNormal, class AActor* FloorActor );
	bool CanTrackATarget ( );
	void SetAimTarget ( float X, float Y, float Z );
	void eventEnableFootControls ( int foot, unsigned long bDisable );
	void zpivot ( float F );
	void CacheMainMeshReferences ( class UTgSkeletalMeshComponent* smcomp );
	void PostBeginPlay ( );
	void EndRefireTimer ( );
	void EndRefire ( );
	void BeginRefire ( );
	bool InitializeFootIKZeroStrengthAnimNodes ( class USkeletalMeshComponent* SkelComp );
	bool InitializeLeftHandIKAnimNodes ( class USkeletalMeshComponent* SkelComp );
};

UClass* ATgPawn_Biped::pClassPointer = NULL;

// Class TgGame.TgPawn_Character
// 0x0050 (0x1C6C - 0x1C1C)
class ATgPawn_Character : public ATgPawn_Biped
{
public:
	unsigned long                                      c_bUpdatePlayerStatUI : 1;                        		// 0x1C1C (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bCachedTeleportResult : 1;                      		// 0x1C1C (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	unsigned long                                      s_bRepossessOnPawnSwap : 1;                       		// 0x1C1C (0x0004) [0x0000000000000000] [0x00000004] 
	float                                              c_AttackDurationPausePercentage;                  		// 0x1C20 (0x0004) [0x0000000000000002]              ( CPF_Const )
	TArray< struct FPERSISTENT_BUFF_STRUCT >           m_PersistentBuffs;                                		// 0x1C24 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< struct FTG_HUD_INFO >                      c_HudInfos;                                       		// 0x1C30 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	float                                              m_fLastCapturePointReclaimedTime;                 		// 0x1C3C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_fMinReclaimPointTime;                           		// 0x1C40 (0x0004) [0x0000000000000000]              
	float                                              m_fLastHealthLowMessageTime;                      		// 0x1C44 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_fMinHealthLowMessageTime;                       		// 0x1C48 (0x0004) [0x0000000000000000]              
	float                                              m_minWardEmoteTime;                               		// 0x1C4C (0x0004) [0x0000000000000000]              
	float                                              m_lastWardEmoteTime;                              		// 0x1C50 (0x0004) [0x0000000000000000]              
	float                                              m_fMinItemEmoteTime;                              		// 0x1C54 (0x0004) [0x0000000000000000]              
	float                                              m_fLastItemEmoteTime;                             		// 0x1C58 (0x0004) [0x0000000000000000]              
	float                                              m_vCachedTeleportTimestamp;                       		// 0x1C5C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FVector                                     m_vCachedTeleportDestination;                     		// 0x1C60 (0x000C) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2746 );

		return pClassPointer;
	};

	bool eventAnimNotifySound ( class USoundCue* Cue, class UAnimNodeSequence* OwningNode, float VolumeMultipler, float PitchMultipler );
	void eventPlayEmote ( unsigned char Emote, int ExtraInfo );
	bool eventDied ( class AController* Killer, class UClass* dmgType, struct FVector HitLocation );
	void ResetAnimPlayRate ( );
	void ResumeAnimationsAfterHit ( );
	void OnMeleeHitAnimationPause ( int nEquipSlot );
	void PossessedBy ( class AController* C, unsigned long bVehicleTransition );
	void eventInterruptRecallFromDamage ( );
	void eventInterruptRecall ( );
	bool eventShouldInterruptRecall ( unsigned long bDebugLog, unsigned char Slot );
	void Tick ( float DeltaSeconds );
	void eventReplicatedEvent ( struct FName VarName );
	void eventClientUpdateAttackSpeed ( float fAttackSpeed );
	void eventReceivedPropValues ( );
	bool eventPostPawnSetup ( );
	void CharacterPawnControllerSet ( );
	void ResetKillCombo ( );
	void eventTakeDamage ( int Damage, class AController* InstigatedBy, struct FVector HitLocation, struct FVector Momentum, class UClass* DamageType, struct FTraceHitInfo HitInfo, class AActor* DamageCauser );
	bool TakeDamageSpecial ( int Damage, class AController* InstigatedBy, struct FVector HitLocation, struct FVector Momentum, class UClass* DamageType, struct FTraceHitInfo HitInfo, class AActor* DamageCauser );
	void PlaySpawnFx ( );
	void PrepareIntro ( );
	void PostBeginPlay ( );
	void PlaySeasonalDyingEffects ( );
	void NotifyTeamOnKillComboReset ( );
	bool GetPassiveAuxMax ( float* fResult );
	bool GetPassiveAux ( float* fResult );
	bool GetPassiveString ( struct FString* sResult );
	bool GetPassiveBool ( int* bResult );
	bool GetPassiveInt2 ( int* nResult );
	bool GetPassiveInt1 ( int* nResult );
	void AddTargetingAidHudInfos ( class ATgPlayerController* PC, struct FVector* CamLoc, struct FVector* CamRot );
	int GetPassiveRank ( );
	class UTgDeviceFire* GetPassiveFireMode ( );
	class ATgDevice* GetPassiveDevice ( );
	bool IsPassiveTrained ( );
	void OnSilenceOther ( class ATgPawn* Target, class UTgEffectGroup* effectGroup );
	void OnKnockupEnd ( class AActor* Target );
	void OnSpecialKnockback ( class AActor* Target, class AActor* BlockingActor );
	void EffectGroupOnApplied ( class UTgEffectGroup* effectGroup, unsigned long bInterval );
	void EffectGroupOnSetActive ( unsigned long bActive, unsigned long bRemoving, class UTgEffectGroup* effectGroup );
	void DeviceOnProjShutdown ( class ATgDevice* Dev );
	void DeviceAdjustDamage ( class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage );
	void DeviceOnKilled ( class ATgDevice* Dev, float fDamage, struct FImpactInfo* Impact );
	void DeviceOnHealed ( struct FOnHealedParams* Params );
	void DeviceOnDodged ( struct FOnDodgedParams* Params );
	void DeviceOnAbsorbHit ( struct FOnAbsorbHitParams* Params );
	void DeviceOnDamaged ( struct FOnDamagedParams* Params );
	void DeviceOnHitSpecial ( class ATgDevice* Dev, int nHitSpecialSituationalType, struct FImpactInfo* Impact );
	void DeviceOnHit ( class ATgDevice* Dev, struct FImpactInfo* Impact );
	void DeviceOnStartCooldown ( class ATgDevice* Dev, float CooldownTime );
	void DeviceOnStopFire ( class ATgDevice* Dev, unsigned long WasInterrupted );
	void DeviceOnStartFire ( class ATgDevice* Dev );
	void DeviceOnFire ( class ATgDevice* Dev );
	void DeviceOnAboutToFire ( class ATgDevice* Dev );
	void PawnOnLifesteal ( class ATgPawn* attacker, class UTgEffectGroup* effectGroup, float* lifestealAmount );
	void PawnOnCombatEvent ( );
	void PawnOnExitCombat ( );
	void PawnOnEnterCombat ( );
	void PawnOnRevive ( );
	void PawnOnHealed ( struct FOnHealedParams* Params );
	void PawnOnAssisted ( class AActor* Victim, int* xpGain, int* goldGain );
	void PawnOnKilled ( class AActor* Victim, int* xpGain, int* goldGain );
	void PawnOnDodged ( struct FOnDodgedParams* Params );
	void PawnOnAbsorbHit ( struct FOnAbsorbHitParams* Params );
	void PawnOnDamaged ( struct FOnDamagedParams* Params );
	bool CacheTeleportDestination ( unsigned long bteleporting, struct FVector Destination );
	bool GetTeleportDestination ( struct FVector* Destination );
	void OnPawnDied ( );
	bool ApplyMonsterRewardEffects ( class UTgInventoryObject* pItem, unsigned long bRemove );
	bool ApplyItemEffects ( class UTgInventoryObject* pItem, unsigned long bRemove );
	void ReapplyLoadoutEffects ( );
	bool DeviceOnCanDeviceFireNow ( class ATgDevice* Dev, unsigned char FireModeNum, unsigned long bDeviceFailLog, struct FAimData* Aim );
	void LoadDisconnectedPlayerState ( );
	bool ApplyPawnSetup ( );
};

UClass* ATgPawn_Character::pClassPointer = NULL;

// Class TgGame.TgPawn_Agni
// 0x0038 (0x1CA4 - 0x1C6C)
class ATgPawn_Agni : public ATgPawn_Character
{
public:
	int                                                m_CombustionCounter;                              		// 0x1C6C (0x0004) [0x0000000000000000]              
	struct FVector                                     m_LastPathOfFlamesDeployableLocation;             		// 0x1C70 (0x000C) [0x0000000000000000]              
	float                                              m_PathOfFlamesDistanceInterval;                   		// 0x1C7C (0x0004) [0x0000000000000000]              
	int                                                r_RainFireAmmunitionCount;                        		// 0x1C80 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                c_RainFireAmmunitionCount;                        		// 0x1C84 (0x0004) [0x0000000000000000]              
	TArray< class ATgDeployable* >                     m_CombustingDeployables;                          		// 0x1C88 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	unsigned long                                      c_bCombustionFxActive : 1;                        		// 0x1C94 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      c_bCombustionDisplayGroupActive : 1;              		// 0x1C94 (0x0004) [0x0000000000000000] [0x00000002] 
	float                                              c_fCombustionFxWeight;                            		// 0x1C98 (0x0004) [0x0000000000000000]              
	float                                              c_fCombustionFxRate;                              		// 0x1C9C (0x0004) [0x0000000000000000]              
	float                                              c_RemainingAmmoReplenishTime;                     		// 0x1CA0 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2747 );

		return pClassPointer;
	};

	bool IgnoreFaceRotationWithInterp ( );
	void TickCombustionFx ( float DeltaSeconds );
	void CombustionForceCombatWary ( );
	void UpdateCombustionMIC ( );
	void ToggleCombustionFx ( unsigned long bEnable, float fTweenTime );
	void ReceivedPropValues ( );
	void eventPostDemoRewind ( );
	void eventReplicatedEvent ( struct FName VarName );
	void ExpendRainFireAmmunition ( );
	void PlayAndUpdateRainFirePSC ( unsigned long IsPlayingDeath, unsigned long IsPlayingRespawn );
	void ReplenishRainFireAmmunition ( );
	void UpdateRainFireAmmoReplenishTime ( float NewTime );
	void Tick ( float DeltaSeconds );
	void OnRespawn ( );
	void PlayDyingEffects ( );
	bool GetPassiveInt2 ( int* nResult );
	bool GetPassiveInt1 ( int* nResult );
	bool ConsumeCombustionCounter ( unsigned long bForce );
	void IncrementCombustionCounter ( );
	void SpawnPathOfFlamesFire ( struct FVector SpawnLocation );
	float GetPathOfFlamesDistanceInterval ( );
	bool DeviceOverrideTargetingAim ( class ATgDevice* Dev, struct FAimData* Aim, TArray< struct FImpactInfo >* ImpactList );
	void DeviceOnStopFire ( class ATgDevice* Dev, unsigned long WasInterrupted );
	void DeviceOnHit ( class ATgDevice* Dev, struct FImpactInfo* Impact );
	void DeviceOnStartFire ( class ATgDevice* Dev );
	void PawnOnSpecialReset ( );
	void PawnOnReduceActiveCooldowns ( float fValue, unsigned long bPercentage );
	void PostPawnSetupServer ( );
};

UClass* ATgPawn_Agni::pClassPointer = NULL;

// Class TgGame.TgPawn_AhMuzenCab
// 0x0058 (0x1CC4 - 0x1C6C)
class ATgPawn_AhMuzenCab : public ATgPawn_Character
{
public:
	TArray< class ATgDeployable_AhMuzenCab_Hive* >     m_Hives;                                          		// 0x1C6C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class ATgAhMuzenCabSwarmInstance*                  m_Num2Strain;                                     		// 0x1C78 (0x0004) [0x0000000000000000]              
	unsigned long                                      r_bHoneySprayEffectsActive : 1;                   		// 0x1C7C (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )
	unsigned long                                      r_bIsHoneyDeviceActive : 1;                       		// 0x1C7C (0x0004) [0x0000000000000020] [0x00000002] ( CPF_Net )
	unsigned long                                      m_bPendingBeeBuff : 1;                            		// 0x1C7C (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_bKilledByUltStinger : 1;                        		// 0x1C7C (0x0004) [0x0000000000000000] [0x00000008] 
	int                                                c_Num3PostureIndex;                               		// 0x1C80 (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                m_HoneyBeamFx;                                    		// 0x1C84 (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                m_HoneySprayEndFx;                                		// 0x1C88 (0x0004) [0x0000000000000000]              
	struct FVector                                     r_vNum3HoneyEndLocation;                          		// 0x1C8C (0x000C) [0x0000000000000020]              ( CPF_Net )
	TArray< class ATgDeployable_AhMuzenCab_HoneyPool* > m_HoneyPools;                                     		// 0x1C98 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class ATgAhMuzenCabSwarmInstance*                  m_Num3Strain;                                     		// 0x1CA4 (0x0004) [0x0000000000000000]              
	TArray< class ATgAhMuzenCabSwarmInstance* >        m_SwarmStrains;                                   		// 0x1CA8 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< struct FHoneyVictimInfo >                  m_HoneyVictimList;                                		// 0x1CB4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class ATgDeployable_AhMuzenCab_Stinger*            r_DeployedStinger;                                		// 0x1CC0 (0x0004) [0x0000000000000020]              ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2748 );

		return pClassPointer;
	};

	void SetDeployableStinger ( class ATgDeployable_AhMuzenCab_Stinger* DeployedStinger );
	void StopNum3EquipEffects ( );
	void PlayNum3EquipEffects ( );
	void ServerTargetingDeviceSet ( class ATgDevice* Dev );
	void eventSetTargetingDevice ( class ATgDevice* Dev );
	void OnRespawn ( );
	void UnRegisterHoneyPool ( class ATgDeployable_AhMuzenCab_HoneyPool* HoneyPoolToRemove );
	void RegisterHoneyPool ( class ATgDeployable_AhMuzenCab_HoneyPool* NewHoneyPool );
	void UnRegisterHive ( class ATgDeployable_AhMuzenCab_Hive* HiveToRemove );
	void RegisterHive ( class ATgDeployable_AhMuzenCab_Hive* NewHive );
	void eventEnableHoneySprayEffects ( unsigned long bActive );
	void eventReplicatedEvent ( struct FName VarName );
	void PawnOnHealed ( struct FOnHealedParams* Params );
	void PlayTeleportFx ( int nTeleportState, struct FVector vLoc );
	void DropStinger ( struct FImpactInfo Impact );
	float GetSmoothEnergy ( );
	float AdjustRespawnTime ( float InRespawnTime );
	void KillSelfFromFailedStinger ( );
	float ApplySwarmToTarget ( class ATgPawn* Target, float SwarmTime, class ATgAhMuzenCabSwarmInstance* SwarmInstance, unsigned long bBasicAttack );
	void ReapplyLoadoutEffects ( );
	void EffectGroupOnSetActive ( unsigned long bActive, unsigned long bRemoving, class UTgEffectGroup* effectGroup );
	void DeviceOnSetFireMode ( class ATgDevice* Dev );
	void DeviceAdjustDamage ( class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage );
	bool DeviceOverrideTargetingAim ( class ATgDevice* Dev, struct FAimData* Aim, TArray< struct FImpactInfo >* ImpactList );
	void DeviceOnKilled ( class ATgDevice* Dev, float fDamage, struct FImpactInfo* Impact );
	void DeviceOnHit ( class ATgDevice* Dev, struct FImpactInfo* Impact );
	void DeviceOnStopFire ( class ATgDevice* Dev, unsigned long WasInterrupted );
	void DeviceOnStartFire ( class ATgDevice* Dev );
};

UClass* ATgPawn_AhMuzenCab::pClassPointer = NULL;

// Class TgGame.TgPawn_AhPuch
// 0x0080 (0x1CEC - 0x1C6C)
class ATgPawn_AhPuch : public ATgPawn_Character
{
public:
	int                                                r_nCurrentCorpses;                                		// 0x1C6C (0x0004) [0x0000000000000020]              ( CPF_Net )
	unsigned long                                      c_bCorpsePickupDisplayGroupActive : 1;            		// 0x1C70 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      s_bIsAhPuchFireHeightSet : 1;                     		// 0x1C70 (0x0004) [0x0000000000000000] [0x00000002] 
	float                                              s_fAhPuchFireHeight;                              		// 0x1C74 (0x0004) [0x0000000000000000]              
	int                                                r_nCorpseExplosionsThisFire;                      		// 0x1C78 (0x0004) [0x0000000000000020]              ( CPF_Net )
	struct FVector                                     r_vWarmupLoc[ 0x6 ];                              		// 0x1C7C (0x0048) [0x0000000000000020]              ( CPF_Net )
	TArray< struct FDev3Victim >                       m_Dev3VictimPawns;                                		// 0x1CC4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class UTgMarkComponent_AhPuch_Dev3*                m_Dev3DotMark;                                    		// 0x1CD0 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	TArray< class UTgDeviceFire* >                     m_Dev3Modes;                                      		// 0x1CD4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UTgDeviceFire* >                     m_Dev4SubModes;                                   		// 0x1CE0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2749 );

		return pClassPointer;
	};

	void eventResetCorpseWarmupLocations ( );
	int eventGetCorpseWarmupCount ( );
	void eventSpawnZombie ( struct FVector vLocation, struct FVector vNormal, struct FVector vInitialLocation, unsigned long bFromDev3 );
	void eventReplicatedEvent ( struct FName VarName );
	int GetDev3VictimIndex ( class AActor* Target );
	void EndHealListening ( unsigned long bWasInterrupted );
	void StartHealListening ( class AActor* Target );
	void UltAOEHitSpecial ( );
	void ConsumeCorpse ( );
	bool GetPassiveAux ( float* fResult );
	void OnPawnDied ( );
	void PlayTeleportFx ( int nTeleportState, struct FVector vLoc );
	void DeviceAdjustDamage ( class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage );
	void DeviceOnHit ( class ATgDevice* Dev, struct FImpactInfo* Impact );
	void DeviceOnFire ( class ATgDevice* Dev );
	void DeviceOnStartFire ( class ATgDevice* Dev );
	bool DeviceOverrideTargetingAim ( class ATgDevice* Dev, struct FAimData* Aim, TArray< struct FImpactInfo >* ImpactList );
	void DeviceOnSetFireMode ( class ATgDevice* Dev );
};

UClass* ATgPawn_AhPuch::pClassPointer = NULL;

// Class TgGame.TgPawn_Anhur
// 0x0000 (0x1C6C - 0x1C6C)
class ATgPawn_Anhur : public ATgPawn_Character
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2750 );

		return pClassPointer;
	};

	void EndTween ( unsigned char endingTweenState, unsigned long bInterrupted );
	void BeginTween ( unsigned char newTweenState );
	void DeviceAdjustDamage ( class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage );
	bool DeviceOverrideTargetingAim ( class ATgDevice* Dev, struct FAimData* Aim, TArray< struct FImpactInfo >* ImpactList );
	void DeviceOnHit ( class ATgDevice* Dev, struct FImpactInfo* Impact );
	void DeviceOnStartFire ( class ATgDevice* Dev );
};

UClass* ATgPawn_Anhur::pClassPointer = NULL;

// Class TgGame.TgPawn_Anubis
// 0x0008 (0x1C74 - 0x1C6C)
class ATgPawn_Anubis : public ATgPawn_Character
{
public:
	int                                                r_nPassiveStacks;                                 		// 0x1C6C (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                m_nPassiveEffectGroupId;                          		// 0x1C70 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2751 );

		return pClassPointer;
	};

	void eventPlayEmote ( unsigned char Emote, int nExtraInfo );
	bool eventCanPlayHitReaction ( );
	void DeviceOnStartFire ( class ATgDevice* Dev );
	struct FString GetEmoteCustomSuffix ( unsigned char Emote, int ExtraInfo );
	struct FString GetVGSCustomSuffix ( int nPreferredVPSetting );
	void PlaySkinLevelUpFx ( );
	void PlayTeleportFx ( int nTeleportState, struct FVector vLoc );
	void EffectGroupOnApplied ( class UTgEffectGroup* effectGroup, unsigned long bInterval );
	void EffectGroupOnSetActive ( unsigned long bActive, unsigned long bRemoving, class UTgEffectGroup* effectGroup );
	bool GetPassiveAux ( float* fResult );
	float GetSpellVamp ( );
	class UClass* DeviceOnOverrideDamageType ( class ATgDevice* Dev, class UTgEffectGroup* effectGroup );
	void DeviceOnHit ( class ATgDevice* Dev, struct FImpactInfo* Impact );
	struct FVector CalculateDeathGazeTargetPosition ( );
};

UClass* ATgPawn_Anubis::pClassPointer = NULL;

// Class TgGame.TgPawn_AoKuang
// 0x0138 (0x1DA4 - 0x1C6C)
class ATgPawn_AoKuang : public ATgPawn_Character
{
public:
	unsigned long                                      r_bSwordInHand : 1;                               		// 0x1C6C (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )
	unsigned long                                      c_bLocalSwordInHand : 1;                          		// 0x1C6C (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      c_bGlowOff : 1;                                   		// 0x1C6C (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_bTransformInProgress : 1;                       		// 0x1C6C (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      m_bTriggerTransformMeshChange : 1;                		// 0x1C6C (0x0004) [0x0000000000000000] [0x00000010] 
	unsigned long                                      m_bTriggerTransformToNormalMesh : 1;              		// 0x1C6C (0x0004) [0x0000000000000000] [0x00000020] 
	unsigned long                                      m_bUseBestDashLocation : 1;                       		// 0x1C6C (0x0004) [0x0000000000000000] [0x00000040] 
	float                                              s_fSwordExpireTime;                               		// 0x1C70 (0x0004) [0x0000000000000002]              ( CPF_Const )
	float                                              c_fSwordSwapInCooldown;                           		// 0x1C74 (0x0004) [0x0000000000000000]              
	int                                                c_nSwordEnergyLevel;                              		// 0x1C78 (0x0004) [0x0000000000000000]              
	float                                              m_fDelayedSwordGlowShutdownTime;                  		// 0x1C7C (0x0004) [0x0000000000000000]              
	TArray< class ATgDevice* >                         s_ConsumeNextChargeForFree;                       		// 0x1C80 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UTgAnimNodeBlendList* >              c_WaterIllusionBlendNodes;                        		// 0x1C8C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FName                                       c_WaterIllusionNodeName;                          		// 0x1C98 (0x0008) [0x0000000000000000]              
	TArray< class UTgAnimNodeBlendList* >              c_DragonCallBlendNodes;                           		// 0x1CA0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FName                                       c_DragonCallNodeName;                             		// 0x1CAC (0x0008) [0x0000000000000000]              
	unsigned char                                      r_DragonBushelState;                              		// 0x1CB4 (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      c_LocalDragonBushelState;                         		// 0x1CB5 (0x0001) [0x0000000000000000]              
	unsigned char                                      r_eUltimateState;                                 		// 0x1CB6 (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      m_eLocalUltState;                                 		// 0x1CB7 (0x0001) [0x0000000000000000]              
	unsigned char                                      r_CurrentTransformState;                          		// 0x1CB8 (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      c_PrevTransformState;                             		// 0x1CB9 (0x0001) [0x0000000000000000]              
	unsigned char                                      c_LocalTransformState;                            		// 0x1CBA (0x0001) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_DragonBushelAssemblyId;                         		// 0x1CBC (0x0004) [0x0000000000000000]              
	struct FPointer                                    m_DragonBushelAssembly;                           		// 0x1CC0 (0x0004) [0x0000000000001000]              ( CPF_Native )
	class USkeletalMeshComponent*                      c_DragonBushelMesh;                               		// 0x1CC4 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	TArray< class USkelControlBase* >                  c_DragonBushelDragonScalers;                      		// 0x1CC8 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class USkelControlBase* >                  c_DragonBushelDissipateControls;                  		// 0x1CD4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class USkelControlBase* >                  c_DragonBushelCombineControls;                    		// 0x1CE0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FName                                       c_DragonBushelDragonScalerBaseName;               		// 0x1CEC (0x0008) [0x0000000000000000]              
	struct FName                                       c_DragonBushelDragonSocketBaseName;               		// 0x1CF4 (0x0008) [0x0000000000000000]              
	struct FName                                       c_DragonBushelDissipateName;                      		// 0x1CFC (0x0008) [0x0000000000000000]              
	struct FName                                       c_DragonBushelCombineName;                        		// 0x1D04 (0x0008) [0x0000000000000000]              
	float                                              c_DragonBushelDissipateTime;                      		// 0x1D0C (0x0004) [0x0000000000000000]              
	float                                              c_DragonBushelCombineTime;                        		// 0x1D10 (0x0004) [0x0000000000000000]              
	TArray< class UAnimNodeSequence* >                 m_TransformIntroSequenceNodes;                    		// 0x1D14 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UTgAnimBlendByAoKuangDragon* >       m_DragonAttackNodes;                              		// 0x1D20 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FName                                       c_DragonAttackAnimName;                           		// 0x1D2C (0x0008) [0x0000000000000000]              
	struct FName                                       c_UltimateDashAnimName;                           		// 0x1D34 (0x0008) [0x0000000000000000]              
	struct FName                                       c_UltimateStunAnimName;                           		// 0x1D3C (0x0008) [0x0000000000000000]              
	struct FName                                       c_UltimateStunKillAnimName;                       		// 0x1D44 (0x0008) [0x0000000000000000]              
	struct FName                                       c_TransformIntroAnimName;                         		// 0x1D4C (0x0008) [0x0000000000000000]              
	struct FName                                       c_TransformOutroAnimName;                         		// 0x1D54 (0x0008) [0x0000000000000000]              
	class AActor*                                      r_UltimateDastTarget;                             		// 0x1D5C (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              m_fDashTargetBufferSpace;                         		// 0x1D60 (0x0004) [0x0000000000000000]              
	struct FVector                                     m_BestDashLocation;                               		// 0x1D64 (0x000C) [0x0000000000000000]              
	class UTgEffectGroup*                              s_InterimCCImmunity;                              		// 0x1D70 (0x0004) [0x0000000000000000]              
	float                                              s_fUltimateCancelTime;                            		// 0x1D74 (0x0004) [0x0000000000000000]              
	class UClass*                                      c_UltimateCameraModuleClass;                      		// 0x1D78 (0x0004) [0x0000000000000000]              
	class UClass*                                      c_PreviousCameraModuleClass;                      		// 0x1D7C (0x0004) [0x0000000000000000]              
	class UTgCameraModule*                             c_UltimateCameraMod;                              		// 0x1D80 (0x0004) [0x0000000000000000]              
	int                                                m_TransformMeshAssemblyIds[ 0x2 ];                		// 0x1D84 (0x0008) [0x0000000000000000]              
	struct FPointer                                    m_TransformBodyMeshAssemblies[ 0x2 ];             		// 0x1D8C (0x0008) [0x0000000000001000]              ( CPF_Native )
	struct FPointer                                    m_TransformDestroyedMeshAssemblies[ 0x2 ];        		// 0x1D94 (0x0008) [0x0000000000001000]              ( CPF_Native )
	int                                                m_TransformDesiredAssemblyId;                     		// 0x1D9C (0x0004) [0x0000000000000000]              
	int                                                m_TransformDesiredDestroyedAssemblyId;            		// 0x1DA0 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2752 );

		return pClassPointer;
	};

	bool IsInClassSpecificMovement ( );
	bool eventConsumeCharge ( class AActor* ChargeConsumer );
	void OnRespawn ( );
	void PlayNearDeathCleanup ( );
	void PlayDying ( class UClass* dmgType, struct FVector HitLoc );
	struct FVector eventGetPhysTweenTargetLocation ( );
	void EndTween ( unsigned char endingTweenState, unsigned long bInterrupted );
	void BeginTween ( unsigned char newTweenState );
	void DragonTweenEnd ( unsigned long bInterrupted, unsigned long EndTransform );
	void DashTweenEnd ( unsigned long bInterrupted );
	void DragonTweenStart ( unsigned long bRemoveRoots );
	void OnDeviceFormInterruptFire ( int nEquipSlot );
	void OnDeviceFormStartFire ( int nEquipSlot, float FireDuration, int nFireMode );
	void OnDeviceFormBuildup ( int nEquipSlot, float fBuildupTime );
	void eventToggleUltimateCameraMod ( unsigned long bOn );
	void eventOnAnimEnd ( class UAnimNodeSequence* SeqNode, float PlayedTime, float ExcessTime );
	void CacheMultiMeshAnimNodeReferences ( class UTgSkeletalMeshComponent* smcomp );
	void ClearMultiMeshAnimNodeReferences ( );
	void CacheMainMeshReferences ( class UTgSkeletalMeshComponent* smcomp );
	void eventCombat ( unsigned long bInCombat );
	void Tick ( float DeltaSeconds );
	bool IsFullBodyUltAnimPlaying ( );
	void ClientUpdateUltimateState ( unsigned char NewState );
	void EndUltimateCancel ( );
	bool IsInputLocked ( );
	void OnTeleportNotify ( class AActor* TeleportingActor );
	void ClientSetBestDashLocation ( float DashX, float DashY, float DashZ );
	void SetBestDashLocation ( struct FVector BestLocation );
	void LoseUltimateDashTarget ( );
	void SetUltimateDashTarget ( class AActor* Target );
	void eventUpdateUltimateState ( unsigned char NewState );
	void DelayedSwordGlowShutdown ( );
	void eventUpdateSwordEnergyLevel ( int nOverride, unsigned long bForce );
	void PutAwaySword ( );
	void eventSetSwordInHand ( unsigned long bInHand );
	void StartPassiveRegen ( );
	bool eventIsSwordInHand ( );
	void eventPostInitAnimTree ( class USkeletalMeshComponent* SkelComp );
	void EndDragonBuff ( );
	void BeginDragonBuffCombine ( );
	void eventBeginDragonBuffDissipate ( );
	void eventUpdateDragonBushelState ( unsigned char NewState );
	void eventReceivedPropValues ( );
	void eventReplicatedEvent ( struct FName VarName );
	void SetSpawnEnergy ( );
	bool OverrideDistanceFadeRange ( );
	void AdjustMeshTranslation ( );
	void SetMeshVisibility ( unsigned long bVisible );
	void SwapTransformMesh ( );
	void SwapToDestroyedMesh ( );
	void SwapToLiveMesh ( );
	void OnPostureChange ( );
	void OnTransformTransitionEnd ( );
	void StartTransform ( unsigned char NewStance, unsigned long bSkipTransition );
	bool CalcBestDashLocation ( class AActor* Target, struct FVector* BestLocation );
	struct FVector UsedDragonFromBushel ( );
	void BeginDragonBuff ( unsigned char StartState );
	void CacheDragonBushelControls ( class UTgSkeletalMeshComponent* SkelComp );
	void CreateDragonBushelMesh ( );
	bool DeviceOverrideManaUseVitals ( class ATgDevice* Dev, class ATgPlayerController* PC );
	bool DeviceOnCanDeviceFireNow ( class ATgDevice* Dev, unsigned char FireModeNum, unsigned long bDeviceFailLog, struct FAimData* Aim );
	bool DeviceOnCanDeviceCriticalStrike ( class ATgDevice* Dev, int nPropertyId, int nDamageType, struct FImpactInfo* Impact, float* fCritChance );
	void DeviceOnStopFire ( class ATgDevice* Dev, unsigned long WasInterrupted );
	void DeviceOnStartFire ( class ATgDevice* Dev );
	void DeviceOnStopBuildup ( class ATgDevice* Dev, unsigned long WasInterrupted );
	void DeviceOnStartBuildup ( class ATgDevice* Dev );
	void ReapplyLevelEffectGroups ( int nPrevLevel, int nCurrentLevel, unsigned long bPreserveParams );
	bool DeviceHasEnoughPowerPool ( class ATgDevice* Dev, unsigned char FireModeNum );
	void ConsumePowerPool ( class ATgDevice* Dev, int nPacingType, float fAmount );
};

UClass* ATgPawn_AoKuang::pClassPointer = NULL;

// Class TgGame.TgPawn_Aphrodite
// 0x00A4 (0x1D10 - 0x1C6C)
class ATgPawn_Aphrodite : public ATgPawn_Character
{
public:
	unsigned long                                      m_bAllowLinksToDieOut : 1;                        		// 0x1C6C (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      c_bSoulMateActive : 1;                            		// 0x1C6C (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_bEnableJealousDamageBuff : 1;                   		// 0x1C6C (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_bEnableUndyingLove : 1;                         		// 0x1C6C (0x0004) [0x0000000000000000] [0x00000008] 
	float                                              m_fDeadLinkShrinkRate;                            		// 0x1C70 (0x0004) [0x0000000000000000]              
	struct FVector                                     m_vSpineOffset;                                   		// 0x1C74 (0x000C) [0x0000000000000000]              
	TArray< struct FSoulMateLinkInfo >                 c_DeadSoulMateLinks;                              		// 0x1C80 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	struct FSoulMateLinkInfo                           c_ActiveSoulMateLink;                             		// 0x1C8C (0x0030) [0x0000000000002000]              ( CPF_Transient )
	class UTgSpecialFx*                                c_SoulMateLinkExplosion;                          		// 0x1CBC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UTgSpecialFx*                                c_SoulMateLinkWarning;                            		// 0x1CC0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UTgMarkComponent_Aphrodite_SoulMates*        m_SoulMateMark;                                   		// 0x1CC4 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class AActor*                                      r_SoulMateLinkActor;                              		// 0x1CC8 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              r_fWorryMoveDistance;                             		// 0x1CCC (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              r_fLinkRange;                                     		// 0x1CD0 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              s_fForceBreakRange;                               		// 0x1CD4 (0x0004) [0x0000000000000000]              
	float                                              s_fGracePeriod;                                   		// 0x1CD8 (0x0004) [0x0000000000000000]              
	float                                              s_fLeftOverTransferableHealth;                    		// 0x1CDC (0x0004) [0x0000000000000000]              
	float                                              s_fLeftOverTransferableMana;                      		// 0x1CE0 (0x0004) [0x0000000000000000]              
	float                                              s_fTransferableHealth;                            		// 0x1CE4 (0x0004) [0x0000000000000000]              
	float                                              s_fTransferableMana;                              		// 0x1CE8 (0x0004) [0x0000000000000000]              
	class UTgMarkComponent_Aphrodite_Base*             m_JealousDamageBuffMark;                          		// 0x1CEC (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	TArray< class UTgDeviceFire* >                     m_JealousDeviceModes;                             		// 0x1CF0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	float                                              m_fGetAwayPulseValue;                             		// 0x1CFC (0x0004) [0x0000000000000000]              
	float                                              m_fGetAwayPulseRate;                              		// 0x1D00 (0x0004) [0x0000000000000000]              
	float                                              r_fGetAwayPulseDuration;                          		// 0x1D04 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class UTgMarkComponent_Aphrodite_Base*             m_UndyingLoveMark;                                		// 0x1D08 (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )
	int                                                r_nPassiveAux;                                    		// 0x1D0C (0x0004) [0x0000000000000020]              ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2753 );

		return pClassPointer;
	};

	void OnDeviceFormStartFire ( int nEquipPoint, float fFireDuration, int nFireMode );
	void TickGetAwayPulse ( float DeltaTime );
	void eventStartGetAwayPulse ( float fDuration );
	void UpdateLinkVisibility ( struct FSoulMateLinkInfo* LinkInfo );
	bool UpdateSoulMateLink ( float DeltaTime, struct FSoulMateLinkInfo* LinkInfo );
	void TickSoulMateLinks ( float DeltaTime );
	void eventSetSoulMateLinkActor ( class AActor* SoulMate, unsigned long bEnable );
	struct FSoulMateLinkInfo CreateSoulMateLink ( class AActor* SoulMate );
	void DeactivateSoulMateLink ( );
	void Tick ( float DeltaSeconds );
	void eventPostDemoRewind ( );
	bool PostPawnSetup ( );
	void eventReplicatedEvent ( struct FName VarName );
	void OnPawnDied ( );
	void EndUndyingLove ( unsigned long bWasInterrupted );
	void StartUndyingLove ( class ATgDevice* Dev );
	void EndJealousDamageBuff ( unsigned long bWasInterrupted );
	void StartJealousDamageBuff ( class ATgDevice* Dev, class AActor* Target );
	class AActor* GetSoulMateServer ( int* Index );
	bool IsSoulMate ( class AActor* Other );
	bool HasSoulMate ( );
	void ApplySoulMateHeals ( );
	void StartSoulMateHealsTimer ( );
	void CalcSoulMateLinkLocation ( class AActor* SoulMate, struct FVector* LinkLocation );
	class UTgSpecialFx* GetSoulMateLinkFxAndMic ( class UMaterialInstanceConstant* MIC );
	bool InitSoulMateLinkExplosionFx ( );
	bool GetPassiveAuxMax ( float* fResult );
	bool GetPassiveAux ( float* fResult );
	void EffectGroupOnApplied ( class UTgEffectGroup* effectGroup, unsigned long bInterval );
	void EffectGroupOnSetActive ( unsigned long bActive, unsigned long bRemoving, class UTgEffectGroup* effectGroup );
	void RegainPools ( float DeltaSeconds );
	void PawnOnHealed ( struct FOnHealedParams* Params );
	bool DeviceOverrideTargetingAim ( class ATgDevice* Dev, struct FAimData* Aim, TArray< struct FImpactInfo >* ImpactList );
	void DeviceOnSetFireMode ( class ATgDevice* Dev );
	void DeviceOnHit ( class ATgDevice* Dev, struct FImpactInfo* Impact );
	void DeviceOnFire ( class ATgDevice* Dev );
};

UClass* ATgPawn_Aphrodite::pClassPointer = NULL;

// Class TgGame.TgPawn_Apollo
// 0x00D0 (0x1D3C - 0x1C6C)
class ATgPawn_Apollo : public ATgPawn_Character
{
public:
	unsigned long                                      r_bPassiveActive : 1;                             		// 0x1C6C (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )
	unsigned long                                      c_bLocalPassiveActive : 1;                        		// 0x1C6C (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_bSkyJumpAtLocation : 1;                         		// 0x1C6C (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_bSkyJumpHasFired : 1;                           		// 0x1C6C (0x0004) [0x0000000000000000] [0x00000008] 
	TArray< class UTgSpecialFx* >                      c_PassiveFx;                                      		// 0x1C70 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	TArray< class UTgAnimBlendByApolloPassive* >       c_PassiveNodes;                                   		// 0x1C7C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< struct FName >                             m_InHandSkelControlNames;                         		// 0x1C88 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class USkelControlSingleBone* >            m_InHandSkelControls;                             		// 0x1C94 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	float                                              m_fInHandTargetScale;                             		// 0x1CA0 (0x0004) [0x0000000000000000]              
	float                                              m_fInHandCurrentScale;                            		// 0x1CA4 (0x0004) [0x0000000000000000]              
	float                                              m_fInHandScalingRate;                             		// 0x1CA8 (0x0004) [0x0000000000000000]              
	class ATgCollisionProxy_Cylinder*                  m_ChargeCollisionProxy;                           		// 0x1CAC (0x0004) [0x0000000000000000]              
	TArray< struct FChargeHitInfo >                    m_ChargeHitInfos;                                 		// 0x1CB0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UTgDeviceFire* >                     m_ChargeExplosionModes;                           		// 0x1CBC (0x000C) [0x0000000000500000]              ( CPF_NeedCtorLink )
	float                                              r_fTheMovesAOERadius;                             		// 0x1CC8 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class UTgSkeletalMeshComponent*                    c_ChariotComponent;                               		// 0x1CCC (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )
	class UTgSkeletalMeshComponent*                    c_FuselageComponent;                              		// 0x1CD0 (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )
	class UTgAnimNodeAimOffset*                        c_ChariotAimOffset;                               		// 0x1CD4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UTgAnimNodeAimOffset*                        c_ApolloChariotAimOffset;                         		// 0x1CD8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	TArray< class UAudioComponent* >                   c_ChariotAudioComponents;                         		// 0x1CDC (0x000C) [0x0000000004482008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_NeedCtorLink | CPF_EditInline )
	class ATgDevice*                                   r_SkyJumpInHandDevice;                            		// 0x1CE8 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgDevice*                                   r_InHandDevice;                                   		// 0x1CEC (0x0004) [0x0000000000000020]              ( CPF_Net )
	class UTgDeviceFire*                               m_SkyJumpKnockBackMode;                           		// 0x1CF0 (0x0004) [0x0000000000000000]              
	TArray< class USoundCue* >                         m_ChariotSoundCues;                               		// 0x1CF4 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	int                                                r_nSkyJumpCameraYaw;                              		// 0x1D00 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              m_fAimOffsetMax;                                  		// 0x1D04 (0x0004) [0x0000000000000000]              
	unsigned char                                      r_SkyJumpPhase;                                   		// 0x1D08 (0x0001) [0x0000000000000020]              ( CPF_Net )
	struct FVector                                     r_SkyJumpStartLocation;                           		// 0x1D0C (0x000C) [0x0000000000000020]              ( CPF_Net )
	struct FVector                                     r_SkyJumpBackupLocation;                          		// 0x1D18 (0x000C) [0x0000000000000020]              ( CPF_Net )
	class UTgSpecialFx*                                c_SkyJumpBeamFx;                                  		// 0x1D24 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class AActor*                                      r_SkyJumpBeamTarget;                              		// 0x1D28 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class AActor*                                      c_SkyJumpBeamActor;                               		// 0x1D2C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FVector                                     m_vSkyJumpBeamOffset;                             		// 0x1D30 (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2754 );

		return pClassPointer;
	};

	bool IsInClassSpecificMovement ( );
	bool IgnoreFaceRotationWithInterp ( );
	void SetInHandScaleDownTimer ( );
	void ScaleInHandDownFast ( );
	void ScaleInHandDown ( );
	void ScaleInHandUpAndSetTimer ( );
	void UpdateInHandWeapons ( );
	void eventToggleInHandWeapons ( unsigned long bEnable, float fTweenTime );
	void TickInHandWeapons ( float DeltaTime );
	void TickSkyJumpBeam ( float DeltaSeconds );
	void UpdateSkyBeamFx ( float DeltaTime );
	void eventSetSkyJumpBeamActor ( class AActor* Target );
	void eventOnAnimEnd ( class UAnimNodeSequence* SeqNode, float PlayedTime, float ExcessTime );
	void OnDeviceFormInterruptFire ( int nEquipSlot );
	void OnDeviceFormStopFire ( int nEquipSlot );
	void OnDeviceFormStartFire ( int nEquipSlot, float FireDuration, int nFireMode );
	void EndTween ( unsigned char endingTweenState, unsigned long bInterrupted );
	void BeginTween ( unsigned char newTweenState );
	void eventSetTargetingDevice ( class ATgDevice* Dev );
	float ApplyPitchLimit ( float fPitch );
	void FaceRotation ( struct FRotator NewRotation, float DeltaTime );
	void eventChargeCollisionProxyOnTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void eventTick ( float DeltaSeconds );
	void PlayDying ( class UClass* dmgType, struct FVector HitLoc );
	void PlayDeathAnimation ( );
	void eventUpdateSkyJumpPhase ( );
	void eventUpdatePassiveFx ( );
	void OnRespawn ( );
	void eventClearSkyJumpAfterDeath ( );
	void eventPostDemoRewind ( );
	void eventPostInitAnimTree ( class USkeletalMeshComponent* SkelComp );
	bool PostPawnSetup ( );
	void eventReplicatedEvent ( struct FName VarName );
	void TickSkyJumpMeshVisibility ( float fDelta );
	bool OverrideDistanceFadeRange ( );
	bool ShowImmunityHighlight ( );
	void SkyJumpKnockback ( );
	void RegainManaPool ( float fDelta );
	class ATgSkeletalMeshActorSpawnable_ApolloChariot* DetachChariot ( unsigned long bRagdoll );
	void AttachChariot ( );
	void EndSkyJump ( );
	void StartSkyJump ( );
	bool InitializeSkyJumpBeamFx ( );
	bool InitializePassiveFx ( );
	bool InitializeChariotSoundCues ( );
	void ChargeExplosion ( );
	void DeviceAdjustDamage ( class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage );
	bool DeviceOnCanDeviceFireNow ( class ATgDevice* Dev, unsigned char FireModeNum, unsigned long bDeviceFailLog, struct FAimData* Aim );
	bool DeviceOverrideTargetingAim ( class ATgDevice* Dev, struct FAimData* Aim, TArray< struct FImpactInfo >* ImpactList );
	void DeviceOnSetFireMode ( class ATgDevice* Dev );
	void DeviceOnStopFire ( class ATgDevice* Dev, unsigned long bWasInterrupted );
	void DeviceOnFire ( class ATgDevice* Dev );
	void DeviceOnStartFire ( class ATgDevice* Dev );
	void DeviceOnStartBuildup ( class ATgDevice* Dev );
	void DeviceOnHit ( class ATgDevice* Dev, struct FImpactInfo* Impact );
	void SetPassiveActive ( unsigned long bActive );
	bool TryToTogglePassive ( );
	void ApplyAudacityCharge ( unsigned long bRemove );
	void OnPawnDied ( );
	void PawnOnDamaged ( struct FOnDamagedParams* Params );
};

UClass* ATgPawn_Apollo::pClassPointer = NULL;

// Class TgGame.TgPawn_Arachne
// 0x0008 (0x1C74 - 0x1C6C)
class ATgPawn_Arachne : public ATgPawn_Character
{
public:
	class ATgPawn*                                     r_AttachedTarget;                                 		// 0x1C6C (0x0004) [0x0000000000000020]              ( CPF_Net )
	class UParticleSystemComponent*                    c_CocoonBeamPSC;                                  		// 0x1C70 (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2755 );

		return pClassPointer;
	};

	void PlayCocoonRetrieve ( );
	void KillCocoonBeam ( );
	void eventSetCocoonBeamTarget ( class AActor* Target );
	void OnTeleportNotify ( class AActor* TeleportingActor );
	struct FVector eventGetPhysTweenTargetLocation ( );
	void EndTween ( unsigned char endingTweenState, unsigned long bInterrupted );
	void ArachneAttachTweenStart ( );
	void BeginTween ( unsigned char newTweenState );
	void TickGrab ( float DeltaSeconds );
	void EndGrab ( unsigned char endingGrabState, unsigned long bInterrupted );
	void BeginGrab ( unsigned char newGrabState );
	void eventDetachFromTarget ( );
	void eventAttachToTarget ( unsigned long bCallEndTween );
	bool eventPostPawnSetup ( );
	void DeviceOnHit ( class ATgDevice* Dev, struct FImpactInfo* Impact );
	void DeviceOnStopFire ( class ATgDevice* Dev, unsigned long WasInterrupted );
	void DeviceOnStartFire ( class ATgDevice* Dev );
};

UClass* ATgPawn_Arachne::pClassPointer = NULL;

// Class TgGame.TgPawn_ArachneV2
// 0x0058 (0x1CC4 - 0x1C6C)
class ATgPawn_ArachneV2 : public ATgPawn_Character
{
public:
	int                                                c_FangsFXID;                                      		// 0x1C6C (0x0004) [0x0000000000000000]              
	unsigned long                                      r_bFangsEnabled : 1;                              		// 0x1C70 (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )
	unsigned long                                      r_bWrapEnabled : 1;                               		// 0x1C70 (0x0004) [0x0000000000000020] [0x00000002] ( CPF_Net )
	class UTgSpecialFx*                                c_FangsLeftHandFX;                                		// 0x1C74 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UTgSpecialFx*                                c_FangsRightHandFX;                               		// 0x1C78 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class ATgPawn*                                     s_WrapTarget;                                     		// 0x1C7C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                c_CocoonFXID;                                     		// 0x1C80 (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                c_CocoonLeftHandFX;                               		// 0x1C84 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UTgSpecialFx*                                c_CocoonRightHandFX;                              		// 0x1C88 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      r_eUltimateState;                                 		// 0x1C8C (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      m_eLocalUltState;                                 		// 0x1C8D (0x0001) [0x0000000000000000]              
	unsigned char                                      c_eUltimatePosture;                               		// 0x1C8E (0x0001) [0x0000000000000000]              
	int                                                c_nUltimatePostureId;                             		// 0x1C90 (0x0004) [0x0000000000000000]              
	struct FName                                       c_UltimateFireAnimName;                           		// 0x1C94 (0x0008) [0x0000000000000000]              
	struct FName                                       c_UltimateCancelAnimName;                         		// 0x1C9C (0x0008) [0x0000000000000000]              
	struct FName                                       c_UltimateDeathAnimName;                          		// 0x1CA4 (0x0008) [0x0000000000000000]              
	float                                              s_fUltimateCancelTime;                            		// 0x1CAC (0x0004) [0x0000000000000000]              
	int                                                c_nUltimateWebFXId;                               		// 0x1CB0 (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                c_UltimateWebFX;                                  		// 0x1CB4 (0x0004) [0x0000000000000000]              
	class UClass*                                      c_UltimateCameraModuleClass;                      		// 0x1CB8 (0x0004) [0x0000000000000000]              
	class UClass*                                      c_PreviousCameraModuleClass;                      		// 0x1CBC (0x0004) [0x0000000000000000]              
	class UTgCameraModule*                             c_UltimateCameraMod;                              		// 0x1CC0 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2756 );

		return pClassPointer;
	};

	bool IsInClassSpecificMovement ( );
	void eventResetChainedAttack ( unsigned char eqpPoint );
	void OnDeviceFormStartFire ( int nEquipSlot, float FireDiruation, int nFireMode );
	void OnDeviceFormBuildup ( int nEquipSlot, float fBuildupTime );
	void EndTween ( unsigned char endingTweenState, unsigned long bInterrupted );
	void BeginTween ( unsigned char newTweenState );
	void ToggleUltimateCameraMod ( unsigned long bOn );
	void EndCancelUltimate ( );
	void SetUltimateFX ( );
	void eventUpdateUltimateState ( unsigned char NewState );
	void eventOnAnimEnd ( class UAnimNodeSequence* SeqNode, float PlayedTime, float ExcessTime );
	void OnRespawn ( );
	void eventReplicatedEvent ( struct FName VarName );
	void eventUpdateFangsFX ( );
	void eventUpdateWrapFX ( );
	bool eventPostPawnSetup ( );
	void eventPostDemoRewind ( );
	void InitializeUltimateFX ( );
	void InitializeCocoonFX ( );
	void InitializeFangsFX ( );
	void PlayTeleportFx ( int nTeleportState, struct FVector vLoc );
	void EffectGroupOnSetActive ( unsigned long bActive, unsigned long bRemoving, class UTgEffectGroup* effectGroup );
	void DeviceAdjustPowerScaling ( class ATgDevice* Dev, int nScalingType, struct FImpactInfo* Impact, float* fPhysicalPower, float* fMagicPower );
	bool DeviceOnCanDeviceCriticalStrike ( class ATgDevice* Dev, int nPropertyId, int nDamageType, struct FImpactInfo* Impact, float* fCritChance );
	void DeviceOnPostHit ( class ATgDevice* Dev );
	void DeviceOnHit ( class ATgDevice* Dev, struct FImpactInfo* Impact );
	void DeviceOnStartFire ( class ATgDevice* Dev );
};

UClass* ATgPawn_ArachneV2::pClassPointer = NULL;

// Class TgGame.TgPawn_Ares
// 0x00DC (0x1D48 - 0x1C6C)
class ATgPawn_Ares : public ATgPawn_Character
{
public:
	TArray< class ATgPawn* >                           m_ShackledPawns;                                  		// 0x1C6C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class ATgPawn*                                     r_ShackledPawns[ 0x5 ];                           		// 0x1C78 (0x0014) [0x0000000000000020]              ( CPF_Net )
	class ATgPawn*                                     c_ShackledPawns[ 0x5 ];                           		// 0x1C8C (0x0014) [0x0000000000002000]              ( CPF_Transient )
	class UTgStaticMeshComponent*                      c_ShackleMeshComponents[ 0x5 ];                   		// 0x1CA0 (0x0014) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )
	class UTgStaticMeshComponent*                      c_BreakingShackleMeshComponents[ 0x5 ];           		// 0x1CB4 (0x0014) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )
	float                                              c_ShackleDestroyProgressPercentage[ 0x5 ];        		// 0x1CC8 (0x0014) [0x0000000000002000]              ( CPF_Transient )
	class UTgMarkComponent*                            m_ShackleSpeedMarkComponent;                      		// 0x1CDC (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	TArray< class ATgPawn* >                           m_TetheredPawns;                                  		// 0x1CE0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class ATgPawn*                                     r_TetheredPawns[ 0x5 ];                           		// 0x1CEC (0x0014) [0x0000000000000020]              ( CPF_Net )
	class ATgPawn*                                     c_TetheredPawns[ 0x5 ];                           		// 0x1D00 (0x0014) [0x0000000000002000]              ( CPF_Transient )
	class UTgStaticMeshComponent*                      c_TetherMeshComponents[ 0x5 ];                    		// 0x1D14 (0x0014) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )
	float                                              c_TetherAttachProgressPercentage;                 		// 0x1D28 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UTgSpecialFx*                                c_TetherSpecialFX[ 0x5 ];                         		// 0x1D2C (0x0014) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_EquippedAuraDeviceCount;                        		// 0x1D40 (0x0004) [0x0000000000000000]              
	class UTgSkeletalMeshComponent*                    c_DeathChainMeshComponent;                        		// 0x1D44 (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2757 );

		return pClassPointer;
	};

	void CleanUpDyingEffects ( );
	void PlayDyingEffects ( );
	void Tick ( float DeltaSeconds );
	void RemoveShackleEffectGroups ( class ATgPawn* TargetPawn );
	void UpdateTetherChainComponents ( float DeltaSeconds );
	void UpdateShackleChainComponents ( float DeltaSeconds );
	void OnRespawn ( );
	int eventGetTetheredPawnCount ( );
	int eventGetShackledPawnCount ( );
	bool eventPostPawnSetup ( );
	void DeviceOnStopFire ( class ATgDevice* Dev, unsigned long WasInterrupted );
	void DeviceOnHit ( class ATgDevice* Dev, struct FImpactInfo* Impact );
	void ResetDeathChainMeshComponent ( );
	bool InitializeDeathChainMeshComponent ( );
	class UTgSpecialFx* CreateTetherSpecialFX ( );
	class UTgStaticMeshComponent* CreateTetherMeshComponent ( );
	class UTgStaticMeshComponent* CreateShackleMeshComponent ( );
	void eventReplicatedEvent ( struct FName VarName );
	void eventUpdateTetheredPawns ( );
	void eventUpdateShackledPawns ( );
	void eventPreDemoRewind ( );
	int GetAuraItemCount ( );
	bool DeviceOverrideTargetingAim ( class ATgDevice* Dev, struct FAimData* Aim, TArray< struct FImpactInfo >* ImpactList );
};

UClass* ATgPawn_Ares::pClassPointer = NULL;

// Class TgGame.TgPawn_Artemis
// 0x0000 (0x1C6C - 0x1C6C)
class ATgPawn_Artemis : public ATgPawn_Character
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2758 );

		return pClassPointer;
	};

	struct FName eventGetDeathAnimName ( );
	bool DeviceOverrideTargetingAim ( class ATgDevice* Dev, struct FAimData* Aim, TArray< struct FImpactInfo >* ImpactList );
};

UClass* ATgPawn_Artemis::pClassPointer = NULL;

// Class TgGame.TgPawn_Athena
// 0x01B4 (0x1E20 - 0x1C6C)
class ATgPawn_Athena : public ATgPawn_Character
{
public:
	class ATgDevice*                                   r_LeapingLungeDevice;                             		// 0x1C6C (0x0004) [0x0000000000000020]              ( CPF_Net )
	class UTgSpecialFx*                                m_LeapingLungeFX;                                 		// 0x1C70 (0x0004) [0x0000000000000000]              
	class ATgDevice*                                   m_PassiveDevice;                                  		// 0x1C74 (0x0004) [0x0000000000000000]              
	class ATgDevice*                                   r_UltShooterDevice;                               		// 0x1C78 (0x0004) [0x0000000000000020]              ( CPF_Net )
	TArray< class UTgDeviceFire* >                     m_UltExplosionFireModes;                          		// 0x1C7C (0x000C) [0x0000000000500000]              ( CPF_NeedCtorLink )
	class UTgDeviceFire*                               m_AllOutFriendlyReflectDamageFireMode;            		// 0x1C88 (0x0004) [0x0000000000000000]              
	class ATgDevice*                                   r_DefaultBasicAttackDevice;                       		// 0x1C8C (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              m_fLeapingLungeChargeTime;                        		// 0x1C90 (0x0004) [0x0000000000000002]              ( CPF_Const )
	float                                              m_fRemainingLeapingLungeChargeTime;               		// 0x1C94 (0x0004) [0x0000000000000000]              
	unsigned long                                      r_bIsLeapingLungeFullyCharged : 1;                		// 0x1C98 (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )
	unsigned long                                      s_LastLeapingLungeHit : 1;                        		// 0x1C98 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      s_LastLeapingLungeHitAnyTarget : 1;               		// 0x1C98 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      r_bReachingStrikeEffectsActive : 1;               		// 0x1C98 (0x0004) [0x0000000000000020] [0x00000008] ( CPF_Net )
	unsigned long                                      c_bIsCurentlyLeaping : 1;                         		// 0x1C98 (0x0004) [0x0000000000000000] [0x00000010] 
	unsigned long                                      r_bIsZoomedForUlt : 1;                            		// 0x1C98 (0x0004) [0x0000000000000020] [0x00000020] ( CPF_Net )
	unsigned long                                      r_bHasBasicAttackAbsorb : 1;                      		// 0x1C98 (0x0004) [0x0000000000000020] [0x00000040] ( CPF_Net )
	unsigned long                                      r_bIsCurrentlyUltTweening : 1;                    		// 0x1C98 (0x0004) [0x0000000000000020] [0x00000080] ( CPF_Net )
	class ATgCollisionProxy_PawnListener*              m_AllOutCollisionProxyListener;                   		// 0x1C9C (0x0004) [0x0000000000000000]              
	TArray< class AActor* >                            m_ActorsWithEffects;                              		// 0x1CA0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	unsigned char                                      r_eLeapingLungeState;                             		// 0x1CAC (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      c_eLocalLeapingLungeState;                        		// 0x1CAD (0x0001) [0x0000000000000000]              
	unsigned char                                      r_AllOutSpearReturnNotify;                        		// 0x1CAE (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      r_UltBeginEffects;                                		// 0x1CAF (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      r_UltEndEffects;                                  		// 0x1CB0 (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      c_bFxHiddenLastTick;                              		// 0x1CB1 (0x0001) [0x0000000000002000]              ( CPF_Transient )
	class ATgCollisionProxy_Cylinder*                  m_ChargeCollisionProxy;                           		// 0x1CB4 (0x0004) [0x0000000000000000]              
	TArray< struct FChargeHitInfo >                    m_ChargeHitInfos;                                 		// 0x1CB8 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class UTgAnimNodeBlendList*                        m_PassiveBlendNode;                               		// 0x1CC4 (0x0004) [0x0000000000000000]              
	class ATgPawn*                                     r_UltTargetPawn;                                  		// 0x1CC8 (0x0004) [0x0000000000000020]              ( CPF_Net )
	struct FVector                                     m_vLastUltTargetPawnLocation;                     		// 0x1CCC (0x000C) [0x0000000000000000]              
	class UTgSkeletalMeshComponent*                    m_DeathMeshComponent;                             		// 0x1CD8 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	struct FTG_HUD_INFO                                c_TargetingHudInfo;                               		// 0x1CDC (0x0130) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class UTgSpecialFx*                                c_UltSphereFX;                                    		// 0x1E0C (0x0004) [0x0000000000000000]              
	int                                                c_UltPostureId;                                   		// 0x1E10 (0x0004) [0x0000000000000000]              
	struct FVector                                     m_vLeapingLungeInitialLocation;                   		// 0x1E14 (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2759 );

		return pClassPointer;
	};

	void eventDetachFromTarget ( class AActor* TargetActor );
	void eventAttachToTarget ( class AActor* TargetActor );
	void EndGrab ( unsigned char endingGrabState, unsigned long bInterrupted );
	void BeginGrab ( unsigned char newGrabState );
	struct FVector GetFireLocationOffset ( class ATgDevice* Dev );
	void eventPostDemoRewind ( );
	void OnDeviceFormInterruptFire ( int nEquipSlot );
	void OnDeviceFormStartFire ( int nEquipSlot, float FireDuration, int nFireMode );
	void ToggleUltSphereFx ( );
	void StopBasicAttackAbsorbEffects ( );
	void PlayBasicAttackAbsorbEffects ( );
	void eventPropertySet ( int nPropertyId, float fPreviousValue, float fNewValue );
	void CleanUpDyingEffects ( );
	void PlayDyingEffects ( );
	struct FVector eventGetPhysTweenTargetLocation ( );
	void eventToggleUltimateCameraModule ( unsigned long bOn );
	bool eventAnimNotifySound ( class USoundCue* Cue, class UAnimNodeSequence* OwningNode, float VolumeMultipler, float PitchMultipler );
	bool ShouldManageParticleFX ( class UAnimNotify_PlayParticleEffect* AnimNotifyData );
	void eventEndUltEffects ( );
	void eventBeginUltEffects ( );
	void EndTween ( unsigned char endingTweenState, unsigned long bInterrupted );
	void BeginTween ( unsigned char newTweenState );
	void eventOnRedirectedDamageOriginUpdated ( struct FVector Origin );
	void eventStopReachingStrikeEffects ( );
	void eventPlayReachingStrikeEffects ( );
	void eventChargeCollisionProxyOnTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void eventCollisionProxyOnUnTouch ( class AActor* Other );
	void eventCollisionProxyOnTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void MitigateDamageFromAllOut ( class ATgPawn* Other, class ATgPawn* attacker, class UTgEffectGroup* Effect, int nPropertyId, float* Damage );
	void eventInitializeCollisionProxyListener ( );
	void eventPlayAllOutSpearReturn ( );
	void eventUpdateLeapingLungeState ( );
	void eventStopLeapingLungeFullyChargedEffects ( );
	void eventPlayLeapingLungeFullyChargedEffects ( );
	void eventSetTargetingDevice ( class ATgDevice* Dev );
	void eventPostInitAnimTree ( class USkeletalMeshComponent* SkelComp );
	void eventSpecialFXAttached ( class UTgSpecialFx* NewFX, int FxId );
	void eventSetHiddenInDeath ( unsigned long bHiddenDueToDeath );
	bool eventPostPawnSetup ( );
	void eventReplicatedEvent ( struct FName VarName );
	bool GetTeleportDestination ( struct FVector* Destination );
	bool IsShooterTargetValid ( class ATgPawn* PawnTarget, class ATgDevice* Dev );
	bool GetPassiveBool ( int* bResult );
	void SetMeshVisibility ( unsigned long bVisible );
	bool ShouldPawnMeshBeHiddenThisTick ( );
	void DeviceOnStartBuildup ( class ATgDevice* Dev );
	bool DeviceOverrideManaUseVitals ( class ATgDevice* Dev, class ATgPlayerController* PC );
	bool DeviceOverrideTargetingAim ( class ATgDevice* Dev, struct FAimData* Aim, TArray< struct FImpactInfo >* ImpactList );
	void PawnOnDamaged ( struct FOnDamagedParams* Params );
	bool AreAnyOtherOffhandsLockingFiring ( class ATgDevice* CurrentDevice );
	bool DeviceOnCanDeviceFireNow ( class ATgDevice* Dev, unsigned char FireModeNum, unsigned long bDeviceFailLog, struct FAimData* Aim );
	void DeviceOnStopFire ( class ATgDevice* Dev, unsigned long WasInterrupted );
	void DeviceOnStartFire ( class ATgDevice* Dev );
	void DeviceOnFire ( class ATgDevice* Dev );
};

UClass* ATgPawn_Athena::pClassPointer = NULL;

// Class TgGame.TgPawn_Awilix
// 0x007C (0x1CE8 - 0x1C6C)
class ATgPawn_Awilix : public ATgPawn_Character
{
public:
	unsigned long                                      s_bInitiatedLastCombat : 1;                       		// 0x1C6C (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      c_bOnJungleMount : 1;                             		// 0x1C6C (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      r_bTriggerAOEFX : 1;                              		// 0x1C6C (0x0004) [0x0000000000000020] [0x00000004] ( CPF_Net )
	unsigned char                                      r_eMountState;                                    		// 0x1C70 (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      r_nStarlightState;                                		// 0x1C71 (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      r_nMoonlightState;                                		// 0x1C72 (0x0001) [0x0000000000000020]              ( CPF_Net )
	int                                                m_nJungleFriendMeshID;                            		// 0x1C74 (0x0004) [0x0000000000000000]              
	class UTgSkeletalMeshComponent*                    c_JungleFriendMesh;                               		// 0x1C78 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class ATgPawn*                                     r_RepositionTarget;                               		// 0x1C7C (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              m_fStartingYaw;                                   		// 0x1C80 (0x0004) [0x0000000000000000]              
	float                                              m_fDiffYaw;                                       		// 0x1C84 (0x0004) [0x0000000000000000]              
	int                                                r_nRepositionInHandMode;                          		// 0x1C88 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              m_fCurrentTweenTime;                              		// 0x1C8C (0x0004) [0x0000000000000000]              
	int                                                m_nCurrentFSMode;                                 		// 0x1C90 (0x0004) [0x0000000000000000]              
	int                                                m_nRepositionFXID;                                		// 0x1C94 (0x0004) [0x0000000000000000]              
	int                                                m_nRepositionTargeterID;                          		// 0x1C98 (0x0004) [0x0000000000000000]              
	int                                                m_nRepositionAOETargeterID;                       		// 0x1C9C (0x0004) [0x0000000000000000]              
	int                                                m_nRepositionBeamID;                              		// 0x1CA0 (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                c_RepositionAOEFX;                                		// 0x1CA4 (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                c_RepositionTargeter;                             		// 0x1CA8 (0x0004) [0x0000000000000000]              
	class ATgSkeletalMeshActor*                        c_RepositionTargeterMesh;                         		// 0x1CAC (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                c_RepositionAOETargeter;                          		// 0x1CB0 (0x0004) [0x0000000000000000]              
	class ATgSkeletalMeshActor*                        c_RepositionAOETargeterMesh;                      		// 0x1CB4 (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                c_RepositionBeam;                                 		// 0x1CB8 (0x0004) [0x0000000000000000]              
	int                                                m_nMoonlightBeamFXID;                             		// 0x1CBC (0x0004) [0x0000000000000000]              
	int                                                m_nMoonlightBubbleFXID;                           		// 0x1CC0 (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                c_MoonlightBeamFX;                                		// 0x1CC4 (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                c_MoonlightBubbleFX;                              		// 0x1CC8 (0x0004) [0x0000000000000000]              
	class ATgPawn*                                     r_PullTarget;                                     		// 0x1CCC (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgPawn*                                     r_BestPullTarget;                                 		// 0x1CD0 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                m_nMoonlightMarkID;                               		// 0x1CD4 (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                c_MoonlightMark;                                  		// 0x1CD8 (0x0004) [0x0000000000000000]              
	TArray< class UTgAnimBlendByAwilixUlt* >           m_UltPullBlendNodes;                              		// 0x1CDC (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2760 );

		return pClassPointer;
	};

	void CacheMultiMeshAnimNodeReferences ( class UTgSkeletalMeshComponent* smcomp );
	void ClearMultiMeshAnimNodeReferences ( );
	void eventSetMoonlightMaterial ( );
	void UltWillPull ( );
	void eventPlayMoonlightFullbody ( unsigned long bGrabbedTarget );
	void eventSetMoonlightPullTimer ( float DelayTime );
	void eventTriggerRepositionFX ( );
	void OnDeviceFormStartFire ( int nEquipSlot, float FireDuration, int nFireMode );
	void InterruptInhand ( class ATgDevice* InterruptingDevice );
	struct FName eventGetDeathAnimName ( );
	void PlayStarlightLanceAnim ( unsigned long bKnockup );
	void eventSetJungleFriendMesh ( unsigned long bAttach );
	void PlayJungleFriendAnim ( unsigned long bInterrupted );
	void UpdateMountState ( );
	void EndTween ( unsigned char endingTweenState, unsigned long bInterrupted );
	void BeginTween ( unsigned char newTweenState );
	void ResetRepositionTarget ( );
	void eventSetRepositionTarget ( class ATgPawn* NewTarget, float ResetTime );
	void OnRespawn ( );
	void InCombatTimer ( );
	void eventEnterCombat ( class AActor* aInstigator, class AActor* ATarget, float fLength );
	bool eventPostPawnSetup ( );
	bool eventDied ( class AController* Killer, class UClass* dmgType, struct FVector HitLocation );
	void Tick ( float DeltaSeconds );
	void eventReplicatedEvent ( struct FName VarName );
	void SetMeshVisibility ( unsigned long bVisible );
	void TriggerMoonlightPull ( );
	void UpdateMoonlightTarget ( );
	bool IsValidMoonlightTarget ( class ATgPawn* TestPawn );
	void UpdateRepositionFX ( );
	bool IsInAOEHit ( );
	bool IsValidRepositionTarget ( );
	bool InitializeMoonlightFX ( );
	bool InitializeRepositionFX ( );
	bool InitializeJungleFriendMesh ( );
	void FlashResetChainAttack ( int nDeviceInstanceId );
	void EffectGroupOnSetActive ( unsigned long bActive, unsigned long bRemoving, class UTgEffectGroup* effectGroup );
	void DeviceOnStartCooldown ( class ATgDevice* Dev, float fCooldownTime );
	void DeviceAdjustDamage ( class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage );
	void DeviceOnHit ( class ATgDevice* Dev, struct FImpactInfo* Impact );
	void DeviceOnStopFire ( class ATgDevice* Dev, unsigned long WasInterrupted );
	void DeviceOnFire ( class ATgDevice* Dev );
	void DeviceOnStartFire ( class ATgDevice* Dev );
	void DeviceOnStartBuildup ( class ATgDevice* Dev );
	void PawnOnDeliverHits ( TArray< struct FImpactInfo >* PendingHits );
	void SetSpawnEnergy ( );
};

UClass* ATgPawn_Awilix::pClassPointer = NULL;

// Class TgGame.TgPawn_Bacchus
// 0x0028 (0x1C94 - 0x1C6C)
class ATgPawn_Bacchus : public ATgPawn_Character
{
public:
	float                                              m_fSmoothEnergy;                                  		// 0x1C6C (0x0004) [0x0000000000000000]              
	float                                              m_fSmoothEnergySpeed;                             		// 0x1C70 (0x0004) [0x0000000000000000]              
	unsigned char                                      m_CurrentDrunkType;                               		// 0x1C74 (0x0001) [0x0000000000000000]              
	unsigned long                                      c_DrunkFxSuccessfulLoad : 1;                      		// 0x1C78 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	class UTgSpecialFx*                                c_DrunkStateFx[ 0x3 ];                            		// 0x1C7C (0x000C) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_fBelchRadiusFeet;                               		// 0x1C88 (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                m_BelchConeEffect;                                		// 0x1C8C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UTgSpecialFx*                                c_BelchCameraShakeFx;                             		// 0x1C90 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2761 );

		return pClassPointer;
	};

	void PlayDyingEffects ( );
	void DeactivateBelchEffects ( );
	void ActivateBelchEffects ( );
	void OnDeviceFormInterruptFire ( int nEquipSlot );
	void OnDeviceFormStopFire ( int nEquipSlot );
	void OnDeviceFormFire ( int nEquipSlot );
	void OnDeviceFormStartFire ( int nEquipSlot, float FireDuration, int nFireMode );
	void Tick ( float DeltaSeconds );
	bool eventShouldRechargeSpecial ( );
	void EndTween ( unsigned char endingTweenState, unsigned long bInterrupted );
	void BeginTween ( unsigned char newTweenState );
	void eventOnRespawn ( );
	bool eventPostPawnSetup ( );
	void CancelBelch ( );
	void BelchFromLocation ( );
	struct FString GetEmoteCustomSuffix ( unsigned char Emote, int ExtraInfo );
	bool InitDrunkFX ( );
	void UpdateDrunkStatus ( );
	void PawnOnKilled ( class AActor* Victim, int* xpGain, int* goldGain );
	void DeviceOnHit ( class ATgDevice* Dev, struct FImpactInfo* Impact );
	void DeviceOnStopFire ( class ATgDevice* Dev, unsigned long WasInterrupted );
	void DeviceOnFire ( class ATgDevice* Dev );
	void DeviceOnStartFire ( class ATgDevice* Dev );
	void CalcSmoothEnergy ( float fDelta );
	void RegainEnergyPool ( float fDelta );
	void OnUtilityPowerChange ( );
	void SetSpawnEnergy ( );
	float GetSmoothEnergy ( );
};

UClass* ATgPawn_Bacchus::pClassPointer = NULL;

// Class TgGame.TgPawn_Bakasura
// 0x0068 (0x1CD4 - 0x1C6C)
class ATgPawn_Bakasura : public ATgPawn_Character
{
public:
	class UTgMarkComponent*                            m_MinionAmmunitionMarkComponent;                  		// 0x1C6C (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )
	class ATgDevice*                                   m_BasicAttackDevice;                              		// 0x1C70 (0x0004) [0x0000000000000000]              
	class ATgDevice*                                   m_ChompDevice;                                    		// 0x1C74 (0x0004) [0x0000000000000000]              
	int                                                r_PawnIdToBeConsumed;                             		// 0x1C78 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgPawn*                                     c_PawnToBeConsumed;                               		// 0x1C7C (0x0004) [0x0000000000000000]              
	float                                              c_PawnConsumptionStartTimestamp;                  		// 0x1C80 (0x0004) [0x0000000000000000]              
	float                                              c_ConsumedPawnInitialScale;                       		// 0x1C84 (0x0004) [0x0000000000000000]              
	unsigned long                                      c_bConsumingPawn : 1;                             		// 0x1C88 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bTrueDamageBuffActive : 1;                      		// 0x1C88 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      c_HasTrueDamageBlades : 1;                        		// 0x1C88 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      c_bIsInUltimate : 1;                              		// 0x1C88 (0x0004) [0x0000000000000000] [0x00000008] 
	struct FName                                       m_ConsumeBone;                                    		// 0x1C8C (0x0008) [0x0000000000000000]              
	TArray< class UTgDeviceFire* >                     m_TrueDamageDeviceModes;                          		// 0x1C94 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                m_nTrueDamageBuffFiringInstance;                  		// 0x1CA0 (0x0004) [0x0000000000000000]              
	class UTgSkeletalMeshComponent*                    c_BladesMeshComponent;                            		// 0x1CA4 (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )
	class UMaterialInstanceConstant*                   c_BladesMIC;                                      		// 0x1CA8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              c_BladeOpacity;                                   		// 0x1CAC (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                c_LeftBladeSpecialFX;                             		// 0x1CB0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UTgSpecialFx*                                c_RightBladeSpecialFX;                            		// 0x1CB4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FName                                       m_LeftBladeSocket;                                		// 0x1CB8 (0x0008) [0x0000000000000000]              
	struct FName                                       m_RightBladeSocket;                               		// 0x1CC0 (0x0008) [0x0000000000000000]              
	float                                              r_fUltimateDuration;                              		// 0x1CC8 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              r_fPassiveDuration;                               		// 0x1CCC (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nPassiveStacks;                                 		// 0x1CD0 (0x0004) [0x0000000000000020]              ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2762 );

		return pClassPointer;
	};

	void UltimateComplete ( );
	bool eventBlendInHandToUltimate ( );
	struct FName eventGetDeathAnimName ( );
	void eventOnBotDied ( class ATgPawn* DeadPawn );
	void eventEndChompMode ( );
	void OnDeviceFormFire ( int nEquipSlot );
	void OnDeviceFormStopFire ( int nEquipSlot );
	void OnDeviceFormStartFire ( int nEquipSlot, float FireDuration, int nFireMode );
	void EndTween ( unsigned char endingTweenState, unsigned long bInterrupted );
	void Tick ( float DeltaSeconds );
	void FinishedIntro ( );
	void PlaySpawnFx ( );
	bool eventPostPawnSetup ( );
	void eventReplicatedEvent ( struct FName VarName );
	void eventDestroyConsumedPawn ( );
	bool GetPassiveInt2 ( int* nResult );
	bool GetPassiveInt1 ( int* nResult );
	void DeviceOnSetFireMode ( class ATgDevice* Dev );
	void PostPawnSetupServer ( );
	void SetSpawnEnergy ( );
	void ReapplyLoadoutEffects ( );
	void DeviceOnStopFire ( class ATgDevice* Dev, unsigned long WasInterrupted );
	void PawnOnKilled ( class AActor* Victim, int* xpGain, int* goldGain );
	void EffectGroupOnSetActive ( unsigned long bActive, unsigned long bRemoving, class UTgEffectGroup* effectGroup );
	void DeviceOnHit ( class ATgDevice* Dev, struct FImpactInfo* Impact );
	void DeviceOnFire ( class ATgDevice* Dev );
	void DeviceOnStartFire ( class ATgDevice* Dev );
	bool InitializeBladeSpecialFX ( );
	bool InitializeBladeMeshComponent ( );
};

UClass* ATgPawn_Bakasura::pClassPointer = NULL;

// Class TgGame.TgPawn_BakasuraV1
// 0x0010 (0x1CE4 - 0x1CD4)
class ATgPawn_BakasuraV1 : public ATgPawn_Bakasura
{
public:
	class UTgSkeletalMeshComponent*                    c_HeadMeshComponent;                              		// 0x1CD4 (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )
	unsigned long                                      c_ShouldHideHeadBone : 1;                         		// 0x1CD8 (0x0004) [0x0000000000000000] [0x00000001] 
	class UTgSpecialFx*                                c_HoodSmokeSpecialFX;                             		// 0x1CDC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UTgSpecialFx*                                c_HeadSmokeSpecialFX;                             		// 0x1CE0 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2763 );

		return pClassPointer;
	};

	void UltimateComplete ( );
	struct FName eventGetDeathAnimName ( );
	void CleanUpDyingEffects ( );
	void PlayDyingEffects ( );
	void BeginTween ( unsigned char newTweenState );
	void OnDeviceFormStartFire ( int nEquipSlot, float FireDuration, int nFireMode );
	void ShrinkHead ( );
	void FinishedIntro ( );
	void PlaySpawnFx ( );
	bool eventPostPawnSetup ( );
	void Tick ( float DeltaSeconds );
	void SetMeshVisibility ( unsigned long bVisible );
	bool InitializeSmokeSpecialFX ( );
	bool InitializeHeadMeshComponent ( );
};

UClass* ATgPawn_BakasuraV1::pClassPointer = NULL;

// Class TgGame.TgPawn_BakasuraV2
// 0x0024 (0x1CF8 - 0x1CD4)
class ATgPawn_BakasuraV2 : public ATgPawn_Bakasura
{
public:
	class UTgSkeletalMeshComponent*                    c_TentacleMeshComponent;                          		// 0x1CD4 (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )
	float                                              m_fTentacleDuration;                              		// 0x1CD8 (0x0004) [0x0000000000000000]              
	struct FName                                       m_TentacleSkelControlName;                        		// 0x1CDC (0x0008) [0x0000000000000000]              
	class USkelControlBase*                            m_TentacleSkelControl;                            		// 0x1CE4 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bShowTentacles : 1;                             		// 0x1CE8 (0x0004) [0x0000000000000000] [0x00000001] 
	class UTgSkeletalMeshComponent*                    c_UltimateMeshComponent;                          		// 0x1CEC (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )
	struct FName                                       c_UltimateSocketName;                             		// 0x1CF0 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2764 );

		return pClassPointer;
	};

	void eventSetUltimateMesh ( unsigned long bAttach );
	void UltimateComplete ( );
	void eventSetTentacleMesh ( unsigned long bAttach );
	void OnDeviceFormStartFire ( int nEquipSlot, float FireDuration, int nFireMode );
	void BeginTween ( unsigned char newTweenState );
	void Tick ( float DeltaSeconds );
	void eventPostInitAnimTree ( class USkeletalMeshComponent* SkelComp );
	bool eventPostPawnSetup ( );
	bool InitializeTentacleMeshComponent ( );
	bool InitializeUltimateMeshComponent ( );
};

UClass* ATgPawn_BakasuraV2::pClassPointer = NULL;

// Class TgGame.TgPawn_Bastet
// 0x0018 (0x1C84 - 0x1C6C)
class ATgPawn_Bastet : public ATgPawn_Character
{
public:
	TArray< class ATgAIController* >                   m_CatControllers;                                 		// 0x1C6C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class UMaterialInstanceConstant*                   m_PulsingMIC;                                     		// 0x1C78 (0x0004) [0x0000000000000000]              
	unsigned long                                      r_ShouldPounceBack : 1;                           		// 0x1C7C (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )
	unsigned long                                      r_bIsPouncingBack : 1;                            		// 0x1C7C (0x0004) [0x0000000000000020] [0x00000002] ( CPF_Net )
	float                                              m_PounceDuration;                                 		// 0x1C80 (0x0004) [0x0000000000000020]              ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2765 );

		return pClassPointer;
	};

	void KillPounceBack ( );
	void ClientKillPounceBack ( );
	void PostTeleport ( class ATeleporter* OutTeleporter );
	void eventReplicatedEvent ( struct FName VarName );
	void EndTween ( unsigned char endingTweenState, unsigned long bInterrupted );
	void BeginTween ( unsigned char newTweenState );
	void CatSummonTimerExpired ( );
	void BlinkTimerExpired ( );
	void OnDeviceFormFire ( int nEquipSlot );
	void OnDeviceFormStartFire ( int nEquipSlot, float FireDuration, int nFireMode );
	void ShouldPounceBack ( unsigned long Value );
	bool eventPostPawnSetup ( );
	bool DeviceOverrideTargetingAim ( class ATgDevice* Dev, struct FAimData* Aim, TArray< struct FImpactInfo >* ImpactList );
	void DeviceOnDamaged ( struct FOnDamagedParams* Params );
	void DeviceOnFire ( class ATgDevice* Dev );
};

UClass* ATgPawn_Bastet::pClassPointer = NULL;

// Class TgGame.TgPawn_Bellona
// 0x00EC (0x1D58 - 0x1C6C)
class ATgPawn_Bellona : public ATgPawn_Character
{
public:
	float                                              m_fLocalPassiveLifeMax;                           		// 0x1C6C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FWeaponSetInfo                              r_CurrentWeaponSetInfo;                           		// 0x1C70 (0x0004) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      s_ePreviousWeaponSet;                             		// 0x1C74 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_eLocalWeaponSet;                                		// 0x1C75 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_VisibleWeaponSet;                               		// 0x1C76 (0x0001) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      r_nShieldBashAOETicker;                           		// 0x1C77 (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned long                                      m_bWaitingForAnimationToSwap : 1;                 		// 0x1C78 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bHideVisibleWeaponSet : 1;                      		// 0x1C78 (0x0004) [0x0000000000000000] [0x00000002] 
	float                                              m_fWeaponSetLifetime;                             		// 0x1C7C (0x0004) [0x0000000000000000]              
	TArray< class UTgAnimBlendByBellonaWeaponSetIdle* > m_WeaponSetStanceNodes;                           		// 0x1C80 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UAnimNode* >                         m_WeaponSwapBlockers;                             		// 0x1C8C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< struct FVisibleWeaponOverrides >           m_WeaponSwapOverrides;                            		// 0x1C98 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                m_WeaponSetMeshAssemblyIds[ 0x5 ];                		// 0x1CA4 (0x0014) [0x0000000000000000]              
	struct FPointer                                    m_WeaponSetMeshAssembly;                          		// 0x1CB8 (0x0004) [0x0000000000001000]              ( CPF_Native )
	TArray< class UAnimSet* >                          m_ActiveWeaponSetAnimSets;                        		// 0x1CBC (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FPointer                                    m_VisibleWeaponSetAssembly;                       		// 0x1CC8 (0x0004) [0x0000000000003000]              ( CPF_Native | CPF_Transient )
	float                                              m_VisibleWeaponSetMaterialFlare;                  		// 0x1CCC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FName                                       m_VisibleWaponsSetMaterialParamName;              		// 0x1CD0 (0x0008) [0x0000000000002000]              ( CPF_Transient )
	class UTgSkeletalMeshComponent*                    m_VisibleWeaponSetMesh;                           		// 0x1CD8 (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )
	float                                              m_fDesiredWeaponWeighting[ 0x5 ];                 		// 0x1CDC (0x0014) [0x0000000000000000]              
	float                                              m_fCachedWeaponWeighting[ 0x5 ];                  		// 0x1CF0 (0x0014) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_WeaponSetDeviceIds[ 0x5 ];                      		// 0x1D04 (0x0014) [0x0000000000000002]              ( CPF_Const )
	class ATgDevice*                                   r_BaseWeaponSet;                                  		// 0x1D18 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgDevice*                                   r_WeaponSets[ 0x5 ];                              		// 0x1D1C (0x0014) [0x0000000000000020]              ( CPF_Net )
	struct FShieldBashRepInfo                          r_ShieldBashRepInfo;                              		// 0x1D30 (0x0014) [0x0000000000000020]              ( CPF_Net )
	int                                                m_FlagMeshAssemblyId;                             		// 0x1D44 (0x0004) [0x0000000000000000]              
	class UTgSkeletalMeshComponent*                    m_FlagMesh;                                       		// 0x1D48 (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )
	TArray< struct FVisibleFlagMesh >                  m_VisibleFlagMeshInfos;                           		// 0x1D4C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2766 );

		return pClassPointer;
	};

	void ClientForceToWeaponSet ( unsigned char NewSet );
	void FaceRotation ( struct FRotator NewRotation, float DeltaTime );
	void FlashHammerStrikeFxs ( struct FVector StrikeLocation, struct FVector ForwardVector );
	void PlayShieldBashAOEFx ( );
	void eventFlashShieldBashAOEFx ( );
	void PlayShieldBashConeFx ( );
	void FlashShieldBashFxs ( struct FVector BashLocation, struct FVector ForwardVector );
	void ResetToSword ( );
	void eventRefreshWeaponSetTimer ( );
	void eventEnterCombat ( class AActor* aInstigator, class AActor* ATarget, float fLength );
	void OnRespawn ( );
	void CacheMainMeshReferences ( class UTgSkeletalMeshComponent* smcomp );
	void eventReplicatedEvent ( struct FName VarName );
	bool GetPassiveAuxMax ( float* fResult );
	bool GetPassiveAux ( float* fResult );
	bool GetPassiveInt1 ( int* nResult );
	void SetSpawnEnergy ( );
	void SetMeshVisibility ( unsigned long bVisible );
	bool DeviceOnCanDeviceFireNow ( class ATgDevice* Dev, unsigned char FireModeNum, unsigned long bDeviceFailLog, struct FAimData* Aim );
	void DeviceOnStartFire ( class ATgDevice* Dev );
	void SwapToLiveMesh ( );
	void CalcAndApplyWeaponSetWeightings ( float DeltaSeconds, unsigned long bForceToDesired );
	void RemoveFlagMeshSequenceNode ( class UAnimNodeSequence* RequestingNode );
	void AddFlagMeshSequenceNode ( class UAnimNodeSequence* RequestingNode, unsigned long bUseOverlay );
	void RemoveWeaponVisualOverride ( class UAnimNodeSequence* RequestingNode );
	void AddWeaponVisualOverride ( unsigned char DesiredWeaponSet, float fSetWeight, class UAnimNodeSequence* RequestingNode );
	void RemoveWeaponSetSwapBlocker ( class UAnimNode* Blocker );
	void AddWeaponSetSwapBlocker ( class UAnimNode* Blocker );
	void UpdateLocalWeaponSet ( struct FWeaponSetInfo WeaponSet, unsigned long bRespawning );
	void EndChangeWeaponSet ( unsigned char NewSet, unsigned long bSuccess );
	void PerformDeviceSwap ( unsigned char NewSet );
	void StartChangeWeaponSet ( unsigned char NewSet, unsigned long bForce );
};

UClass* ATgPawn_Bellona::pClassPointer = NULL;

// Class TgGame.TgPawn_Cabrakan
// 0x003C (0x1CA8 - 0x1C6C)
class ATgPawn_Cabrakan : public ATgPawn_Character
{
public:
	TArray< class AActor* >                            m_Dev2TargetsHit;                                 		// 0x1C6C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FVector                                     r_vDev2Location;                                  		// 0x1C78 (0x000C) [0x0000000000000020]              ( CPF_Net )
	struct FRotator                                    r_rDev2Rotation;                                  		// 0x1C84 (0x000C) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nDev2Ticker;                                    		// 0x1C90 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nDev2Stacks;                                    		// 0x1C94 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              r_fDev2Duration;                                  		// 0x1C98 (0x0004) [0x0000000000000020]              ( CPF_Net )
	unsigned long                                      c_bRefractionShieldFXActive : 1;                  		// 0x1C9C (0x0004) [0x0000000000000000] [0x00000001] 
	class UTgMarkComponent_Cabrakan_Dev2*              m_RefractionShieldMark;                           		// 0x1CA0 (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )
	class ATgCollisionProxy_Vortex_Cabrakan_Dev3*      m_Vortex;                                         		// 0x1CA4 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2767 );

		return pClassPointer;
	};

	void Tick ( float DeltaSeconds );
	void eventReplicatedEvent ( struct FName VarName );
	bool GetPassiveInt2 ( int* nResult );
	bool GetPassiveInt1 ( int* nResult );
	void SpawnVortex ( class ATgDevice* Dev );
	void LoadAndPlayDev2Mesh ( struct FVector vLocation, struct FRotator rRotation );
	void UpdateDev2Stacks ( );
	bool DeviceOverrideTargetingAim ( class ATgDevice* Dev, struct FAimData* Aim, TArray< struct FImpactInfo >* ImpactList );
	void DeviceOnStopFire ( class ATgDevice* Dev, unsigned long WasInterrupted );
	void DeviceOnHit ( class ATgDevice* Dev, struct FImpactInfo* Impact );
	void DeviceOnStartFire ( class ATgDevice* Dev );
	void PawnOnDamaged ( struct FOnDamagedParams* Params );
	void ReapplyLoadoutEffects ( );
	void DeviceOnSetFireMode ( class ATgDevice* Dev );
};

UClass* ATgPawn_Cabrakan::pClassPointer = NULL;

// Class TgGame.TgPawn_Camazotz
// 0x0070 (0x1CDC - 0x1C6C)
class ATgPawn_Camazotz : public ATgPawn_Character
{
public:
	class ATgDevice_Camazotz_Essence*                  m_DevicePsv_EssenceDrinker;                       		// 0x1C6C (0x0004) [0x0000000000000000]              
	class ATgDevice_Camazotz_Screech*                  m_DeviceA01_Screech;                              		// 0x1C70 (0x0004) [0x0000000000000000]              
	class ATgDevice*                                   m_DeviceA01_ScreechEcho;                          		// 0x1C74 (0x0004) [0x0000000000000000]              
	class ATgDevice_Camazotz_VampireBats*              m_DeviceA02_VampireBats;                          		// 0x1C78 (0x0004) [0x0000000000000000]              
	class ATgDevice*                                   m_DeviceA02_VampireBatsBuff;                      		// 0x1C7C (0x0004) [0x0000000000000000]              
	class ATgDevice*                                   m_DeviceA02_VampireBatsHeal;                      		// 0x1C80 (0x0004) [0x0000000000000000]              
	class ATgDevice*                                   m_DeviceA03_ToothAndNail;                         		// 0x1C84 (0x0004) [0x0000000000000000]              
	class ATgDevice_Camazotz_Dev4Staging*              m_DeviceA04_Dev4Staging;                          		// 0x1C88 (0x0004) [0x0000000000000000]              
	int                                                r_nCurrentEssenceDrinksRemaining;                 		// 0x1C8C (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nTouchingEssences;                              		// 0x1C90 (0x0004) [0x0000000000000020]              ( CPF_Net )
	struct FVector                                     m_PrevVelocity;                                   		// 0x1C94 (0x000C) [0x0000000000000000]              
	unsigned long                                      m_bScreechBuffActive : 1;                         		// 0x1CA0 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bFireLastShot : 1;                              		// 0x1CA0 (0x0004) [0x0000000000000000] [0x00000002] 
	class ATgPawn*                                     m_ScreechHitPawn;                                 		// 0x1CA4 (0x0004) [0x0000000000000000]              
	class ATgPawn*                                     m_ScreechRevealedPawn;                            		// 0x1CA8 (0x0004) [0x0000000000000000]              
	int                                                r_nNumJungleBuffStacks;                           		// 0x1CAC (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              r_fJungleBuffTimeRemaining;                       		// 0x1CB0 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              r_fJungleBuffAlertThreshold;                      		// 0x1CB4 (0x0004) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      r_eUltimateState;                                 		// 0x1CB8 (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      m_eLocalUltState;                                 		// 0x1CB9 (0x0001) [0x0000000000000000]              
	unsigned char                                      c_eUltimatePosture;                               		// 0x1CBA (0x0001) [0x0000000000000000]              
	unsigned char                                      r_EquippedInHand;                                 		// 0x1CBB (0x0001) [0x0000000000000020]              ( CPF_Net )
	int                                                c_nUltimatePostureId;                             		// 0x1CBC (0x0004) [0x0000000000000000]              
	float                                              s_fUltimateTakeDownTime;                          		// 0x1CC0 (0x0004) [0x0000000000000000]              
	class UTgAnimNodeBlendByCamazotzUltimate*          m_UltimateCycleBlendList;                         		// 0x1CC4 (0x0004) [0x0000000000000000]              
	int                                                m_nHitCountForSwoop;                              		// 0x1CC8 (0x0004) [0x0000000000000000]              
	int                                                m_nAmmoUsed;                                      		// 0x1CCC (0x0004) [0x0000000000000000]              
	int                                                m_nMaxAmmoCount;                                  		// 0x1CD0 (0x0004) [0x0000000000000000]              
	float                                              r_fTransformCameraZoom;                           		// 0x1CD4 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              r_fTransformCameraZoomTween;                      		// 0x1CD8 (0x0004) [0x0000000000000020]              ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2768 );

		return pClassPointer;
	};

	bool eventWantsLoopingEmote ( unsigned char Emote );
	void OnDeviceFormInterruptFire ( int nEquipSlot );
	void OnDeviceFormStopFire ( int nEquipSlot );
	void OnDeviceFormFire ( int nEquipSlot );
	void OnDeviceFormStartFire ( int nEquipSlot, float FireDuration, int nFireMode );
	void OnDeviceFormBuildup ( int nEquipSlot, float fBuildupTime );
	void eventPostInitAnimTree ( class USkeletalMeshComponent* SkelComp );
	bool CannotJumpNow ( );
	void PlayNearDeathCleanup ( );
	void OnRespawn ( );
	void Tick ( float DeltaSeconds );
	void EndUltimateTakeDown ( );
	void GetCameraZoomOverride ( float* fZoom, float* fTweenSpeed );
	void eventSetCameraZoomOverride ( float fZoom, float fTweenSpeed );
	void ToggleUltimateCameraModule ( unsigned long bOn );
	void eventUpdateUltimateState ( unsigned char NewState );
	void EndTween ( unsigned char endingTweenState, unsigned long bInterrupted );
	void BeginTween ( unsigned char newTweenState );
	void eventReplicatedEvent ( struct FName VarName );
	void ReturnVampireBatsHealth ( struct FVector vLoc );
	void EndVampireBatsLock ( struct FVector vLoc );
	void EndScreechBuff ( );
	void BeginScreechBuff ( );
	void OnPawnDied ( );
	void DeviceAdjustDamage ( class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage );
	void DeviceOnHit ( class ATgDevice* Dev, struct FImpactInfo* Impact );
	void DeviceOnStopFire ( class ATgDevice* Dev, unsigned long WasInterrupted );
	void DeviceOnStartFire ( class ATgDevice* Dev );
	void EffectGroupOnSetActive ( unsigned long bActive, unsigned long bRemoving, class UTgEffectGroup* effectGroup );
	void CancelEssenceDrinkingEmote ( );
	void PlayEssenceDrinkingEmote ( );
	void HealSelfFromEssence ( );
	bool GetPassiveAuxMax ( float* fResult );
	bool GetPassiveAux ( float* fResult );
	bool GetPassiveInt1 ( int* nResult );
	bool GetPassiveBool ( int* bResult );
	void PopulatePassiveMeterValues ( );
};

UClass* ATgPawn_Camazotz::pClassPointer = NULL;

// Class TgGame.TgPawn_Chaac
// 0x006C (0x1CD8 - 0x1C6C)
class ATgPawn_Chaac : public ATgPawn_Character
{
public:
	int                                                r_nPassiveCount;                                  		// 0x1C6C (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                m_nCachedPassiveCount;                            		// 0x1C70 (0x0004) [0x0000000000000000]              
	int                                                r_nPassiveMaxCount;                               		// 0x1C74 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgDevice*                                   m_BasicAttackDevice;                              		// 0x1C78 (0x0004) [0x0000000000000000]              
	class ATgDevice*                                   m_Num1SeekingProjectileDevice;                    		// 0x1C7C (0x0004) [0x0000000000000000]              
	class ATgDeployable*                               r_Num1AxeDeployable;                              		// 0x1C80 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgDeployable*                               m_Num1WarningDeployable;                          		// 0x1C84 (0x0004) [0x0000000000000000]              
	class ATgCollisionProxy_Cylinder*                  m_Num2TweenCylinder;                              		// 0x1C88 (0x0004) [0x0000000000000000]              
	TArray< class ATgPawn* >                           m_Num2TweenHitPawns;                              		// 0x1C8C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FVector                                     m_Num2TweenDestination;                           		// 0x1C98 (0x000C) [0x0000000000000000]              
	TArray< struct FLevitateVictimInfo >               m_UltLevitateVictims;                             		// 0x1CA4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class ATgPawn* >                           m_UltStunnedVictims;                              		// 0x1CB0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class ATgPawn*                                     m_UltEffectsPawn;                                 		// 0x1CBC (0x0004) [0x0000000000000000]              
	unsigned long                                      r_bIsUltBuffed : 1;                               		// 0x1CC0 (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )
	unsigned char                                      r_nRunningKillCount;                              		// 0x1CC4 (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      c_nLocalRunningKillCount;                         		// 0x1CC5 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_nRunningKillCountMax;                           		// 0x1CC6 (0x0001) [0x0000000000000000]              
	TArray< struct FKillMaterialInfo >                 m_KillMaterialInfos;                              		// 0x1CC8 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	float                                              m_fKillCountDecrementTime;                        		// 0x1CD4 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2769 );

		return pClassPointer;
	};

	void eventOnAnimEnd ( class UAnimNodeSequence* SeqNode, float PlayedTime, float ExcessTime );
	void DecrementKillCount ( );
	void eventUpdateRunningKillCount ( unsigned char NewCount );
	void ResetRunningKillCount ( );
	void PlayDying ( class UClass* dmgType, struct FVector HitLoc );
	void OnRespawn ( );
	void PostTeleport ( class ATeleporter* OutTeleporter );
	void eventPostDemoRewind ( );
	void eventCheckPassiveEffects ( );
	void PlayDyingEffects ( );
	void eventStopUltBuffedEffects ( );
	void eventPlayUltBuffedEffects ( );
	bool eventDied ( class AController* Killer, class UClass* dmgType, struct FVector HitLocation );
	void eventOnNum2CollisionProxyTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void UpdateNum2Targeter ( );
	void RegisterNum1AxeDeployable ( class ATgDeployable* NewAxeDeployable );
	int GetNum1SeekingProjectileFireModeId ( );
	void OnDeviceFormStartFire ( int nEquipSlot, float FireDuration, int nFireMode );
	void OnDeviceFormBuildup ( int nEquipSlot, float fBuildupTime );
	void eventSetTargetingDevice ( class ATgDevice* Dev );
	bool IgnoreFaceRotationWithInterp ( );
	void EndTween ( unsigned char endingTweenState, unsigned long bInterrupted );
	void BeginTween ( unsigned char newTweenState );
	void eventReplicatedEvent ( struct FName VarName );
	bool eventPostPawnSetup ( );
	void RecalculateMaterial ( unsigned long bIsFriendlyWithLocalPawn, unsigned long bForce );
	void UpdateKillMaterial ( float DeltaTime, unsigned long bForce, struct FKillMaterialInfo* KillMatInfo );
	void PawnOnKilled ( class AActor* Victim, int* xpGain, int* goldGain );
	bool DeviceOverrideManaUseVitals ( class ATgDevice* Dev, class ATgPlayerController* PC );
	void UltRemoveHitSpecialStun ( );
	bool ShouldPawnMeshBeHiddenThisTick ( );
	float GetSmoothEnergy ( );
	bool DeviceHasEnoughPowerPool ( class ATgDevice* Dev, unsigned char FireModeNum );
	void ConsumePowerPool ( class ATgDevice* Dev, int nPacingType, float fAmount );
	void DeviceOnSetFireMode ( class ATgDevice* Dev );
	bool DeviceOnCanDeviceFireNow ( class ATgDevice* Dev, unsigned char FireModeNum, unsigned long bDeviceFailLog, struct FAimData* Aim );
	bool DeviceOverrideTargetingAim ( class ATgDevice* Dev, struct FAimData* Aim, TArray< struct FImpactInfo >* ImpactList );
	void DeviceOnHit ( class ATgDevice* Dev, struct FImpactInfo* Impact );
	void DeviceOnDamaged ( struct FOnDamagedParams* Params );
	void DeviceOnStopFire ( class ATgDevice* Dev, unsigned long WasInterrupted );
	void DeviceOnFire ( class ATgDevice* Dev );
	void DeviceOnStartFire ( class ATgDevice* Dev );
	void DeviceOnStopBuildup ( class ATgDevice* Dev, unsigned long WasInterrupted );
	void DeviceOnStartBuildup ( class ATgDevice* Dev );
};

UClass* ATgPawn_Chaac::pClassPointer = NULL;

// Class TgGame.TgPawn_ChangE
// 0x0010 (0x1C7C - 0x1C6C)
class ATgPawn_ChangE : public ATgPawn_Character
{
public:
	unsigned long                                      r_bUltIsActive : 1;                               		// 0x1C6C (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )
	unsigned long                                      r_bDodgeIsActive : 1;                             		// 0x1C6C (0x0004) [0x0000000000000020] [0x00000002] ( CPF_Net )
	int                                                s_nNumAvoidedHits;                                		// 0x1C70 (0x0004) [0x0000000000000000]              
	int                                                s_nNumUltGodHits;                                 		// 0x1C74 (0x0004) [0x0000000000000000]              
	class UTgSkeletalMeshComponent*                    m_DeathMeshComponent;                             		// 0x1C78 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2770 );

		return pClassPointer;
	};

	void CleanUpDyingEffects ( );
	void PlayDyingEffects ( );
	void eventSetMICMode ( );
	void eventReplicatedEvent ( struct FName VarName );
	void OnRespawn ( );
	void CourierPhaseChanged ( unsigned char Phase );
	void DespawnPet ( );
	void SpawnPet ( );
	void HealAlliesAfterDodge ( );
	void PostPawnSetupServer ( );
	void PlayTeleportFx ( int TeleportId, struct FVector FXLocation );
	void PawnOnDamageMitigation ( class ATgPawn* attacker, class UTgEffectGroup* eg, int nPropertyId, float* fDamage );
	void OnPawnDied ( );
	bool DeviceOverrideTargetingAim ( class ATgDevice* Dev, struct FAimData* Aim, TArray< struct FImpactInfo >* ImpactList );
	void DeviceOnHit ( class ATgDevice* Dev, struct FImpactInfo* Impact );
	void DeviceOnStopFire ( class ATgDevice* Dev, unsigned long WasInterrupted );
	void DeviceOnStartFire ( class ATgDevice* Dev );
	class ATgPawn_Courier* GetAvailableCourier ( );
};

UClass* ATgPawn_ChangE::pClassPointer = NULL;

// Class TgGame.TgPawn_Chiron
// 0x00B0 (0x1D1C - 0x1C6C)
class ATgPawn_Chiron : public ATgPawn_Character
{
public:
	class ATgDevice*                                   r_dev_inhand;                                     		// 0x1C6C (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgDevice_Chiron_ChargeLong*                 r_dev_chargelong;                                 		// 0x1C70 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgDevice_Chiron_Ultimate*                   r_dev_ultimate;                                   		// 0x1C74 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgDevice_Chiron_Passive*                    s_dev_passive;                                    		// 0x1C78 (0x0004) [0x0000000000000000]              
	int                                                r_nLocksActive;                                   		// 0x1C7C (0x0004) [0x0000000000000020]              ( CPF_Net )
	class UTgMarkComponent_Chiron_Lockon*              s_TargetingMarks;                                 		// 0x1C80 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class UClass*                                      m_ChargeLongControlModuleClass;                   		// 0x1C84 (0x0004) [0x0000000000000002]              ( CPF_Const )
	class UClass*                                      m_PreviousControlModuleClass;                     		// 0x1C88 (0x0004) [0x0000000000000000]              
	class UTgControlModule*                            m_ChargeLongControlModule;                        		// 0x1C8C (0x0004) [0x0000000000000000]              
	class UTgAnimNodeSlot*                             c_KickAnimSlot;                                   		// 0x1C90 (0x0004) [0x0000000000000000]              
	struct FName                                       c_KickAnimName;                                   		// 0x1C94 (0x0008) [0x0000000000000000]              
	float                                              m_fKickAnimRecoverTime;                           		// 0x1C9C (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bTransformInProgress : 1;                       		// 0x1CA0 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bKicking : 1;                                   		// 0x1CA0 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      r_bUltIsBuildingUp : 1;                           		// 0x1CA0 (0x0004) [0x0000000000000020] [0x00000004] ( CPF_Net )
	unsigned long                                      s_bKillOnStopFire : 1;                            		// 0x1CA0 (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      s_bTargetable : 1;                                		// 0x1CA0 (0x0004) [0x0000000000000000] [0x00000010] 
	unsigned long                                      r_bReviveOccured : 1;                             		// 0x1CA0 (0x0004) [0x0000000000000020] [0x00000020] ( CPF_Net )
	float                                              r_fChargeDecreaseSpeedMultiplier;                 		// 0x1CA4 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              m_fChargeIncreaseSpeedMultiplier;                 		// 0x1CA8 (0x0004) [0x0000000000000000]              
	float                                              m_fTurnSlowPct;                                   		// 0x1CAC (0x0004) [0x0000000000000000]              
	float                                              m_fKickCheckCount;                                		// 0x1CB0 (0x0004) [0x0000000000000000]              
	float                                              m_fKickCheckDelta;                                		// 0x1CB4 (0x0004) [0x0000000000000000]              
	float                                              m_fKickCheckRange;                                		// 0x1CB8 (0x0004) [0x0000000000000000]              
	float                                              m_fTotalUltChargeUpTime;                          		// 0x1CBC (0x0004) [0x0000000000000000]              
	float                                              m_fRemainingUltChargeUpTime;                      		// 0x1CC0 (0x0004) [0x0000000000000000]              
	class APawn*                                       s_Killer;                                         		// 0x1CC4 (0x0004) [0x0000000000000000]              
	TArray< class AActor* >                            s_Damaged;                                        		// 0x1CC8 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< float >                                    s_AccumulatedDamage;                              		// 0x1CD4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	float                                              r_fTotalHealthStolen;                             		// 0x1CE0 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class UTgEffectGroup*                              s_UltimateCancelRoot;                             		// 0x1CE4 (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                m_ReviveFX;                                       		// 0x1CE8 (0x0004) [0x0000000000000000]              
	int                                                c_nMaxPassiveStacks;                              		// 0x1CEC (0x0004) [0x0000000000000000]              
	int                                                r_nCurrentPassiveStacks;                          		// 0x1CF0 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              r_fCurrentPassiveMeterEnergy;                     		// 0x1CF4 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              r_fMaxPassiveMeterEnergy;                         		// 0x1CF8 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              r_fCurrentPassiveDistance;                        		// 0x1CFC (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              r_fMaxPassiveDistance;                            		// 0x1D00 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              m_fPassiveDistanceMultiplier;                     		// 0x1D04 (0x0004) [0x0000000000000000]              
	float                                              m_fRemainingPausePassiveDistanceTime;             		// 0x1D08 (0x0004) [0x0000000000000000]              
	TArray< class UTgSpecialFx* >                      c_PassiveSpecialFX;                               		// 0x1D0C (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	int                                                c_nPrevStacks;                                    		// 0x1D18 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2771 );

		return pClassPointer;
	};

	void OnRespawn ( );
	bool eventDied ( class AController* Killer, class UClass* dmgType, struct FVector HitLocation );
	void eventPlayReviveFx ( );
	void ToggleUltimateRoot ( unsigned long bEnable );
	void CacheMainMeshReferences ( class UTgSkeletalMeshComponent* smcomp );
	void EndChargeKickAnim ( );
	void eventPlayChargeKickAnim ( );
	void eventDeathPreventedFrom ( class APawn* attacker );
	struct FRotator GetAdjustedAimFor ( class AWeapon* W, struct FVector StartFireLoc );
	float GetChargeTurnRate ( );
	void eventPassiveFire ( class AActor* Target );
	int GetNumPassiveStacks ( );
	void eventSetTargetingDevice ( class ATgDevice* Dev );
	bool eventDeviceOverrideLockedDown ( class ATgDevice* Dev );
	bool eventPostPawnSetup ( );
	void ReplicatedEvent ( struct FName VarName );
	void SendKillingBlowMessage ( class AActor* Source, class AActor* Target, float fDamage, float fMitigated );
	void SetTargetable ( unsigned long targetable );
	void UpdatePassiveSpecialFX ( int nStacks );
	bool InitializePassiveSpecialFX ( );
	bool InitializeReviveFX ( );
	bool CanFirePassive ( class ATgDevice* Dev );
	void DecrementPassiveStacks ( );
	void IncrementPassiveStacks ( );
	bool GetPassiveAuxMax ( float* fResult );
	bool GetPassiveAux ( float* fResult );
	float GetSmoothEnergy ( );
	void PawnAdjustHeal ( class ATgPawn* InstigatorPawn, int nPropertyId, struct FImpactInfo* Impact, float* fHeal );
	void DeviceOnKilled ( class ATgDevice* Dev, float fDamage, struct FImpactInfo* Impact );
	void DeviceOnDamaged ( struct FOnDamagedParams* Params );
	void DeviceOnStopFire ( class ATgDevice* Dev, unsigned long WasInterrupted );
	void DeviceOnStartFire ( class ATgDevice* Dev );
	void DeviceOnStartBuildup ( class ATgDevice* Dev );
	bool DeviceOnCanDeviceFireNow ( class ATgDevice* Dev, unsigned char FireModeNum, unsigned long bDeviceFailLog, struct FAimData* Aim );
};

UClass* ATgPawn_Chiron::pClassPointer = NULL;

// Class TgGame.TgPawn_Chronos
// 0x00CC (0x1D38 - 0x1C6C)
class ATgPawn_Chronos : public ATgPawn_Character
{
public:
	unsigned long                                      r_bPhaseShiftEnabled : 1;                         		// 0x1C6C (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )
	unsigned long                                      r_bHastenActive : 1;                              		// 0x1C6C (0x0004) [0x0000000000000020] [0x00000002] ( CPF_Net )
	unsigned long                                      r_bIsRewinding : 1;                               		// 0x1C6C (0x0004) [0x0000000000000020] [0x00000004] ( CPF_Net )
	unsigned long                                      c_bReceivedReplicatedRewindInfo : 1;              		// 0x1C6C (0x0004) [0x0000000000000000] [0x00000008] 
	float                                              SmoothedEnergy;                                   		// 0x1C70 (0x0004) [0x0000000000000000]              
	float                                              SmoothedEnergyTolerance;                          		// 0x1C74 (0x0004) [0x0000000000000000]              
	float                                              SmoothedEnergyCorrectionNeeded;                   		// 0x1C78 (0x0004) [0x0000000000000000]              
	float                                              LastServerEnergy;                                 		// 0x1C7C (0x0004) [0x0000000000000000]              
	int                                                LastPhaseShiftQuadrant;                           		// 0x1C80 (0x0004) [0x0000000000000000]              
	int                                                s_nQuadrantToActivate[ 0x4 ];                     		// 0x1C84 (0x0010) [0x0000000000000000]              
	int                                                r_nActiveQuadrant;                                		// 0x1C94 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                c_nChronosHastenState;                            		// 0x1C98 (0x0004) [0x0000000000000000]              
	TArray< class UTgAnimBlendByChronosHasten* >       c_HastenAnimNodes;                                		// 0x1C9C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	float                                              r_fTargetHastenMultipler;                         		// 0x1CA8 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              r_fHastenTweenRate;                               		// 0x1CAC (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              m_fHastenMultipler;                               		// 0x1CB0 (0x0004) [0x0000000000000000]              
	float                                              c_fLastHUDHastenMultipler;                        		// 0x1CB4 (0x0004) [0x0000000000000000]              
	TArray< class UTgSpecialFx* >                      c_HastenFXs;                                      		// 0x1CB8 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	TArray< struct FName >                             c_HastenSkelControlNames;                         		// 0x1CC4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                m_nHastenActiveDeviceMode;                        		// 0x1CD0 (0x0004) [0x0000000000000000]              
	int                                                r_nHUDHastenTicker;                               		// 0x1CD4 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nRewindTicker;                                  		// 0x1CD8 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              r_fRewindTargetTimeStamp;                         		// 0x1CDC (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              r_fRewindRate;                                    		// 0x1CE0 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              r_fRewindLocationZ;                               		// 0x1CE4 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              m_fRewindTargetTimeStamp;                         		// 0x1CE8 (0x0004) [0x0000000000000000]              
	float                                              m_fRewindRate;                                    		// 0x1CEC (0x0004) [0x0000000000000000]              
	float                                              m_fRewindProgress;                                		// 0x1CF0 (0x0004) [0x0000000000000000]              
	float                                              m_fRewindDuration;                                		// 0x1CF4 (0x0004) [0x0000000000000000]              
	TArray< struct FRewindInfo >                       s_RewindArray;                                    		// 0x1CF8 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	float                                              s_fRewindTime;                                    		// 0x1D04 (0x0004) [0x0000000000000000]              
	float                                              s_fRewindSavePeriod;                              		// 0x1D08 (0x0004) [0x0000000000000000]              
	int                                                s_nMaxRewindHistory;                              		// 0x1D0C (0x0004) [0x0000000000000000]              
	class USkeletalMeshComponent*                      c_RewindMeshComponent;                            		// 0x1D10 (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )
	TArray< class UTgSpecialFx* >                      c_RewindFXs;                                      		// 0x1D14 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< struct FName >                             c_AliveSkelControlNames;                          		// 0x1D20 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< struct FName >                             c_DeadSkelControlNames;                           		// 0x1D2C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2772 );

		return pClassPointer;
	};

	void ToggleSkelControls ( unsigned long bAlive );
	void eventFaceRotation ( struct FRotator NewRotation, float DeltaTime );
	void DisablePassive ( );
	void TickPhaseShift ( float DeltaSeconds );
	void eventTogglePhaseShift ( unsigned long bEnable );
	void TickHasten ( float DeltaSeconds );
	void eventStartHastenTween ( float fTargetMultipler, float fTweenTime );
	void TickRewind ( float DeltaSeconds );
	void eventUpdateRewindHistory ( );
	void Tick ( float DeltaSeconds );
	bool HastenAreOtherDevicesFiring ( );
	void eventUpdateHastenState ( unsigned long bEnable );
	void OnDeviceFormStartFire ( int nEquipSlot, float FireDuration, int nFireMode );
	void OnDeviceFormBuildup ( int nEquipSlot, float fBuildupTime );
	void eventDeactivateRewindMesh ( unsigned long bWasInterrupted );
	void ActivateRewindMesh ( float Rate );
	void EndTween ( unsigned char endingTweenState, unsigned long bInterrupted );
	void BeginTween ( unsigned char newTweenState );
	void OnRespawn ( );
	void eventSetRewindProgress ( float fProgress );
	void eventSetRewindRate ( float fRewindRate );
	void eventSetRewindTargetTimeStamp ( float fRewindTargetTimeStamp );
	void eventReplicateRewindInfo ( );
	void eventToggleRewind ( );
	void eventReceivedActiveQuadrant ( );
	void ClientRestartRewindHistory ( );
	void RestartRewindHistory ( );
	void PostTeleport ( class ATeleporter* OutTeleporter );
	void eventSetEnergySyncPoint ( float fEnergy );
	void eventPropertySet ( int nPropertyId, float fPreviousValue, float fNewValue );
	void eventReceivedHastenTicker ( );
	void eventReceivedPropValues ( );
	void eventPostDemoRewind ( );
	void eventReplicatedEvent ( struct FName VarName );
	void eventPostInitAnimTree ( class USkeletalMeshComponent* SkelComp );
	bool eventPostPawnSetup ( );
	bool ShouldPawnMeshBeHiddenThisTick ( );
	void AttachAndActivateRewindFXsToMesh ( class UMeshComponent* RewindMesh );
	void EndRewind ( );
	void BeginRewind ( class ATgDevice* Dev, float fDelta );
	bool InitializeRewindMeshComponent ( );
	void ChangePassive ( class ATgDevice* Dev );
	void EndHasten ( unsigned long bWasInterrupted );
	void BeginHasten ( class ATgDevice* Dev );
	bool InitializeHastenFXs ( );
	void OnAttackDamagePropertyChange ( );
	void RegainEnergyPool ( float fDelta );
	void CalcSmoothEnergy ( float fDelta );
	void SetSpawnEnergy ( );
	float GetSmoothEnergy ( );
	float GetUIGroundSpeed ( );
	void DeviceAdjustDamage ( class ATgDevice* Device, int nPropertyId, struct FImpactInfo* Impact, float* DamageAmt );
	bool GetPassiveInt1 ( int* nResult );
	void PawnOnDodged ( struct FOnDodgedParams* Params );
	void PawnOnDamaged ( struct FOnDamagedParams* Params );
	bool DeviceOverrideTargetingAim ( class ATgDevice* Dev, struct FAimData* Aim, TArray< struct FImpactInfo >* ImpactList );
	void DeviceOnHit ( class ATgDevice* Dev, struct FImpactInfo* Impact );
	void DeviceOnStopFire ( class ATgDevice* Dev, unsigned long WasInterrupted );
	void DeviceOnFire ( class ATgDevice* Dev );
	void DeviceOnStartFire ( class ATgDevice* Dev );
	void DeviceOnStartBuildup ( class ATgDevice* Dev );
	void PostPawnSetupServer ( );
};

UClass* ATgPawn_Chronos::pClassPointer = NULL;

// Class TgGame.TgPawn_Cupid
// 0x003C (0x1CA8 - 0x1C6C)
class ATgPawn_Cupid : public ATgPawn_Character
{
public:
	class UTgMarkComponent*                            m_PassiveMarkComponent;                           		// 0x1C6C (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )
	class UTgSpecialFx*                                c_PassiveSpecialFX;                               		// 0x1C70 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_TimedBombProjectileLovestruckCount;             		// 0x1C74 (0x0004) [0x0000000000000000]              
	int                                                m_TimedBombLovestruckCount;                       		// 0x1C78 (0x0004) [0x0000000000000000]              
	class UTgMarkComponent_Cupid_TimedBomb*            m_TimedBombMarkComponent;                         		// 0x1C7C (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )
	TArray< class UTgDeviceFire* >                     m_TimedBombModes;                                 		// 0x1C80 (0x000C) [0x0000000000500000]              ( CPF_NeedCtorLink )
	class UTgEffectGroup*                              m_TimedBombInstantExplosionEffectGroup;           		// 0x1C8C (0x0004) [0x0000000000000000]              
	int                                                m_HealingHeartsLovestruckCounter;                 		// 0x1C90 (0x0004) [0x0000000000000000]              
	struct FVector                                     m_LastSpeedPadDeployableLocation;                 		// 0x1C94 (0x000C) [0x0000000000000000]              
	float                                              m_SpeedPadDistanceInterval;                       		// 0x1CA0 (0x0004) [0x0000000000000000]              
	class UTgSkeletalMeshComponent*                    c_GhostMeshComponent;                             		// 0x1CA4 (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2773 );

		return pClassPointer;
	};

	bool IgnoreFaceRotationWithInterp ( );
	void CleanUpDyingEffects ( );
	void PlayDyingEffects ( );
	void Tick ( float DeltaSeconds );
	bool eventPostPawnSetup ( );
	void SpawnSpeedPad ( struct FVector SpawnLocation );
	float GetSpeedPadDistanceInterval ( );
	void PlayTeleportFx ( int nTeleportState, struct FVector vLoc );
	void TimedBombExplosion ( class AActor* ExplodingActor, unsigned long ShouldStun );
	void DeviceOnStopFire ( class ATgDevice* Dev, unsigned long WasInterrupted );
	void DeviceAdjustHeal ( class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fHeal );
	void DeviceAdjustDamage ( class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage );
	void DeviceOnHit ( class ATgDevice* Dev, struct FImpactInfo* Impact );
	void DeviceOnFire ( class ATgDevice* Dev );
	void DeviceOnStartFire ( class ATgDevice* Dev );
	void PostPawnSetupServer ( );
	void ResetGhostMeshComponent ( );
	bool InitializeGhostMeshComponent ( );
	bool InitializePassiveSpecialFX ( );
};

UClass* ATgPawn_Cupid::pClassPointer = NULL;

// Class TgGame.TgPawn_Fenrir
// 0x00B4 (0x1D20 - 0x1C6C)
class ATgPawn_Fenrir : public ATgPawn_Character
{
public:
	float                                              s_fLeapComboPoints;                               		// 0x1C6C (0x0004) [0x0000000000000000]              
	unsigned char                                      r_eBiteState;                                     		// 0x1C70 (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      m_eLocalBiteState;                                		// 0x1C71 (0x0001) [0x0000000000000000]              
	int                                                m_nBiteBigPostureID;                              		// 0x1C74 (0x0004) [0x0000000000000000]              
	int                                                m_nBiteGrabPostureID;                             		// 0x1C78 (0x0004) [0x0000000000000000]              
	class ATgDevice*                                   r_BiteInHand;                                     		// 0x1C7C (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgDevice*                                   r_NormalInHand;                                   		// 0x1C80 (0x0004) [0x0000000000000020]              ( CPF_Net )
	unsigned long                                      s_bNoComboPointsForNextHit : 1;                   		// 0x1C84 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bEndMaulOnTweenEnd : 1;                         		// 0x1C84 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_bUseBestMaulLocation : 1;                       		// 0x1C84 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      s_bInEndMaul : 1;                                 		// 0x1C84 (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      r_bIsHowling : 1;                                 		// 0x1C84 (0x0004) [0x0000000000000020] [0x00000010] ( CPF_Net )
	float                                              s_fBiteComboPoints;                               		// 0x1C88 (0x0004) [0x0000000000000000]              
	class UTgEffectGroup*                              s_GrabTargetCCImmunity;                           		// 0x1C8C (0x0004) [0x0000000000000000]              
	class UTgAnimBlendByFire*                          m_EnragedFireNode;                                		// 0x1C90 (0x0004) [0x0000000000000000]              
	float                                              m_fScalingProgress;                               		// 0x1C94 (0x0004) [0x0000000000000000]              
	float                                              m_fScalingRate;                                   		// 0x1C98 (0x0004) [0x0000000000000000]              
	float                                              m_fMaxMeshScale;                                  		// 0x1C9C (0x0004) [0x0000000000000000]              
	float                                              m_fMaxCollisionRadius;                            		// 0x1CA0 (0x0004) [0x0000000000000000]              
	float                                              m_fMaxCollisionHeight;                            		// 0x1CA4 (0x0004) [0x0000000000000000]              
	float                                              m_fThrowdownDuration;                             		// 0x1CA8 (0x0004) [0x0000000000000000]              
	int                                                c_nLocalJumpCount;                                		// 0x1CAC (0x0004) [0x0000000000000000]              
	TArray< class UTgSpecialFx* >                      c_BiteFxs;                                        		// 0x1CB0 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	float                                              s_fMaulComboPoints;                               		// 0x1CBC (0x0004) [0x0000000000000000]              
	class AActor*                                      r_MaulTarget;                                     		// 0x1CC0 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class AActor*                                      c_MaulTarget;                                     		// 0x1CC4 (0x0004) [0x0000000000000000]              
	TArray< class UTgDeviceFire* >                     s_MaulDamageModes;                                		// 0x1CC8 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UTgDeviceFire* >                     s_MaulBonusDamageModes;                           		// 0x1CD4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                s_nMaulJumpCount;                                 		// 0x1CE0 (0x0004) [0x0000000000000000]              
	int                                                s_nMaulExplosionCount;                            		// 0x1CE4 (0x0004) [0x0000000000000000]              
	struct FVector                                     m_BestMaulLocation;                               		// 0x1CE8 (0x000C) [0x0000000000000000]              
	float                                              s_fHowlComboPoints;                               		// 0x1CF4 (0x0004) [0x0000000000000000]              
	TArray< class UTgSpecialFx* >                      c_HowlFxs;                                        		// 0x1CF8 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	class UTgSkeletalMeshComponent*                    c_HowlMeshComponent;                              		// 0x1D04 (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )
	class UMaterialInstanceConstant*                   c_HowlMIC;                                        		// 0x1D08 (0x0004) [0x0000000000000000]              
	class UMaterialInstanceConstant*                   c_MeshMIC;                                        		// 0x1D0C (0x0004) [0x0000000000000000]              
	float                                              c_fHowlTargetScale;                               		// 0x1D10 (0x0004) [0x0000000000000000]              
	float                                              c_fHowlCurrentScale;                              		// 0x1D14 (0x0004) [0x0000000000000000]              
	float                                              c_fHowlScalingRate;                               		// 0x1D18 (0x0004) [0x0000000000000000]              
	float                                              c_fDefaultScaleUpTime;                            		// 0x1D1C (0x0004) [0x0000000000000002]              ( CPF_Const )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2774 );

		return pClassPointer;
	};

	void FaceRotation ( struct FRotator NewRotation, float DeltaTime );
	void ClientBestMaulLocation ( float MaulX, float MaulY, float MaulZ );
	void eventSetBestMaulLocation ( struct FVector BestLocation, unsigned long bInTweenEnd );
	void eventUpdateMaulTarget ( class AActor* Target );
	void OnEndShrink ( unsigned char OldState );
	void StartShrink ( unsigned char OldState );
	void OnEndGrow ( unsigned char OldState );
	void StartGrow ( unsigned char OldState );
	void AdjustScaleAndCollision ( float fProgress );
	void BiteThrowdown ( unsigned char OldState );
	void OnBiteFail ( unsigned char OldState );
	void BiteGrab ( unsigned char OldState );
	void eventUpdateBite ( unsigned char eNextBiteState );
	void eventClientBiteSuccessful ( );
	void ClientBiteFailed ( );
	void EndThrowdown ( );
	void TickBite ( float DeltaSeconds );
	void UpdatedHowl ( );
	void eventToggleHowl ( unsigned long bEnable, float fTweenTime );
	void TickHowl ( float DeltaSeconds );
	void OnDeviceFormStartFire ( int nEquipSlot, float FireDuration, int nFireMode );
	void OnDeviceFormBuildup ( int nEquipSlot, float fBuildupTime );
	void OnGrabTargetDetach ( unsigned char endingGrabState, class ATgPawn* Target, unsigned long bInterrupted );
	void OnGrabTargetAttach ( unsigned char newGrabState, class ATgPawn* Target );
	void OnTeleportNotify ( class AActor* TeleportingActor );
	struct FVector eventGetPhysTweenTargetLocation ( );
	void EndTween ( unsigned char endingTweenState, unsigned long bInterrupted );
	void MaulTweenEnd ( unsigned long bInterrupted );
	void MaulTweenStart ( unsigned long bRemoveRoots );
	void BeginTween ( unsigned char newTweenState );
	void Tick ( float DeltaSeconds );
	void eventSetTargetingDevice ( class ATgDevice* Dev );
	bool CannotJumpNow ( );
	void eventPostDemoRewind ( );
	bool eventPostPawnSetup ( );
	void eventPostInitAnimTree ( class USkeletalMeshComponent* SkelComp );
	void eventReplicatedEvent ( struct FName VarName );
	void EndHowl ( unsigned long bInterrupted );
	void BeginHowl ( class ATgDevice* Dev );
	bool InitializeHowlMeshComponent ( );
	bool InitializeHowlFxs ( );
	void MaulExplosion ( );
	void StartMaulJump ( class ATgDevice* Dev );
	void EndMaul ( unsigned long bInterrupted, unsigned long bEndInTween );
	void BeginMaul ( class ATgDevice* Dev, class AActor* Target );
	float GetGiantMeshScale ( );
	float GetDefaultMeshScale ( );
	void CorrectLocationWhileChangingSize ( float HeightDelta );
	void GetSmallCollisionCylinderSize ( float* Radius, float* Height );
	void GetGiantCollisionCylinderSize ( float* Radius, float* Height );
	bool InitializeBiteFxs ( );
	void EndBite ( unsigned long bInterrupted );
	void BeginBite ( class ATgDevice* Dev );
	void EndCharge ( unsigned long bInterrupted );
	void StartCharge ( class ATgDevice* Dev );
	void OnPawnDied ( );
	bool DeviceOnCanDeviceFireNow ( class ATgDevice* Dev, unsigned char FireModeNum, unsigned long bDeviceFailLog, struct FAimData* Aim );
	void DeviceAdjustDamage ( class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage );
	void PawnOnKilled ( class AActor* Victim, int* xpGain, int* goldGain );
	void DeviceOnHit ( class ATgDevice* Dev, struct FImpactInfo* Impact );
	void DeviceOnStopFire ( class ATgDevice* Dev, unsigned long WasInterrupted );
	void DeviceOnFire ( class ATgDevice* Dev );
	void DeviceOnStartFire ( class ATgDevice* Dev );
	float ConsumeComboPoints ( );
	float GetSmoothEnergy ( );
	void SetSpawnEnergy ( );
};

UClass* ATgPawn_Fenrir::pClassPointer = NULL;

// Class TgGame.TgPawn_Fenrir_PVE
// 0x0000 (0x1D20 - 0x1D20)
class ATgPawn_Fenrir_PVE : public ATgPawn_Fenrir
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2775 );

		return pClassPointer;
	};

	void OnGrabTargetDetach ( unsigned char endingGrabState, class ATgPawn* Target, unsigned long bInterrupted );
	void OnGrabTargetAttach ( unsigned char newGrabState, class ATgPawn* Target );
	void eventUpdateBite ( unsigned char eNextBiteState );
	void TickBite ( float DeltaSeconds );
	void PostPawnSetupServer ( );
	void EndBite ( unsigned long bInterrupted );
};

UClass* ATgPawn_Fenrir_PVE::pClassPointer = NULL;

// Class TgGame.TgPawn_Fenrir_PVE_Tier2
// 0x0000 (0x1D20 - 0x1D20)
class ATgPawn_Fenrir_PVE_Tier2 : public ATgPawn_Fenrir_PVE
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2776 );

		return pClassPointer;
	};

	void eventBump ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitNormal );
	void PostPawnSetupServer ( );
};

UClass* ATgPawn_Fenrir_PVE_Tier2::pClassPointer = NULL;

// Class TgGame.TgPawn_Freya
// 0x008C (0x1CF8 - 0x1C6C)
class ATgPawn_Freya : public ATgPawn_Character
{
public:
	unsigned char                                      r_EquippedInHand;                                 		// 0x1C6C (0x0001) [0x0000000000000020]              ( CPF_Net )
	class ATgDevice*                                   s_InHandMelee;                                    		// 0x1C70 (0x0004) [0x0000000000000000]              
	class ATgDevice*                                   s_InHandRanged;                                   		// 0x1C74 (0x0004) [0x0000000000000000]              
	class ATgDevice*                                   s_InHandUltimate;                                 		// 0x1C78 (0x0004) [0x0000000000000000]              
	unsigned long                                      s_bInHandSwapOnHold : 1;                          		// 0x1C7C (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	unsigned long                                      r_bGlowingOn : 1;                                 		// 0x1C7C (0x0004) [0x0000000000000020] [0x00000002] ( CPF_Net )
	unsigned long                                      m_bDoScaledDamage : 1;                            		// 0x1C7C (0x0004) [0x0000000000002000] [0x00000004] ( CPF_Transient )
	unsigned long                                      r_bInCloakJump : 1;                               		// 0x1C7C (0x0004) [0x0000000000000020] [0x00000008] ( CPF_Net )
	unsigned long                                      r_bInCloakTakedown : 1;                           		// 0x1C7C (0x0004) [0x0000000000000020] [0x00000010] ( CPF_Net )
	struct FVector                                     m_InHandFireLocationOffset[ 0x3 ];                		// 0x1C80 (0x0024) [0x0000000000000000]              
	class UTgAnimBlendByFreyaInHand*                   m_InHandAnimNode;                                 		// 0x1CA4 (0x0004) [0x0000000000000000]              
	class UTgMarkComponent*                            m_DamageBuffMarkComponent;                        		// 0x1CA8 (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )
	class UMaterialInstanceConstant*                   m_GlowingTattooMIC;                               		// 0x1CAC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_fGlowProgress;                                  		// 0x1CB0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_fGlowSpeed;                                     		// 0x1CB4 (0x0004) [0x0000000000000000]              
	TArray< class UTgDeviceFire* >                     m_RangedAOEModes;                                 		// 0x1CB8 (0x000C) [0x0000000000500000]              ( CPF_NeedCtorLink )
	class UTgSpecialFx*                                m_RangedAOEVisualFX;                              		// 0x1CC4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UTgSpecialFx*                                m_RangedGauntletFx[ 0x2 ];                        		// 0x1CC8 (0x0008) [0x0000000000002000]              ( CPF_Transient )
	class UTgMarkComponent*                            m_CloakOfFeathersMarkComponent;                   		// 0x1CD0 (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )
	class UTgSkeletalMeshComponent*                    c_CloakMeshComponent;                             		// 0x1CD4 (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )
	TArray< class UTgAnimNodeFreyaCloak* >             c_FreyaCloakAnimNodes;                            		// 0x1CD8 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class UTgAnimNodeBlendByFreyaUltimate*             m_UltimateCycleBlendList;                         		// 0x1CE4 (0x0004) [0x0000000000000000]              
	TArray< struct FName >                             m_DeathAnimList;                                  		// 0x1CE8 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                m_nLastDeathAnim;                                 		// 0x1CF4 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2777 );

		return pClassPointer;
	};

	struct FName eventGetDeathAnimName ( );
	bool IsInClassSpecificMovement ( );
	void CleanUpDyingEffects ( );
	void PlayDyingEffects ( );
	void OnDeviceFormInterruptFire ( int nEquipSlot );
	void OnDeviceFormStopFire ( int nEquipSlot );
	void OnDeviceFormFire ( int nEquipSlot );
	void OnDeviceFormStartFire ( int nEquipSlot, float FireDuration, int nFireMode );
	void OnDeviceFormBuildup ( int nEquipSlot, float fBuildupTime );
	float ApplyPitchLimit ( float fPitch );
	void eventGauntletsDeactivate ( );
	void eventGauntletsActivate ( );
	void eventTattoosDeactivate ( );
	void eventTattoosActivate ( );
	void Tick ( float DeltaSeconds );
	void eventSetTargetingDevice ( class ATgDevice* Dev );
	void DetachCloak ( );
	void PlaySpawnFx ( );
	bool InitTattooAndLightFX ( );
	void eventPostInitAnimTree ( class USkeletalMeshComponent* SkelComp );
	bool eventPostPawnSetup ( );
	void eventPreDemoRewind ( );
	void eventReplicatedEvent ( struct FName VarName );
	bool CannotJumpNow ( );
	void eventChangedEquippedInHand ( );
	void OnPawnDied ( );
	void EndRangedAttack ( unsigned long bForce );
	float GetPhysicalPowerItem ( struct FImpactInfo Impact, float PowerScaling );
	void EffectGroupOnSetActive ( unsigned long bActive, unsigned long bRemoving, class UTgEffectGroup* effectGroup );
	bool DeviceOnCanDeviceFireNow ( class ATgDevice* Dev, unsigned char FireModeNum, unsigned long bDeviceFailLog, struct FAimData* Aim );
	void DeviceAdjustDamage ( class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage );
	void DeviceOnHit ( class ATgDevice* Dev, struct FImpactInfo* Impact );
	void DeviceOnStopFire ( class ATgDevice* Dev, unsigned long WasInterrupted );
	void DeviceOnFire ( class ATgDevice* Dev );
	void DeviceOnStartFire ( class ATgDevice* Dev );
	void PlayTeleportFx ( int nTeleportState, struct FVector vLoc );
	bool InitRangedAoeFX ( );
	bool InitRangedGauntletFX ( );
	bool InitializeCloakMeshComponent ( );
};

UClass* ATgPawn_Freya::pClassPointer = NULL;

// Class TgGame.TgPawn_G72
// 0x0048 (0x1CB4 - 0x1C6C)
class ATgPawn_G72 : public ATgPawn_Character
{
public:
	float                                              r_fStoredDamage;                                  		// 0x1C6C (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgDevice*                                   s_dDefaultInHand;                                 		// 0x1C70 (0x0004) [0x0000000000000000]              
	int                                                r_nUltAnim;                                       		// 0x1C74 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              m_fLastUltimateFire;                              		// 0x1C78 (0x0004) [0x0000000000000000]              
	int                                                r_nChargeEndTrigger;                              		// 0x1C7C (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nStartStoredCharge;                             		// 0x1C80 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nMaxCharged;                                    		// 0x1C84 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nResetCharge;                                   		// 0x1C88 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class UTgSpecialFx*                                c_sfxChargeFx;                                    		// 0x1C8C (0x0004) [0x0000000000000000]              
	class UTgAnimNodeSlot*                             c_MirrorSlot;                                     		// 0x1C90 (0x0004) [0x0000000000000000]              
	unsigned long                                      r_bEnraged : 1;                                   		// 0x1C94 (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )
	unsigned long                                      s_bServerRefireMirror : 1;                        		// 0x1C94 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      r_bMirrorOnlyAnim : 1;                            		// 0x1C94 (0x0004) [0x0000000000000020] [0x00000004] ( CPF_Net )
	int                                                c_nEnragedPostureId;                              		// 0x1C98 (0x0004) [0x0000000000000000]              
	struct FG72PassiveTarget                           s_PassiveTargets[ 0x3 ];                          		// 0x1C9C (0x0018) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2778 );

		return pClassPointer;
	};

	void CacheMainMeshReferences ( class UTgSkeletalMeshComponent* smcomp );
	void OnDeviceFormStartFire ( int nEquipSlot, float FireDuration, int nFireMode );
	void OnDeviceFormBuildup ( int nEquipSlot, float fBuildupTime );
	bool eventOtherDeviceBlockingOffhand2Anim ( class ATgDevice* FinishingDevice );
	void PlayDying ( class UClass* dmgType, struct FVector HitLoc );
	void Tick ( float DeltaSeconds );
	void eventTriggerChargeEndFx ( );
	void eventDeactivateChargeFx ( );
	void eventActivateFullChargeFx ( );
	void eventActivateChargingFx ( );
	void eventSetPosture ( );
	void eventReplicatedEvent ( struct FName VarName );
	void FlashStartFire ( int nDeviceInstanceId, int nFireModeNum, float RefireTime, class AActor* Target );
	void PlayTeleportFx ( int nTeleportState, struct FVector vLoc );
	bool InitPassiveAuras ( );
	bool GetPassiveBool ( int* bResult );
	bool GetPassiveAuxMax ( float* fResult );
	bool GetPassiveAux ( float* fResult );
	bool AreAnyOtherOffhandsLockingFiring ( class ATgDevice* CurrentDevice );
	void EffectGroupOnSetActive ( unsigned long bActive, unsigned long bRemoving, class UTgEffectGroup* effectGroup );
	void EffectGroupOnApplied ( class UTgEffectGroup* effectGroup, unsigned long bInterval );
	void DeviceOnDamaged ( struct FOnDamagedParams* Params );
	void DeviceOnStopFire ( class ATgDevice* Dev, unsigned long WasInterrupted );
	void DeviceOnStartFire ( class ATgDevice* Dev );
	void PawnOnDamaged ( struct FOnDamagedParams* Params );
	void PostPawnSetupServer ( );
};

UClass* ATgPawn_G72::pClassPointer = NULL;

// Class TgGame.TgPawn_G84
// 0x001C (0x1C88 - 0x1C6C)
class ATgPawn_G84 : public ATgPawn_Character
{
public:
	struct FVector                                     r_vLastValidPetLocation;                          		// 0x1C6C (0x000C) [0x0000000000000020]              ( CPF_Net )
	unsigned long                                      r_bPetInMovement : 1;                             		// 0x1C78 (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )
	class UTgSpecialFx*                                c_RevertMarkerFx;                                 		// 0x1C7C (0x0004) [0x0000000000000000]              
	class ATgSkeletalMeshActor*                        c_RevertMarkerMesh;                               		// 0x1C80 (0x0004) [0x0000000000000000]              
	int                                                m_nRevertMarkerFxId;                              		// 0x1C84 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2779 );

		return pClassPointer;
	};

	bool WillOverrideTakeDamage ( class APawn* Victim, int Damage, class AController* InstigatedBy, struct FVector HitLocation, struct FVector Momentum, class UClass* DamageType, struct FTraceHitInfo HitInfo, class AActor* DamageCauser );
	void TgPawnControllerSet ( );
	void Tick ( float DeltaSeconds );
	bool PostPawnSetup ( );
	void eventForceUIRefresh ( );
	void CharacterPawnControllerSet ( );
	void eventReplicatedEvent ( struct FName VarName );
	void ResetGodTargeterState ( );
	bool InitializeRevertFx ( );
	void PetExpired ( );
	void SwapControlToPet ( float fLifeTime );
};

UClass* ATgPawn_G84::pClassPointer = NULL;

// Class TgGame.TgPawn_G84_Decoy
// 0x0008 (0x1C74 - 0x1C6C)
class ATgPawn_G84_Decoy : public ATgPawn_Character
{
public:
	float                                              c_fInheritedMana;                                 		// 0x1C6C (0x0004) [0x0000000000000000]              
	float                                              c_fInheritedMaxMana;                              		// 0x1C70 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2780 );

		return pClassPointer;
	};

	void Tick ( float DeltaTime );
	bool TakeDamageSpecial ( int Damage, class AController* InstigatedBy, struct FVector HitLocation, struct FVector Momentum, class UClass* DamageType, struct FTraceHitInfo HitInfo, class AActor* DamageCauser );
};

UClass* ATgPawn_G84_Decoy::pClassPointer = NULL;

// Class TgGame.TgPawn_Geb
// 0x0058 (0x1CC4 - 0x1C6C)
class ATgPawn_Geb : public ATgPawn_Character
{
public:
	unsigned char                                      r_eBoulderState;                                  		// 0x1C6C (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      m_eLocalBoulderState;                             		// 0x1C6D (0x0001) [0x0000000000002000]              ( CPF_Transient )
	struct FName                                       c_BoulderOutroAnimNames[ 0x3 ];                   		// 0x1C70 (0x0018) [0x0000000000000000]              
	class UAnimNodeSequence*                           m_BoulderIntroSequenceNode;                       		// 0x1C88 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bTriggerBoulderMeshChange : 1;                  		// 0x1C8C (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bTransformInProgress : 1;                       		// 0x1C8C (0x0004) [0x0000000000000000] [0x00000002] 
	int                                                m_BoulderMeshAssemblyIds[ 0x3 ];                  		// 0x1C90 (0x000C) [0x0000000000000000]              
	struct FPointer                                    m_BoulderBodyMeshAssemblies[ 0x3 ];               		// 0x1C9C (0x000C) [0x0000000000001000]              ( CPF_Native )
	struct FPointer                                    m_BoulderDestroyedMeshAssemblies[ 0x3 ];          		// 0x1CA8 (0x000C) [0x0000000000001000]              ( CPF_Native )
	int                                                m_BoulderDesiredAssemblyId;                       		// 0x1CB4 (0x0004) [0x0000000000000000]              
	int                                                m_BoulderDesiredDestroyedAssemblyId;              		// 0x1CB8 (0x0004) [0x0000000000000000]              
	float                                              m_fLastBoulderSpeed;                              		// 0x1CBC (0x0004) [0x0000000000000000]              
	float                                              r_fRootlessGroundSpeed;                           		// 0x1CC0 (0x0004) [0x0000000000000020]              ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2781 );

		return pClassPointer;
	};

	void OnDeviceFormStartFire ( int nEquipSlot, float FireDuration, int nFireMode );
	void OnDeviceFormBuildup ( int nEquipSlot, float fBuildupTime );
	void eventTriggerBoulderMeshChange ( );
	void PlayNearDeathCleanup ( );
	void PlayDying ( class UClass* dmgType, struct FVector HitLoc );
	void eventPostDemoRewind ( );
	void CacheMainMeshReferences ( class UTgSkeletalMeshComponent* smcomp );
	bool eventIsValidBoulderOutroName ( struct FName AnimName );
	void eventOnAnimEnd ( class UAnimNodeSequence* SeqNode, float PlayedTime, float ExcessTime );
	void eventClientPlayEmote ( unsigned char Emote, int nExtraInfo );
	void eventReplicatedEvent ( struct FName VarName );
	void CancelEmote ( unsigned long bVerifyNoRelevantEmotes, class UTgAnimNodeEmoteSequence* Exclude );
	void KillEmoteParticles ( );
	void StartTransform ( unsigned char NewState, unsigned long bSkipTransition );
	void SwapTransformMesh ( );
	void SwapToDestroyedMesh ( );
	void SwapToLiveMesh ( );
	void SetSpawnEnergy ( );
	void PostPawnSetupServer ( );
	void OnPostureChange ( );
	float GetUIGroundSpeed ( );
};

UClass* ATgPawn_Geb::pClassPointer = NULL;

// Class TgGame.TgPawn_Geb_PVE
// 0x0004 (0x1CC8 - 0x1CC4)
class ATgPawn_Geb_PVE : public ATgPawn_Geb
{
public:
	float                                              r_fTurnRateOverride;                              		// 0x1CC4 (0x0004) [0x0000000000000020]              ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2782 );

		return pClassPointer;
	};

	bool eventDied ( class AController* Killer, class UClass* dmgType, struct FVector HitLocation );
	float GetChargeTurnRate ( );
	void SpawnOffspring ( );
};

UClass* ATgPawn_Geb_PVE::pClassPointer = NULL;

// Class TgGame.TgPawn_GuanYuV2
// 0x00B0 (0x1D1C - 0x1C6C)
class ATgPawn_GuanYuV2 : public ATgPawn_Character
{
public:
	unsigned long                                      m_bHasInitializedPassiveEnergy : 1;               		// 0x1C6C (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_HasHitWithThisHeal : 1;                         		// 0x1C6C (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_NeedsToShortenHealCooldown : 1;                 		// 0x1C6C (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_HasHitWithThisCharge : 1;                       		// 0x1C6C (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      m_NeedsToShortenChargeCooldown : 1;               		// 0x1C6C (0x0004) [0x0000000000000000] [0x00000010] 
	unsigned long                                      r_bAnimIsRidingHorse : 1;                         		// 0x1C6C (0x0004) [0x0000000000000020] [0x00000020] ( CPF_Net )
	unsigned long                                      r_bPassiveFXEnabled : 1;                          		// 0x1C6C (0x0004) [0x0000000000000020] [0x00000040] ( CPF_Net )
	class ATgCollisionProxy_Cylinder*                  m_ChargeCollisionProxy;                           		// 0x1C70 (0x0004) [0x0000000000000000]              
	TArray< struct FSavedChargeHitV2 >                 m_SavedChargeHits;                                		// 0x1C74 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class UStaticMeshComponent*                        c_GuanDaoMeshComponent;                           		// 0x1C80 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class UTgMarkComponent*                            m_TripleJumpSlamMarkComponent;                    		// 0x1C84 (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )
	float                                              m_TimeSinceInitiatedUltimate;                     		// 0x1C88 (0x0004) [0x0000000000000000]              
	float                                              m_fUltPhase1RemainingTime;                        		// 0x1C8C (0x0004) [0x0000000000000000]              
	float                                              r_fUltPhase1Time;                                 		// 0x1C90 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class UTgSkeletalMeshComponent*                    m_WarHorseMesh;                                   		// 0x1C94 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	float                                              m_fUltPhase1MaxSpeedMultiplier;                   		// 0x1C98 (0x0004) [0x0000000000000000]              
	float                                              m_fUltPhase2MaxSpeedMultiplier;                   		// 0x1C9C (0x0004) [0x0000000000000000]              
	float                                              m_fUltPhase3GallopSpeed;                          		// 0x1CA0 (0x0004) [0x0000000000000000]              
	int                                                m_nUltTurnRate;                                   		// 0x1CA4 (0x0004) [0x0000000000000000]              
	float                                              r_fUltPhase2SlowMaxSpeedMultiplier;               		// 0x1CA8 (0x0004) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      r_CurrentUltPhase;                                		// 0x1CAC (0x0001) [0x0000000000000020]              ( CPF_Net )
	float                                              m_fUltHorseZOffset;                               		// 0x1CB0 (0x0004) [0x0000000000000000]              
	struct FVector                                     m_vUltHorseInitialLocation;                       		// 0x1CB4 (0x000C) [0x0000000000000000]              
	struct FVector                                     m_vGallopAwayHorseSourceLocation;                 		// 0x1CC0 (0x000C) [0x0000000000000000]              
	struct FVector                                     m_vGallopAwayTargetLocation;                      		// 0x1CCC (0x000C) [0x0000000000000000]              
	float                                              m_fGallopAwayRemainingTime;                       		// 0x1CD8 (0x0004) [0x0000000000000000]              
	float                                              r_fGallopAwayTime;                                		// 0x1CDC (0x0004) [0x0000000000000020]              ( CPF_Net )
	class UTgAnimNodeAimOffset*                        m_GuanYuLeanAimNode;                              		// 0x1CE0 (0x0004) [0x0000000000000000]              
	class UTgAnimNodeAimOffset*                        m_HorseLeanAimNode;                               		// 0x1CE4 (0x0004) [0x0000000000000000]              
	float                                              m_fTurnSlowPct;                                   		// 0x1CE8 (0x0004) [0x0000000000000000]              
	float                                              m_fPassiveHealingMultiplier;                      		// 0x1CEC (0x0004) [0x0000000000000000]              
	class ATgDevice*                                   r_UltShooterDevice;                               		// 0x1CF0 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgDevice*                                   r_UltDismountDevice;                              		// 0x1CF4 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgDevice*                                   m_DefaultInHandDevice;                            		// 0x1CF8 (0x0004) [0x0000000000000000]              
	int                                                m_nUltHitIndex;                                   		// 0x1CFC (0x0004) [0x0000000000000000]              
	int                                                r_nNumTotalUltHits;                               		// 0x1D00 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class UTgAnimBlendByGuanYuV2Ult*                   m_UltAnimNode;                                    		// 0x1D04 (0x0004) [0x0000000000000000]              
	class UTgAnimNodeSequence*                         m_UltFire01SeqNode;                               		// 0x1D08 (0x0004) [0x0000000000000000]              
	class UTgAnimNodeSequence*                         m_UltFire02SeqNode;                               		// 0x1D0C (0x0004) [0x0000000000000000]              
	TArray< struct FGuanYuV2UltTarget >                m_UltTargets;                                     		// 0x1D10 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2783 );

		return pClassPointer;
	};

	bool CanFireDeviceWhenInvulnerable ( class ATgDevice* Dev );
	bool CanFireDeviceInStasis ( class ATgDevice* Dev );
	void FaceRotation ( struct FRotator NewRotation, float DeltaTime );
	void OnDeviceFormStopFire ( int nEquipSlot );
	bool eventDied ( class AController* Killer, class UClass* dmgType, struct FVector HitLocation );
	void ServerForceUltDismount ( );
	void OnRightMousePressed ( );
	void eventPostDemoRewind ( );
	void PlayNearDeathCleanup ( );
	void PlayDying ( class UClass* dmgType, struct FVector HitLoc );
	void eventSetTargetingDevice ( class ATgDevice* Dev );
	void OnDeviceFormStartFire ( int nEquipSlot, float FireDuration, int nFireMode );
	void eventEndHorse ( );
	void eventPlayUltFire ( );
	void eventPlayDismount ( );
	void eventStopCharging ( );
	void eventOnUltFinished ( );
	void eventPlayWarhorseStage2Effects ( );
	void eventSpawnWarhorse ( unsigned long bPlayMount );
	void BeginTween ( unsigned char newTweenState );
	void ClientSetStun ( );
	void eventStun ( unsigned long bStunController, unsigned char eType );
	float GetChargeTurnRate ( );
	void eventChargeCollisionProxyOnTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void eventTick ( float DeltaSeconds );
	void eventPostInitAnimTree ( class USkeletalMeshComponent* SkelComp );
	void eventReplicatedEvent ( struct FName VarName );
	void eventPreDemoRewind ( );
	void EnablePassiveFX ( unsigned long bEnabled );
	int GetModifiedSituationalType ( class ATgDevice* Dev );
	bool ShouldModifyDevice ( class ATgDevice* Dev );
	float GetSmoothEnergy ( );
	void PostPawnSetupServer ( );
	void SetSpawnEnergy ( );
	bool DeviceOverrideTargetingAim ( class ATgDevice* Dev, struct FAimData* Aim, TArray< struct FImpactInfo >* ImpactList );
	void ForceDismountFire ( );
	void UpdateHorse ( float DeltaTime );
	bool AreAnyOtherOffhandsLockingFiring ( class ATgDevice* CurrentDevice );
	bool DeviceOnCanDeviceFireNow ( class ATgDevice* Dev, unsigned char FireModeNum, unsigned long bDeviceFailLog, struct FAimData* Aim );
	void DeviceAdjustHeal ( class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fHeal );
	void DeviceOnStopFire ( class ATgDevice* Dev, unsigned long WasInterrupted );
	void DeviceAdjustDamage ( class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage );
	void DeviceOnPostHit ( class ATgDevice* Dev );
	void DeviceOnHit ( class ATgDevice* Dev, struct FImpactInfo* Impact );
	void DeviceOnFire ( class ATgDevice* Dev );
	void DeviceOnStartFire ( class ATgDevice* Dev );
};

UClass* ATgPawn_GuanYuV2::pClassPointer = NULL;

// Class TgGame.TgPawn_Hades
// 0x0018 (0x1C84 - 0x1C6C)
class ATgPawn_Hades : public ATgPawn_Character
{
public:
	class UTgMarkComponent*                            m_BlightComponent;                                		// 0x1C6C (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )
	class UTgMarkComponent*                            m_DevourSoulsMarkComponent;                       		// 0x1C70 (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )
	TArray< class UTgDeviceFire* >                     m_DevourSoulsModes;                               		// 0x1C74 (0x000C) [0x0000000000500000]              ( CPF_NeedCtorLink )
	class ATgCollisionProxy_Vortex_Hades*              m_PillarOfAgonyVortex;                            		// 0x1C80 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2784 );

		return pClassPointer;
	};

	void EndTween ( unsigned char endingTweenState, unsigned long bInterrupted );
	void BeginTween ( unsigned char newTweenState );
	void OnSwapToDestroyedMesh ( );
	bool eventCanBePulled ( );
	void SpawnVortex ( class ATgDevice* Dev );
	void BlightExplosion ( );
	bool ShouldPawnMeshBeHiddenThisTick ( );
	void DeviceOnSetFireMode ( class ATgDevice* Dev );
	void DeviceOnHit ( class ATgDevice* Dev, struct FImpactInfo* Impact );
	void DeviceOnStopFire ( class ATgDevice* Dev, unsigned long WasInterrupted );
	void DeviceOnStartFire ( class ATgDevice* Dev );
};

UClass* ATgPawn_Hades::pClassPointer = NULL;

// Class TgGame.TgPawn_HeBo
// 0x0020 (0x1C8C - 0x1C6C)
class ATgPawn_HeBo : public ATgPawn_Character
{
public:
	class UParticleSystemComponent*                    m_Splash;                                         		// 0x1C6C (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	struct FName                                       m_SplashAttachPoint;                              		// 0x1C70 (0x0008) [0x0000000000000000]              
	class UTgAudioComponent*                           m_MovementSound;                                  		// 0x1C78 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class ATgCollisionProxy_Wave_Hebo*                 m_WaveCollision;                                  		// 0x1C7C (0x0004) [0x0000000000000000]              
	TArray< class AActor* >                            m_WaveHitActors;                                  		// 0x1C80 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2785 );

		return pClassPointer;
	};

	void Tick ( float DeltaSeconds );
	void eventWaveTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void OnDeviceFormStopFire ( int nEquipSlot );
	void eventPostDemoRewind ( );
	void ShowScroll ( );
	void OnDeviceFormStartFire ( int nEquipSlot, float FireDuration, int nFireMode );
	void OnDeviceFormBuildup ( int nEquipSlot, float fBuildupTime );
	void PlayDyingEffects ( );
	void OnRespawn ( );
	bool eventPostPawnSetup ( );
	bool ShouldPawnMeshBeHiddenThisTick ( );
	bool DeviceOverrideTargetingAim ( class ATgDevice* Dev, struct FAimData* Aim, TArray< struct FImpactInfo >* ImpactList );
	void DeviceOnStopFire ( class ATgDevice* Dev, unsigned long WasInterrupted );
	void DeviceOnStartFire ( class ATgDevice* Dev );
};

UClass* ATgPawn_HeBo::pClassPointer = NULL;

// Class TgGame.TgPawn_HelV3
// 0x030C (0x1F78 - 0x1C6C)
class ATgPawn_HelV3 : public ATgPawn_Character
{
public:
	unsigned char                                      r_CurrentStance;                                  		// 0x1C6C (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      c_LocalCurrentStance;                             		// 0x1C6D (0x0001) [0x0000000000000000]              
	unsigned long                                      r_StanceSwapLockout : 1;                          		// 0x1C70 (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )
	unsigned long                                      m_bProgressingStance : 1;                         		// 0x1C70 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      s_bSwitchingStances : 1;                          		// 0x1C70 (0x0004) [0x0000000000000000] [0x00000004] 
	float                                              m_fSmoothEnergy;                                  		// 0x1C74 (0x0004) [0x0000000000000000]              
	float                                              m_fProgressStanceDelay;                           		// 0x1C78 (0x0004) [0x0000000000000000]              
	float                                              m_fProgressStanceSpeed;                           		// 0x1C7C (0x0004) [0x0000000000000000]              
	int                                                m_DarkDeviceIds[ 0x19 ];                          		// 0x1C80 (0x0064) [0x0000000000000000]              
	int                                                m_LightDeviceIds[ 0x19 ];                         		// 0x1CE4 (0x0064) [0x0000000000000000]              
	class ATgDevice*                                   m_DarkDevices[ 0x19 ];                            		// 0x1D48 (0x0064) [0x0000000000000000]              
	class ATgDevice*                                   m_LightDevices[ 0x19 ];                           		// 0x1DAC (0x0064) [0x0000000000000000]              
	struct FVector                                     FireLocationOffsetsLight[ 0x19 ];                 		// 0x1E10 (0x012C) [0x0000000000000000]              
	int                                                m_StanceMeshAssemblyIds[ 0x3 ];                   		// 0x1F3C (0x000C) [0x0000000000000000]              
	struct FPointer                                    m_StanceBodyMeshAssemblies[ 0x3 ];                		// 0x1F48 (0x000C) [0x0000000000001000]              ( CPF_Native )
	struct FPointer                                    m_StanceDestroyedMeshAssemblies[ 0x3 ];           		// 0x1F54 (0x000C) [0x0000000000001000]              ( CPF_Native )
	struct FName                                       m_StanceSwapAnimNames[ 0x3 ];                     		// 0x1F60 (0x0018) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2786 );

		return pClassPointer;
	};

	void OnDeviceFormStartFire ( int nEquipSlot, float FireDuration, int nFireMode );
	void OnDeviceFormBuildup ( int nEquipSlot, float fBuildupTime );
	void eventPlayDeathAnimation ( );
	void eventPostDemoRewind ( );
	unsigned char eventGetStateStance ( );
	void eventReactivateWhileAliveFxs ( );
	void eventStanceSwapLockout ( );
	void eventTriggerStanceProgression ( );
	void eventTriggerStanceMeshChange ( );
	void eventClientPlayStanceSwapAnimation ( unsigned char NewStance );
	void TickTargeting ( float DeltaSeconds );
	void Tick ( float DeltaSeconds );
	void InterruptInhand ( class ATgDevice* InterruptingDevice );
	void eventReplicatedEvent ( struct FName VarName );
	void eventSetInitialState ( );
	bool StartAction ( class ATgDevice* Dev, unsigned long bUpdateTimeStamp, unsigned char* failType );
	void OnRespawn ( );
	void eventPostInitAnimTree ( class USkeletalMeshComponent* SkelComp );
	bool CannotJumpNow ( );
	bool GetPassiveBool ( int* bResult );
	void TriggerAllSwitchStanceTimers ( unsigned long bExcludeProgressingStance, float fBlendOutTime );
	struct FString GetVGSCustomSuffix ( int nPreferredVPSetting );
	void PlayTeleportFx ( int nTeleportState, struct FVector vLoc );
	void SwapStanceMesh ( );
	void SwapToDestroyedMesh ( );
	void SwapToLiveMesh ( );
	void CalcSmoothEnergy ( float DeltaSeconds );
	float GetSmoothEnergy ( );
	void SetSpawnEnergy ( );
	void RecalculateMaterial ( unsigned long bIsFriendlyWithLocalPawn, unsigned long bForce );
	void LoadDevicesByStance ( unsigned char NewStance );
	void SwapStance ( unsigned char NewStance, unsigned long bSkipTransition );
	bool AreAnyOtherOffhandsLockingFiring ( class ATgDevice* CurrentDevice );
	bool DeviceOnCanDeviceFireNow ( class ATgDevice* Dev, unsigned char FireModeNum, unsigned long bDeviceFailLog, struct FAimData* Aim );
	void DeviceAdjustHeal ( class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fHeal );
	void DeviceAdjustDamage ( class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage );
	void DeviceOnDamaged ( struct FOnDamagedParams* Params );
	void DeviceOnStartFire ( class ATgDevice* Dev );
};

UClass* ATgPawn_HelV3::pClassPointer = NULL;

// Class TgGame.TgPawn_Hercules
// 0x005C (0x1CC8 - 0x1C6C)
class ATgPawn_Hercules : public ATgPawn_Character
{
public:
	class ATgCollisionProxy_Cylinder*                  m_ChargeCollisionProxy;                           		// 0x1C6C (0x0004) [0x0000000000000000]              
	TArray< struct FChargeHitInfo >                    m_ChargeHitInfos;                                 		// 0x1C70 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FVector                                     m_fChargeStartLocation;                           		// 0x1C7C (0x000C) [0x0000000000000000]              
	unsigned long                                      s_bTrackDamage : 1;                               		// 0x1C88 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      c_bBoulderPickupInterrupted : 1;                  		// 0x1C88 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      r_bBoulderOverhead : 1;                           		// 0x1C88 (0x0004) [0x0000000000000020] [0x00000004] ( CPF_Net )
	unsigned long                                      r_bBoulderFireInterrupted : 1;                    		// 0x1C88 (0x0004) [0x0000000000000020] [0x00000008] ( CPF_Net )
	unsigned long                                      s_bBoulderHasFired : 1;                           		// 0x1C88 (0x0004) [0x0000000000000000] [0x00000010] 
	float                                              s_fDamageTakenWhileTracking;                      		// 0x1C8C (0x0004) [0x0000000000000000]              
	class UTgDeviceFire*                               s_HealthReturnFireMode;                           		// 0x1C90 (0x0004) [0x0000000000000000]              
	float                                              s_fHealthBeforeTracking;                          		// 0x1C94 (0x0004) [0x0000000000000000]              
	class ATgDevice*                                   s_NormalInHand;                                   		// 0x1C98 (0x0004) [0x0000000000000000]              
	class ATgDevice*                                   s_BoulderThrower;                                 		// 0x1C9C (0x0004) [0x0000000000000000]              
	float                                              m_fBoulderSpeedModifier;                          		// 0x1CA0 (0x0004) [0x0000000000000000]              
	class UTgDeviceFire*                               s_BoulderThrowerCCProtection;                     		// 0x1CA4 (0x0004) [0x0000000000000000]              
	class UMeshComponent*                              c_BoulderMeshComponent;                           		// 0x1CA8 (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )
	class USkeletalMeshComponent*                      c_BoulderEruptionMeshComponent;                   		// 0x1CAC (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )
	struct FVector                                     m_InHandFireOffsets[ 0x2 ];                       		// 0x1CB0 (0x0018) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2787 );

		return pClassPointer;
	};

	bool IgnoreFaceRotationWithInterp ( );
	void PlayDyingEffects ( );
	void eventOnAnimEnd ( class UAnimNodeSequence* SeqNode, float PlayTime, float ExcessTime );
	void eventOnAnimPlay ( class UAnimNodeSequence* SeqNode );
	void OnDeviceFormInterruptFire ( int nEquipSlot );
	void OnDeviceFormStopFire ( int nEquipSlot );
	void OnDeviceFormStartFire ( int nEquipSlot, float FireDuration, int nFireMode );
	void OnDeviceFormBuildup ( int nEquipSlot, float fBuildupTime );
	struct FVector eventGetWeaponStartTraceLocation ( class ATgDevice* Dev );
	void eventDeactivateBoulder ( unsigned long bWasInterrupted );
	void eventPrepareBoulderIntro ( );
	void eventDeactivateEruption ( unsigned long bWasInterrupted );
	void ActivateEruption ( float Rate );
	bool eventPostPawnSetup ( );
	void eventChargeCollisionProxyOnTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void eventTakeDamage ( int Damage, class AController* InstigatedBy, struct FVector HitLocation, struct FVector Momentum, class UClass* DamageType, struct FTraceHitInfo HitInfo, class AActor* DamageCauser );
	bool CanTrackDamageDoneBy ( class AActor* DamagerCauser );
	void eventReplicatedEvent ( struct FName VarName );
	void eventRepBoulderOverheadChanged ( );
	void OnPawnDied ( );
	void EndBoulderThrower ( unsigned long bWasInterrupted );
	void StartBoulderThrower ( class ATgDevice* Dev, float Duration );
	bool InitializeBoulderEruptionMeshComponent ( );
	bool InitializeBoulderMeshComponent ( );
	void BeginHealingFromDamageTaken ( );
	void BeginDamageTracking ( class UTgDeviceFire* devFire );
	void PerformPunchKnockback ( class ATgPawn* HitActor );
	float GetPhysicalPowerItem ( struct FImpactInfo Impact, float PowerScaling );
	bool AreAnyOtherOffhandsLockingFiring ( class ATgDevice* CurrentDevice );
	bool DeviceOnCanDeviceFireNow ( class ATgDevice* Dev, unsigned char FireModeNum, unsigned long bDeviceFailLog, struct FAimData* Aim );
	bool DeviceOverrideTargetingAim ( class ATgDevice* Dev, struct FAimData* Aim, TArray< struct FImpactInfo >* ImpactList );
	void DeviceOnStopFire ( class ATgDevice* Dev, unsigned long WasInterrupted );
	void DeviceAdjustDamage ( class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage );
	void DeviceOnHit ( class ATgDevice* Dev, struct FImpactInfo* Impact );
	void DeviceOnFire ( class ATgDevice* Dev );
	void DeviceOnStartFire ( class ATgDevice* Dev );
};

UClass* ATgPawn_Hercules::pClassPointer = NULL;

// Class TgGame.TgPawn_HouYi
// 0x0014 (0x1C80 - 0x1C6C)
class ATgPawn_HouYi : public ATgPawn_Character
{
public:
	float                                              r_fPassiveDuration;                               		// 0x1C6C (0x0004) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      r_CurrentDivebombState;                           		// 0x1C70 (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      c_LocalDivebombState;                             		// 0x1C71 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_eDiveBombPosture;                               		// 0x1C72 (0x0001) [0x0000000000000000]              
	int                                                m_nDiveBombPostureId;                             		// 0x1C74 (0x0004) [0x0000000000000000]              
	unsigned long                                      s_bAppliedNotGrabSource : 1;                      		// 0x1C78 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bIgnoreEndTweenLogic : 1;                       		// 0x1C78 (0x0004) [0x0000000000000000] [0x00000002] 
	class ATgDevice_HouYi_DivebombShooter*             s_DivebombShooter;                                		// 0x1C7C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2788 );

		return pClassPointer;
	};

	bool eventIsLeaping ( );
	void CancelDivebombAnim ( );
	void UpdatePassiveMIC ( );
	void OnRespawn ( );
	void PlayNearDeathCleanup ( );
	void PlayDying ( class UClass* dmgType, struct FVector HitLoc );
	void OnDeviceFormStartFire ( int nEquipSlot, float FireDuration, int nFireMode );
	void OnDeviceFormBuildup ( int nEquipSlot, float fBuildupTime );
	void EndTween ( unsigned char endingTweenState, unsigned long bInterrupted );
	void BeginTween ( unsigned char newTweenState );
	void UpdateDivebombState ( unsigned char NewState );
	void Tick ( float DeltaSeconds );
	void eventReplicatedEvent ( struct FName VarName );
	void PlayTeleportFx ( int nTeleportState, struct FVector vLoc );
	float GetPercPenetration ( int nProtectionType, class AActor* Target );
	bool GetPassiveAuxMax ( float* fResult );
	bool GetPassiveAux ( float* fResult );
};

UClass* ATgPawn_HouYi::pClassPointer = NULL;

// Class TgGame.TgPawn_Isis
// 0x001C (0x1C88 - 0x1C6C)
class ATgPawn_Isis : public ATgPawn_Character
{
public:
	int                                                r_FuneralRiteStackCount;                          		// 0x1C6C (0x0004) [0x0000000000002020]              ( CPF_Net | CPF_Transient )
	int                                                DispelMagicStackCount;                            		// 0x1C70 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UTgSpecialFx*                                DispelMagicBuildupFx;                             		// 0x1C74 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      StaffBoneScaleFlash;                              		// 0x1C78 (0x0001) [0x0000000000002020]              ( CPF_Net | CPF_Transient )
	class USkelControlSingleBone*                      StaffBoneScale;                                   		// 0x1C7C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class USkelControlSingleBone*                      m_HaloBoneScale;                                  		// 0x1C80 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_fDesiredHaloScale;                              		// 0x1C84 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2789 );

		return pClassPointer;
	};

	void RestoreStaff ( );
	void OnRespawn ( );
	void PlayDyingEffects ( );
	void eventPostInitAnimTree ( class USkeletalMeshComponent* SkelComp );
	void eventReplicatedEvent ( struct FName VarName );
	void OnDeviceFormInterruptFire ( int nEquipSlot );
	void OnDeviceFormStopFire ( int nEquipSlot );
	void OnDeviceFormStartFire ( int nEquipSlot, float FireDuration, int nFireMode );
	void OnDeviceFormBuildup ( int nEquipSlot, float fBuildupTime );
	void PlayTeleportFx ( int TeleportId, struct FVector FXLocation );
	void DeviceAdjustHeal ( class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fHeal );
	void DeviceAdjustDamage ( class ATgDevice* Device, int nPropertyId, struct FImpactInfo* Impact, float* DamageAmt );
	void DeviceOnHit ( class ATgDevice* Device, struct FImpactInfo* Impact );
	void DeviceOnStopFire ( class ATgDevice* Device, unsigned long bWasInterrupted );
	void DeviceOnStartFire ( class ATgDevice* Device );
	float GetSmoothEnergy ( );
};

UClass* ATgPawn_Isis::pClassPointer = NULL;

// Class TgGame.TgPawn_Izanami
// 0x0020 (0x1C8C - 0x1C6C)
class ATgPawn_Izanami : public ATgPawn_Character
{
public:
	unsigned long                                      r_bIsBitingStrike : 1;                            		// 0x1C6C (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )
	unsigned long                                      m_bCanRemoveStealth : 1;                          		// 0x1C6C (0x0004) [0x0000000000000000] [0x00000002] 
	class UTgSkeletalMeshComponent*                    c_BitingStrikePACMesh;                            		// 0x1C70 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	float                                              r_bInvisibleEscapeIsBuildingUp;                   		// 0x1C74 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              r_fInvisibleEscapeBuildupTime;                    		// 0x1C78 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              r_fDev2PassiveStack;                              		// 0x1C7C (0x0004) [0x0000000000000020]              ( CPF_Net )
	TArray< class ATgPawn* >                           m_AppliedDev2StacksTick;                          		// 0x1C80 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2790 );

		return pClassPointer;
	};

	void ServerOnRightMousePressed ( );
	void OnRightMousePressed ( );
	void eventSetBitingStrikePACMesh ( unsigned long bTurnOn );
	bool eventPostPawnSetup ( );
	void eventReplicatedEvent ( struct FName VarName );
	void OnAttackDamagePropertyChange ( );
	float GetPercPenetration ( int nProtectionType, class AActor* Target );
	bool GetPassiveAuxMax ( float* fResult );
	bool GetPassiveAux ( float* fResult );
	bool GetPassiveInt1 ( int* nResult );
	void DeviceAdjustHeal ( class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fHeal );
	void DeviceOnHit ( class ATgDevice* Dev, struct FImpactInfo* Impact );
	void DeviceOnPostHit ( class ATgDevice* Dev );
	void DeviceOnStopBuildup ( class ATgDevice* Dev, unsigned long WasInterrupted );
	void DeviceOnStartBuildup ( class ATgDevice* Dev );
	bool InitializeBitingStrikeMesh ( );
	void EffectGroupOnSetActive ( unsigned long bActive, unsigned long bRemoving, class UTgEffectGroup* effectGroup );
};

UClass* ATgPawn_Izanami::pClassPointer = NULL;

// Class TgGame.TgPawn_Janus
// 0x0010 (0x1C7C - 0x1C6C)
class ATgPawn_Janus : public ATgPawn_Character
{
public:
	unsigned long                                      r_bPassiveActive : 1;                             		// 0x1C6C (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )
	unsigned long                                      c_bLocalPassiveActive : 1;                        		// 0x1C6C (0x0004) [0x0000000000000000] [0x00000002] 
	class UTgAnimNodeBlendList*                        c_PortalBlendList;                                		// 0x1C70 (0x0004) [0x0000000000000000]              
	struct FName                                       c_PortalBlendListName;                            		// 0x1C74 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2791 );

		return pClassPointer;
	};

	void OnDeviceFormStartFire ( int nEquipSlot, float FireDuration, int nFireMode );
	void eventUpdateJanusPassive ( unsigned long bActive );
	void OnRespawn ( );
	void CacheMainMeshReferences ( class UTgSkeletalMeshComponent* smcomp );
	void eventResetInvisibleWalls ( );
	void eventReplicatedEvent ( struct FName VarName );
	bool DeviceOverrideTargetingAim ( class ATgDevice* Dev, struct FAimData* Aim, TArray< struct FImpactInfo >* ImpactList );
};

UClass* ATgPawn_Janus::pClassPointer = NULL;

// Class TgGame.TgPawn_JingWei
// 0x00B0 (0x1D1C - 0x1C6C)
class ATgPawn_JingWei : public ATgPawn_Character
{
public:
	class ATgDevice*                                   r_dev_inhand;                                     		// 0x1C6C (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgDevice*                                   r_dev_super_inhand;                               		// 0x1C70 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgDevice*                                   s_dev_passive;                                    		// 0x1C74 (0x0004) [0x0000000000000000]              
	class ATgDevice_JingWei_Dev1*                      s_dev_offhand1;                                   		// 0x1C78 (0x0004) [0x0000000000000000]              
	class ATgDevice*                                   r_dev_offhand2;                                   		// 0x1C7C (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgDevice_JingWei_Dev3*                      s_dev_offhand3;                                   		// 0x1C80 (0x0004) [0x0000000000000000]              
	class ATgDevice*                                   r_dev_offhand4;                                   		// 0x1C84 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgDevice*                                   r_dev_offhand4_landing;                           		// 0x1C88 (0x0004) [0x0000000000000020]              ( CPF_Net )
	TArray< class UTgAnimNodeBlendList_JingWei_KnockupSource* > m_KnockupAnimNodes;                               		// 0x1C8C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                r_nDesiredKnockupAnimChild;                       		// 0x1C98 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgDevice*                                   r_SkyJumpInHandDevice;                            		// 0x1C9C (0x0004) [0x0000000000000020]              ( CPF_Net )
	unsigned long                                      m_bSkyJumpAtLocation : 1;                         		// 0x1CA0 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bSkyJumpHasFired : 1;                           		// 0x1CA0 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      r_bIsInBase : 1;                                  		// 0x1CA0 (0x0004) [0x0000000000000020] [0x00000004] ( CPF_Net )
	unsigned long                                      m_bPassivePreventNextFiring : 1;                  		// 0x1CA0 (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      r_bIgnoreAllBlocking : 1;                         		// 0x1CA0 (0x0004) [0x0000000000000000] [0x00000010] 
	unsigned long                                      m_bDoingBackupLandingCheck : 1;                   		// 0x1CA0 (0x0004) [0x0000000000000000] [0x00000020] 
	unsigned long                                      m_bLockFaceRotation : 1;                          		// 0x1CA0 (0x0004) [0x0000000000000000] [0x00000040] 
	int                                                r_nSkyJumpCameraYaw;                              		// 0x1CA4 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              m_fAimOffsetMax;                                  		// 0x1CA8 (0x0004) [0x0000000000000000]              
	unsigned char                                      r_SkyJumpPhase;                                   		// 0x1CAC (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      r_nShowBowStimMesh;                               		// 0x1CAD (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      r_Dev4Phase;                                      		// 0x1CAE (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      m_Dev4PhaseLocal;                                 		// 0x1CAF (0x0001) [0x0000000000000000]              
	struct FVector                                     r_SkyJumpStartLocation;                           		// 0x1CB0 (0x000C) [0x0000000000000020]              ( CPF_Net )
	struct FVector                                     r_SkyJumpBackupLocation;                          		// 0x1CBC (0x000C) [0x0000000000000020]              ( CPF_Net )
	struct FName                                       c_PassiveLandingAnimName;                         		// 0x1CC8 (0x0008) [0x0000000000000000]              
	float                                              r_fPassiveFlightTimeProgress;                     		// 0x1CD0 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              r_fPassiveFlightTimeMax;                          		// 0x1CD4 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              r_fPassiveCancelTimeProgress;                     		// 0x1CD8 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              r_fPassiveCancelTimeMax;                          		// 0x1CDC (0x0004) [0x0000000000000020]              ( CPF_Net )
	class UTgAnimNodeBlendList*                        c_BasicAttackBlendList;                           		// 0x1CE0 (0x0004) [0x0000000000000000]              
	struct FName                                       c_BasicAttackBlendListName;                       		// 0x1CE4 (0x0008) [0x0000000000000000]              
	class UTgSkeletalMeshComponent*                    c_BowStimMesh;                                    		// 0x1CEC (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	int                                                r_nDev2AmmoCount;                                 		// 0x1CF0 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class UTgSpecialFx*                                m_CollisionProxyFX;                               		// 0x1CF4 (0x0004) [0x0000000000000000]              
	struct FVector                                     m_Dev4StartLocation;                              		// 0x1CF8 (0x000C) [0x0000000000000000]              
	float                                              m_Dev4PhaseTime;                                  		// 0x1D04 (0x0004) [0x0000000000000000]              
	float                                              m_Dev4ForceLandingTime;                           		// 0x1D08 (0x0004) [0x0000000000000000]              
	TArray< class UTgAnimNodeBlendList_JingWei_Dev4* > m_UltimateAnimNodes;                              		// 0x1D0C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class UTgSkeletalMeshComponent*                    m_DeathMeshComponent;                             		// 0x1D18 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2792 );

		return pClassPointer;
	};

	bool DoJump ( unsigned long bUpdating );
	void CleanUpDyingEffects ( );
	void PlayDyingEffects ( );
	void eventPlayPassiveLandingAnimation ( );
	void EndTween ( unsigned char endingTweenState, unsigned long bInterrupted );
	void BeginTween ( unsigned char newTweenState );
	void ServerOnRightMousePressed ( );
	void OnRightMousePressed ( );
	bool IsInClassSpecificMovement ( );
	void eventSetTargetingDevice ( class ATgDevice* Dev );
	bool IgnoreFaceRotationWithInterp ( );
	float ApplyPitchLimit ( float fPitch );
	void FaceRotation ( struct FRotator NewRotation, float DeltaTime );
	void eventLanded ( struct FVector HitNormal, class AActor* FloorActor );
	void eventTick ( float DeltaSeconds );
	void OnDeviceFormStartFire ( int nEquipSlot, float FireDuration, int nFireMode );
	void eventUpdateSkyJumpPhase ( );
	void DeactivateBuffedInhand ( );
	void ActivateBuffedInhand ( );
	void eventAdjustAmmo ( int Delta );
	void eventUpdateBowMesh ( unsigned char NewShowBowStim );
	void OnRespawn ( );
	void eventClearSkyJumpAfterDeath ( );
	void eventPostDemoRewind ( );
	void PlayDying ( class UClass* dmgType, struct FVector HitLoc );
	bool eventDied ( class AController* Killer, class UClass* dmgType, struct FVector HitLocation );
	void PostTeleport ( class ATeleporter* OutTeleporter );
	bool eventPostPawnSetup ( );
	void eventDeactivateCollisionProxyFX ( );
	void eventActivateCollisionProxyFX ( );
	void OnDeviceFormInterruptCharge ( int nEquipSlot );
	void OnDeviceFormEndCharge ( int nEquipSlot, unsigned long bHit );
	void OnDeviceFormBeginCharge ( int nEquipSlot );
	void ToggleUltimateCameraModule ( unsigned long bOn );
	void eventForceSelfCollisions ( unsigned long bEnable );
	void eventForceSelfRoot ( unsigned long bEnable );
	void eventForceDev4Landing ( );
	void UpdateDev4Phase ( );
	void SetDev4Phase ( unsigned char Phase );
	void eventSetUltimateAnimationIndex ( int nIndex );
	void eventSetKnockupAnimationIndex ( int nIndex );
	void CacheMultiMeshAnimNodeReferences ( class UTgSkeletalMeshComponent* smcomp );
	bool IsAValidGrabTarget ( );
	bool IsFiringUltimate ( );
	void CacheMainMeshReferences ( class UTgSkeletalMeshComponent* smcomp );
	void eventReplicatedEvent ( struct FName VarName );
	void OnMeshSwapped ( );
	bool InitializeCollisionProxyFX ( );
	void EffectGroupOnSetActive ( unsigned long bActive, unsigned long bRemoving, class UTgEffectGroup* effectGroup );
	void FlashBeginCharge ( int nDeviceInstanceId );
	void DeviceOnStopFire ( class ATgDevice* Dev, unsigned long bWasInterrupted );
	void DeviceOnHit ( class ATgDevice* Dev, struct FImpactInfo* Impact );
	void DeviceOnFire ( class ATgDevice* Dev );
	void DeviceOnStartFire ( class ATgDevice* Dev );
	bool DeviceOnCanDeviceCriticalStrike ( class ATgDevice* Dev, int nPropertyId, int nDamageType, struct FImpactInfo* Impact, float* fCritChance );
	bool DeviceOnCanDeviceFireNow ( class ATgDevice* Dev, unsigned char FireModeNum, unsigned long bDeviceFailLog, struct FAimData* Aim );
	void DeviceOnStopBuildup ( class ATgDevice* Dev, unsigned long WasInterrupted );
	void DeviceOnStartBuildup ( class ATgDevice* Dev );
	bool AreAnyOtherOffhandsLockingFiring ( class ATgDevice* CurrentDevice );
	bool GetPassiveInt2 ( int* nResult );
	bool GetPassiveInt1 ( int* nResult );
	bool GetPassiveAuxMax ( float* fResult );
	bool GetPassiveAux ( float* fResult );
	bool GetPassiveBool ( int* bResult );
	bool OverrideDistanceFadeRange ( );
	void EndSkyJump ( );
	void StartSkyJump ( );
};

UClass* ATgPawn_JingWei::pClassPointer = NULL;

// Class TgGame.TgPawn_Jumong
// 0x0004 (0x1C70 - 0x1C6C)
class ATgPawn_Jumong : public ATgPawn_Character
{
public:
	class UTgMarkComponent*                            m_DamageMultiplierMarkComponent;                  		// 0x1C6C (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2793 );

		return pClassPointer;
	};

	void DeviceAdjustDamage ( class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage );
	void DeviceOnHit ( class ATgDevice* Dev, struct FImpactInfo* Impact );
};

UClass* ATgPawn_Jumong::pClassPointer = NULL;

// Class TgGame.TgPawn_KaliV2
// 0x0078 (0x1CE4 - 0x1C6C)
class ATgPawn_KaliV2 : public ATgPawn_Character
{
public:
	TArray< class AActor* >                            s_MarkedTargets;                                  		// 0x1C6C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< unsigned char >                            s_MarkedIsLowHealth;                              		// 0x1C78 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class AActor* >                            s_MarkedHistory;                                  		// 0x1C84 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class ATgRepInfo_Player*                           r_MarkedPRIs[ 0x2 ];                              		// 0x1C90 (0x0008) [0x0000000000000020]              ( CPF_Net )
	class ATgRepInfo_Deployable*                       r_MarkedDRIs[ 0x2 ];                              		// 0x1C98 (0x0008) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nKillCount;                                     		// 0x1CA0 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                m_nMarkedListMin;                                 		// 0x1CA4 (0x0004) [0x0000000000000000]              
	int                                                m_nMarkedListMax;                                 		// 0x1CA8 (0x0004) [0x0000000000000000]              
	int                                                m_nMarkedHistoryMax;                              		// 0x1CAC (0x0004) [0x0000000000000000]              
	unsigned long                                      s_bChooseTargetOnRevive : 1;                      		// 0x1CB0 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      c_UltimateMeshActive : 1;                         		// 0x1CB0 (0x0004) [0x0000000000000000] [0x00000002] 
	int                                                r_nTriggerTargetChoice;                           		// 0x1CB4 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                c_nTargetsTriggered;                              		// 0x1CB8 (0x0004) [0x0000000000000000]              
	struct FVector                                     r_vBloodlashLocation;                             		// 0x1CBC (0x000C) [0x0000000000000020]              ( CPF_Net )
	struct FRotator                                    r_rBloodlashRotation;                             		// 0x1CC8 (0x000C) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nBloodlashTicker;                               		// 0x1CD4 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class UTgSkeletalMeshComponent*                    c_UltimateMesh;                                   		// 0x1CD8 (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )
	float                                              c_UltimateBoneScaleValue;                         		// 0x1CDC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class USkelControlSingleBone*                      c_UltimateBoneScale;                              		// 0x1CE0 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2794 );

		return pClassPointer;
	};

	void eventOnGroupChange ( );
	void eventDestroyed ( );
	void TickTargeting ( float DeltaSeconds );
	void Tick ( float DeltaSeconds );
	void EndTween ( unsigned char endingTweenState, unsigned long bInterrupted );
	void BeginTween ( unsigned char newTweenState );
	bool eventDied ( class AController* Killer, class UClass* dmgType, struct FVector HitLocation );
	void OnDeviceFormStopFire ( int nEquipSlot );
	void OnDeviceFormStartFire ( int nEquipSlot, float FireDuration, int nFireMode );
	void ToggleUltimateMesh ( unsigned long bEnable );
	void EnablePassiveTargeter ( );
	void PossessedBy ( class AController* C, unsigned long bVehicleTransition );
	void eventReplicatedEvent ( struct FName VarName );
	void SetGodTargeterState ( );
	void PawnOnRevive ( );
	bool HasDiedByGod ( );
	bool HasOpposingForce ( );
	void LoadAndPlayBloodLashMesh ( struct FVector vLocation, struct FRotator rRotation );
	class UTgSkeletalMeshComponent* SpawnExtraSkeletalMesh ( int nMeshId );
	bool ChooseNextMarkedTarget ( class AActor* PriorityActor, unsigned long bNotifyTarget, TArray< class AActor* >* ExcludeList );
	void RemoveMarkedTarget ( class AActor* Victim, unsigned long bDoNotFindTarget, unsigned long bSetKilled );
	void PawnOnAssisted ( class AActor* Victim, int* xpGain, int* goldGain );
	void PawnOnKilled ( class AActor* Victim, int* xpGain, int* goldGain );
	float GetPercPenetration ( int nProtectionType, class AActor* Target );
	void DeviceOnStartFire ( class ATgDevice* Dev );
	bool DeviceOnCanDeviceCriticalStrike ( class ATgDevice* Dev, int nPropertyId, int nDamageType, struct FImpactInfo* Impact, float* fCritChance );
	bool GetPassiveString ( struct FString* sResult );
	float GetMaxEnergy ( );
	float GetSmoothEnergy ( );
};

UClass* ATgPawn_KaliV2::pClassPointer = NULL;

// Class TgGame.TgPawn_Khepri
// 0x004C (0x1CB8 - 0x1C6C)
class ATgPawn_Khepri : public ATgPawn_Character
{
public:
	class ATgDevice_Khepri_Abduct*                     s_AbductDevice;                                   		// 0x1C6C (0x0004) [0x0000000000000000]              
	class UClass*                                      m_CrawlBackControlModuleClass;                    		// 0x1C70 (0x0004) [0x0000000000000002]              ( CPF_Const )
	class UClass*                                      m_PreviousControlModuleClass;                     		// 0x1C74 (0x0004) [0x0000000000000000]              
	class UTgControlModule*                            m_CrawlBackControlModule;                         		// 0x1C78 (0x0004) [0x0000000000000000]              
	TArray< int >                                      m_CanFireDuringCrawlBack;                         		// 0x1C7C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	unsigned long                                      m_bAllowCrawlBackCancelOnRightMousePressed : 1;   		// 0x1C88 (0x0004) [0x0000000000000002] [0x00000001] ( CPF_Const )
	unsigned long                                      m_bApplyBigHeal : 1;                              		// 0x1C88 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned char                                      r_bEndCrawlBackTrigger;                           		// 0x1C8C (0x0001) [0x0000000000000020]              ( CPF_Net )
	TArray< class UTgAnimBlendByKhepriCrawlBack* >     m_CrawlBackNodes;                                 		// 0x1C90 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class UTgSpecialFx*                                m_ReviveFX;                                       		// 0x1C9C (0x0004) [0x0000000000000000]              
	class AActor*                                      r_RevivedActor;                                   		// 0x1CA0 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class UTgSkeletalMeshComponent*                    m_ReviveMesh;                                     		// 0x1CA4 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class ATgPawn*                                     m_ReviveTarget;                                   		// 0x1CA8 (0x0004) [0x0000000000000000]              
	struct FVector                                     m_vReviveLocation;                                		// 0x1CAC (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2795 );

		return pClassPointer;
	};

	void eventTick ( float DeltaSeconds );
	void eventHookTargetOnKhepri ( );
	void eventSendTargetToKhepri ( );
	bool WillOverrideTakeDamage ( class APawn* Victim, int Damage, class AController* InstigatedBy, struct FVector HitLocation, struct FVector Momentum, class UClass* DamageType, struct FTraceHitInfo HitInfo, class AActor* DamageCauser );
	bool DeviceCausesWariness ( int nEquipSlot );
	void ServerEndCrawlBack ( );
	void EndCrawlBackAnim ( );
	void ClientEndCrawlBack ( );
	void EndCrawlBack ( unsigned long bInterrupted, unsigned long bSkipClient );
	void OnGrabTargetDetach ( unsigned char endingGrabState, class ATgPawn* Target, unsigned long bInterrupted );
	void ClientBeginCrawlBack ( float fDuration, int nYaw );
	bool BeginCrawlBack ( float fDuration, struct FRotator ForwardRotation );
	void eventDestroyReviveFx ( );
	void eventPlayReviveFxAt ( class AActor* RevivedTarget );
	bool PostPawnSetup ( );
	void CacheMultiMeshAnimNodeReferences ( class UTgSkeletalMeshComponent* smcomp );
	void ClearMultiMeshAnimNodeReferences ( );
	void eventReplicatedEvent ( struct FName VarName );
	bool GetPassiveAuxMax ( float* fResult );
	bool GetPassiveAux ( float* fResult );
	bool InitializeReviveFX ( );
	bool DeviceOnCanDeviceFireNow ( class ATgDevice* Dev, unsigned char FireModeNum, unsigned long bDeviceFailLog, struct FAimData* Aim );
	void EffectGroupOnSetActive ( unsigned long bActive, unsigned long bRemoving, class UTgEffectGroup* effectGroup );
	void EffectGroupOnApplied ( class UTgEffectGroup* effectGroup, unsigned long bInterval );
};

UClass* ATgPawn_Khepri::pClassPointer = NULL;

// Class TgGame.TgPawn_Kukulkan
// 0x0014 (0x1C80 - 0x1C6C)
class ATgPawn_Kukulkan : public ATgPawn_Character
{
public:
	class UTgDeviceFire*                               m_UltimateKnockbackMode;                          		// 0x1C6C (0x0004) [0x0000000000000000]              
	struct FSlipstreamMod                              r_SSM;                                            		// 0x1C70 (0x0008) [0x0000000000000020]              ( CPF_Net )
	struct FSlipstreamMod                              c_SSM;                                            		// 0x1C78 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2796 );

		return pClassPointer;
	};

	void eventDischargeAirBall ( );
	void RechargeAirBall ( );
	void eventOnAttackComboTimeout ( );
	void Tick ( float DeltaSeconds );
	void eventSetSlipstreamMod ( float Modifier, float Duration );
	void eventReplicatedEvent ( struct FName VarName );
	void DeviceOnFire ( class ATgDevice* Dev );
	void DeviceOnHit ( class ATgDevice* Dev, struct FImpactInfo* Impact );
	bool DeviceOverrideTargetingAim ( class ATgDevice* Dev, struct FAimData* Aim, TArray< struct FImpactInfo >* ImpactList );
	float GetMagicalPowerItem ( struct FImpactInfo Impact, float PowerScaling );
};

UClass* ATgPawn_Kukulkan::pClassPointer = NULL;

// Class TgGame.TgPawn_Kumbhakarna
// 0x0160 (0x1DCC - 0x1C6C)
class ATgPawn_Kumbhakarna : public ATgPawn_Character
{
public:
	struct FTG_HUD_INFO                                c_TargetingHudInfo;                               		// 0x1C6C (0x0130) [0x0000000000400000]              ( CPF_NeedCtorLink )
	unsigned long                                      r_bIsAsleep : 1;                                  		// 0x1D9C (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )
	unsigned long                                      r_bIsSleepPostureActive : 1;                      		// 0x1D9C (0x0004) [0x0000000000000020] [0x00000002] ( CPF_Net )
	float                                              m_fFellAsleepTimeStamp;                           		// 0x1DA0 (0x0004) [0x0000000000000000]              
	float                                              m_fRespawnDeductionAmount;                        		// 0x1DA4 (0x0004) [0x0000000000000000]              
	int                                                r_nNumHitsReceivedWhileSleeping;                  		// 0x1DA8 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nMaxNumHitsWhileSleeping;                       		// 0x1DAC (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                m_nSleepingPostureID;                             		// 0x1DB0 (0x0004) [0x0000000000000000]              
	TArray< class ATgPawn_Apollo* >                    m_ApolloPawns;                                    		// 0x1DB4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< struct FVictimCollisionData >              m_KnockedUpVictims;                               		// 0x1DC0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2797 );

		return pClassPointer;
	};

	bool eventWantsLoopingEmote ( unsigned char Emote );
	bool eventCanApplyShield ( );
	void PopSleepPostureTimer ( );
	void eventRemoveSleepEffect ( );
	void RemoveSleepPosture ( );
	void UpdateSleepingEffects ( );
	void UpdateNum3Targeter ( );
	bool IsInputLocked ( );
	bool eventCanPlayHitReaction ( );
	bool IgnoreFaceRotationWithInterp ( );
	bool eventShouldRecharge ( );
	void eventLanded ( struct FVector HitNormal, class AActor* FloorActor );
	void eventSetIsAsleep ( unsigned long bIsAsleep );
	bool eventDied ( class AController* Killer, class UClass* dmgType, struct FVector HitLocation );
	bool TakeDamageSpecial ( int Damage, class AController* InstigatedBy, struct FVector HitLocation, struct FVector Momentum, class UClass* DamageType, struct FTraceHitInfo HitInfo, class AActor* DamageCauser );
	void eventReplicatedEvent ( struct FName VarName );
	bool GetPassiveBool ( int* bResult );
	bool GetPassiveInt2 ( int* nResult );
	bool GetPassiveInt1 ( int* nResult );
	bool PawnCanDisplayImmuneMessage ( );
	void SetSpawnEnergy ( );
	int GetMaxHitsWhileSleeping ( );
	void PlayTeleportFx ( int nTeleportState, struct FVector vLoc );
	void PawnOnPreDamageMitigation ( class ATgPawn* attacker, class UTgEffectGroup* eg, int nPropertyId, float* fDamage );
	float AdjustRespawnTime ( float InRespawnTime );
	bool IsInvisible ( );
	void EffectGroupOnSetActive ( unsigned long bActive, unsigned long bRemoving, class UTgEffectGroup* effectGroup );
	void DeviceOnHit ( class ATgDevice* Dev, struct FImpactInfo* Impact );
	bool DeviceIsTargetingModeReady ( class ATgDevice* Dev, unsigned char* failType );
	void DeviceAdjustDamage ( class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage );
	bool DeviceOnCanDeviceFireNow ( class ATgDevice* Dev, unsigned char FireModeNum, unsigned long bDeviceFailLog, struct FAimData* Aim );
	bool DeviceOverrideTargetingAim ( class ATgDevice* Dev, struct FAimData* Aim, TArray< struct FImpactInfo >* ImpactList );
	void DeviceOnStartFire ( class ATgDevice* Dev );
};

UClass* ATgPawn_Kumbhakarna::pClassPointer = NULL;

// Class TgGame.TgPawn_Kumbhakarna_PVE
// 0x0000 (0x1DCC - 0x1DCC)
class ATgPawn_Kumbhakarna_PVE : public ATgPawn_Kumbhakarna
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2798 );

		return pClassPointer;
	};

	bool DeviceOnCanDeviceFireNow ( class ATgDevice* Dev, unsigned char FireModeNum, unsigned long bDeviceFailLog, struct FAimData* Aim );
};

UClass* ATgPawn_Kumbhakarna_PVE::pClassPointer = NULL;

// Class TgGame.TgPawn_Loki
// 0x001C (0x1C88 - 0x1C6C)
class ATgPawn_Loki : public ATgPawn_Character
{
public:
	TArray< class UTgDeviceFire* >                     m_StimSubDeviceModes;                             		// 0x1C6C (0x000C) [0x0000000000500000]              ( CPF_NeedCtorLink )
	unsigned long                                      s_IsLokiStealthedThisTick : 1;                    		// 0x1C78 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      r_HasVanishBuff : 1;                              		// 0x1C78 (0x0004) [0x0000000000000020] [0x00000002] ( CPF_Net )
	class AActor*                                      r_AssassinateBaseActor;                           		// 0x1C7C (0x0004) [0x0000000000000020]              ( CPF_Net )
	class AActor*                                      c_AssassinateBaseActor;                           		// 0x1C80 (0x0004) [0x0000000000000000]              
	class UTgSkeletalMeshComponent*                    m_DeathMeshComponent;                             		// 0x1C84 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2799 );

		return pClassPointer;
	};

	void CleanUpDyingEffects ( );
	void PlayDyingEffects ( );
	void eventTick ( float DeltaSeconds );
	void eventDetachFromTarget ( class AActor* TargetActor );
	void eventAttachToTarget ( class AActor* TargetActor );
	void EndGrab ( unsigned char endingGrabState, unsigned long bInterrupted );
	void BeginGrab ( unsigned char newGrabState );
	void ClientAssassinateTeleport ( float TeleportLocationX, float TeleportLocationY, float TeleportLocationZ, int TeleportYaw );
	void eventAssassinateTeleport ( float TeleportLocationX, float TeleportLocationY, float TeleportLocationZ, int TeleportYaw );
	void eventReplicatedEvent ( struct FName VarName );
	void CalcStealthFadeValue ( float fDeltaTime );
	void PlayTeleportFx ( int nTeleportState, struct FVector vLoc );
	void DeviceAdjustDamage ( class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage );
	void DeviceOnHit ( class ATgDevice* Dev, struct FImpactInfo* Impact );
	void DeviceOnStopFire ( class ATgDevice* Dev, unsigned long WasInterrupted );
	void DeviceOnFire ( class ATgDevice* Dev );
	void DeviceOnStartFire ( class ATgDevice* Dev );
};

UClass* ATgPawn_Loki::pClassPointer = NULL;

// Class TgGame.TgPawn_Medusa
// 0x0034 (0x1CA0 - 0x1C6C)
class ATgPawn_Medusa : public ATgPawn_Character
{
public:
	int                                                r_nNum1Stacks;                                    		// 0x1C6C (0x0004) [0x0000000000000020]              ( CPF_Net )
	class UTgSpecialFx*                                c_PheremonesFX;                                   		// 0x1C70 (0x0004) [0x0000000000000000]              
	int                                                m_nPheremonesFXID;                                		// 0x1C74 (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                c_PheremonesStacksFX[ 0x3 ];                      		// 0x1C78 (0x000C) [0x0000000000000000]              
	int                                                m_nPheremonesStacksFXID[ 0x3 ];                   		// 0x1C84 (0x000C) [0x0000000000000000]              
	class UTgDeviceFire*                               m_Num3FireMode;                                   		// 0x1C90 (0x0004) [0x0000000000000000]              
	class ATgPawn*                                     m_MaulTarget;                                     		// 0x1C94 (0x0004) [0x0000000000000000]              
	class UMaterialInstanceConstant*                   c_StoneMat;                                       		// 0x1C98 (0x0004) [0x0000000000000000]              
	int                                                m_nStatueDeployID;                                		// 0x1C9C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2800 );

		return pClassPointer;
	};

	bool eventWantsLoopingEmote ( unsigned char Emote );
	bool eventPostPawnSetup ( );
	void eventUpdatePheremonesFX ( unsigned long bReset );
	void OnDeviceFormStopFire ( int nEquipSlot );
	void eventReplicatedEvent ( struct FName VarName );
	void SpawnStatue ( class ATgPawn_Character* StatuePawn );
	bool InitializePheremonesFX ( );
	bool InitializeStoneMat ( );
	bool ShouldApplyExtraUltEffects ( float MinimumAngle, class ATgPawn* TargetPawn );
	void EffectGroupOnSetActive ( unsigned long bActive, unsigned long bRemoving, class UTgEffectGroup* effectGroup );
	bool DeviceOverrideTargetingAim ( class ATgDevice* Dev, struct FAimData* Aim, TArray< struct FImpactInfo >* ImpactList );
	void DeviceOnHit ( class ATgDevice* Dev, struct FImpactInfo* Impact );
	bool GetPassiveInt1 ( int* nResult );
	float GetStrafePercent ( );
	float GetBackpedalPercent ( );
};

UClass* ATgPawn_Medusa::pClassPointer = NULL;

// Class TgGame.TgPawn_Mercury
// 0x01C0 (0x1E2C - 0x1C6C)
class ATgPawn_Mercury : public ATgPawn_Character
{
public:
	class ATgDevice*                                   m_DefaultBasicAttackDevice;                       		// 0x1C6C (0x0004) [0x0000000000000000]              
	float                                              m_fPassiveConvertPct;                             		// 0x1C70 (0x0004) [0x0000000000000000]              
	unsigned long                                      s_bNeedToRecalculatePassivePhysicalPower : 1;     		// 0x1C74 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      s_bHasBeenDisplaced : 1;                          		// 0x1C74 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      r_bIsInvisibleFromNum1 : 1;                       		// 0x1C74 (0x0004) [0x0000000000000020] [0x00000004] ( CPF_Net )
	unsigned long                                      r_bIsWhirlwinding : 1;                            		// 0x1C74 (0x0004) [0x0000000000000020] [0x00000008] ( CPF_Net )
	unsigned long                                      s_bWhirlwindEffectsApplied : 1;                   		// 0x1C74 (0x0004) [0x0000000000000000] [0x00000010] 
	unsigned long                                      s_bTriggerEndWhirlwind : 1;                       		// 0x1C74 (0x0004) [0x0000000000000000] [0x00000020] 
	unsigned long                                      s_bWhirlwindInterrupted : 1;                      		// 0x1C74 (0x0004) [0x0000000000000000] [0x00000040] 
	unsigned long                                      r_bIsZoomedForUlt : 1;                            		// 0x1C74 (0x0004) [0x0000000000000020] [0x00000080] ( CPF_Net )
	unsigned long                                      r_bIsUltSprinting : 1;                            		// 0x1C74 (0x0004) [0x0000000000000020] [0x00000100] ( CPF_Net )
	unsigned long                                      r_bUltIsBuildingUp : 1;                           		// 0x1C74 (0x0004) [0x0000000000000020] [0x00000200] ( CPF_Net )
	float                                              r_fPassivePhysicalPower;                          		// 0x1C78 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              r_fPassiveDistanceTraveled;                       		// 0x1C7C (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              r_fMaxPassiveDistance;                            		// 0x1C80 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              m_fPassiveDistanceMultiplier;                     		// 0x1C84 (0x0004) [0x0000000000000000]              
	float                                              m_fRemainingPausePassiveDistanceTime;             		// 0x1C88 (0x0004) [0x0000000000000000]              
	float                                              s_fDisplacementPassiveRefreshTime;                		// 0x1C8C (0x0004) [0x0000000000000000]              
	class ATgDevice*                                   m_Num1SubDevice;                                  		// 0x1C90 (0x0004) [0x0000000000000000]              
	class ATgDeployable_Scaling*                       m_Num1Deployable;                                 		// 0x1C94 (0x0004) [0x0000000000000000]              
	class ATgProj_Mercury_Num1*                        m_Num1Projectile;                                 		// 0x1C98 (0x0004) [0x0000000000000000]              
	class ATgCollisionProxy_Cylinder*                  m_Num3CollisionProxy;                             		// 0x1C9C (0x0004) [0x0000000000000000]              
	class ATgPawn*                                     m_TargetToThrow;                                  		// 0x1CA0 (0x0004) [0x0000000000000000]              
	class UTgDeviceFire*                               m_WhirlwindFireMode;                              		// 0x1CA4 (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                m_WhirlwindTargeterFX;                            		// 0x1CA8 (0x0004) [0x0000000000000000]              
	class ATgDevice*                                   r_UltShooterDevice;                               		// 0x1CAC (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgPawn*                                     r_UltTargetPawn;                                  		// 0x1CB0 (0x0004) [0x0000000000000020]              ( CPF_Net )
	struct FVector                                     m_vLastUltTargetPawnLocation;                     		// 0x1CB4 (0x000C) [0x0000000000000000]              
	class UTgSpecialFx*                                c_UltSphereFX;                                    		// 0x1CC0 (0x0004) [0x0000000000000000]              
	int                                                c_UltPostureId;                                   		// 0x1CC4 (0x0004) [0x0000000000000000]              
	struct FTG_HUD_INFO                                c_TargetingHudInfo;                               		// 0x1CC8 (0x0130) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class ATgPathfinder*                               m_Pathfinder;                                     		// 0x1DF8 (0x0004) [0x0000000004000001]              ( CPF_Edit | CPF_EditInline )
	float                                              m_fUltPathSpeed;                                  		// 0x1DFC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class ATgDeployable*                               m_UltDeployable;                                  		// 0x1E00 (0x0004) [0x0000000000000000]              
	class ATgCollisionProxy_Cylinder*                  m_Num4CollisionProxy;                             		// 0x1E04 (0x0004) [0x0000000000000000]              
	class ATgDevice*                                   r_Num4ShooterDevice;                              		// 0x1E08 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgSkeletalMeshActorSpawnable*               m_UltAvatarTargeter;                              		// 0x1E0C (0x0004) [0x0000000000000000]              
	float                                              m_fTotalUltChargeUpTime;                          		// 0x1E10 (0x0004) [0x0000000000000000]              
	float                                              m_fRemainingUltChargeUpTime;                      		// 0x1E14 (0x0004) [0x0000000000000000]              
	TArray< class AActor* >                            UltHitTargets;                                    		// 0x1E18 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class UTgSkeletalMeshComponent*                    m_DeathMeshComponent;                             		// 0x1E24 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class UTgSpecialFx*                                m_UltTargeterFX;                                  		// 0x1E28 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2801 );

		return pClassPointer;
	};

	void UpdateBasicAttackFromPassive ( unsigned long bForce );
	void eventClearPassiveBasicAttackBonus ( unsigned long bDied );
	void eventPlayUltBuildupEffects ( );
	void eventBump ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitNormal );
	bool eventDied ( class AController* Killer, class UClass* dmgType, struct FVector HitLocation );
	void CleanUpDyingEffects ( );
	void PlayDyingEffects ( );
	void TurnOffNum1Invisibility ( );
	void PostWhirlwindTimer ( );
	void PlayUltOutroAnim ( );
	void eventPlayUltSprintingEffects ( );
	void TickTargeting ( float DeltaSeconds );
	void eventOnNum4CollisionProxyTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void OnDeviceFormInterruptFire ( int nEquipSlot );
	void OnDeviceFormStopFire ( int nEquipSlot );
	void OnDeviceFormStartFire ( int nEquipSlot, float FireDuration, int nFireMode );
	void eventSilence ( unsigned long bSilenced );
	void eventStun ( unsigned long bStunController, unsigned char eType );
	bool IgnoreFaceRotationWithInterp ( );
	void eventStopWhirlwindEffects ( );
	void eventPlayWhirlwindEffects ( );
	void eventOnNum3CollisionProxyTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void OnGrabTargetDetach ( unsigned char endingGrabState, class ATgPawn* Target, unsigned long bInterrupted );
	void OnGrabTargetAttach ( unsigned char newGrabState, class ATgPawn* Target );
	void eventSetTargetingDevice ( class ATgDevice* Dev );
	void eventSpecialFXAttached ( class UTgSpecialFx* NewFX, int FxId );
	void eventReplicatedEvent ( struct FName VarName );
	void EndWhirlWind ( unsigned long bInterrupted );
	float CalcSpecialDeliveryTime ( );
	void SwapToLiveMesh ( );
	void CheckValidCharge ( );
	void OnAttackDamagePropertyChange ( );
	float GetMaxEnergy ( );
	float GetSmoothEnergy ( );
	float GetPhysicalPowerItem ( struct FImpactInfo Impact, float PowerScaling );
	void DeviceAdjustDamage ( class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage );
	bool DeviceOverrideManaUseVitals ( class ATgDevice* Dev, class ATgPlayerController* PC );
	bool DeviceOverrideTargetingAim ( class ATgDevice* Dev, struct FAimData* Aim, TArray< struct FImpactInfo >* ImpactList );
	void DeviceOnSetFireMode ( class ATgDevice* Dev );
	bool DeviceOnCanDeviceFireNow ( class ATgDevice* Dev, unsigned char FireModeNum, unsigned long bDeviceFailLog, struct FAimData* Aim );
	void EffectGroupOnSetActive ( unsigned long bActive, unsigned long bRemoving, class UTgEffectGroup* effectGroup );
	void DeviceOnStopFire ( class ATgDevice* Dev, unsigned long WasInterrupted );
	void DeviceOnStartFire ( class ATgDevice* Dev );
	void DeviceOnStartBuildup ( class ATgDevice* Dev );
	void PostPawnSetupServer ( );
};

UClass* ATgPawn_Mercury::pClassPointer = NULL;

// Class TgGame.TgPawn_MeshSwapper
// 0x0020 (0x1C8C - 0x1C6C)
class ATgPawn_MeshSwapper : public ATgPawn_Character
{
public:
	TArray< struct FStanceInfo >                       m_Stances;                                        		// 0x1C6C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< struct FCachedStanceObject >               c_StanceCache;                                    		// 0x1C78 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                r_nTargetMesh;                                    		// 0x1C84 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                c_nCurrentSwappedMesh;                            		// 0x1C88 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2802 );

		return pClassPointer;
	};

	void eventStopFiringAllDevices ( unsigned long bClearEquipEffectFlag, unsigned long bResetCooldowns );
	void eventReplicatedEvent ( struct FName VarName );
	bool FindAdjustedMeshLocation ( struct FVector Extent, struct FVector* FouncLocation );
	void SwapDevices ( int nMeshId );
	void SwapToMesh ( int nMeshId );
};

UClass* ATgPawn_MeshSwapper::pClassPointer = NULL;

// Class TgGame.TgPawn_ErlangShen
// 0x0094 (0x1D20 - 0x1C8C)
class ATgPawn_ErlangShen : public ATgPawn_MeshSwapper
{
public:
	class ATgDevice*                                   m_DevicePsv_GuardDog;                             		// 0x1C8C (0x0004) [0x0000000000000000]              
	class ATgDevice_ErlangShen_SeeWeakness*            m_DeviceA01_SeeWeakness;                          		// 0x1C90 (0x0004) [0x0000000000000000]              
	class ATgDevice*                                   m_DeviceA02_Pin;                                  		// 0x1C94 (0x0004) [0x0000000000000000]              
	class ATgDevice_ErlangShen_TransformMink*          m_DeviceA03_72Transformations_Mink;               		// 0x1C98 (0x0004) [0x0000000000000000]              
	class ATgDevice_ErlangShen_TransformTurtle*        m_DeviceA03_72Transformations_Turtle;             		// 0x1C9C (0x0004) [0x0000000000000000]              
	class ATgDevice_ErlangShen_NineTurnsBlessing*      m_DeviceA04_NineTurnsBlessing;                    		// 0x1CA0 (0x0004) [0x0000000000000000]              
	class ATgPawn_ErlangShen_Dog*                      r_GuardDog;                                       		// 0x1CA4 (0x0004) [0x0000000000000020]              ( CPF_Net )
	unsigned long                                      m_bIsSpotWeaknessActive : 1;                      		// 0x1CA8 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      r_bSpotWeaknessFXEnabled : 1;                     		// 0x1CA8 (0x0004) [0x0000000000000020] [0x00000002] ( CPF_Net )
	unsigned long                                      m_bTransformInProgress : 1;                       		// 0x1CA8 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_bTriggerTransformMeshChange : 1;                		// 0x1CA8 (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      r_bTransformPouncing : 1;                         		// 0x1CA8 (0x0004) [0x0000000000000020] [0x00000010] ( CPF_Net )
	unsigned long                                      r_bMinkBuffFXEnabled : 1;                         		// 0x1CA8 (0x0004) [0x0000000000000020] [0x00000020] ( CPF_Net )
	unsigned long                                      m_bIsTurtleShieldActive : 1;                      		// 0x1CA8 (0x0004) [0x0000000000000000] [0x00000040] 
	unsigned long                                      m_bNineTurnsActive : 1;                           		// 0x1CA8 (0x0004) [0x0000000000000000] [0x00000080] 
	int                                                m_nSpotWeaknessFiringInstance;                    		// 0x1CAC (0x0004) [0x0000000000000000]              
	unsigned char                                      r_CurrentTransformState;                          		// 0x1CB0 (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      c_PrevTransformState;                             		// 0x1CB1 (0x0001) [0x0000000000000000]              
	unsigned char                                      c_LocalTransformState;                            		// 0x1CB2 (0x0001) [0x0000000000002000]              ( CPF_Transient )
	class ATgDevice_ErlangShen_Transform*              r_TransformDevices[ 0x3 ];                        		// 0x1CB4 (0x000C) [0x0000000000000020]              ( CPF_Net )
	TArray< class UTgAnimNodeAimOffset* >              c_TransformAimOffsets;                            		// 0x1CC0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                r_nTransformYawOffset;                            		// 0x1CCC (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              m_fTransformAimOffsetMax;                         		// 0x1CD0 (0x0004) [0x0000000000000002]              ( CPF_Const )
	class UAnimNodeSequence*                           m_TransformIntroSequenceNode;                     		// 0x1CD4 (0x0004) [0x0000000000000000]              
	struct FName                                       c_TransformOutroAnimName;                         		// 0x1CD8 (0x0008) [0x0000000000000000]              
	struct FPointer                                    m_TransformBodyMeshAssemblies[ 0x3 ];             		// 0x1CE0 (0x000C) [0x0000000000001000]              ( CPF_Native )
	struct FPointer                                    m_TransformDestroyedMeshAssemblies[ 0x3 ];        		// 0x1CEC (0x000C) [0x0000000000001000]              ( CPF_Native )
	int                                                m_TransformDesiredAssemblyId;                     		// 0x1CF8 (0x0004) [0x0000000000000000]              
	int                                                m_TransformDesiredDestroyedAssemblyId;            		// 0x1CFC (0x0004) [0x0000000000000000]              
	struct FName                                       c_MinkPounceAnimName;                             		// 0x1D00 (0x0008) [0x0000000000000000]              
	float                                              m_fTransformPounceRecoverTime;                    		// 0x1D08 (0x0004) [0x0000000000000002]              ( CPF_Const )
	class UTgEffectGroup*                              s_TransformPouceRoot;                             		// 0x1D0C (0x0004) [0x0000000000000000]              
	class UTgAnimNodeSlot*                             c_PounceSlot;                                     		// 0x1D10 (0x0004) [0x0000000000000000]              
	int                                                r_nTurtleShieldEndCounter;                        		// 0x1D14 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              c_fNineTurnsApplyTime;                            		// 0x1D18 (0x0004) [0x0000000000000000]              
	float                                              r_fNineTurnsLifeTime;                             		// 0x1D1C (0x0004) [0x0000000000000020]              ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2803 );

		return pClassPointer;
	};

	void eventOnAnimEnd ( class UAnimNodeSequence* SeqNode, float PlayedTime, float ExcessTime );
	void CacheMainMeshReferences ( class UTgSkeletalMeshComponent* smcomp );
	void PlayNearDeathCleanup ( );
	void PlayDying ( class UClass* dmgType, struct FVector HitLoc );
	void EndMinkPounce ( );
	void BeginMinkPounce ( );
	void FaceRotation ( struct FRotator NewRotation, float DeltaTime );
	void SetPinFireMode ( int nFireMode );
	void OnDeviceFormInterruptFire ( int nEquipSlot );
	void OnDeviceFormStopFire ( int nEquipSlot );
	void OnDeviceFormHit ( int nEquipSlot, class ATgPawn* TargetPawn );
	void OnDeviceFormFire ( int nEquipSlot );
	void OnDeviceFormStartFire ( int nEquipSlot, float FireDuration, int nFireMode );
	void OnDeviceFormBuildup ( int nEquipSlot, float fBuildupTime );
	unsigned char OverrideOffhandSlot ( unsigned char eqp );
	struct FVector GetLookAtLocation ( );
	void OnRespawn ( );
	void eventReplicatedEvent ( struct FName VarName );
	void TriggerTurtleShieldEndFX ( );
	void EnableMinkBuffFX ( unsigned long bEnabled );
	void EnableSpotWeaknessFX ( unsigned long bEnabled );
	bool GetPassiveAuxMax ( float* fResult );
	bool GetPassiveAux ( float* fResult );
	bool GetPassiveInt1 ( int* nResult );
	void EndTransform ( );
	void StartTransform ( unsigned char NewStance, unsigned long bSkipTransition );
	void DespawnPet ( );
	void SpawnPet ( );
	void OnPawnDied ( );
	void PostPawnSetupServer ( );
	void EffectGroupOnSetActive ( unsigned long bActive, unsigned long bRemoving, class UTgEffectGroup* effectGroup );
	bool DeviceOverrideTargetingAim ( class ATgDevice* Dev, struct FAimData* Aim, TArray< struct FImpactInfo >* ImpactList );
	void DeviceOnStopFire ( class ATgDevice* Dev, unsigned long WasInterrupted );
	void DeviceOnStartFire ( class ATgDevice* Dev );
	void DeviceOnHit ( class ATgDevice* Dev, struct FImpactInfo* Impact );
	void SwapTransformMesh ( );
	void SwapToDestroyedMesh ( );
	void SwapToLiveMesh ( );
	void OnPostureChange ( );
	void OnTransformTransitionEnd ( unsigned long bTriggeredInAnimTick );
};

UClass* ATgPawn_ErlangShen::pClassPointer = NULL;

// Class TgGame.TgPawn_Fafnir
// 0x0020 (0x1CAC - 0x1C8C)
class ATgPawn_Fafnir : public ATgPawn_MeshSwapper
{
public:
	int                                                r_nMaxGoldThreshold;                              		// 0x1C8C (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              r_fMaxProtections;                                		// 0x1C90 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class AController*                                 s_KillerOverride;                                 		// 0x1C94 (0x0004) [0x0000000000000000]              
	float                                              r_fTotalDragonTime;                               		// 0x1C98 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              c_fDragonStartTime;                               		// 0x1C9C (0x0004) [0x0000000000000000]              
	float                                              r_fTransformCameraZoom;                           		// 0x1CA0 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              r_fTransformCameraZoomTween;                      		// 0x1CA4 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              c_nActiveDisplayGroup_Passive;                    		// 0x1CA8 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2804 );

		return pClassPointer;
	};

	void SetLeapFireMode ( int nFireMode );
	void OnDeviceFormStartFire ( int nEquipSlot, float FireDuration, int nFireMode );
	void eventAttemptDwarfTransform ( );
	bool DoJump ( unsigned long bUpdating );
	void GetCameraZoomOverride ( float* fZoom, float* fTweenSpeed );
	bool eventIsDragon ( );
	void SetPassiveDisplayGroup ( int ActiveGroup );
	void Tick ( float DeltaSeconds );
	float ApplyPitchLimit ( float fPitch );
	bool IgnoreFaceRotationWithInterp ( );
	void EndTween ( unsigned char endingTweenState, unsigned long bInterrupted );
	void BeginTween ( unsigned char newTweenState );
	class AController* OverrideKillInstigator ( );
	void eventReplicatedEvent ( struct FName VarName );
	void SwapToMesh ( int nMeshId );
	struct FString GetEmoteCustomSuffix ( unsigned char Emote, int ExtraInfo );
	struct FString GetVGSCustomSuffix ( int nPreferredVPSetting );
	void OnPawnDied ( );
	void EffectGroupOnSetActive ( unsigned long bActive, unsigned long bRemoving, class UTgEffectGroup* effectGroup );
	void DeviceOnStopFire ( class ATgDevice* Dev, unsigned long WasInterrupted );
	void DeviceOnStartFire ( class ATgDevice* Dev );
	bool GetPassiveInt1 ( int* nResult );
	bool GetPassiveAuxMax ( float* fResult );
	bool GetPassiveAux ( float* fResult );
	float GetMagicalProtection ( );
	float GetPhysicalProtection ( );
	float GetGoldProtectionPct ( );
};

UClass* ATgPawn_Fafnir::pClassPointer = NULL;

// Class TgGame.TgPawn_Monkey
// 0x0004 (0x1C70 - 0x1C6C)
class ATgPawn_Monkey : public ATgPawn_Character
{
public:
	class ATgProj_FuriousMonkey*                       m_FuriousMonkey;                                  		// 0x1C6C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2805 );

		return pClassPointer;
	};

	void eventSetFuriousMonkey ( class ATgProj_FuriousMonkey* Proj );
	void EndTween ( unsigned char endingTweenState, unsigned long bInterrupted );
	void BeginTween ( unsigned char newTweenState );
	void OnDeviceFormBuildup ( int nEquipSlot, float fBuildupTime );
	void PlayTeleportFx ( int nTeleportState, struct FVector vLoc );
	void DeviceOnSetFireMode ( class ATgDevice* Dev );
	void ReapplyLoadoutEffects ( );
	void PawnOnExitCombat ( );
	void PawnOnEnterCombat ( );
	void PawnOnRevive ( );
	bool DeviceOnCanDeviceCriticalStrike ( class ATgDevice* Dev, int nPropertyId, int nDamageType, struct FImpactInfo* Impact, float* fCritChance );
	void DeviceOnStartFire ( class ATgDevice* Dev );
};

UClass* ATgPawn_Monkey::pClassPointer = NULL;

// Class TgGame.TgPawn_Neith
// 0x02C4 (0x1F30 - 0x1C6C)
class ATgPawn_Neith : public ATgPawn_Character
{
public:
	class UMaterialInstanceConstant*                   c_BodyArt;                                        		// 0x1C6C (0x0004) [0x0000000000000000]              
	unsigned long                                      c_bEnableBodyArt : 1;                             		// 0x1C70 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      c_bEnableWorldWeaverSphere : 1;                   		// 0x1C70 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      r_bInUltimateSetup : 1;                           		// 0x1C70 (0x0004) [0x0000000000000020] [0x00000004] ( CPF_Net )
	unsigned long                                      c_bUltimateSetupInterrupted : 1;                  		// 0x1C70 (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      r_bUltHasFired : 1;                               		// 0x1C70 (0x0004) [0x0000000000000020] [0x00000010] ( CPF_Net )
	unsigned long                                      s_bCanTeleport : 1;                               		// 0x1C70 (0x0004) [0x0000000000000000] [0x00000020] 
	float                                              c_fBodyArtCurrentScale;                           		// 0x1C74 (0x0004) [0x0000000000000000]              
	float                                              c_fBodyArtTweenRate;                              		// 0x1C78 (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                c_UnravelBlastFx;                                 		// 0x1C7C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                s_UnravelWeaveHealCount;                          		// 0x1C80 (0x0004) [0x0000000000000000]              
	int                                                s_UnravelPawnHealCount;                           		// 0x1C84 (0x0004) [0x0000000000000000]              
	int                                                s_UnravelMaxPawnHeals;                            		// 0x1C88 (0x0004) [0x0000000000000000]              
	int                                                s_UnravelMaxWeaveHeals;                           		// 0x1C8C (0x0004) [0x0000000000000000]              
	class UTgDeviceFire*                               s_UnravelPawnFireMode;                            		// 0x1C90 (0x0004) [0x0000000000000000]              
	class UTgDeviceFire*                               s_UnravelWeaveFireMode;                           		// 0x1C94 (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                c_WorldWeaverOnFireSoundFx;                       		// 0x1C98 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UTgSpecialFx*                                c_WorldWeaverSphereFx;                            		// 0x1C9C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                s_iFireYaw;                                       		// 0x1CA0 (0x0004) [0x0000000000000000]              
	float                                              c_fWorldWeaverSphereCurrentScale;                 		// 0x1CA4 (0x0004) [0x0000000000000000]              
	float                                              c_fWorldWeaverSphereTweenRate;                    		// 0x1CA8 (0x0004) [0x0000000000000000]              
	float                                              s_fWorldWeaverDamageScaleFactor;                  		// 0x1CAC (0x0004) [0x0000000000000000]              
	float                                              m_fSmoothEnergy;                                  		// 0x1CB0 (0x0004) [0x0000000000000000]              
	float                                              m_fSmoothEnergySpeed;                             		// 0x1CB4 (0x0004) [0x0000000000000000]              
	int                                                c_iUltimatePostureID;                             		// 0x1CB8 (0x0004) [0x0000000000000000]              
	class ATgDevice*                                   r_InHandBasic;                                    		// 0x1CBC (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgDevice*                                   r_InHandUltimate;                                 		// 0x1CC0 (0x0004) [0x0000000000000020]              ( CPF_Net )
	struct FTG_HUD_INFO                                c_TargetingHudInfo;                               		// 0x1CC4 (0x0130) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FTG_HUD_INFO                                c_ChargeHudInfo;                                  		// 0x1DF4 (0x0130) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UTgAnimBlendByNeithUltimate* >       m_NeithUltAnimNodes;                              		// 0x1F24 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2806 );

		return pClassPointer;
	};

	void eventPlayUltHitEffects ( );
	void eventClientWorldWeaverTeleport ( float TeleportLocationX, float TeleportLocationY, float TeleportLocationZ, int TeleportYaw );
	void eventWorldWeaverTeleport ( float TeleportLocationX, float TeleportLocationY, float TeleportLocationZ, int TeleportYaw );
	void eventOnAnimEnd ( class UAnimNodeSequence* SeqNode, float PlayedTime, float ExcessTime );
	void OnDeviceFormInterruptFire ( int nEquipSlot );
	void OnDeviceFormStopFire ( int nEquipSlot );
	void OnDeviceFormStartFire ( int nEquipSlot, float FireDuration, int nFireMode );
	void OnDeviceFormBuildup ( int nEquipSlot, float fBuildupTime );
	void TickWorldWeaverSphereVisibility ( float DeltaTime );
	void TickThreadOfLifeFxs ( float DeltaTime );
	void TickBodyArt ( float DeltaTime );
	void ToggleWorldWeaverSphereVisibility ( unsigned long bOn, float TweenTime );
	void ToggleUltimateCameraModule ( unsigned long bOn );
	void ToggleBodyArt ( unsigned long bOn, float TweenTime );
	void eventDeactivateUltimatePosture ( unsigned long bWasInterrupted );
	void ActivateUltimatePosture ( );
	void EndTween ( unsigned char endingTweenState, unsigned long bInterrupted );
	void BeginTween ( unsigned char newTweenState );
	void eventSetTargetingDevice ( class ATgDevice* Dev );
	void eventForceUltConsumePowerPool ( );
	void Tick ( float DeltaSeconds );
	void FaceRotation ( struct FRotator NewRotation, float DeltaTime );
	void eventPostInitAnimTree ( class USkeletalMeshComponent* SkelComp );
	bool eventPostPawnSetup ( );
	void eventReplicatedEvent ( struct FName VarName );
	bool OverrideDistanceFadeRange ( );
	void OnBrokenWeaveHitByWorldWeaver ( class ATgDeployable_Neith_BrokenWeave* Weave );
	void OnPawnDied ( );
	void PlayTeleportFx ( int nTeleportState, struct FVector vLoc );
	class UTgSpecialFx* GetUnusedThreadOfLifeFx ( );
	bool InitializeUnravelAOEFx ( );
	bool InitializeWorldWeaverSoundFx ( );
	bool InitializeWorldWeaverSphereFx ( );
	bool DeviceOnCanDeviceFireNow ( class ATgDevice* Dev, unsigned char FireModeNum, unsigned long bDeviceFailLog, struct FAimData* Aim );
	bool DeviceOverrideManaUseVitals ( class ATgDevice* Dev, class ATgPlayerController* PC );
	bool DeviceOverrideTargetingAim ( class ATgDevice* Dev, struct FAimData* Aim, TArray< struct FImpactInfo >* ImpactList );
	bool IsMyBrokenWeave ( class AActor* HitActor );
	void CalcSmoothEnergy ( float fDelta );
	void SetSpawnEnergy ( );
	float GetSmoothEnergy ( );
	void EndUltimateSetup ( unsigned long bForce );
	void StartUltimateSetup ( class ATgDevice* Dev );
	void StartBackFlip ( );
	void DeviceOnSetFireMode ( class ATgDevice* Dev );
	void DeviceAdjustHeal ( class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fHeal );
	void DeviceAdjustDamage ( class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage );
	void DeviceOnHit ( class ATgDevice* Dev, struct FImpactInfo* Impact );
	void DeviceOnStopFire ( class ATgDevice* Dev, unsigned long WasInterrupted );
	void DeviceOnFire ( class ATgDevice* Dev );
	void DeviceOnStartFire ( class ATgDevice* Dev );
};

UClass* ATgPawn_Neith::pClassPointer = NULL;

// Class TgGame.TgPawn_Nemesis
// 0x0014 (0x1C80 - 0x1C6C)
class ATgPawn_Nemesis : public ATgPawn_Character
{
public:
	int                                                r_nCurrentPassiveMeterEnergy;                     		// 0x1C6C (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nMaxPassiveMeterEnergy;                         		// 0x1C70 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                m_nHealingInTakeDamage;                           		// 0x1C74 (0x0004) [0x0000000000000000]              
	class UTgSkeletalMeshComponent*                    m_Num2EffectsMeshComponent;                       		// 0x1C78 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class ATgDevice*                                   m_Num4SubDevice;                                  		// 0x1C7C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2807 );

		return pClassPointer;
	};

	void AdjustDamage ( class AController* InstigatedBy, struct FVector HitLocation, class UClass* DamageType, struct FTraceHitInfo HitInfo, class AActor* DamageCauser, int* InDamage, struct FVector* Momentum );
	void eventModifyHealthProp ( int nDamage );
	void eventTakeDamage ( int Damage, class AController* InstigatedBy, struct FVector HitLocation, struct FVector Momentum, class UClass* DamageType, struct FTraceHitInfo HitInfo, class AActor* DamageCauser );
	void Num2EffectDetachTimer ( );
	void OnDeviceFormStartFire ( int nEquipSlot, float FireDuration, int nFireMode );
	bool eventDied ( class AController* Killer, class UClass* dmgType, struct FVector HitLocation );
	bool AreAnyOtherOffhandsLockingFiring ( class ATgDevice* CurrentDevice );
	void PlayTeleportFx ( int nTeleportState, struct FVector vLoc );
	float GetSmoothEnergy ( );
	bool PawnCanDisplayImmuneMessage ( );
	void DeviceOnDamaged ( struct FOnDamagedParams* Params );
	void DeviceAdjustDamage ( class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage );
	void DeviceOnKilled ( class ATgDevice* Dev, float fDamage, struct FImpactInfo* Impact );
	void DeviceOnHit ( class ATgDevice* Dev, struct FImpactInfo* Impact );
	void DeviceOnSetFireMode ( class ATgDevice* Dev );
	void DeviceOnStartBuildup ( class ATgDevice* Dev );
};

UClass* ATgPawn_Nemesis::pClassPointer = NULL;

// Class TgGame.TgPawn_NeZha
// 0x011C (0x1D88 - 0x1C6C)
class ATgPawn_NeZha : public ATgPawn_Character
{
public:
	TArray< struct FUniverseRingTossDamageTracker >    UniverseRingTossBounces;                          		// 0x1C6C (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	unsigned char                                      r_ArmillarySashPhase;                             		// 0x1C78 (0x0001) [0x0000000000002020]              ( CPF_Net | CPF_Transient )
	unsigned char                                      r_WindFireWheelsPhase;                            		// 0x1C79 (0x0001) [0x0000000000002020]              ( CPF_Net | CPF_Transient )
	unsigned char                                      r_ePassiveState;                                  		// 0x1C7A (0x0001) [0x0000000000000020]              ( CPF_Net )
	TArray< class UTgDeviceFire* >                     SashAoeBlastModes;                                		// 0x1C7C (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	class ATgPawn*                                     r_ArmillarySashTarget;                            		// 0x1C88 (0x0004) [0x0000000000002020]              ( CPF_Net | CPF_Transient )
	class UTgAnimNodeBlendByNeZhaArmillarySash*        SashAnimBlend;                                    		// 0x1C8C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class USkelControlSingleBone*                      SashSkelControlDistance;                          		// 0x1C90 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class USkelControlLookAt*                          SashSkelControlAim;                               		// 0x1C94 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class USkelControlSingleBone*                      SashSkelScale;                                    		// 0x1C98 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned long                                      m_bDoArmillarySashAoeOnStunFail : 1;              		// 0x1C9C (0x0004) [0x0000000000000002] [0x00000001] ( CPF_Const )
	unsigned long                                      bWindFireAirDashQueuedHit : 1;                    		// 0x1C9C (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	unsigned long                                      bHasNewAirDashHit : 1;                            		// 0x1C9C (0x0004) [0x0000000000002000] [0x00000004] ( CPF_Transient )
	unsigned long                                      m_bJustLanded : 1;                                		// 0x1C9C (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      r_bPassiveFXEnabled : 1;                          		// 0x1C9C (0x0004) [0x0000000000000020] [0x00000010] ( CPF_Net )
	class ATgProj_NeZha_ArmillarySash*                 m_SashProjectile;                                 		// 0x1CA0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              WindFireLiftDuration;                             		// 0x1CA4 (0x0004) [0x0000000000000000]              
	float                                              WindFireAirDashDuration;                          		// 0x1CA8 (0x0004) [0x0000000000000000]              
	float                                              WindFireKnockDownDuration;                        		// 0x1CAC (0x0004) [0x0000000000000000]              
	float                                              WindFireLandedDuration;                           		// 0x1CB0 (0x0004) [0x0000000000000000]              
	TArray< class UTgDeviceFire* >                     WindFireAirDashModes;                             		// 0x1CB4 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	TArray< class UTgDeviceFire* >                     WindFireKnockDownModes;                           		// 0x1CC0 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	TArray< class UTgDeviceFire* >                     WindFireLandedBlastModes;                         		// 0x1CCC (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	struct FWindFireWheelsQteStatus                    WindFireHudInfo[ 0x3 ];                           		// 0x1CD8 (0x0060) [0x0000000000002000]              ( CPF_Transient )
	int                                                r_WindFireAirDashHits;                            		// 0x1D38 (0x0004) [0x0000000000002020]              ( CPF_Net | CPF_Transient )
	class ATgCollisionProxy_Cylinder*                  WindFireChargeCollisionProxy;                     		// 0x1D3C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class ATgPawn*                                     r_WindFireTarget;                                 		// 0x1D40 (0x0004) [0x0000000000002020]              ( CPF_Net | CPF_Transient )
	class ATgPawn*                                     c_WindFirePostProcessTarget;                      		// 0x1D44 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UTgSpecialFx*                                WindFireLandedFx;                                 		// 0x1D48 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class ATgDevice_NeZha_UltQte*                      r_WindFireAirDashTiming;                          		// 0x1D4C (0x0004) [0x0000000000002020]              ( CPF_Net | CPF_Transient )
	class UTgDeviceFire*                               WindFireInitialDeviceFireMode;                    		// 0x1D50 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FVector                                     WindFireStartLocation;                            		// 0x1D54 (0x000C) [0x0000000000002000]              ( CPF_Transient )
	class UPostProcessChain*                           m_UltPostProcessChain;                            		// 0x1D60 (0x0004) [0x0000000000000000]              
	class ATgDevice*                                   r_InHandDevice;                                   		// 0x1D64 (0x0004) [0x0000000000002020]              ( CPF_Net | CPF_Transient )
	class UTgSkeletalMeshComponent*                    c_SashMeshComponent;                              		// 0x1D68 (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )
	class UTgSkeletalMeshComponent*                    c_PACSashMeshComponent;                           		// 0x1D6C (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )
	float                                              c_fPassiveTimer;                                  		// 0x1D70 (0x0004) [0x0000000000000000]              
	float                                              r_fPassiveTransitionTime;                         		// 0x1D74 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                m_nSashAOEBlastOverrideSubId;                     		// 0x1D78 (0x0004) [0x0000000000000000]              
	int                                                m_nWFADOverrideSubId;                             		// 0x1D7C (0x0004) [0x0000000000000000]              
	int                                                m_nWFKDOverrideSubId;                             		// 0x1D80 (0x0004) [0x0000000000000000]              
	int                                                m_nWFLBOverrideSubId;                             		// 0x1D84 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2808 );

		return pClassPointer;
	};

	bool IgnoreFaceRotationWithInterp ( );
	void eventSetTargetingDevice ( class ATgDevice* Dev );
	void OnRespawn ( );
	bool eventPostPawnSetup ( );
	void PlayNearDeathCleanup ( );
	void PlayDyingEffects ( );
	void StopWindFireEffects ( );
	void PlayWindFireMissEffects ( );
	void PlayWindFireLiftMissEffects ( );
	void PlayWindFireLandedEffects ( );
	void PlayWindFireKnockDownEffects ( );
	void PlayWindFireDashEffects ( );
	void PlayWindFireLiftEffects ( );
	void ForceWindFireWheelsFinishLanding ( unsigned long bSkipCollision );
	void WindFireLandedUpdate ( );
	void WindFireAirDashUpdate ( );
	void StartWindFireAirDashDamage ( );
	void EndWindFireAirDash ( );
	void SetUltPostProcess ( class ATgPawn* OtherTarget );
	void ClearUltPostProcess ( );
	void UpdateUltPostProcess ( );
	void StartWindFireAirDash ( );
	void WindFireSelfLift ( );
	void WindFireTargetLift ( );
	void eventUpdateWindFireWheelsPhase ( unsigned char NewPhase );
	void UpdateWindFireWheelsTargetEffect ( class AActor* Other, unsigned long bEnable );
	void SetArmillarySashProjectile ( class ATgProj_NeZha_ArmillarySash* Proj );
	void UpdateArmillarySashEffects ( float DeltaSeconds );
	void eventUpdateArmillarySashPhase ( unsigned char NewPhase );
	void eventUpdateArmillarySashTarget ( class ATgPawn* Target );
	void eventUpdatePassiveState ( unsigned char ePassiveState );
	void eventTick ( float DeltaSeconds );
	void eventWindFireChargeCollisionProxyOnTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	bool eventCanBePulled ( );
	void KnockdownTweenEnd ( unsigned long bInterrupted );
	void EndTween ( unsigned char endingTweenState, unsigned long bInterrupted );
	void BeginTween ( unsigned char newTweenState );
	void BeginGrab ( unsigned char newGrabState );
	void eventPostInitAnimTree ( class USkeletalMeshComponent* SkelComp );
	void eventPreDemoRewind ( );
	void eventReplicatedEvent ( struct FName VarName );
	void EnablePassiveFX ( unsigned long bEnabled );
	bool GetPassiveInt1 ( int* nResult );
	bool GetPassiveAux ( float* fResult );
	void CalcSmoothEnergy ( float DeltaSeconds );
	void SetSpawnEnergy ( );
	float GetUltEnergy ( );
	float GetSmoothEnergy ( );
	void WindFireWheelsLandedTweenTrace ( struct FVector* SelfTweenLoc, struct FVector* TargetTweenLoc );
	void WindFireWheelsLandedHit ( );
	void WindFireWheelsKnockDownHit ( );
	void WindFireWheelsAirDashHit ( );
	void DetachSashMesh ( );
	void AttachSashMesh ( );
	void ArmillarySashAoeBlast ( struct FVector OverrideLocation );
	void OnMeshSwapped ( );
	void OnPawnDied ( );
	int GetCustomParticleSystemFilter ( );
	bool DeviceOnCanDeviceCriticalStrike ( class ATgDevice* Dev, int nPropertyId, int nDamageType, struct FImpactInfo* Impact, float* fCritChance );
	void DeviceOnHit ( class ATgDevice* Device, struct FImpactInfo* Impact );
	void DeviceOnStartCooldown ( class ATgDevice* Device, float Cooldown );
	void DeviceOnStopFire ( class ATgDevice* Device, unsigned long WasInterrupted );
	void DeviceOnFire ( class ATgDevice* Device );
	void DeviceOnStartFire ( class ATgDevice* Device );
	void DeviceOnSetFireMode ( class ATgDevice* Device );
	void DeviceAdjustDamage ( class ATgDevice* Device, int nPropertyId, struct FImpactInfo* Impact, float* DamageAmt );
	bool DeviceOverrideTargetingAim ( class ATgDevice* Device, struct FAimData* Aim, TArray< struct FImpactInfo >* ImpactList );
	bool DeviceOnCanDeviceFireNow ( class ATgDevice* Device, unsigned char FireMode, unsigned long bDeviceFailLog, struct FAimData* Aim );
	bool InitializeSashMeshComponent ( );
	void InitializeUltPostProcess ( );
	void CreateWindFireLandedFx ( );
	void PostPawnSetupServer ( );
};

UClass* ATgPawn_NeZha::pClassPointer = NULL;

// Class TgGame.TgPawn_NeZha_PVE
// 0x0000 (0x1D88 - 0x1D88)
class ATgPawn_NeZha_PVE : public ATgPawn_NeZha
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2809 );

		return pClassPointer;
	};

};

UClass* ATgPawn_NeZha_PVE::pClassPointer = NULL;

// Class TgGame.TgPawn_Nike
// 0x005C (0x1CC8 - 0x1C6C)
class ATgPawn_Nike : public ATgPawn_Character
{
public:
	class ATgDevice*                                   m_DevicePsv;                                      		// 0x1C6C (0x0004) [0x0000000000000000]              
	class ATgDevice_Nike_Dev1*                         m_DeviceA01;                                      		// 0x1C70 (0x0004) [0x0000000000000000]              
	class ATgDevice_Nike_Dev2*                         m_DeviceA02;                                      		// 0x1C74 (0x0004) [0x0000000000000000]              
	class ATgDevice_Nike_Dev3*                         m_DeviceA03;                                      		// 0x1C78 (0x0004) [0x0000000000000000]              
	class ATgDevice*                                   m_DeviceA04;                                      		// 0x1C7C (0x0004) [0x0000000000000000]              
	int                                                r_nTotalCreaturesKilled;                          		// 0x1C80 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nTotalGodsKilled;                               		// 0x1C84 (0x0004) [0x0000000000000020]              ( CPF_Net )
	unsigned long                                      r_bMaxLevelAlliesReached : 1;                     		// 0x1C88 (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )
	unsigned long                                      r_bIsDev2Active : 1;                              		// 0x1C88 (0x0004) [0x0000000000000020] [0x00000002] ( CPF_Net )
	unsigned long                                      r_bIsArmorActive : 1;                             		// 0x1C88 (0x0004) [0x0000000000000020] [0x00000004] ( CPF_Net )
	unsigned long                                      r_bIsArmorBroken : 1;                             		// 0x1C88 (0x0004) [0x0000000000000020] [0x00000008] ( CPF_Net )
	unsigned long                                      r_bDisplayUltWings : 1;                           		// 0x1C88 (0x0004) [0x0000000000000020] [0x00000010] ( CPF_Net )
	unsigned long                                      r_bManageUltWings : 1;                            		// 0x1C88 (0x0004) [0x0000000000000020] [0x00000020] ( CPF_Net )
	unsigned char                                      r_eUltVisualsState;                               		// 0x1C8C (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      c_eLocalUltVisualsState;                          		// 0x1C8D (0x0001) [0x0000000000000000]              
	TArray< class USkelControlBase* >                  c_UltVisualsStateSkelControls_Helmet;             		// 0x1C90 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class USkelControlBase* >                  c_UltVisualsStateSkelControls_Hair;               		// 0x1C9C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FName                                       c_UltVisualsSkelControlName_Helmet;               		// 0x1CA8 (0x0008) [0x0000000000000000]              
	struct FName                                       c_UltVisualsSkelControlName_Hair;                 		// 0x1CB0 (0x0008) [0x0000000000000000]              
	class UTgSkeletalMeshComponent*                    c_UltWingsMesh;                                   		// 0x1CB8 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	float                                              r_fUltWingBlend;                                  		// 0x1CBC (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              m_fUltWingBlendInSpeed;                           		// 0x1CC0 (0x0004) [0x0000000000000000]              
	float                                              m_fUltWingBlendOutSpeed;                          		// 0x1CC4 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2810 );

		return pClassPointer;
	};

	void UpdateHairState ( unsigned long SkelControlActive );
	void UpdateHelmetState ( unsigned long SkelControlActive );
	void eventUpdateUltVisualsState ( unsigned char NewState );
	void CacheMultiMeshAnimNodeReferences ( class UTgSkeletalMeshComponent* smcomp );
	void ClearMultiMeshAnimNodeReferences ( );
	void eventManageDev4ArmorBreakFx ( );
	void eventPlayDev4TransformationFx ( );
	void eventToggleDev4Fx ( unsigned long Active );
	void eventToggleDev2Fx ( );
	void EndTween ( unsigned char endingTweenState, unsigned long bInterrupted );
	void BeginTween ( unsigned char newTweenState );
	void eventOnRespawn ( );
	void Tick ( float DeltaSeconds );
	void eventReplicatedEvent ( struct FName VarName );
	void EffectGroupOnSetActive ( unsigned long bActive, unsigned long bRemoving, class UTgEffectGroup* effectGroup );
	void DeviceOnStopFire ( class ATgDevice* Dev, unsigned long WasInterrupted );
	void DeviceOnStartFire ( class ATgDevice* Dev );
	void DeviceOnHit ( class ATgDevice* Dev, struct FImpactInfo* Impact );
	bool GetPassiveBool ( int* bResult );
	bool GetPassiveInt2 ( int* nResult );
	bool GetPassiveInt1 ( int* nResult );
	struct FString GetEmoteCustomSuffix ( unsigned char Emote, int ExtraInfo );
	struct FString GetVGSCustomSuffix ( int nPreferredVPSetting );
	void ForceUltWingsOff ( );
	bool ShouldDisplayUltWings ( );
	void ToggleUltWings ( unsigned long ActiveWings );
	void InitializeUltWings ( );
};

UClass* ATgPawn_Nike::pClassPointer = NULL;

// Class TgGame.TgPawn_Nox
// 0x00B0 (0x1D1C - 0x1C6C)
class ATgPawn_Nox : public ATgPawn_Character
{
public:
	int                                                r_nPassiveAbilitiesUsed;                          		// 0x1C6C (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nPassiveAbilityMax;                             		// 0x1C70 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class UTgSpecialFx*                                c_CandleFx[ 0x4 ];                                		// 0x1C74 (0x0010) [0x0000000000002000]              ( CPF_Transient )
	unsigned long                                      c_bHideCandles : 1;                               		// 0x1C84 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	unsigned long                                      m_bTickCheckGrabEnd : 1;                          		// 0x1C84 (0x0004) [0x0000000000000000] [0x00000002] 
	class UTgSkeletalMeshComponent*                    m_DeathMeshComponent;                             		// 0x1C88 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	int                                                m_Dev1Category;                                   		// 0x1C8C (0x0004) [0x0000000000000000]              
	int                                                r_fLinkRange;                                     		// 0x1C90 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgPawn*                                     r_LinkedTarget;                                   		// 0x1C94 (0x0004) [0x0000000000000020]              ( CPF_Net )
	struct FShadowLockInfo                             c_LinkedTargetInfo;                               		// 0x1C98 (0x0030) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_nLinkBeamHandFxId;                              		// 0x1CC8 (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                c_LinkBeamHandFx;                                 		// 0x1CCC (0x0004) [0x0000000000000000]              
	float                                              m_fDeadLinkShrinkRate;                            		// 0x1CD0 (0x0004) [0x0000000000000000]              
	struct FVector                                     m_vSpineOffset;                                   		// 0x1CD4 (0x000C) [0x0000000000000000]              
	class UTgDeviceFire*                               m_LinkedTargetFire;                               		// 0x1CE0 (0x0004) [0x0000000000000000]              
	int                                                m_LinkMICId;                                      		// 0x1CE4 (0x0004) [0x0000000000000000]              
	int                                                m_nDev3FriendlyCategory;                          		// 0x1CE8 (0x0004) [0x0000000000000000]              
	class ATgPawn*                                     r_AttachedTarget;                                 		// 0x1CEC (0x0004) [0x0000000000000020]              ( CPF_Net )
	class UTgDeviceFire*                               m_AttachedTargetFire;                             		// 0x1CF0 (0x0004) [0x0000000000000000]              
	int                                                m_nEjectionExplosionFxId;                         		// 0x1CF4 (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                c_EjectionExplosionFx;                            		// 0x1CF8 (0x0004) [0x0000000000000000]              
	int                                                m_nAOETargeterFxId;                               		// 0x1CFC (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                c_InsideAOETargeter;                              		// 0x1D00 (0x0004) [0x0000000000000000]              
	class ATgSkeletalMeshActor*                        c_InsideAOETargeterMesh;                          		// 0x1D04 (0x0004) [0x0000000000000000]              
	struct FVector                                     m_LastValidShadowLocation;                        		// 0x1D08 (0x000C) [0x0000000000000000]              
	class UTgEffectGroup*                              m_AttachedGroup;                                  		// 0x1D14 (0x0004) [0x0000000000000000]              
	float                                              r_fAOETargetPercent;                              		// 0x1D18 (0x0004) [0x0000000000000020]              ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2811 );

		return pClassPointer;
	};

	void TriggerEjectionFX ( );
	void ApplyPawnShadows ( unsigned long bOn );
	void eventOnDetachFromTarget ( );
	void eventOnAttachedToTarget ( );
	void StartDev3Cooldown ( );
	void VerifyGrabEffectRemoved ( );
	void NotifyGrabEndIgnored ( );
	bool ShouldGrabEnd ( unsigned long bInterrupted );
	bool eventIsGrabSourceValid ( class ATgPawn* Target, unsigned long bAllowTurrets, unsigned long bAllowStealthed );
	void NoxGrabEnd ( unsigned long bInterrupted );
	void EndGrab ( unsigned char endingGrabState, unsigned long bInterrupted );
	void BeginGrab ( unsigned char newGrabState );
	void TriggerEjectionExplosion ( );
	bool UpdateLinkedTarget ( float DeltaTime, struct FShadowLockInfo* LinkInfo );
	void eventSetLinkedActor ( class AActor* LinkedTarget, unsigned long bEnable );
	struct FShadowLockInfo CreateShadowLockInfo ( class AActor* LinkedTarget );
	void eventDeactivateLinkedTarget ( );
	void CheckLinkBreakSources ( );
	void CheckLinkTargetRange ( );
	void CalcLinkedTargetLocation ( class AActor* SoulMate, struct FVector* LinkLocation );
	class UTgSpecialFx* GetLinkedTargetFX ( class UMaterialInstanceConstant* MIC );
	bool eventDeviceOverrideLockedDown ( class ATgDevice* Device );
	void TogglePassiveFX ( unsigned long bNewHideState );
	void eventUpdatePassiveFx ( int NewPassiveCount );
	bool loadfx ( );
	void eventUpdatePassiveStacks ( );
	void eventIncrementPassiveCount ( );
	void FaceRotation ( struct FRotator NewRotation, float DeltaTime );
	void Tick ( float DeltaSeconds );
	bool SelfIsDeadOrDying ( );
	bool TargetIsDeadOrDying ( );
	void CleanUpDyingEffects ( );
	void PlayDyingEffects ( );
	void eventPostDemoRewind ( );
	bool PostPawnSetup ( );
	void eventReplicatedEvent ( struct FName VarName );
	void UpdateDev3TargetingFX ( );
	bool GetPassiveAuxMax ( float* fResult );
	bool GetPassiveAux ( float* fResult );
	bool GetPassiveBool ( int* bResult );
	bool InitializeDev3AOEFX ( );
	bool InitializeEjectionExplosion ( );
	bool InitializePassiveCandleFX ( );
	void OnPawnDied ( );
	void PawnOnDamaged ( struct FOnDamagedParams* Params );
	bool IsStealthed ( class ATgRepInfo_Player* Viewer );
	void EffectGroupOnSetActive ( unsigned long bActive, unsigned long bRemoving, class UTgEffectGroup* effectGroup );
	bool DeviceOverrideTargetingAim ( class ATgDevice* Dev, struct FAimData* Aim, TArray< struct FImpactInfo >* ImpactList );
	void DeviceOnHit ( class ATgDevice* Dev, struct FImpactInfo* Impact );
	void DeviceOnFire ( class ATgDevice* Dev );
	bool DeviceHasEnoughPowerPool ( class ATgDevice* Dev, unsigned char FireModeNum );
	bool DeviceOnCanDeviceFireNow ( class ATgDevice* Dev, unsigned char FireModeNum, unsigned long bDeviceFailLog, struct FAimData* Aim );
	void DeviceOnSetFireMode ( class ATgDevice* Dev );
};

UClass* ATgPawn_Nox::pClassPointer = NULL;

// Class TgGame.TgPawn_NuWa
// 0x02C4 (0x1F30 - 0x1C6C)
class ATgPawn_NuWa : public ATgPawn_Character
{
public:
	int                                                r_nCrystalFlashEventIndex;                        		// 0x1C6C (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                c_nCrystalFlashEventIndex;                        		// 0x1C70 (0x0004) [0x0000000000000000]              
	int                                                r_nCrystalFlashEvents[ 0x10 ];                    		// 0x1C74 (0x0040) [0x0000000000000020]              ( CPF_Net )
	float                                              r_fCrystalFlashLifetimes[ 0x10 ];                 		// 0x1CB4 (0x0040) [0x0000000000000020]              ( CPF_Net )
	struct FNuWaCrystalInfo                            c_LocalCrystals[ 0x19 ];                          		// 0x1CF4 (0x01F4) [0x0000000000000000]              
	float                                              m_fCrystalActivateTime;                           		// 0x1EE8 (0x0004) [0x0000000000000000]              
	float                                              m_fCrystalDeactivateTime;                         		// 0x1EEC (0x0004) [0x0000000000000000]              
	int                                                m_nCurrentInHandMode;                             		// 0x1EF0 (0x0004) [0x0000000000000000]              
	int                                                m_nSnakeTailMeshId;                               		// 0x1EF4 (0x0004) [0x0000000000000000]              
	unsigned char                                      r_eCurrentNuWaForm;                               		// 0x1EF8 (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      c_eLocalNuWaForm;                                 		// 0x1EF9 (0x0001) [0x0000000000000000]              
	unsigned long                                      m_bFormTransitionInProgress : 1;                  		// 0x1EFC (0x0004) [0x0000000000000000] [0x00000001] 
	float                                              m_fNuWaFormTimeToGo;                              		// 0x1F00 (0x0004) [0x0000000000000000]              
	float                                              m_fNuWaFormBlend;                                 		// 0x1F04 (0x0004) [0x0000000000000000]              
	float                                              m_fNuWaFormBlendTarget;                           		// 0x1F08 (0x0004) [0x0000000000000000]              
	float                                              m_fNuWaFormTransitionTimes[ 0x2 ];                		// 0x1F0C (0x0008) [0x0000000000000002]              ( CPF_Const )
	TArray< class UAnimNodeBlend* >                    c_NuWaFormBlendNodes;                             		// 0x1F14 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< struct FNuWaFormControl >                  c_NuWaFormControls;                               		// 0x1F20 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class UTgSkeletalMeshComponent*                    c_SnakeMeshComponent;                             		// 0x1F2C (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2812 );

		return pClassPointer;
	};

	void eventStun ( unsigned long bStunController, unsigned char eType );
	void PrepareIntro ( );
	void OnRespawn ( );
	void PlayNearDeathCleanup ( );
	void PlayDying ( class UClass* dmgType, struct FVector HitLoc );
	void eventOnDeactivateCrystal ( unsigned char eqp );
	void eventOnActivateCrystal ( unsigned char eqp, float fLifeTime );
	void eventEndFormTransition ( );
	void FixInHandProgressionAnims ( int nNewMode, float NewDesiredDuration );
	void OnDeviceFormStartFire ( int nEquipSlot, float FireDuration, int nFireMode );
	void CacheMultiMeshAnimNodeReferences ( class UTgSkeletalMeshComponent* smcomp );
	void CacheMainMeshReferences ( class UTgSkeletalMeshComponent* smcomp );
	void ClearMultiMeshAnimNodeReferences ( );
	void ReflashActiveCrystals ( );
	void PossessedBy ( class AController* C, unsigned long bVehicleTransition );
	void eventReplicatedEvent ( struct FName VarName );
	bool ShouldShowSnakeTailThisTick ( );
	void ChangeForm ( unsigned char NewForm, unsigned long bSkipTransition, unsigned long bIntroOrDeath );
	void UpdateCrystalEvents ( );
	void FlashDeactivateCrystal ( unsigned char eqp );
	void FlashActivateCrystal ( unsigned char eqp, float fLifeTime );
	void DeviceOnSetFireMode ( class ATgDevice* Dev );
	void SetMeshVisibility ( unsigned long bVisible );
	void OnMeshSwapped ( );
	float GetSmoothEnergy ( );
};

UClass* ATgPawn_NuWa::pClassPointer = NULL;

// Class TgGame.TgPawn_NuWaV2
// 0x001C (0x1F4C - 0x1F30)
class ATgPawn_NuWaV2 : public ATgPawn_NuWa
{
public:
	unsigned char                                      r_eUltimateState;                                 		// 0x1F30 (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      m_eLocalUltState;                                 		// 0x1F31 (0x0001) [0x0000000000000000]              
	float                                              s_fUltimateTakeDownTime;                          		// 0x1F34 (0x0004) [0x0000000000000000]              
	class UClass*                                      c_UltimateCameraModuleClass;                      		// 0x1F38 (0x0004) [0x0000000000000000]              
	class UClass*                                      c_PreviousCameraModuleClass;                      		// 0x1F3C (0x0004) [0x0000000000000000]              
	class UTgCameraModule*                             c_UltimateCameraMod;                              		// 0x1F40 (0x0004) [0x0000000000000000]              
	unsigned long                                      r_bUltimateVision : 1;                            		// 0x1F44 (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )
	float                                              m_fCollisionOffTime;                              		// 0x1F48 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2813 );

		return pClassPointer;
	};

	bool CannotJumpNow ( );
	void OnRespawn ( );
	void EndSnakeForm ( );
	void ToggleUltimateCameraMod ( unsigned long bOn );
	void DelayedCameraPull ( );
	void EndUltimateTakeDown ( );
	void UltimateCollisionTimer ( );
	void eventUpdateUltimateState ( unsigned char NewState );
	void eventStun ( unsigned long bStunController, unsigned char eType );
	void PrepareIntro ( );
	void eventReplicatedEvent ( struct FName VarName );
	void EndSkinLevelUp ( );
	void DeviceOnStartBuildup ( class ATgDevice* Dev );
	void PawnOnRevive ( );
	bool OverrideDistanceFadeRange ( );
	bool DeviceOnCanDeviceFireNow ( class ATgDevice* Dev, unsigned char FireModeNum, unsigned long bDeviceFailLog, struct FAimData* Aim );
	void PlayTeleportFx ( int nTeleportState, struct FVector vLoc );
};

UClass* ATgPawn_NuWaV2::pClassPointer = NULL;

// Class TgGame.TgPawn_Odin
// 0x0010 (0x1C7C - 0x1C6C)
class ATgPawn_Odin : public ATgPawn_Character
{
public:
	TArray< class UTgDeviceFire* >                     GungnirsMightSecondHit;                           		// 0x1C6C (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	int                                                GungnirsMightCurrentMode;                         		// 0x1C78 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2814 );

		return pClassPointer;
	};

	void EndTween ( unsigned char endingTweenState, unsigned long bInterrupted );
	void BeginTween ( unsigned char newTweenState );
	void PlayTeleportFx ( int nTeleportState, struct FVector vLoc );
	void SetSpawnEnergy ( );
	void DoGungnirsMightSecondHit ( );
	void OnUtilityPowerChange ( );
	void DeviceOnStopFire ( class ATgDevice* Dev, unsigned long WasInterrupted );
	void DeviceOnStartFire ( class ATgDevice* Dev );
	void DeviceOnFire ( class ATgDevice* Dev );
};

UClass* ATgPawn_Odin::pClassPointer = NULL;

// Class TgGame.TgPawn_Osiris
// 0x00CC (0x1D38 - 0x1C6C)
class ATgPawn_Osiris : public ATgPawn_Character
{
public:
	TArray< class ATgPawn* >                           m_TetheredPawns;                                  		// 0x1C6C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	unsigned long                                      r_CanAttackDuringTether : 1;                      		// 0x1C78 (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )
	unsigned long                                      m_bTetherFiring : 1;                              		// 0x1C78 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      s_nPassiveInhandHasHit : 1;                       		// 0x1C78 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_bIsInSpectralState : 1;                         		// 0x1C78 (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      r_bUltActive : 1;                                 		// 0x1C78 (0x0004) [0x0000000000000020] [0x00000010] ( CPF_Net )
	class ATgPawn*                                     r_TetheredPawns[ 0x5 ];                           		// 0x1C7C (0x0014) [0x0000000000000020]              ( CPF_Net )
	class ATgPawn*                                     c_TetheredPawns[ 0x5 ];                           		// 0x1C90 (0x0014) [0x0000000000000000]              
	class UTgStaticMeshComponent*                      c_TetherMeshComponents[ 0x5 ];                    		// 0x1CA4 (0x0014) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class UTgStaticMeshComponent*                      c_BreakingTetherMeshComponents[ 0x5 ];            		// 0x1CB8 (0x0014) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	float                                              c_TetherDestroyProgressPercentage[ 0x5 ];         		// 0x1CCC (0x0014) [0x0000000000000000]              
	class USoundCue*                                   c_TetherSoundCue;                                 		// 0x1CE0 (0x0004) [0x0000000000000000]              
	unsigned char                                      r_eCurrentPassiveState;                           		// 0x1CE4 (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      c_eLocalPassiveState;                             		// 0x1CE5 (0x0001) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      r_UltState;                                       		// 0x1CE6 (0x0001) [0x0000000000002020]              ( CPF_Net | CPF_Transient )
	class UTgSpecialFx*                                c_PartsLostFx[ 0x9 ];                             		// 0x1CE8 (0x0024) [0x0000000000002000]              ( CPF_Transient )
	int                                                r_nPassiveAttacksLeft;                            		// 0x1D0C (0x0004) [0x0000000000000020]              ( CPF_Net )
	class UTgSkeletalMeshComponent*                    m_PassiveMeshComponent;                           		// 0x1D10 (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )
	class UMaterialInstanceConstant*                   c_PassiveMIC;                                     		// 0x1D14 (0x0004) [0x0000000000000000]              
	float                                              c_fBodyTransitionState;                           		// 0x1D18 (0x0004) [0x0000000000000000]              
	class ATgCollisionProxy_Cylinder*                  m_ChargeCollisionProxy;                           		// 0x1D1C (0x0004) [0x0000000000000000]              
	TArray< struct FChargeHitInfo >                    m_ChargeHitInfos;                                 		// 0x1D20 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FVector                                     m_fChargeStartLocation;                           		// 0x1D2C (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2815 );

		return pClassPointer;
	};

	void SetMeshDepthPriority ( unsigned char NewDepth );
	void eventUpdateIgnoreBlockingFlags ( );
	void SetSpectralState ( unsigned long ShouldBeOn );
	void eventResetPassiveStacks ( );
	void eventSetPassiveStacks ( unsigned char eDesiredPart, unsigned char bForceInstant );
	void eventSetUltState ( unsigned char NewState );
	void SetUltimateInactive ( );
	void eventPlayUltimateHitAnim ( unsigned long HitGod );
	void EndTween ( unsigned char endingTweenState, unsigned long bInterrupted );
	void BeginTween ( unsigned char newTweenState );
	void eventApplyPassiveStacks ( );
	void eventUpdatePassiveState ( );
	void eventAllowAttacksDuringTether ( );
	void RemoveTetherEffectGroups ( class ATgPawn* TargetPawn );
	void UpdateTetherChainComponents ( float DeltaSeconds );
	int eventGetTetheredPawnCount ( );
	void eventUpdateTetheredPawns ( );
	void eventSetBodyVisibility ( unsigned char eDesiredPart );
	void UpdateVisibleMesh ( float DeltaSeconds );
	void eventPopulateTetherList ( );
	void eventSetTargetingDevice ( class ATgDevice* Dev );
	void Tick ( float DeltaSeconds );
	bool loadfx ( );
	bool eventPostPawnSetup ( );
	void eventReplicatedEvent ( struct FName VarName );
	void eventPreDemoRewind ( );
	bool GetPassiveAuxMax ( float* nResult );
	bool GetPassiveAux ( float* nResult );
	bool GetPassiveInt1 ( int* nResult );
	void OnAttackDamagePropertyChange ( );
	class UTgSpecialFx* CreateTetherSpecialFX ( );
	class UTgStaticMeshComponent* CreateTetherMeshComponent ( );
	bool InitializePartLossSpecialFX ( );
	bool InitializePassiveMeshComponent ( );
	void RecalculateMaterial ( unsigned long bIsFriendlyWithLocalPawn, unsigned long bForce );
	void StartCharge ( class ATgDevice* Dev );
	void DeviceOnStopFire ( class ATgDevice* Dev, unsigned long WasInterrupted );
	void DeviceAdjustDamage ( class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage );
	void DeviceOnHit ( class ATgDevice* Dev, struct FImpactInfo* Impact );
	void DeviceOnFire ( class ATgDevice* Dev );
	void DeviceOnStartFire ( class ATgDevice* Dev );
	bool DeviceOverrideTargetingAim ( class ATgDevice* Dev, struct FAimData* Aim, TArray< struct FImpactInfo >* ImpactList );
};

UClass* ATgPawn_Osiris::pClassPointer = NULL;

// Class TgGame.TgPawn_Poseidon
// 0x0038 (0x1CA4 - 0x1C6C)
class ATgPawn_Poseidon : public ATgPawn_Character
{
public:
	unsigned long                                      s_bTridentActive : 1;                             		// 0x1C6C (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      s_bInHandSwapOnHold : 1;                          		// 0x1C6C (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      c_bLeftFootForward : 1;                           		// 0x1C6C (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      c_bFeetFxActive : 1;                              		// 0x1C6C (0x0004) [0x0000000000000000] [0x00000008] 
	TArray< class UTgDeviceFire* >                     s_TridentSplitDeviceModes;                        		// 0x1C70 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class ATgDevice*                                   s_NormalInHand;                                   		// 0x1C7C (0x0004) [0x0000000000000000]              
	class ATgDevice*                                   s_TridentInHand;                                  		// 0x1C80 (0x0004) [0x0000000000000000]              
	class ATgProj_Poseidon_TridentShot*                m_HittingTridentProjectile;                       		// 0x1C84 (0x0004) [0x0000000000000000]              
	class ATgDeployable_Poseidon_Surge*                m_HittingSurge;                                   		// 0x1C88 (0x0004) [0x0000000000000000]              
	class ATgDeployable_Poseidon_Whirlpool*            m_HittingWhirlpool;                               		// 0x1C8C (0x0004) [0x0000000000000000]              
	class ATgDeployable_Poseidon_Kraken*               m_HittingKraken;                                  		// 0x1C90 (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                c_FeetFx[ 0x2 ];                                  		// 0x1C94 (0x0008) [0x0000000000002000]              ( CPF_Transient )
	class USkelControlBase*                            c_FeetSkelController;                             		// 0x1C9C (0x0004) [0x0000000000000000]              
	class UTgEffectGroup*                              s_PassiveEffectGroup;                             		// 0x1CA0 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2816 );

		return pClassPointer;
	};

	void eventUpdateFeetFx ( );
	void eventTick ( float DeltaTime );
	void NotifyRightFootForward ( );
	void NotifyLeftFootForward ( );
	void CacheMainMeshReferences ( class UTgSkeletalMeshComponent* SkelComp );
	class UTgDeviceFire* GetTridentFireMode ( );
	void eventTideUpdated ( );
	bool eventPostPawnSetup ( );
	void eventOnRespawn ( );
	void StopTridentAttack ( unsigned long bForce );
	void StartTridentAttack ( class UTgDeviceFire* FireMode );
	void ReapplyLoadoutEffects ( );
	void ResetTideStack ( );
	bool InitializeFeetFX ( );
	float GetUIGroundSpeed ( );
	void SetSpawnEnergy ( );
	void OnPawnDied ( );
	bool DeviceOnCanDeviceFireNow ( class ATgDevice* Dev, unsigned char FireModeNum, unsigned long bDeviceFailLog, struct FAimData* Aim );
	void DeviceAdjustDamage ( class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage );
	bool DeviceOverrideTargetingAim ( class ATgDevice* Dev, struct FAimData* Aim, TArray< struct FImpactInfo >* ImpactList );
	void DeviceOnStopFire ( class ATgDevice* Dev, unsigned long bWasInterrupted );
	void DeviceOnFire ( class ATgDevice* Dev );
	void DeviceOnHit ( class ATgDevice* Dev, struct FImpactInfo* Impact );
};

UClass* ATgPawn_Poseidon::pClassPointer = NULL;

// Class TgGame.TgPawn_Ra
// 0x0030 (0x1C9C - 0x1C6C)
class ATgPawn_Ra : public ATgPawn_Character
{
public:
	class UTgMarkComponent*                            m_SpeedOfLightSelfMarks;                          		// 0x1C6C (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class UTgMarkComponent*                            m_DivineLightMarks;                               		// 0x1C70 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	TArray< class UTgDeviceFire* >                     m_DivineLightDetonationModes;                     		// 0x1C74 (0x000C) [0x0000000000500000]              ( CPF_NeedCtorLink )
	class UTgEffectGroup*                              m_DivineLightSlowEffectGroup;                     		// 0x1C80 (0x0004) [0x0000000000000000]              
	class UTgEffect*                                   m_DivineLightSlowEffect;                          		// 0x1C84 (0x0004) [0x0000000000000000]              
	class UTgEffectGroup*                              m_DivineLightBlindEffectGroup;                    		// 0x1C88 (0x0004) [0x0000000000000000]              
	class UTgEffect*                                   m_DivineLightBlindEffect;                         		// 0x1C8C (0x0004) [0x0000000000000000]              
	class UMaterialInstanceConstant*                   m_DivineLightGlowingMIC;                          		// 0x1C90 (0x0004) [0x0000000000000000]              
	float                                              m_DivineLightPercentageProgress;                  		// 0x1C94 (0x0004) [0x0000000000000000]              
	float                                              r_fPassiveDuration;                               		// 0x1C98 (0x0004) [0x0000000000000020]              ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2817 );

		return pClassPointer;
	};

	bool AreAnyOtherOffhandsLockingFiring ( class ATgDevice* CurrentDevice );
	bool GetPassiveInt1 ( int* nResult );
	void DeviceOnStopFire ( class ATgDevice* Dev, unsigned long WasInterrupted );
	void DeviceOnStartFire ( class ATgDevice* Dev );
	bool DeviceOverrideTargetingAim ( class ATgDevice* Dev, struct FAimData* Aim, TArray< struct FImpactInfo >* ImpactList );
	void ResetWeaponDuringDivineLight ( );
	void Tick ( float DeltaSeconds );
	void DeviceOnHit ( class ATgDevice* Dev, struct FImpactInfo* Impact );
	bool eventPostPawnSetup ( );
};

UClass* ATgPawn_Ra::pClassPointer = NULL;

// Class TgGame.TgPawn_Racer
// 0x0098 (0x1D04 - 0x1C6C)
class ATgPawn_Racer : public ATgPawn_Character
{
public:
	float                                              m_Mass;                                           		// 0x1C6C (0x0004) [0x0000000000000000]              
	struct FVector                                     m_Momentum;                                       		// 0x1C70 (0x000C) [0x0000000000000000]              
	float                                              m_WallCollisionTimer;                             		// 0x1C7C (0x0004) [0x0000000000000000]              
	unsigned char                                      r_Gear;                                           		// 0x1C80 (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      r_DriftState;                                     		// 0x1C81 (0x0001) [0x0000000000000020]              ( CPF_Net )
	struct FRacerAccelData                             m_FwdAccelRates[ 0x3 ];                           		// 0x1C84 (0x0018) [0x0000000000000000]              
	float                                              m_ReverseAccelRate;                               		// 0x1C9C (0x0004) [0x0000000000000000]              
	float                                              m_BrakeAccelRate;                                 		// 0x1CA0 (0x0004) [0x0000000000000000]              
	float                                              m_DragAccelRate;                                  		// 0x1CA4 (0x0004) [0x0000000000000000]              
	struct FRacerTurnRateData                          m_TurnRates[ 0x3 ];                               		// 0x1CA8 (0x0024) [0x0000000000000000]              
	float                                              m_TurnTimer;                                      		// 0x1CCC (0x0004) [0x0000000000000000]              
	float                                              m_DriftFacingRate;                                		// 0x1CD0 (0x0004) [0x0000000000000000]              
	float                                              m_BrakeAccumulator;                               		// 0x1CD4 (0x0004) [0x0000000000000000]              
	float                                              m_TurnFacingAngleOffsets[ 0x3 ];                  		// 0x1CD8 (0x000C) [0x0000000000000000]              
	unsigned long                                      r_IsDriftButtonPressed : 1;                       		// 0x1CE4 (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )
	unsigned long                                      r_BoostActive : 1;                                		// 0x1CE4 (0x0004) [0x0000000000000020] [0x00000002] ( CPF_Net )
	float                                              m_BoostAccelModifier;                             		// 0x1CE8 (0x0004) [0x0000000000000000]              
	int                                                r_LapsCompleted;                                  		// 0x1CEC (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_CurrentPlace;                                   		// 0x1CF0 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              m_LapDistance;                                    		// 0x1CF4 (0x0004) [0x0000000000000000]              
	float                                              m_TotalRaceDistance;                              		// 0x1CF8 (0x0004) [0x0000000000000000]              
	int                                                m_NumRacersAhead;                                 		// 0x1CFC (0x0004) [0x0000000000000000]              
	class ATgRacingCheckpoint*                         s_CurrentCheckpoint;                              		// 0x1D00 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2818 );

		return pClassPointer;
	};

	void DebugDump ( );
	void eventHitWall ( struct FVector HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp );
	void FaceRotation ( struct FRotator NewRotation, float DeltaTime );
	bool eventIsInTightRegularTurn ( );
	void Tick ( float DeltaSeconds );
	void UpdateDriftState ( );
	void TryActivateDrift ( );
	void ToggleDriftButton ( unsigned long IsOn );
	bool eventPostPawnSetup ( );
	void SetupCameraAndControlModules ( );
	void EffectGroupOnSetActive ( unsigned long bActive, unsigned long bRemoving, class UTgEffectGroup* effectGroup );
	void InitializeDefaultProps ( );
	void HandleWallCollision ( struct FVector HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp );
	bool GetPassiveAuxMax ( float* fResult );
	bool GetPassiveAux ( float* fResult );
	bool GetPassiveBool ( int* bResult );
	bool GetPassiveInt2 ( int* nResult );
	bool GetPassiveInt1 ( int* nResult );
};

UClass* ATgPawn_Racer::pClassPointer = NULL;

// Class TgGame.TgPawn_Raijin
// 0x00B8 (0x1D24 - 0x1C6C)
class ATgPawn_Raijin : public ATgPawn_Character
{
public:
	int                                                m_nBotInhandId;                                   		// 0x1C6C (0x0004) [0x0000000000000000]              
	int                                                m_nBotPassiveId;                                  		// 0x1C70 (0x0004) [0x0000000000000000]              
	int                                                m_nBotOffhand1Id;                                 		// 0x1C74 (0x0004) [0x0000000000000000]              
	int                                                m_nBotOffhand2Id;                                 		// 0x1C78 (0x0004) [0x0000000000000000]              
	int                                                m_nBotOffhand2SubId;                              		// 0x1C7C (0x0004) [0x0000000000000000]              
	int                                                m_nBotOffhand3Id;                                 		// 0x1C80 (0x0004) [0x0000000000000000]              
	int                                                m_nBotKotoDrumId;                                 		// 0x1C84 (0x0004) [0x0000000000000000]              
	int                                                m_nBotBeat1Id;                                    		// 0x1C88 (0x0004) [0x0000000000000000]              
	int                                                m_nBotBeat2Id;                                    		// 0x1C8C (0x0004) [0x0000000000000000]              
	int                                                m_nBotBeat3Id;                                    		// 0x1C90 (0x0004) [0x0000000000000000]              
	class ATgDevice*                                   r_dev_inhand;                                     		// 0x1C94 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgDevice*                                   s_dev_passive;                                    		// 0x1C98 (0x0004) [0x0000000000000000]              
	class ATgDevice_Raijin_Dev1*                       r_dev_offhand1;                                   		// 0x1C9C (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgDevice_Raijin_Dev2*                       r_dev_offhand2;                                   		// 0x1CA0 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgDevice_Raijin_Dev3*                       r_dev_offhand3;                                   		// 0x1CA4 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgDevice_Raijin_Dev4*                       r_dev_offhand4;                                   		// 0x1CA8 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgDevice_Raijin_KotoDrums*                  r_dev_kotodrums;                                  		// 0x1CAC (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgDevice*                                   r_dev_beat1;                                      		// 0x1CB0 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgDevice*                                   r_dev_beat2;                                      		// 0x1CB4 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgDevice*                                   r_dev_beat3;                                      		// 0x1CB8 (0x0004) [0x0000000000000020]              ( CPF_Net )
	unsigned long                                      r_bPassiveBuffActive : 1;                         		// 0x1CBC (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      r_bCachedPassiveBuffActive : 1;                   		// 0x1CBC (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      s_bBlockPassiveStacks : 1;                        		// 0x1CBC (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      r_bRaijuuBouncing : 1;                            		// 0x1CBC (0x0004) [0x0000000000000020] [0x00000008] ( CPF_Net )
	unsigned long                                      r_bRaijuuVisible : 1;                             		// 0x1CBC (0x0004) [0x0000000000000020] [0x00000010] ( CPF_Net )
	unsigned long                                      s_bTargetable : 1;                                		// 0x1CBC (0x0004) [0x0000000000000000] [0x00000020] 
	class UObject*                                     s_CachedPassiveDeviceModeReference;               		// 0x1CC0 (0x0004) [0x0000000000000000]              
	int                                                s_nCachedPassiveFiringInstance;                   		// 0x1CC4 (0x0004) [0x0000000000000000]              
	int                                                c_nPrevPassiveStacks;                             		// 0x1CC8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                r_nCurrentPassiveStacks;                          		// 0x1CCC (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                m_nMaxPassiveStacks;                              		// 0x1CD0 (0x0004) [0x0000000000000000]              
	TArray< class UTgSpecialFx* >                      c_PassiveSpecialFX;                               		// 0x1CD4 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	class UTgSpecialFx*                                c_ThunderCrashFX;                                 		// 0x1CE0 (0x0004) [0x0000000000000000]              
	class USkeletalMeshComponent*                      c_Raijuu;                                         		// 0x1CE4 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class UTgSpecialFx*                                c_RaijuuBellybuttonFX;                            		// 0x1CE8 (0x0004) [0x0000000000000000]              
	class UTgAnimNodeSlot*                             m_RaijuuFullBodyNode;                             		// 0x1CEC (0x0004) [0x0000000000000000]              
	float                                              m_fDesiredRaijuuScale;                            		// 0x1CF0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class AActor*                                      r_RaijuuBellyButtonTarget;                        		// 0x1CF4 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              r_fRemainingRaijuuBellyButtonTime;                		// 0x1CF8 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              m_fMaxRaijuuBellyButtonTime;                      		// 0x1CFC (0x0004) [0x0000000000000000]              
	TArray< class UTgDeviceFire* >                     m_RaijuuBounceModes;                              		// 0x1D00 (0x000C) [0x0000000000500000]              ( CPF_NeedCtorLink )
	class AActor*                                      m_RaijuuBounceTarget;                             		// 0x1D0C (0x0004) [0x0000000000000000]              
	int                                                m_nMaxRaijuuBounceCount;                          		// 0x1D10 (0x0004) [0x0000000000000000]              
	class UTgDeviceFire*                               s_RaijuuFiremode;                                 		// 0x1D14 (0x0004) [0x0000000000000000]              
	class ATgDeployable*                               m_Num3WarningDeployable;                          		// 0x1D18 (0x0004) [0x0000000000000000]              
	unsigned char                                      r_BeatSelect;                                     		// 0x1D1C (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      m_LastBeatSelect;                                 		// 0x1D1D (0x0001) [0x0000000000000000]              
	class ATgDevice_Raijin_KotoDrums_Beat*             m_BeatDevice;                                     		// 0x1D20 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2819 );

		return pClassPointer;
	};

	void OnRespawn ( );
	bool eventDied ( class AController* Killer, class UClass* dmgType, struct FVector HitLocation );
	void eventStopRaijuuBellybuttonFx ( );
	void eventPlayRaijuuBellybuttonFx ( );
	class AProjectile* eventSpawnRaijuuBouncingProjectile ( );
	void eventRaijuuEndBouncing ( );
	void eventRaijuuStartBouncing ( );
	void eventSetRaijuuVisibility ( unsigned long bVisible );
	void eventResetRaijuuTimers ( );
	void eventSetRaijuuBellyButtonTarget ( class AActor* Target );
	void SetBeatDevice ( class ATgDevice* Dev );
	void ServerSetBeatSelect ( unsigned char beatType );
	void eventSetTargetingDevice ( class ATgDevice* Dev );
	bool StartAction ( class ATgDevice* Dev, unsigned long bUpdateTimeStamp, unsigned char* failType );
	bool eventDeviceOverrideLockedDown ( class ATgDevice* Dev );
	void Tick ( float fDeltaSeconds );
	void StopFullBodyAnimation ( float BlendOutTime );
	bool eventPostPawnSetup ( );
	void CacheMainMeshReferences ( class UTgSkeletalMeshComponent* smcomp );
	void eventPostInitAnimTree ( class USkeletalMeshComponent* SkelComp );
	void eventReplicatedEvent ( struct FName VarName );
	void TryAutoSkillUp ( );
	bool ShouldAllowSkillUp ( unsigned long bIsAutoSkillUp );
	bool FindTeleportSpot ( struct FVector Extent, struct FVector* TeleportLocation );
	void PlayTeleportFx ( int nTeleportState, struct FVector vLoc );
	void UpdateRaijuuVisibility ( );
	void SetTargetable ( unsigned long targetable );
	void SetDeviceFlashing ( class ATgDevice* Dev, unsigned long bFlashing );
	void UpdatePassiveSpecialFX ( int nStacks );
	void ClearPassiveStacks ( );
	void IncrementPassiveStacks ( unsigned long bCanBeBuffed );
	bool GetPassiveAuxMax ( float* fResult );
	bool GetPassiveAux ( float* fResult );
	bool GetPassiveInt1 ( int* nResult );
	void ApplyPassiveBonusDamage ( struct FImpactInfo Impact );
	void DeviceAdjustDamage ( class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage );
	void DeviceOnDamaged ( struct FOnDamagedParams* Params );
	void DeviceOnStopFire ( class ATgDevice* Dev, unsigned long WasInterrupted );
	void DeviceOnStartFire ( class ATgDevice* Dev );
	bool DeviceOnCanDeviceFireNow ( class ATgDevice* Dev, unsigned char FireModeNum, unsigned long bDeviceFailLog, struct FAimData* Aim );
	bool PlayFullBodyAnim ( struct FName AnimName, float Rate, float BlendInTime, float BlendOutTime, unsigned long bLooping, unsigned long bOverride, unsigned long bBlendOutIfVelocityIsGreaterThanZero, unsigned long bHideInHandDevice );
	void AdjustMeshTranslation ( );
	void SwapToLiveMesh ( );
	void InitRaijuuMesh ( );
	bool InitializePassiveSpecialFX ( );
	bool InitializeRaijuuBellybuttonFX ( );
	void PostPawnSetupServer ( );
};

UClass* ATgPawn_Raijin::pClassPointer = NULL;

// Class TgGame.TgPawn_Raijin_PVE
// 0x0000 (0x1D24 - 0x1D24)
class ATgPawn_Raijin_PVE : public ATgPawn_Raijin
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2820 );

		return pClassPointer;
	};

};

UClass* ATgPawn_Raijin_PVE::pClassPointer = NULL;

// Class TgGame.TgPawn_Ram
// 0x008C (0x1CF8 - 0x1C6C)
class ATgPawn_Ram : public ATgPawn_Character
{
public:
	unsigned char                                      m_eCurrentInhandActiveMode;                       		// 0x1C6C (0x0001) [0x0000000000000000]              
	unsigned char                                      r_eUltimateState;                                 		// 0x1C6D (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      m_eLocalUltState;                                 		// 0x1C6E (0x0001) [0x0000000000000000]              
	unsigned char                                      c_eUltimatePosture;                               		// 0x1C6F (0x0001) [0x0000000000000000]              
	class ATgDevice_ActiveMode*                        r_InHandDevice;                                   		// 0x1C70 (0x0004) [0x0000000000000020]              ( CPF_Net )
	unsigned long                                      s_bNum1HasHit : 1;                                		// 0x1C74 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      r_bNum3BonusEffect : 1;                           		// 0x1C74 (0x0004) [0x0000000000000020] [0x00000002] ( CPF_Net )
	unsigned long                                      s_bNum3ArrowConsumed : 1;                         		// 0x1C74 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_bHasAdjustedCamera : 1;                         		// 0x1C74 (0x0004) [0x0000000000000000] [0x00000008] 
	struct FVector                                     s_ArrowLocation;                                  		// 0x1C78 (0x000C) [0x0000000000000000]              
	struct FRotator                                    s_ArrowRotation;                                  		// 0x1C84 (0x000C) [0x0000000000000000]              
	int                                                r_nUltimateAimPitch;                              		// 0x1C90 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                c_nUltimatePostureId;                             		// 0x1C94 (0x0004) [0x0000000000000000]              
	struct FName                                       c_UltimateEndAnimName;                            		// 0x1C98 (0x0008) [0x0000000000000000]              
	struct FName                                       c_UltimateDeathAnimName;                          		// 0x1CA0 (0x0008) [0x0000000000000000]              
	float                                              s_fUltimateTakeDownTime;                          		// 0x1CA8 (0x0004) [0x0000000000000000]              
	TArray< class UTgAnimBlendByFire* >                c_UltimateFireNodes;                              		// 0x1CAC (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UTgAnimNodeAimOffset* >              c_UltimateAimOffsets;                             		// 0x1CB8 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FName                                       c_UltimateFireNodeName;                           		// 0x1CC4 (0x0008) [0x0000000000000000]              
	class UTgSkeletalMeshComponent*                    m_UltPropMesh;                                    		// 0x1CCC (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	float                                              m_fSmoothEnergy;                                  		// 0x1CD0 (0x0004) [0x0000000000000000]              
	float                                              m_fSmoothEnergySpeed;                             		// 0x1CD4 (0x0004) [0x0000000000000000]              
	int                                                r_nQuiverAmmunitionCount;                         		// 0x1CD8 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class USkelControlBase*                            m_ArrowSkelControl[ 0x5 ];                        		// 0x1CDC (0x0014) [0x0000000000000000]              
	float                                              c_fRemainingAmmoReplenishTime;                    		// 0x1CF0 (0x0004) [0x0000000000000000]              
	float                                              s_fRamaHeightOnFire;                              		// 0x1CF4 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2821 );

		return pClassPointer;
	};

	bool IsInClassSpecificMovement ( );
	void ActivatePickupArrowFX ( );
	void DeactivatePickupArrowFX ( );
	void eventActivateArrowBones ( int desiredArrow );
	void eventEndNum3BonusEffect ( );
	void OnDeviceFormStartFire ( int nEquipSlot, float FireDuration, int nFireMode );
	void OnDeviceFormBuildup ( int nEquipSlot, float fBuildupTime );
	bool CannotJumpNow ( );
	void OnRespawn ( );
	bool IsInForcedConsoleRestrictedPitch ( );
	float ApplyPitchLimit ( float fPitch );
	void EndUltimateTakeDown ( );
	void eventUpdateUltimateState ( unsigned char NewState );
	bool IgnoreFaceRotationWithInterp ( );
	void eventChangeInhandActiveMode ( unsigned char newActiveMode );
	void UpdateQuiverAmmoReplenishTime ( float NewTime );
	void CacheMultiMeshAnimNodeReferences ( class UTgSkeletalMeshComponent* smcomp );
	void ClearMultiMeshAnimNodeReferences ( );
	void Tick ( float DeltaSeconds );
	void eventPostInitAnimTree ( class USkeletalMeshComponent* SkelComp );
	void eventReplicatedEvent ( struct FName VarName );
	void OnPostureChange ( );
	void RamBasicAttackFiring ( class ATgDevice* Dev );
	bool GetPassiveInt2 ( int* nResult );
	bool GetPassiveInt1 ( int* nResult );
	void UpdateQuiverStatus ( );
	void RecoverArrow ( );
	bool OverrideDistanceFadeRange ( );
	void CalcSmoothEnergy ( float fDelta );
	void SetSmoothEnergy ( float Delta );
	void SetSpawnEnergy ( );
	float GetSmoothEnergy ( );
	void RegainEnergyPool ( float fDelta );
	void PawnOnSpecialReset ( );
	void DeviceAdjustDamage ( class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage );
	void DeviceOnStopFire ( class ATgDevice* Dev, unsigned long bWasInterrupted );
	void DeviceOnHit ( class ATgDevice* Dev, struct FImpactInfo* Impact );
	bool DeviceOnCanDeviceCriticalStrike ( class ATgDevice* Dev, int nPropertyId, int nDamageType, struct FImpactInfo* Impact, float* fCritChance );
	void DeviceOnFire ( class ATgDevice* Dev );
	void DeviceOnStartFire ( class ATgDevice* Dev );
};

UClass* ATgPawn_Ram::pClassPointer = NULL;

// Class TgGame.TgPawn_Ratatoskr
// 0x00DC (0x1D48 - 0x1C6C)
class ATgPawn_Ratatoskr : public ATgPawn_Character
{
public:
	unsigned char                                      r_nHasAcorn[ 0x8 ];                               		// 0x1C6C (0x0008) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      r_nDartNoCooldownTicker;                          		// 0x1C74 (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      r_CurrentUltimateState;                           		// 0x1C75 (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      c_LocalUltimateState;                             		// 0x1C76 (0x0001) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      m_eUltTargetingPosture;                           		// 0x1C77 (0x0001) [0x0000000000000002]              ( CPF_Const )
	unsigned char                                      m_eUltFlyingPosture;                              		// 0x1C78 (0x0001) [0x0000000000000002]              ( CPF_Const )
	struct FLinearColor                                m_EmissiveBodyColors[ 0x8 ];                      		// 0x1C7C (0x0080) [0x0000000000000000]              
	unsigned long                                      s_bAppliedNotGrabSource : 1;                      		// 0x1CFC (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bIgnoreEndTweenLogic : 1;                       		// 0x1CFC (0x0004) [0x0000000000000000] [0x00000002] 
	class UTgDeviceFire*                               s_UltDamagingDeviceMode;                          		// 0x1D00 (0x0004) [0x0000000000000000]              
	int                                                m_nUltTargetingPostureId;                         		// 0x1D04 (0x0004) [0x0000000000000000]              
	class UClass*                                      m_UltTargetingControlModuleClass;                 		// 0x1D08 (0x0004) [0x0000000000000002]              ( CPF_Const )
	class UClass*                                      m_PreviousControlModuleClass;                     		// 0x1D0C (0x0004) [0x0000000000000000]              
	class UTgControlModule*                            m_UltTargetingControlModule;                      		// 0x1D10 (0x0004) [0x0000000000000000]              
	class UClass*                                      m_UltTargetingCameraModuleClass;                  		// 0x1D14 (0x0004) [0x0000000000000002]              ( CPF_Const )
	class UClass*                                      m_PreviousCameraModuleClass;                      		// 0x1D18 (0x0004) [0x0000000000000000]              
	class UTgCameraModule*                             m_UltTargetingCameraModule;                       		// 0x1D1C (0x0004) [0x0000000000000000]              
	class UClass*                                      m_UltTreeHoppingControlModuleClass;               		// 0x1D20 (0x0004) [0x0000000000000002]              ( CPF_Const )
	class UClass*                                      m_PreviousTreeHoppingControlModuleClass;          		// 0x1D24 (0x0004) [0x0000000000000000]              
	class UTgControlModule*                            m_UltTreeHoppingControlModule;                    		// 0x1D28 (0x0004) [0x0000000000000000]              
	int                                                m_nUltFlyngPostureId;                             		// 0x1D2C (0x0004) [0x0000000000000000]              
	TArray< class UTgAnimBlendByFire* >                m_UltFlyingFireNodes;                             		// 0x1D30 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FName                                       m_UltFlyingFireNodeName;                          		// 0x1D3C (0x0008) [0x0000000000000000]              
	class ATgDevice_Ratatoskr_UltimateShooter*         s_UltShooter;                                     		// 0x1D44 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2822 );

		return pClassPointer;
	};

	bool IsInClassSpecificMovement ( );
	void OnRespawn ( );
	void PlayNearDeathCleanup ( );
	void PlayDying ( class UClass* dmgType, struct FVector HitLoc );
	void UltimateTweenEnd ( unsigned long bInterrupted );
	void EndTween ( unsigned char endingTweenState, unsigned long bInterrupted );
	void BeginTween ( unsigned char newTweenState );
	void OnDeviceFormInterruptFire ( int nEquipSlot );
	void OnDeviceFormStopFire ( int nEquipSlot );
	void OnDeviceFormStartFire ( int nEquipSlot, float FireDuration, int nFireMode );
	void OnDeviceFormBuildup ( int nEquipSlot, float fBuildupTime );
	void eventUpdateUltimateState ( unsigned char NewState );
	void ClientFixUltimateState ( unsigned char NewState );
	void eventExitUltTargeting ( );
	void eventEnterUltTargeting ( );
	void OnRightMousePressed ( );
	void eventInterruptRecallFromDamage ( );
	void eventInterruptAcornPurchase ( );
	void Tick ( float DeltaSeconds );
	void OnDartNoCooldown ( );
	void eventPostDemoRewind ( );
	void CacheMultiMeshAnimNodeReferences ( class UTgSkeletalMeshComponent* smcomp );
	void ClearMultiMeshAnimNodeReferences ( );
	float ApplyPitchLimit ( float fPitch );
	void OnAcornHealOver ( );
	void eventOnAcornItemProcced ( );
	void eventReplicatedEvent ( struct FName VarName );
	void SetStripeColor ( unsigned char AcornType );
	void OnAcornChanged ( unsigned long bNoRecalc );
	bool HasYellowAcorn ( );
	bool HasBlueAcorn ( );
	bool HasWhiteAcorn ( );
	bool HasAcorn ( unsigned char AcornType );
	float GetSmoothEnergy ( );
	void RecalculateMaterial ( unsigned long bIsFriendlyWithLocalPawn, unsigned long bForce );
	int GetCustomParticleSystemFilter ( );
};

UClass* ATgPawn_Ratatoskr::pClassPointer = NULL;

// Class TgGame.TgPawn_RatatoskrV2
// 0x0000 (0x1D48 - 0x1D48)
class ATgPawn_RatatoskrV2 : public ATgPawn_Ratatoskr
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2823 );

		return pClassPointer;
	};

	bool AreAnyOtherOffhandsLockingFiring ( class ATgDevice* CurrentDevice );
	void DeviceOnHit ( class ATgDevice* Dev, struct FImpactInfo* Impact );
};

UClass* ATgPawn_RatatoskrV2::pClassPointer = NULL;

// Class TgGame.TgPawn_Ravana
// 0x0040 (0x1CAC - 0x1C6C)
class ATgPawn_Ravana : public ATgPawn_Character
{
public:
	int                                                m_nPassiveCategory;                               		// 0x1C6C (0x0004) [0x0000000000000000]              
	int                                                r_nPassiveCombo;                                  		// 0x1C70 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                m_nPassiveCombosMax;                              		// 0x1C74 (0x0004) [0x0000000000000002]              ( CPF_Const )
	int                                                r_nPassiveStacks;                                 		// 0x1C78 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                m_nPassiveStacksMax;                              		// 0x1C7C (0x0004) [0x0000000000000000]              
	float                                              r_fPassiveDuration;                               		// 0x1C80 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              m_fPassiveDurationMax;                            		// 0x1C84 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bPassiveMaxsUpdated : 1;                        		// 0x1C88 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      r_bDodgeIsActive : 1;                             		// 0x1C88 (0x0004) [0x0000000000000020] [0x00000002] ( CPF_Net )
	unsigned long                                      m_bActivatedPunch : 1;                            		// 0x1C88 (0x0004) [0x0000000000000000] [0x00000004] 
	int                                                m_nMaxMinionHeals;                                		// 0x1C8C (0x0004) [0x0000000000000000]              
	int                                                m_nMaxPlayerHeals;                                		// 0x1C90 (0x0004) [0x0000000000000000]              
	int                                                m_nUltCategoryEnemy;                              		// 0x1C94 (0x0004) [0x0000000000000000]              
	int                                                m_nUltCategorySelf;                               		// 0x1C98 (0x0004) [0x0000000000000000]              
	float                                              m_fPunchWindupTime;                               		// 0x1C9C (0x0004) [0x0000000000000002]              ( CPF_Const )
	int                                                m_nTweenTimerFxId;                                		// 0x1CA0 (0x0004) [0x0000000000000002]              ( CPF_Const )
	class UTgSpecialFx*                                c_TweenTimerFx;                                   		// 0x1CA4 (0x0004) [0x0000000000000000]              
	class ATgSkeletalMeshActor*                        c_TweenTimerMesh;                                 		// 0x1CA8 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2824 );

		return pClassPointer;
	};

	float eventShadowFistHealingScaling ( unsigned long isPlayer );
	void eventResetShadowFistHeals ( int minionHeals, int playerHeals );
	void ActivatePunch ( );
	void EndTween ( unsigned char endingTweenState, unsigned long bInterrupted );
	void BeginTween ( unsigned char newTweenState );
	void Tick ( float DeltaSeconds );
	bool PostPawnSetup ( );
	bool InitializeUltFx ( );
	void OnPostureChange ( );
	void OnAttackDamagePropertyChange ( );
	bool GetPassiveAuxMax ( float* fResult );
	bool GetPassiveAux ( float* fResult );
	bool GetPassiveInt1 ( int* nResult );
	bool PawnCanDisplayImmuneMessage ( );
	void PawnOnDamageMitigation ( class ATgPawn* attacker, class UTgEffectGroup* eg, int nPropertyId, float* fDamage );
	void EffectGroupOnSetActive ( unsigned long bActive, unsigned long bRemoving, class UTgEffectGroup* effectGroup );
	void DeviceOnDamaged ( struct FOnDamagedParams* Params );
	void DeviceAdjustDamage ( class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage );
	void DeviceOnStopFire ( class ATgDevice* Dev, unsigned long WasInterrupted );
	void DeviceOnStartFire ( class ATgDevice* Dev );
};

UClass* ATgPawn_Ravana::pClassPointer = NULL;

// Class TgGame.TgPawn_Scylla
// 0x0078 (0x1CE4 - 0x1C6C)
class ATgPawn_Scylla : public ATgPawn_Character
{
public:
	unsigned char                                      m_bAbilityAtMaxRank[ 0x4 ];                       		// 0x1C6C (0x0004) [0x0000000000000000]              
	unsigned char                                      r_eUltimateState;                                 		// 0x1C70 (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      m_eLocalUltState;                                 		// 0x1C71 (0x0001) [0x0000000000000000]              
	unsigned char                                      c_eUltimatePosture;                               		// 0x1C72 (0x0001) [0x0000000000000000]              
	class UTgSkeletalMeshComponent*                    c_TentacleBuddy;                                  		// 0x1C74 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class UTgAnimNodeSlot*                             c_TentacleAnimSlot;                               		// 0x1C78 (0x0004) [0x0000000000000000]              
	int                                                r_nTentacleBuddyTicker;                           		// 0x1C7C (0x0004) [0x0000000000000020]              ( CPF_Net )
	unsigned long                                      r_bPreTeleportFxActive : 1;                       		// 0x1C80 (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )
	unsigned long                                      c_bPreTeleportFxActive : 1;                       		// 0x1C80 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      c_bTentaclesWereActive : 1;                       		// 0x1C80 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      c_bTentacleOverlaysWereActive : 1;                		// 0x1C80 (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      c_bFlamesWereActive : 1;                          		// 0x1C80 (0x0004) [0x0000000000000000] [0x00000010] 
	int                                                c_nUltimatePostureId;                             		// 0x1C84 (0x0004) [0x0000000000000000]              
	struct FName                                       c_UltimateEndAnimName;                            		// 0x1C88 (0x0008) [0x0000000000000000]              
	struct FName                                       c_UltimateDeathAnimName;                          		// 0x1C90 (0x0008) [0x0000000000000000]              
	float                                              s_fUltimateTakeDownTime;                          		// 0x1C98 (0x0004) [0x0000000000000000]              
	int                                                r_nUltGodKillTrigger;                             		// 0x1C9C (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              s_fUltGodKillMinDelay;                            		// 0x1CA0 (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                c_GodKillFx;                                      		// 0x1CA4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FName                                       c_GodKillAnimName;                                		// 0x1CA8 (0x0008) [0x0000000000000000]              
	TArray< class UTgAnimNodeSlot* >                   c_GodKillAnimSlots;                               		// 0x1CB0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UAnimNodeSequence* >                 c_TentaclesActive;                                		// 0x1CBC (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UAnimNodeSequence* >                 c_TentacleOverlaysActive;                         		// 0x1CC8 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UAnimNodeSequence* >                 c_TentacleFlamesActive;                           		// 0x1CD4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class UTgSkeletalMeshComponent*                    c_TentacleMeshComponent;                          		// 0x1CE0 (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2825 );

		return pClassPointer;
	};

	void PlayNearDeathCleanup ( );
	void PlayDying ( class UClass* dmgType, struct FVector HitLoc );
	void OnUltKillGod ( );
	void UltKillGodDelay ( );
	bool IgnoreFaceRotationWithInterp ( );
	void OnDeviceFormStartFire ( int nEquipSlot, float FireDuration, int nFireMode );
	void OnDeviceFormBuildup ( int nEquipSlot, float fBuildupTime );
	void eventTriggerCobraStrike ( struct FVector EndTrace );
	float BeginOffhand3Tween ( struct FVector TweenLocation, int MovementType );
	void EndTween ( unsigned char endingTweenState, unsigned long bInterrupted );
	void BeginTween ( unsigned char newTweenState );
	void TentacleTeleplort ( float fRate );
	void ToggleSentinelFx ( unsigned long bEnable );
	bool CannotJumpNow ( );
	void EndUltimateTakeDown ( );
	void eventUpdateUltimateState ( unsigned char NewState );
	void eventSetTargetingDevice ( class ATgDevice* Dev );
	void OnRespawn ( );
	void eventPostInitAnimTree ( class USkeletalMeshComponent* SkelComp );
	void CacheMultiMeshAnimNodeReferences ( class UTgSkeletalMeshComponent* smcomp );
	void ClearMultiMeshAnimNodeReferences ( );
	void CacheMainMeshReferences ( class UTgSkeletalMeshComponent* smcomp );
	void eventOnAnimEnd ( class UAnimNodeSequence* SeqNode, float PlayTime, float ExcessTime );
	bool PreTeleport ( class ATeleporter* InTeleporter );
	void eventPreDemoRewind ( );
	bool eventPostPawnSetup ( );
	void eventReplicatedEvent ( struct FName VarName );
	void SetMeshVectorValue ( struct FName ScalarParam, struct FLinearColor* ColorValue );
	void SetMeshScalarValue ( struct FName ScalarParam, float ScalarValue );
	void TentacleBuddyOn ( );
	bool InitializeTentacleBuddy ( );
	void FlashStartFire ( int nDeviceInstanceId, int nFireModeNum, float RefireTime, class AActor* Target );
	void FlashStopFire ( int nDeviceInstanceId, int nFireModeNum );
	void FlashBuildUp ( int nDeviceInstanceId, int nFireModeNum, int nEquipSlot, int nSocketIndex, float fBuildupTime );
	void OnPostureChange ( );
	void PlayTeleportFx ( int nTeleportState, struct FVector vLoc );
	void SetSpawnEnergy ( );
	void PostPawnSetupServer ( );
	bool DeviceOnCanDeviceFireNow ( class ATgDevice* Dev, unsigned char FireModeNum, unsigned long bDeviceFailLog, struct FAimData* Aim );
	void DeviceOnSetFireMode ( class ATgDevice* Dev );
	bool CalcOffhand3TweenLocation ( class ATgPawn* Target, unsigned long bFindValidLocation, struct FVector* TweenLocation );
	void RemoveTentaclesWeights ( class UAnimNodeSequence* SeqNode );
	void AddTentaclesWeights ( class UAnimNodeSequence* SeqNode, unsigned long bActive, unsigned long bOverlayActive, unsigned long bFlamesActive );
	bool ShouldShowTentaclesThisTick ( );
	void SetMeshVisibility ( unsigned long bVisible );
	void OnMeshSwapped ( );
};

UClass* ATgPawn_Scylla::pClassPointer = NULL;

// Class TgGame.TgPawn_Serqet
// 0x006C (0x1CD8 - 0x1C6C)
class ATgPawn_Serqet : public ATgPawn_Character
{
public:
	unsigned char                                      m_ePassivePosture;                                		// 0x1C6C (0x0001) [0x0000000000000000]              
	unsigned char                                      r_eDeathBaneCharge;                               		// 0x1C6D (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      r_nTriggerEndUltimateAnimFailSafe;                		// 0x1C6E (0x0001) [0x0000000000000020]              ( CPF_Net )
	struct FName                                       m_PassiveLeapNodeName;                            		// 0x1C70 (0x0008) [0x0000000000000000]              
	TArray< class UTgAnimBlendByFire* >                m_LeapFireNodes;                                  		// 0x1C78 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UTgAnimSequenceChain* >              m_DeathBaneChainNodes;                            		// 0x1C84 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UTgAnimNodeFitToDuration* >          m_DeathBaneRateNodes;                             		// 0x1C90 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                m_nDeathBaneFireIndex;                            		// 0x1C9C (0x0004) [0x0000000000000000]              
	struct FName                                       m_DeathBaneChainNodeName;                         		// 0x1CA0 (0x0008) [0x0000000000000000]              
	struct FName                                       m_DeathBaneRateNodeName;                          		// 0x1CA8 (0x0008) [0x0000000000000000]              
	int                                                r_nDeathBaneForwardYaw;                           		// 0x1CB0 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                m_nDeathBaneChargeYaw;                            		// 0x1CB4 (0x0004) [0x0000000000000000]              
	float                                              r_fDeathBaneChargeRange;                          		// 0x1CB8 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              r_fDeathBaneChargeSpeed;                          		// 0x1CBC (0x0004) [0x0000000000000020]              ( CPF_Net )
	struct FVector                                     r_vDeathBaneChargeStartLocation;                  		// 0x1CC0 (0x000C) [0x0000000000000020]              ( CPF_Net )
	TArray< class UTgAnimBlendBySerqetUltimate* >      m_UltimateBlendNodes;                             		// 0x1CCC (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2826 );

		return pClassPointer;
	};

	bool eventVerifyChargeHit ( struct FVector HitLocation, struct FVector HitNormal, struct FVector TargetLocation, class AActor* Other );
	void eventEndPhysNewCharge ( unsigned long bInterrupted );
	void eventStartPhysNewCharge ( unsigned char newChargeType, struct FRotator InitialDirection, struct FVector InitialLocation, float fChargeSpeed, float fChargeRange, unsigned long bIngoreHumanoidBlocking, int NewMoveState );
	void OnDeviceFormInterruptFire ( int nEquipSlot );
	void OnDeviceFormStopFire ( int nEquipSlot );
	void OnDeviceFormStartFire ( int nEquipSlot, float FireDuration, int nFireMode );
	void OnDeviceFormBuildup ( int nEquipSlot, float fBuildupTime );
	void EndUltimateAnimFailSafe ( );
	void FaceRotation ( struct FRotator NewRotation, float DeltaTime );
	void LastBreathGrabEnd ( );
	void EndGrab ( unsigned char endingGrabState, unsigned long bInterrupted );
	void BeginGrab ( unsigned char newGrabState );
	void EndTween ( unsigned char endingTweenState, unsigned long bInterrupted );
	void BeginTween ( unsigned char newTweenState );
	void CacheMultiMeshAnimNodeReferences ( class UTgSkeletalMeshComponent* smcomp );
	void ClearMultiMeshAnimNodeReferences ( );
	void eventReplicatedEvent ( struct FName VarName );
	struct FRotator TweenRelRotation ( float fDeltaSeconds, struct FRotator currRel, struct FRotator targetRel );
	bool DeviceOnCanDeviceCriticalStrike ( class ATgDevice* Dev, int nPropertyId, int nDamageType, struct FImpactInfo* Impact, float* fCritChance );
	void PlayTeleportFx ( int nTeleportState, struct FVector vLoc );
};

UClass* ATgPawn_Serqet::pClassPointer = NULL;

// Class TgGame.TgPawn_Skadi
// 0x0004 (0x1C70 - 0x1C6C)
class ATgPawn_Skadi : public ATgPawn_Character
{
public:
	class ATgPawn_Kaldr*                               r_Kaldr;                                          		// 0x1C6C (0x0004) [0x0000000000000020]              ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2827 );

		return pClassPointer;
	};

	void eventSetTargetingDevice ( class ATgDevice* Dev );
	bool eventDeviceOverrideLockedDown ( class ATgDevice* Dev );
	void eventEnterCombat ( class AActor* aInstigator, class AActor* ATarget, float fLength );
	void PlayDyingEffects ( );
	void OnRespawn ( );
	bool GetPassiveString ( struct FString* sResult );
	bool GetPassiveInt2 ( int* nResult );
	bool GetPassiveInt1 ( int* nResult );
	bool GetPassiveBool ( int* bResult );
	bool GetPassiveAuxMax ( float* fResult );
	bool GetPassiveAux ( float* fResult );
	void DespawnPet ( );
	void SpawnPet ( );
	void OnPawnDied ( );
	void PostPawnSetupServer ( );
	void EffectGroupOnSetActive ( unsigned long bActive, unsigned long bRemoving, class UTgEffectGroup* effectGroup );
	void DeviceOnHit ( class ATgDevice* Dev, struct FImpactInfo* Impact );
	bool DeviceOnCanDeviceFireNow ( class ATgDevice* Dev, unsigned char FireModeNum, unsigned long bDeviceFailLog, struct FAimData* Aim );
};

UClass* ATgPawn_Skadi::pClassPointer = NULL;

// Class TgGame.TgPawn_Sobek
// 0x00B0 (0x1D1C - 0x1C6C)
class ATgPawn_Sobek : public ATgPawn_Character
{
public:
	class UTgSkeletalMeshComponent*                    c_PassiveArmorMeshComponent;                      		// 0x1C6C (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )
	class UMaterialInstanceConstant*                   c_PassiveArmorMIC;                                		// 0x1C70 (0x0004) [0x0000000000000000]              
	float                                              c_PassiveArmorOpacity;                            		// 0x1C74 (0x0004) [0x0000000000000000]              
	float                                              r_fPassiveDuration;                               		// 0x1C78 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nPassiveStacks;                                 		// 0x1C7C (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgCollisionProxy_Cylinder*                  m_RushCollisionProxy;                             		// 0x1C80 (0x0004) [0x0000000000000000]              
	class ATgPawn*                                     TargetToThrow;                                    		// 0x1C84 (0x0004) [0x0000000000000000]              
	float                                              PercentageOfPoolDamage;                           		// 0x1C88 (0x0004) [0x0000000000000000]              
	TArray< class UTgAnimNodeSobekGrab* >              c_GrabBlendNodes;                                 		// 0x1C8C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class UTgEffectGroup*                              m_ThrowEffectGroup;                               		// 0x1C98 (0x0004) [0x0000000000000000]              
	int                                                r_GrabNotify;                                     		// 0x1C9C (0x0004) [0x0000000000000020]              ( CPF_Net )
	TArray< class AActor* >                            m_SickeningStrikeTargetsHit;                      		// 0x1CA0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FVector                                     r_vSickeningStrikeLocation;                       		// 0x1CAC (0x000C) [0x0000000000000020]              ( CPF_Net )
	struct FRotator                                    r_rSickeningStrikeRotation;                       		// 0x1CB8 (0x000C) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nSickeningStrikeTicker;                         		// 0x1CC4 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgCollisionProxy_Cylinder*                  m_TailSpinCollisionProxy;                         		// 0x1CC8 (0x0004) [0x0000000000000000]              
	TArray< class AActor* >                            m_ActorsAffectedByTailSpin;                       		// 0x1CCC (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class UTgSpecialFx*                                c_TailWhipFX;                                     		// 0x1CD8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class ATgCollisionProxy_Cylinder*                  m_PoolCollisionProxy;                             		// 0x1CDC (0x0004) [0x0000000000000000]              
	TArray< class AActor* >                            m_ActorsAffectedByPool;                           		// 0x1CE0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UTgAnimNodeSobekPool* >              c_PoolBlendNodes;                                 		// 0x1CEC (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class UMeshComponent*                              c_PoolMeshComponent;                              		// 0x1CF8 (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )
	class UTgSkeletalMeshComponent*                    c_PoolCrocodilesMeshComponents[ 0x4 ];            		// 0x1CFC (0x0010) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )
	class UMaterialInstanceConstant*                   c_PoolMIC;                                        		// 0x1D0C (0x0004) [0x0000000000000000]              
	unsigned long                                      c_PoolIsFiring : 1;                               		// 0x1D10 (0x0004) [0x0000000000000000] [0x00000001] 
	float                                              c_PoolFiringProgress;                             		// 0x1D14 (0x0004) [0x0000000000000000]              
	class UTgDeviceFire*                               PoolProtectionsMode;                              		// 0x1D18 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2828 );

		return pClassPointer;
	};

	void eventRemovePoolProtections ( );
	void OnThrowEnd ( );
	void StartThrow ( );
	void eventTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void eventRemovePoolSlow ( class AActor* Other );
	void ApplyPoolSlow ( class AActor* Other );
	void eventPoolCollisionProxyOnUntouch ( class AActor* Other );
	void eventPoolCollisionProxyOnTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void eventTailSpinCollisionProxyOnTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void eventRushCollisionProxyOnTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void OnDeviceFormStopFire ( int nEquipSlot );
	void OnDeviceFormInterruptFire ( int nEquipSlot );
	void OnDeviceFormFire ( int nEquipSlot );
	void OnDeviceFormStartFire ( int nEquipSlot, float FireDuration, int nFireMode );
	void DetachCrocodiles ( );
	void DetachPool ( );
	void Tick ( float DeltaTime );
	bool eventPostPawnSetup ( );
	void eventPostInitAnimTree ( class USkeletalMeshComponent* SkelComp );
	void PlayTailWhipFX ( );
	void eventReplicatedEvent ( struct FName VarName );
	void OnGrabNotify ( );
	bool CannotJumpNow ( );
	bool eventCanBePulled ( );
	bool GetPassiveAuxMax ( float* fResult );
	bool GetPassiveAux ( float* fResult );
	bool GetPassiveInt1 ( int* nResult );
	void SetSpawnEnergy ( );
	void LoadAndPlaySickeningStrikeMesh ( struct FVector vLocation, struct FRotator rRotation );
	void OnUtilityPowerChange ( );
	void ApplyPoolHit ( );
	void DeviceOnHit ( class ATgDevice* Dev, struct FImpactInfo* Impact );
	void DeviceOnStopFire ( class ATgDevice* Dev, unsigned long WasInterrupted );
	void DeviceAdjustDamage ( class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage );
	void DeviceOnFire ( class ATgDevice* Dev );
	void DeviceOnStartFire ( class ATgDevice* Dev );
	bool DeviceOverrideTargetingAim ( class ATgDevice* Dev, struct FAimData* Aim, TArray< struct FImpactInfo >* ImpactList );
	bool DeviceOnCanDeviceFireNow ( class ATgDevice* Dev, unsigned char FireModeNum, unsigned long bDeviceFailLog, struct FAimData* Aim );
	void DeviceOnSetFireMode ( class ATgDevice* Dev );
	bool InitializeCrocodileMeshComponents ( );
	bool InitializeTailWhipFX ( );
	bool InitializeThrowEffectGroup ( );
	bool InitializePassiveArmorMeshComponent ( );
	void PostPawnSetupServer ( );
};

UClass* ATgPawn_Sobek::pClassPointer = NULL;

// Class TgGame.TgPawn_Sol
// 0x0048 (0x1CB4 - 0x1C6C)
class ATgPawn_Sol : public ATgPawn_Character
{
public:
	unsigned char                                      r_eIsUnstable;                                    		// 0x1C6C (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      c_eLocalIsUnstable;                               		// 0x1C6D (0x0001) [0x0000000000000000]              
	unsigned char                                      r_eCurrentUltState;                               		// 0x1C6E (0x0001) [0x0000000000000020]              ( CPF_Net )
	TArray< int >                                      m_UnStableCannotBlockList;                        		// 0x1C70 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	unsigned long                                      r_bLeapingBack : 1;                               		// 0x1C7C (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )
	unsigned long                                      r_bDashLockingInput : 1;                          		// 0x1C7C (0x0004) [0x0000000000000020] [0x00000002] ( CPF_Net )
	unsigned long                                      r_bIsDisapparated : 1;                            		// 0x1C7C (0x0004) [0x0000000000000020] [0x00000004] ( CPF_Net )
	unsigned long                                      r_bNextPulse : 1;                                 		// 0x1C7C (0x0004) [0x0000000000000020] [0x00000008] ( CPF_Net )
	unsigned long                                      r_bInHandStimmed : 1;                             		// 0x1C7C (0x0004) [0x0000000000000020] [0x00000010] ( CPF_Net )
	unsigned long                                      r_bIsAutoAttacking : 1;                           		// 0x1C7C (0x0004) [0x0000000000000020] [0x00000020] ( CPF_Net )
	unsigned long                                      s_bDidTriggerPassiveAudio : 1;                    		// 0x1C7C (0x0004) [0x0000000000000000] [0x00000040] 
	unsigned long                                      r_bDev2InHand : 1;                                		// 0x1C7C (0x0004) [0x0000000000000020] [0x00000080] ( CPF_Net )
	struct FVector                                     m_vLeapbackLocation;                              		// 0x1C80 (0x000C) [0x0000000000000000]              
	class UTgTrailComponent_Sol_Passive*               s_TrailComp;                                      		// 0x1C8C (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	int                                                m_nUnstableGroupCategory;                         		// 0x1C90 (0x0004) [0x0000000000000000]              
	int                                                c_DisapparatedPostureId;                          		// 0x1C94 (0x0004) [0x0000000000000000]              
	class ATgDevice_Sol_Dev4*                          s_UltShooter;                                     		// 0x1C98 (0x0004) [0x0000000000000000]              
	class ATgDevice_Sol_2Basic*                        s_Dev2InHand;                                     		// 0x1C9C (0x0004) [0x0000000000000000]              
	class ATgDevice_Sol_BasicAttack*                   s_DefaultInHand;                                  		// 0x1CA0 (0x0004) [0x0000000000000000]              
	int                                                m_nDisapparateId;                                 		// 0x1CA4 (0x0004) [0x0000000000000000]              
	float                                              r_fTrailDuration;                                 		// 0x1CA8 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              m_fRemainingTrail;                                		// 0x1CAC (0x0004) [0x0000000000000000]              
	int                                                r_nPassiveAudioCueCount;                          		// 0x1CB0 (0x0004) [0x0000000000000020]              ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2829 );

		return pClassPointer;
	};

	void ServerOnRightMousePressed ( );
	void OnRightMousePressed ( );
	void eventSetTargetingDevice ( class ATgDevice* Dev );
	void eventUpdateIgnoreBlockingFlags ( unsigned long ShouldIgnore );
	bool eventFindTrailComponent ( );
	void eventIgniteTrail ( class AActor* IgnitePoint );
	bool eventShouldProjectilePulse ( );
	bool eventShouldTrail ( );
	void CleanUpOnDeath ( );
	void PlayNearDeathCleanup ( );
	void PlayDying ( class UClass* dmgType, struct FVector HitLoc );
	void Tick ( float DeltaSeconds );
	void EndTween ( unsigned char endingTweenState, unsigned long bInterrupted );
	void BeginTween ( unsigned char newTweenState );
	void OnTeleportNotify ( class AActor* TeleportingActor );
	void eventUpdateDashInputLock ( unsigned long IsLocked );
	void UpdateUltState ( unsigned char NewUltState );
	void eventToggleInstability ( unsigned char NewState );
	void eventToggleAutoAttacking ( unsigned long AutoAttacking );
	void eventToggleStimFx ( unsigned long IsStimmed );
	void eventUpdateTrailDuration ( float Duration );
	void eventReplicatedEvent ( struct FName VarName );
	void TriggerInfrequentUnstableFX ( );
	void ForceInstabilityToZero ( );
	bool IsPartiallyUnstable ( );
	void ClearPersistantDamage ( );
	bool IsCoolingOff ( );
	void SetInHandByPassive ( );
	void ActivateDev2Basic ( );
	void EffectGroupOnApplied ( class UTgEffectGroup* effectGroup, unsigned long bInterval );
	void EffectGroupOnSetActive ( unsigned long bActive, unsigned long bRemoving, class UTgEffectGroup* effectGroup );
	void RegainEnergyPool ( float fDelta );
	void RegainPools ( float fDelta );
	void SetProperty ( int nPropIndex, float fNewValue );
	void PlayTeleportFx ( int nTeleportState, struct FVector vLoc );
	void DeviceOnHit ( class ATgDevice* Dev, struct FImpactInfo* Impact );
	void DeviceOnStopFire ( class ATgDevice* Dev, unsigned long WasInterrupted );
	void DeviceOnFire ( class ATgDevice* Dev );
	void DeviceOnStartFire ( class ATgDevice* Dev );
	bool DeviceOnCanDeviceFireNow ( class ATgDevice* Dev, unsigned char FireModeNum, unsigned long bDeviceFailLog, struct FAimData* Aim );
	bool ShouldPawnMeshBeHiddenThisTick ( );
};

UClass* ATgPawn_Sol::pClassPointer = NULL;

// Class TgGame.TgPawn_SunWukong
// 0x009C (0x1D08 - 0x1C6C)
class ATgPawn_SunWukong : public ATgPawn_Character
{
public:
	unsigned long                                      m_bPassiveIgnoreHealthChange : 1;                 		// 0x1C6C (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	unsigned long                                      m_bTransformInProgress : 1;                       		// 0x1C6C (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      r_bTransformPouncing : 1;                         		// 0x1C6C (0x0004) [0x0000000000000020] [0x00000004] ( CPF_Net )
	unsigned long                                      m_bUltimateHasFired : 1;                          		// 0x1C6C (0x0004) [0x0000000000000000] [0x00000008] 
	class ATgDevice*                                   s_NormalInHand;                                   		// 0x1C70 (0x0004) [0x0000000000000000]              
	unsigned char                                      r_CurrentTransformState;                          		// 0x1C74 (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      c_PrevTransformState;                             		// 0x1C75 (0x0001) [0x0000000000000000]              
	unsigned char                                      c_LocalTransformState;                            		// 0x1C76 (0x0001) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      r_nOxHitTicker[ 0x2 ];                            		// 0x1C77 (0x0002) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      c_nLocalOxHitTicker[ 0x2 ];                       		// 0x1C79 (0x0002) [0x0000000000000000]              
	unsigned char                                      r_CurrentUltimateState;                           		// 0x1C7B (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      c_LocalUltimateState;                             		// 0x1C7C (0x0001) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      c_eUltimatePosture;                               		// 0x1C7D (0x0001) [0x0000000000000000]              
	class ATgDevice_SunWukong_Transform*               r_TransformDevices[ 0x4 ];                        		// 0x1C80 (0x0010) [0x0000000000000020]              ( CPF_Net )
	struct FName                                       c_TigerPounceAnimName;                            		// 0x1C90 (0x0008) [0x0000000000000000]              
	float                                              m_fTransformPounceRecoverTime;                    		// 0x1C98 (0x0004) [0x0000000000000002]              ( CPF_Const )
	class UTgEffectGroup*                              s_TransformPouceRoot;                             		// 0x1C9C (0x0004) [0x0000000000000000]              
	class UTgAnimNodeSlot*                             c_PounceSlot;                                     		// 0x1CA0 (0x0004) [0x0000000000000000]              
	struct FName                                       m_OxHitAnimName[ 0x2 ];                           		// 0x1CA4 (0x0010) [0x0000000000000000]              
	class UTgAnimNodeSlot*                             c_OxHitSlot;                                      		// 0x1CB4 (0x0004) [0x0000000000000000]              
	TArray< class UTgAnimNodeAimOffset* >              c_TransformAimOffsets;                            		// 0x1CB8 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                r_nTransformYawOffset;                            		// 0x1CC4 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              m_fTransformAimOffsetMax;                         		// 0x1CC8 (0x0004) [0x0000000000000002]              ( CPF_Const )
	int                                                c_nUltimatePostureId;                             		// 0x1CCC (0x0004) [0x0000000000000000]              
	struct FName                                       c_UltimateAttackAnimName;                         		// 0x1CD0 (0x0008) [0x0000000000000000]              
	struct FName                                       c_UltimateCancelAnimName;                         		// 0x1CD8 (0x0008) [0x0000000000000000]              
	class ATgDevice*                                   s_UltimateInHand;                                 		// 0x1CE0 (0x0004) [0x0000000000000000]              
	struct FVector                                     r_UltimateCancelLocation;                         		// 0x1CE4 (0x000C) [0x0000000000000000]              
	float                                              m_fUltimateCancelTime;                            		// 0x1CF0 (0x0004) [0x0000000000000000]              
	float                                              m_fInheritableGroundSpeed;                        		// 0x1CF4 (0x0004) [0x0000000000000000]              
	class UTgEffectGroup*                              s_UltimateCancelRoot;                             		// 0x1CF8 (0x0004) [0x0000000000000000]              
	TArray< class UTgSpecialFx* >                      c_UltimateBuildupFxs;                             		// 0x1CFC (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2830 );

		return pClassPointer;
	};

	void PlayNearDeathCleanup ( );
	void PlayDying ( class UClass* dmgType, struct FVector HitLoc );
	void UpdateOxHits ( );
	void eventOnOxHit ( struct FVector HitLocation );
	void EndTigerPounce ( );
	void BeginTigerPounce ( );
	void FaceRotation ( struct FRotator NewRotation, float DeltaTime );
	void OnDeviceFormInterruptFire ( int nEquipSlot );
	void OnDeviceFormStopFire ( int nEquipSlot );
	void OnDeviceFormHit ( int nEquipSlot, class ATgPawn* TargetPawn );
	void OnDeviceFormFire ( int nEquipSlot );
	void OnDeviceFormStartFire ( int nEquipSlot, float FireDuration, int nFireMode );
	void OnDeviceFormBuildup ( int nEquipSlot, float fBuildupTime );
	unsigned char OverrideOffhandSlot ( unsigned char eqp );
	struct FVector GetLookAtLocation ( );
	void StopSomersaultCloud ( unsigned long bInterrupted );
	void ClearUltimateStateAfterDeath ( );
	void SetUltimateInactive ( );
	void ToggleUltimateRoot ( unsigned long bEnable );
	float ApplyPitchLimit ( float fPitch );
	void eventUpdateSomersaultCloud ( unsigned char NextState );
	void LeapBackTweenEnd ( unsigned long bInterrupted );
	void EndTween ( unsigned char endingTweenState, unsigned long bInterrupted );
	void BeginTween ( unsigned char newTweenState );
	void ClearMultiMeshAnimNodeReferences ( );
	void eventSetTargetingDevice ( class ATgDevice* Dev );
	bool eventPostPawnSetup ( );
	void eventPostDemoRewind ( );
	void eventReplicatedEvent ( struct FName VarName );
	int GetCustomParticleSystemFilter ( );
	void OnTransformTransitionEnd ( unsigned long bTriggeredInAnimTick );
	void StartTransform ( unsigned char NewStance, unsigned long bSkipTransition );
	void ReapplyPassive ( unsigned long bForceReapply );
	void ReapplyLevelEffectGroups ( int nPrevLevel, int nCurrentLevel, unsigned long bPreserveParams );
	bool DeviceOverrideTargetingAim ( class ATgDevice* Dev, struct FAimData* Aim, TArray< struct FImpactInfo >* ImpactList );
	void DeviceOnSetFireMode ( class ATgDevice* Dev );
	bool DeviceOnCanDeviceFireNow ( class ATgDevice* Dev, unsigned char FireModeNum, unsigned long bDeviceFailLog, struct FAimData* Aim );
	void DeviceOnStopFire ( class ATgDevice* Dev, unsigned long WasInterrupted );
	void DeviceOnHit ( class ATgDevice* Dev, struct FImpactInfo* Impact );
	void DeviceOnStartFire ( class ATgDevice* Dev );
};

UClass* ATgPawn_SunWukong::pClassPointer = NULL;

// Class TgGame.TgPawn_SunWukong_DarkLord
// 0x0058 (0x1D60 - 0x1D08)
class ATgPawn_SunWukong_DarkLord : public ATgPawn_SunWukong
{
public:
	class UTgAnimBlendByWukongCharge*                  m_ChargeAnimNode;                                 		// 0x1D08 (0x0004) [0x0000000000000000]              
	struct FName                                       m_ChargeAimOffsetProfileNames[ 0x4 ];             		// 0x1D0C (0x0020) [0x0000000000000000]              
	int                                                m_ChargeAnimSetStringIds[ 0x4 ];                  		// 0x1D2C (0x0010) [0x0000000000000000]              
	class UAnimSet*                                    m_ChargeAnimSets[ 0x4 ];                          		// 0x1D3C (0x0010) [0x0000000000000000]              
	class UMaterialInterface*                          m_ChargeMaterials[ 0x4 ];                         		// 0x1D4C (0x0010) [0x0000000000000000]              
	class UMaterialInstanceConstant*                   m_FriendlyFadeOverlayMaterial;                    		// 0x1D5C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2831 );

		return pClassPointer;
	};

	void OnDeviceFormStartFire ( int nEquipSlot, float FireDuration, int nFireMode );
	void OnDeviceFormBuildup ( int nEquipSlot, float fBuildupTime );
	void CacheMultiMeshAnimNodeReferences ( class UTgSkeletalMeshComponent* smcomp );
	void CacheMainMeshReferences ( class UTgSkeletalMeshComponent* smcomp );
	void RecalculateMaterial ( unsigned long bIsFriendlyWithLocalPawn, unsigned long bForce );
	void OnTransformTransitionEnd ( unsigned long bTriggeredInAnimTick );
	void SwapToLiveMesh ( );
};

UClass* ATgPawn_SunWukong_DarkLord::pClassPointer = NULL;

// Class TgGame.TgPawn_SunWukong_Default
// 0x004C (0x1D54 - 0x1D08)
class ATgPawn_SunWukong_Default : public ATgPawn_SunWukong
{
public:
	class UAnimNodeSequence*                           m_TransformIntroSequenceNode;                     		// 0x1D08 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bTriggerTransformMeshChange : 1;                		// 0x1D0C (0x0004) [0x0000000000000000] [0x00000001] 
	struct FName                                       c_TransformOutroAnimName;                         		// 0x1D10 (0x0008) [0x0000000000000000]              
	int                                                m_TransformMeshAssemblyIds[ 0x4 ];                		// 0x1D18 (0x0010) [0x0000000000000000]              
	struct FPointer                                    m_TransformBodyMeshAssemblies[ 0x4 ];             		// 0x1D28 (0x0010) [0x0000000000001000]              ( CPF_Native )
	struct FPointer                                    m_TransformDestroyedMeshAssemblies[ 0x4 ];        		// 0x1D38 (0x0010) [0x0000000000001000]              ( CPF_Native )
	int                                                m_TransformDesiredAssemblyId;                     		// 0x1D48 (0x0004) [0x0000000000000000]              
	int                                                m_TransformDesiredDestroyedAssemblyId;            		// 0x1D4C (0x0004) [0x0000000000000000]              
	float                                              m_fEagleTranslationOffset;                        		// 0x1D50 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2832 );

		return pClassPointer;
	};

	void OnDeviceFormStartFire ( int nEquipSlot, float FireDuration, int nFireMode );
	void OnDeviceFormBuildup ( int nEquipSlot, float fBuildupTime );
	void eventOnAnimEnd ( class UAnimNodeSequence* SeqNode, float PlayedTime, float ExcessTime );
	void CacheMultiMeshAnimNodeReferences ( class UTgSkeletalMeshComponent* smcomp );
	void CacheMainMeshReferences ( class UTgSkeletalMeshComponent* smcomp );
	void OnTransformTransitionEnd ( unsigned long bTriggeredInAnimTick );
	void AdjustMeshTranslation ( );
	void SwapTransformMesh ( );
	void SwapToDestroyedMesh ( );
	void SwapToLiveMesh ( );
	void OnPostureChange ( );
};

UClass* ATgPawn_SunWukong_Default::pClassPointer = NULL;

// Class TgGame.TgPawn_Susano
// 0x0030 (0x1C9C - 0x1C6C)
class ATgPawn_Susano : public ATgPawn_Character
{
public:
	class ATgDevice_Susano_Dev3*                       m_DevOffhand3;                                    		// 0x1C6C (0x0004) [0x0000000000000000]              
	TArray< class ATgDevice* >                         m_Dev1Sequence;                                   		// 0x1C70 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                m_Dev1LocalCurrent;                               		// 0x1C7C (0x0004) [0x0000000000000000]              
	int                                                r_Dev1ServerCurrent;                              		// 0x1C80 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                m_Dev1CurrentlyFiringIndex;                       		// 0x1C84 (0x0004) [0x0000000000000020]              ( CPF_Net )
	unsigned long                                      m_Dev1AllowNextPart : 1;                          		// 0x1C88 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_Dev1LockFiring : 1;                             		// 0x1C88 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_IsDev1ComboSequenceActive : 1;                  		// 0x1C88 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_Dev1SetAsTargetingDevice : 1;                   		// 0x1C88 (0x0004) [0x0000000000000000] [0x00000008] 
	float                                              r_ComboTriggerTime;                               		// 0x1C8C (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              m_ComboCurrentTime;                               		// 0x1C90 (0x0004) [0x0000000000000000]              
	float                                              s_Dev4TyphoonGrowthPercent;                       		// 0x1C94 (0x0004) [0x0000000000000000]              
	class UTgSkeletalMeshComponent*                    m_DeathMeshComponent;                             		// 0x1C98 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2833 );

		return pClassPointer;
	};

	void CleanUpDyingEffects ( );
	void PlayDyingEffects ( );
	void eventTick ( float DeltaSeconds );
	void ForceComboTargetingIfNeeded ( );
	void OnRightMousePressed ( );
	void eventProgressCombo ( );
	void ComboTriggerTimerExpired ( );
	void UpdateDev1Current ( );
	bool eventDeviceOverrideLockedDown ( class ATgDevice* Device );
	void eventReplicatedEvent ( struct FName VarName );
	bool IsComboDevice ( class ATgDevice* Dev, int* Index );
	void PlayTeleportFx ( int nTeleportState, struct FVector vLoc );
	void OnProjectileExploded ( class ATgProjectile* ExplodedProjectile, class AActor* HitActor );
	void DeviceAdjustPowerScaling ( class ATgDevice* Dev, int nScalingType, struct FImpactInfo* Impact, float* fPhysicalPower, float* fMagicPower );
	void DeviceAdjustDamage ( class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage );
	void DeviceOnStopFire ( class ATgDevice* Dev, unsigned long bWasInterrupted );
	void DeviceOnHit ( class ATgDevice* Dev, struct FImpactInfo* Impact );
	void DeviceOnFire ( class ATgDevice* Dev );
	void DeviceOnStartFire ( class ATgDevice* Dev );
	bool GetPassiveAuxMax ( float* fResult );
	bool GetPassiveAux ( float* fResult );
	bool GetPassiveInt2 ( int* nResult );
	bool GetPassiveInt1 ( int* nResult );
};

UClass* ATgPawn_Susano::pClassPointer = NULL;

// Class TgGame.TgPawn_Sylvanus
// 0x0018 (0x1C84 - 0x1C6C)
class ATgPawn_Sylvanus : public ATgPawn_Character
{
public:
	TArray< class ATgDeployable_Sylvanus_Sub1* >       m_Blooms;                                         		// 0x1C6C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class UTgSpecialFx*                                c_PullBeamFx;                                     		// 0x1C78 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UTgSkeletalMeshComponent*                    c_PullMissMeshComponent;                          		// 0x1C7C (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )
	unsigned long                                      m_bCancelPull : 1;                                		// 0x1C80 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2834 );

		return pClassPointer;
	};

	void PostTeleport ( class ATeleporter* OutTeleporter );
	void PlayPullRetrieve ( );
	void KillPullBeam ( );
	void eventSetPullBeamTarget ( class AActor* Target );
	void UnRegisterBloom ( class ATgDeployable_Sylvanus_Sub1* BloomToRemove );
	void eventRegisterBloom ( class ATgDeployable_Sylvanus_Sub1* NewBloom );
	void PlayDyingEffects ( );
	void eventDetachDev3Mesh ( );
	void AttachDev3Mesh ( );
	void eventPassiveFire ( class AActor* Target );
	bool eventPostPawnSetup ( );
	bool GetPassiveAuxMax ( float* fResult );
	bool GetPassiveAux ( float* fResult );
	void InitializePullBeamFx ( );
	void ResetDev3MeshComponent ( );
	bool InitializeDev3MeshComponent ( );
	void PawnOnDamaged ( struct FOnDamagedParams* Params );
	void DeviceOnHit ( class ATgDevice* Dev, struct FImpactInfo* Impact );
	void DeviceOnFire ( class ATgDevice* Dev );
	void DeviceOnStartFire ( class ATgDevice* Dev );
	bool DeviceOverrideTargetingAim ( class ATgDevice* Dev, struct FAimData* Aim, TArray< struct FImpactInfo >* ImpactList );
	void DeviceOnSetFireMode ( class ATgDevice* Dev );
};

UClass* ATgPawn_Sylvanus::pClassPointer = NULL;

// Class TgGame.TgPawn_Terra
// 0x00A0 (0x1D0C - 0x1C6C)
class ATgPawn_Terra : public ATgPawn_Character
{
public:
	class ATgDevice*                                   s_PassiveDevice;                                  		// 0x1C6C (0x0004) [0x0000000000000000]              
	class ATgDevice*                                   s_ShatterDevice;                                  		// 0x1C70 (0x0004) [0x0000000000000000]              
	class ATgDevice*                                   s_Dev3ShatterDevice;                              		// 0x1C74 (0x0004) [0x0000000000000000]              
	class ATgDevice*                                   s_Dev4DetonateDevice;                             		// 0x1C78 (0x0004) [0x0000000000000000]              
	TArray< class ATgDeployable_Terra_StandingStone* > s_StandingStones;                                 		// 0x1C7C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                r_PassiveCount;                                   		// 0x1C88 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class UTgSkeletalMeshComponent*                    c_SpikeArmor;                                     		// 0x1C8C (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	unsigned long                                      r_ShowSpikeArmor : 1;                             		// 0x1C90 (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )
	unsigned long                                      r_ExtendPassive : 1;                              		// 0x1C90 (0x0004) [0x0000000000000020] [0x00000002] ( CPF_Net )
	unsigned long                                      r_Dev2NextCastIsDetonate : 1;                     		// 0x1C90 (0x0004) [0x0000000000000020] [0x00000004] ( CPF_Net )
	float                                              s_LastShatterTime;                                		// 0x1C94 (0x0004) [0x0000000000000000]              
	class UTgAnimNodeSlot*                             m_Dev1ShatterNode;                                		// 0x1C98 (0x0004) [0x0000000000000000]              
	int                                                r_Dev1BonusCharges;                               		// 0x1C9C (0x0004) [0x0000000000000020]              ( CPF_Net )
	TArray< class ATgPawn* >                           m_Dev2HitTracking;                                		// 0x1CA0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< int >                                      m_Dev3DeployableIds;                              		// 0x1CAC (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FTerraWardstoneFXData                       r_Dev4WardStoneStatus[ 0x5 ];                     		// 0x1CB8 (0x003C) [0x0000000000000020]              ( CPF_Net )
	class UMeshComponent*                              m_Dev4WardStoneFx[ 0x5 ];                         		// 0x1CF4 (0x0014) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class UTgSkeletalMeshComponent*                    m_DeathMeshComponent;                             		// 0x1D08 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2835 );

		return pClassPointer;
	};

	void CleanUpDyingEffects ( );
	void PlayDyingEffects ( );
	bool HandleCrushingShaleHit ( class ATgDeployable_Terra_CrushingShale* deployable, class ATgPawn* HitPawn, struct FVector HitLocation, struct FVector HitNormal );
	void CacheMainMeshReferences ( class UTgSkeletalMeshComponent* smcomp );
	void eventTriggerDev4DetonateOnTarget ( class ATgPawn* Target );
	void eventPlayDev1HitAnimation ( );
	void TriggerShatter ( class ATgDeployable_Terra_StandingStone* standingStone, struct FVector HitLocation );
	void Dev1BonusTimeExpired ( );
	void UpdateDev1BonusCharges ( );
	void ConsumeDev1BonusCharges ( );
	bool eventIsDev1BonusChargeAvailable ( );
	void AwardDev1BonusCharge ( );
	void eventTick ( float DeltaSeconds );
	void eventStandingStoneDestroyed ( class ATgDeployable_Terra_StandingStone* standingStone );
	void eventStandingStoneCreated ( class ATgDeployable_Terra_StandingStone* standingStone );
	void AnimateWardStonesOut ( );
	void OnDeviceFormFire ( int nEquipSlot );
	void UpdateWardStones ( );
	void eventSetWardStoneStatus ( class ATgPawn* Target, unsigned long IsActive, int ActiveStoneCount );
	bool eventPostPawnSetup ( );
	void eventReplicatedEvent ( struct FName VarName );
	bool IsMyStandingStone ( class AActor* Target );
	void EffectGroupOnSetActive ( unsigned long bActive, unsigned long bRemoving, class UTgEffectGroup* effectGroup );
	void DeviceOnSetFireMode ( class ATgDevice* Dev );
	void DeviceOnHit ( class ATgDevice* Dev, struct FImpactInfo* Impact );
	void DeviceOnStartFire ( class ATgDevice* Dev );
	bool GetPassiveInt1 ( int* nResult );
	void ToggleSpikeArmor ( unsigned long IsOn );
	void InitializeSpikeArmor ( );
	class UMeshComponent* AttachWardStoneMesh ( class ATgPawn* Target );
};

UClass* ATgPawn_Terra::pClassPointer = NULL;

// Class TgGame.TgPawn_Thanatos
// 0x01E8 (0x1E54 - 0x1C6C)
class ATgPawn_Thanatos : public ATgPawn_Character
{
public:
	TArray< struct FLowHealthInfo >                    m_LowHealthGods;                                  		// 0x1C6C (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	int                                                r_nHarvesterBallQueueIndex;                       		// 0x1C78 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                c_nHarvesterBallQueueIndex;                       		// 0x1C7C (0x0004) [0x0000000000000000]              
	struct FVector                                     r_HarvesterBallLocations[ 0x10 ];                 		// 0x1C80 (0x00C0) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      r_HarvesterBallIsGod[ 0x10 ];                     		// 0x1D40 (0x0010) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      r_eHoveringDeathState;                            		// 0x1D50 (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      c_eLocalHoveringDeathState;                       		// 0x1D51 (0x0001) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      c_eHoveringDeathPosture;                          		// 0x1D52 (0x0001) [0x0000000000000000]              
	float                                              r_HarvesterBallReturnTime[ 0x10 ];                		// 0x1D54 (0x0040) [0x0000000000000020]              ( CPF_Net )
	struct FVector2D                                   m_HarvesterBallReturnTimeRange;                   		// 0x1D94 (0x0008) [0x0000000000000000]              
	TArray< struct FKillBallInfo >                     c_HarvesterBallInfos;                             		// 0x1D9C (0x000C) [0x0000000000482000]              ( CPF_Transient | CPF_Component | CPF_NeedCtorLink )
	unsigned long                                      c_bCanPlayBallConsumeFx : 1;                      		// 0x1DA8 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      c_bShadowVisionEnabled : 1;                       		// 0x1DA8 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_bHungeringDeathActive : 1;                      		// 0x1DA8 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_bHoveringDeathAtLocation : 1;                   		// 0x1DA8 (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      m_bHoveringDeathHasFired : 1;                     		// 0x1DA8 (0x0004) [0x0000000000000000] [0x00000010] 
	unsigned long                                      c_bAllowHoveringDeathLaugh : 1;                   		// 0x1DA8 (0x0004) [0x0000000000000000] [0x00000020] 
	float                                              c_fBallConsumeFxDelay;                            		// 0x1DAC (0x0004) [0x0000000000000000]              
	float                                              r_fLowHealthPercentQualifier;                     		// 0x1DB0 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class UPostProcessChain*                           c_ShadowVisionPostProcess;                        		// 0x1DB4 (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                c_HarvesterHeartbeatFx;                           		// 0x1DB8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class ATgDevice*                                   s_BasicInHand;                                    		// 0x1DBC (0x0004) [0x0000000000000000]              
	int                                                m_nDeathGripCount;                                		// 0x1DC0 (0x0004) [0x0000000000000000]              
	int                                                c_nHoveringDeathPostureId;                        		// 0x1DC4 (0x0004) [0x0000000000000000]              
	struct FName                                       c_HoveringDeathDashAnimName;                      		// 0x1DC8 (0x0008) [0x0000000000000000]              
	struct FName                                       c_HoveringDeathCancelAnimName;                    		// 0x1DD0 (0x0008) [0x0000000000000000]              
	class ATgDevice*                                   s_HoveringDeathInHand;                            		// 0x1DD8 (0x0004) [0x0000000000000000]              
	struct FVector                                     r_HoveringDeathStartLocation;                     		// 0x1DDC (0x000C) [0x0000000000000020]              ( CPF_Net )
	struct FVector                                     r_HoveringDeathBackupLocation;                    		// 0x1DE8 (0x000C) [0x0000000000000020]              ( CPF_Net )
	class UTgSpecialFx*                                c_HoveringDeathExecuteFx;                         		// 0x1DF4 (0x0004) [0x0000000000000000]              
	int                                                r_nHoveringDeathExecutionQueueIndex;              		// 0x1DF8 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                c_nHoveringDeathExecutionQueueIndex;              		// 0x1DFC (0x0004) [0x0000000000000000]              
	int                                                r_nHoveringDeathExecutionPawnIds[ 0x10 ];         		// 0x1E00 (0x0040) [0x0000000000000020]              ( CPF_Net )
	float                                              c_fHoveringDeathLaughDelay;                       		// 0x1E40 (0x0004) [0x0000000000000000]              
	class USkelControlSingleBone*                      m_FlapControl;                                    		// 0x1E44 (0x0004) [0x0000000000000000]              
	float                                              c_fFlutterScale;                                  		// 0x1E48 (0x0004) [0x0000000000000000]              
	float                                              c_fFlutterScaleUpRate;                            		// 0x1E4C (0x0004) [0x0000000000000000]              
	float                                              c_fFlutterCooldownRate;                           		// 0x1E50 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2836 );

		return pClassPointer;
	};

	bool IsInClassSpecificMovement ( );
	void AllowExecuteLaugh ( );
	void eventPlayExecuteLaugh ( );
	void TickFlutter ( float DeltaSeconds );
	void ResetBallConsumeFxTimer ( );
	void eventHandleHarvesterBallMesh ( class USkeletalMeshComponent* BallMesh );
	void UpdateShadowVision ( unsigned long bEnable );
	void ResetHoveringDeath ( );
	void eventClearHoveringDeathAfterSelfDeath ( );
	void ClientUpdateHungeringDeath ( unsigned long bEnable );
	void TickHungeringDeath ( float DeltaSeconds );
	void TickHoveringDeath ( float DeltaSeconds );
	void eventUpdateHoveringDeath ( );
	void UpdateHeartbeat ( );
	void TriggerFlapDown ( );
	void Tick ( float DeltaSeconds );
	void OnRespawn ( );
	float ApplyPitchLimit ( float fPitch );
	void eventStopFiringAllDevices ( unsigned long bClearEquipEffectFlag, unsigned long bResetCooldowns );
	void PlayNearDeathCleanup ( );
	void PlayDying ( class UClass* dmgType, struct FVector HitLoc );
	void eventOnAnimEnd ( class UAnimNodeSequence* SeqNode, float PlayTime, float ExcessTime );
	void eventOnAnimPlay ( class UAnimNodeSequence* SeqNode );
	void OnDeviceFormStopFire ( int nEquipSlot );
	void OnDeviceFormStartFire ( int nEquipSlot, float FireDuration, int nFireMode );
	void OnDeviceFormBuildup ( int nEquipSlot, float fBuildupTime );
	void CacheMainMeshReferences ( class UTgSkeletalMeshComponent* smcomp );
	void eventSetTargetingDevice ( class ATgDevice* Dev );
	void EndTween ( unsigned char endingTweenState, unsigned long bInterrupted );
	void eventReceivedPropValues ( );
	void BeginTween ( unsigned char newTweenState );
	void eventPostDemoRewind ( );
	void eventPreDemoRewind ( );
	void eventReplicatedEvent ( struct FName VarName );
	bool eventPostPawnSetup ( );
	void InitializeShadowVisionPostProcess ( );
	void TickLowHealthList ( float DeltaSeconds );
	bool OverrideDistanceFadeRange ( );
	void UpdateExecution ( );
	void FlashExecution ( class ATgPawn* Victim );
	void EndHoveringDeath ( unsigned long bFired );
	void BeginHoveringDeath ( class ATgDevice* Dev );
	void BeginHoveringDeathRise ( class ATgDevice* Dev );
	void PrepareHoveringDeath ( class ATgDevice* Dev );
	bool RemoveHarvesterBallInfo ( int nIndex );
	void UpdateHarvesterBalls ( );
	void FlashHarvesterBall ( struct FVector Loc, float ReturnTime, unsigned long bIsGod );
	float CalcBearing ( class AActor* Target, float fPreviousBearing, float DeltaSeconds );
	void PawnOnKilled ( class AActor* Victim, int* xpGain, int* goldGain );
	void DeviceOnDamaged ( struct FOnDamagedParams* Params );
	bool DeviceOnCanDeviceFireNow ( class ATgDevice* Dev, unsigned char FireModeNum, unsigned long bDeviceFailLog, struct FAimData* Aim );
	void DeviceOnSetFireMode ( class ATgDevice* Dev );
	void DeviceAdjustDamage ( class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage );
	void DeviceOnStopFire ( class ATgDevice* Dev, unsigned long WasInterrupted );
	void DeviceOnFire ( class ATgDevice* Dev );
	void DeviceOnStartFire ( class ATgDevice* Dev );
	void DeviceOnStopBuildup ( class ATgDevice* Dev, unsigned long WasInterrupted );
	void DeviceOnStartBuildup ( class ATgDevice* Dev );
	float GetUIGroundSpeed ( );
};

UClass* ATgPawn_Thanatos::pClassPointer = NULL;

// Class TgGame.TgPawn_Thor
// 0x002C (0x1C98 - 0x1C6C)
class ATgPawn_Thor : public ATgPawn_Character
{
public:
	class ATgProj_Thor_TeleportHammer*                 m_TeleportHammer;                                 		// 0x1C6C (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                m_TeleportHammerEnterFx;                          		// 0x1C70 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UTgSpecialFx*                                m_TeleportHammerExitFx;                           		// 0x1C74 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned long                                      r_bInAnvilJump : 1;                               		// 0x1C78 (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )
	unsigned char                                      r_nTriggerAnvilDismount;                          		// 0x1C7C (0x0001) [0x0000000000000020]              ( CPF_Net )
	class UTgSpecialFx*                                m_AnvilSpinFx;                                    		// 0x1C80 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UTgSkeletalMeshComponent*                    c_SkinTransitionComponent;                        		// 0x1C84 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	TArray< class UTgSkeletalMeshComponent* >          c_SkinDeathTransitionComponents;                  		// 0x1C88 (0x000C) [0x0000000004580008]              ( CPF_ExportObject | CPF_Component | CPF_NeedCtorLink | CPF_EditInline )
	int                                                r_nPassiveAux;                                    		// 0x1C94 (0x0004) [0x0000000000000020]              ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2837 );

		return pClassPointer;
	};

	void CleanUpDyingEffects ( );
	void PlayDyingEffects ( );
	bool IsInClassSpecificMovement ( );
	void EndTween ( unsigned char endingTweenState, unsigned long bInterrupted );
	void BeginTween ( unsigned char newTweenState );
	void OnDeviceFormStopFire ( int nEquipSlot );
	void OnDeviceFormStartFire ( int nEquipSlot, float FireDuration, int nFireMode );
	void OnDeviceFormBuildup ( int nEquipSlot, float fBuildupTime );
	void CancelTeleportAnim ( float fBlendTime );
	bool eventTeleportToHammer ( struct FVector vClientLocation );
	bool FindTeleportSpot ( struct FVector Extent, struct FVector* TeleportLocation );
	void eventCatchHammer ( );
	void eventSetTeleportHammer ( class ATgProj_Thor_TeleportHammer* hammer );
	float ApplyPitchLimit ( float fPitch );
	void eventReplicatedEvent ( struct FName VarName );
	void eventStopAnvilFBAnimIfDead ( );
	void eventTriggerAnvilDismount ( );
	bool PostPawnSetup ( );
	struct FString GetEmoteCustomSuffix ( unsigned char Emote, int ExtraInfo );
	struct FString GetVGSCustomSuffix ( int nPreferredVPSetting );
	void EndSkinLevelUp ( );
	void PlaySkinLevelUpFx ( );
	void OnSkinLevelChanged ( );
	void PawnOnRevive ( );
	bool OverrideDistanceFadeRange ( );
	void EndAnvilJump ( );
	void StartAnvilJump ( );
	bool GetPassiveAux ( float* fResult );
	void EffectGroupOnSetActive ( unsigned long bActive, unsigned long bRemoving, class UTgEffectGroup* effectGroup );
	void PlayTeleportFx ( int nTeleportState, struct FVector vLoc );
	void DeviceAdjustDamage ( class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage );
	void DeviceOnStartBuildup ( class ATgDevice* Dev );
	void InitializeSkinDeathComponents ( );
	bool InitializeAnvilSpinFX ( );
};

UClass* ATgPawn_Thor::pClassPointer = NULL;

// Class TgGame.TgPawn_Thoth
// 0x01D4 (0x1E40 - 0x1C6C)
class ATgPawn_Thoth : public ATgPawn_Character
{
public:
	unsigned char                                      r_InhandState;                                    		// 0x1C6C (0x0001) [0x0000000000000020]              ( CPF_Net )
	TArray< class UTgAnimNodeBlendList_Thoth_Inhand* > m_InhandBlendListNodes;                           		// 0x1C70 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UTgAnimNodeBlentList_Thoth_Dash* >   m_DashBlendListNodes;                             		// 0x1C7C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< unsigned char >                            s_QueuedInhands;                                  		// 0x1C88 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                m_PsvStackLimitByLevel[ 0x14 ];                   		// 0x1C94 (0x0050) [0x0000000000000000]              
	int                                                r_nCurrentPsvStacks;                              		// 0x1CE4 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nMaxPsvStacks;                                  		// 0x1CE8 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nNumPsvEnemyKills;                              		// 0x1CEC (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nPsvEnemyKillThreshold;                         		// 0x1CF0 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgDevice*                                   s_Dev1Shooter;                                    		// 0x1CF4 (0x0004) [0x0000000000000000]              
	int                                                r_nDev1AmmoCount;                                 		// 0x1CF8 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                c_nDev1LocalAmmoCount;                            		// 0x1CFC (0x0004) [0x0000000000000000]              
	struct FName                                       c_Dev1AmmoFxGroups[ 0x3 ];                        		// 0x1D00 (0x0018) [0x0000000000000000]              
	int                                                c_Dev1AmmoFxCount;                                		// 0x1D18 (0x0004) [0x0000000000000000]              
	class ATgDevice*                                   s_Dev2Shooter;                                    		// 0x1D1C (0x0004) [0x0000000000000000]              
	unsigned long                                      r_Dev2InhandShotFired : 1;                        		// 0x1D20 (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )
	unsigned long                                      r_Dev2ApplyRangeExtension : 1;                    		// 0x1D20 (0x0004) [0x0000000000000020] [0x00000002] ( CPF_Net )
	TArray< struct FSpeedGlyphProjTrackingData >       s_SpeedGlyphProjTracking;                         		// 0x1D24 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FSpeedGlyphProjTrackingData                 s_LastSpeedGlyphAdjustedHit;                      		// 0x1D30 (0x000C) [0x0000000000000000]              
	class ATgDevice_Deployable*                        r_Dev3Device;                                     		// 0x1D3C (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              r_Dev3ProjSpeedMod;                               		// 0x1D40 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              r_Dev3RangeBonus;                                 		// 0x1D44 (0x0004) [0x0000000000000020]              ( CPF_Net )
	struct FSpeedGlyphProjEventData                    r_Dev3ProjEvents[ 0x12 ];                         		// 0x1D48 (0x00D8) [0x0000000000000020]              ( CPF_Net )
	int                                                m_Dev3EventIndex;                                 		// 0x1E20 (0x0004) [0x0000000000000000]              
	class AController*                                 s_Dev3KillerOverride;                             		// 0x1E24 (0x0004) [0x0000000000000000]              
	int                                                r_Dev4PagesCharged;                               		// 0x1E28 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                m_Dev4MaxPages;                                   		// 0x1E2C (0x0004) [0x0000000000000000]              
	TArray< class UTgAnimNodeBlentList_IntroLoopOutro* > m_Dev4SequenceNodes;                              		// 0x1E30 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class UTgSkeletalMeshComponent*                    m_DeathMeshComponent;                             		// 0x1E3C (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2838 );

		return pClassPointer;
	};

	void CleanUpDyingEffects ( );
	void PlayDyingEffects ( );
	void ClearMultiMeshAnimNodeReferences ( );
	void CacheMultiMeshAnimNodeReferences ( class UTgSkeletalMeshComponent* smcomp );
	void OnDeviceFormFire ( int nEquipSlot );
	void OnDeviceFormStartFire ( int nEquipSlot, float FireDuration, int nFireMode );
	void UpdateAnimNodeInhandState ( );
	void ChargeDev4Page ( );
	class AController* OverrideKillInstigator ( );
	void PlayDashFX ( );
	void UpdateDev3ProjectileEvents ( );
	bool TryTrackProjectile ( class ATgProjectile* Proj, int* ShooterDevId );
	bool IsTrackableProjectile ( class ATgDevice* shooterDevice );
	bool DoesProjectilePathCrossSpeedGlyph ( class ATgProjectile* Proj, class ATgPawn* shooter );
	bool eventDied ( class AController* Killer, class UClass* dmgType, struct FVector HitLocation );
	void eventDev2InhandTimerExpired ( );
	void DeactivateDev1AmmoFX ( );
	void ActivateDev1AmmoFX ( );
	void eventDeactivateDev1Inhand ( );
	void eventActivateDev1Inhand ( );
	void eventAdjustAmmo ( int Delta );
	void eventReplicatedEvent ( struct FName VarName );
	void PopEquippedDevice ( class ATgDevice* newDev, int nEqpSlot );
	void PushEquippedDevice ( class ATgDevice* newDev, int nEqpSlot );
	void ApplyProjectileSpeedModifier ( int ProjectileInstanceId, float SpeedModifier, float RangeBonus, int ShooterDevId );
	bool DeviceOnCanDeviceFireNow ( class ATgDevice* Dev, unsigned char FireModeNum, unsigned long bDeviceFailLog, struct FAimData* Aim );
	void DeviceAdjustDamage ( class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage );
	void DeviceOnStopFire ( class ATgDevice* Dev, unsigned long WasInterrupted );
	void DeviceOnStartFire ( class ATgDevice* Dev );
	void DeviceOnSetFireMode ( class ATgDevice* Dev );
	void DeviceOnStartBuildup ( class ATgDevice* Dev );
	bool GetPassiveAuxMax ( float* fResult );
	bool GetPassiveAux ( float* fResult );
	bool GetPassiveInt2 ( int* nResult );
	bool GetPassiveInt1 ( int* nResult );
};

UClass* ATgPawn_Thoth::pClassPointer = NULL;

// Class TgGame.TgPawn_Tyr
// 0x008C (0x1CF8 - 0x1C6C)
class ATgPawn_Tyr : public ATgPawn_Character
{
public:
	class ATgDevice*                                   r_AggressiveNum1Device;                           		// 0x1C6C (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgDevice*                                   r_AggressiveNum1Stage2Device;                     		// 0x1C70 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgDevice*                                   r_AggressiveNum1Stage3Device;                     		// 0x1C74 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgDevice*                                   m_AggressiveBasicAttackDevice;                    		// 0x1C78 (0x0004) [0x0000000000000000]              
	class ATgDevice*                                   r_DefensiveNum1Device;                            		// 0x1C7C (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgDevice*                                   m_DefensiveNum1Stage1Device;                      		// 0x1C80 (0x0004) [0x0000000000000000]              
	class ATgDevice*                                   m_DefensiveNum1Stage2Device;                      		// 0x1C84 (0x0004) [0x0000000000000000]              
	class ATgDevice*                                   m_DefensiveNum1Stage3Device;                      		// 0x1C88 (0x0004) [0x0000000000000000]              
	class ATgDevice*                                   m_AggressiveNum2Device;                           		// 0x1C8C (0x0004) [0x0000000000000000]              
	class ATgDevice*                                   m_DefensiveNum2Device;                            		// 0x1C90 (0x0004) [0x0000000000000000]              
	class ATgDevice*                                   m_AggressiveNum4Device;                           		// 0x1C94 (0x0004) [0x0000000000000000]              
	class ATgDevice*                                   m_DefensiveNum4Device;                            		// 0x1C98 (0x0004) [0x0000000000000000]              
	class ATgDevice*                                   m_AggressiveNum3Device;                           		// 0x1C9C (0x0004) [0x0000000000000000]              
	class ATgDevice*                                   m_DefensiveNum3Device;                            		// 0x1CA0 (0x0004) [0x0000000000000000]              
	class ATgDevice*                                   m_DefensiveBasicAttackDevice;                     		// 0x1CA4 (0x0004) [0x0000000000000000]              
	float                                              m_fRemainingChargeTime;                           		// 0x1CA8 (0x0004) [0x0000000000000000]              
	TArray< class ATgPawn* >                           m_ChargeVictimList;                               		// 0x1CAC (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class ATgPawn* >                           m_ChargeVictimIgnoreList;                         		// 0x1CB8 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	unsigned long                                      r_bForceZeroChargeVelocity : 1;                   		// 0x1CC4 (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )
	unsigned long                                      r_bIsPassiveBuffEnabled : 1;                      		// 0x1CC4 (0x0004) [0x0000000000000020] [0x00000002] ( CPF_Net )
	int                                                m_DefensiveMeshAssemblyId;                        		// 0x1CC8 (0x0004) [0x0000000000000000]              
	struct FPointer                                    m_DefensiveMeshAssembly;                          		// 0x1CCC (0x0004) [0x0000000000001000]              ( CPF_Native )
	TArray< class UAnimSet* >                          m_DefensiveAnimsets;                              		// 0x1CD0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	unsigned char                                      r_CurrentStance;                                  		// 0x1CDC (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      c_LocalCurrentStance;                             		// 0x1CDD (0x0001) [0x0000000000000000]              
	unsigned char                                      r_DefensiveNum1HitNotify;                         		// 0x1CDE (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      r_PlayAggressiveBuff;                             		// 0x1CDF (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      r_PlayDefensiveBuff;                              		// 0x1CE0 (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      r_PlayAggressiveNum2Audio;                        		// 0x1CE1 (0x0001) [0x0000000000000020]              ( CPF_Net )
	float                                              m_fRemainingTimeTillPassiveEnabled;               		// 0x1CE4 (0x0004) [0x0000000000000000]              
	float                                              r_fTotalPassiveTime;                              		// 0x1CE8 (0x0004) [0x0000000000000020]              ( CPF_Net )
	TArray< class AActor* >                            m_DefensiveNum2TargetList;                        		// 0x1CEC (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2839 );

		return pClassPointer;
	};

	bool IsInClassSpecificMovement ( );
	void OnDeviceFormStartFire ( int nEquipSlot, float FireDuration, int nFireMode );
	void OnDeviceFormBuildup ( int nEquipSlot, float fBuildupTime );
	void OnGrabTargetDetach ( unsigned char endingGrabState, class ATgPawn* Target, unsigned long bInterrupted );
	void eventPlayAggressiveNum2Audio ( );
	void eventPostDemoRewind ( );
	void VerifyStanceEffects ( );
	bool IgnoreFaceRotationWithInterp ( );
	void eventPlayDefensiveNum1Hit ( );
	void eventStopPassiveBuffEffects ( );
	void eventPlayPassiveBuffEffects ( unsigned char StanceType );
	void eventPlaySwapStanceEffects ( );
	bool eventPostPawnSetup ( );
	void eventReplicatedEvent ( struct FName VarName );
	bool CheckProcPassive ( );
	bool GetPassiveAux ( float* fResult );
	bool GetPassiveBool ( int* bResult );
	void PawnOnSpecialReset ( );
	void PawnOnModifyEffectLifeTime ( class UTgEffectGroup* eg, float* fLifeTime );
	bool DeviceOverrideTargetingAim ( class ATgDevice* Dev, struct FAimData* Aim, TArray< struct FImpactInfo >* ImpactList );
	float GetSmoothEnergy ( );
	void EnablePassiveBuff ( unsigned long bEnabled );
	void SwapToLiveMesh ( );
	void SwapStance ( unsigned char NewStance );
	void DeviceOnStartCooldown ( class ATgDevice* Dev, float fCooldown );
	void DeviceOnHit ( class ATgDevice* Dev, struct FImpactInfo* Impact );
	void DeviceOnStopFire ( class ATgDevice* Dev, unsigned long WasInterrupted );
	void DeviceOnStartFire ( class ATgDevice* Dev );
	void DeviceOnFire ( class ATgDevice* Dev );
};

UClass* ATgPawn_Tyr::pClassPointer = NULL;

// Class TgGame.TgPawn_Ullr
// 0x008D (0x1CF9 - 0x1C6C)
class ATgPawn_Ullr : public ATgPawn_Character
{
public:
	class UTgSpecialFx*                                m_ReloadArrowFX;                                  		// 0x1C6C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class ATgDevice*                                   m_UllrNum1Ranged;                                 		// 0x1C70 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgDevice*                                   m_UllrNum2Ranged;                                 		// 0x1C74 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgDevice*                                   m_UllrNum3Ranged;                                 		// 0x1C78 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgDevice*                                   m_UllrNum4Ranged;                                 		// 0x1C7C (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgDevice*                                   m_UllrPassRanged;                                 		// 0x1C80 (0x0004) [0x0000000000000000]              
	class ATgDevice*                                   m_UllrNum1Melee;                                  		// 0x1C84 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgDevice*                                   m_UllrNum2Melee;                                  		// 0x1C88 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgDevice*                                   m_UllrNum3Melee;                                  		// 0x1C8C (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgDevice*                                   m_UllrNum4Melee;                                  		// 0x1C90 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgDevice*                                   m_UllrPassMelee;                                  		// 0x1C94 (0x0004) [0x0000000000000000]              
	class UAnimSet*                                    m_MeleeAnimset;                                   		// 0x1C98 (0x0004) [0x0000000000000000]              
	unsigned long                                      r_bIsUllrInMeleeStance : 1;                       		// 0x1C9C (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )
	unsigned long                                      c_bIsLocalUllrInMeleeStance : 1;                  		// 0x1C9C (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      s_bInHandSwapOnHold : 1;                          		// 0x1C9C (0x0004) [0x0000000000002000] [0x00000004] ( CPF_Transient )
	int                                                c_NumPostureId[ 0x4 ];                            		// 0x1CA0 (0x0010) [0x0000000000000000]              
	float                                              m_fPassiveStacks;                                 		// 0x1CB0 (0x0004) [0x0000000000000000]              
	TArray< class UTgAnimNodeBlendList* >              c_GodMeleeAnimLists;                              		// 0x1CB4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class ATgDevice*                                   s_InHandMelee;                                    		// 0x1CC0 (0x0004) [0x0000000000000000]              
	class ATgDevice*                                   s_InHandRanged;                                   		// 0x1CC4 (0x0004) [0x0000000000000000]              
	struct FName                                       m_StanceAimOffsetProfileNames[ 0x4 ];             		// 0x1CC8 (0x0020) [0x0000000000000000]              
	TArray< class UAnimNodeAimOffset* >                c_AimOffsets;                                     		// 0x1CE8 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class UTgSkeletalMeshComponent*                    c_BowStimMesh;                                    		// 0x1CF4 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	unsigned char                                      r_nShowBowStimMesh;                               		// 0x1CF8 (0x0001) [0x0000000000000020]              ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2840 );

		return pClassPointer;
	};

	void Tick ( float DeltaSeconds );
	struct FVector GetFireLocationOffset ( class ATgDevice* Dev );
	void eventUpdateBowMesh ( unsigned char NewShowBowStim );
	void OnDeviceFormFire ( int nEquipSlot );
	void OnDeviceFormStartFire ( int nEquipSlot, float FireDuration, int nFireMode );
	void EndTween ( unsigned char endingTweenState, unsigned long bInterrupted );
	void BeginTween ( unsigned char newTweenState );
	void ActivateArrowFX ( );
	void eventDeactivateArrowFX ( );
	void CacheMultiMeshAnimNodeReferences ( class UTgSkeletalMeshComponent* smcomp );
	void eventPlaySwapStanceEffects ( unsigned long bForce );
	void PlayDying ( class UClass* dmgType, struct FVector HitLoc );
	void OnRespawn ( );
	bool eventPostPawnSetup ( );
	void eventReplicatedEvent ( struct FName VarName );
	bool GetPassiveAux ( float* fResult );
	bool GetPassiveBool ( int* bResult );
	void ReduceRangedCooldown ( float TimeReduced );
	void ReduceMeleeCooldown ( float TimeReduced );
	bool InitializeReloadArrowFX ( );
	void OnMeshSwapped ( );
	void SwapToLiveMesh ( );
	void SwapStance ( unsigned long bIsChangingToMelee );
	void ChangeInhand ( unsigned char NewInhand );
	bool AreAnyOtherOffhandsLockingFiring ( class ATgDevice* CurrentDevice );
	void EffectGroupOnSetActive ( unsigned long bActive, unsigned long bRemoving, class UTgEffectGroup* effectGroup );
	void DeviceOnStartCooldown ( class ATgDevice* Device, float Cooldown );
	void DeviceOnHit ( class ATgDevice* Dev, struct FImpactInfo* Impact );
	void DeviceOnFire ( class ATgDevice* Dev );
	void DeviceOnStartFire ( class ATgDevice* Dev );
};

UClass* ATgPawn_Ullr::pClassPointer = NULL;

// Class TgGame.TgPawn_Vamana
// 0x0030 (0x1C9C - 0x1C6C)
class ATgPawn_Vamana : public ATgPawn_Character
{
public:
	unsigned char                                      r_eVamanaSize;                                    		// 0x1C6C (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      c_eLocalVamanaSize;                               		// 0x1C6D (0x0001) [0x0000000000000000]              
	float                                              s_DurationAsGiant;                                		// 0x1C70 (0x0004) [0x0000000000000000]              
	class ATgCollisionProxy_Cylinder*                  m_ChargeCollisionProxy;                           		// 0x1C74 (0x0004) [0x0000000000000000]              
	float                                              m_ScalingProgress;                                		// 0x1C78 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_IsFinishingTransition : 1;                      		// 0x1C7C (0x0004) [0x0000000000000000] [0x00000001] 
	TArray< struct FChargeHitInfo >                    m_ChargeHitInfos;                                 		// 0x1C80 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class ATgDevice*                                   s_GiantInHandDevice;                              		// 0x1C8C (0x0004) [0x0000000000000000]              
	class ATgDevice*                                   s_InHandDevice;                                   		// 0x1C90 (0x0004) [0x0000000000000000]              
	float                                              r_fPassiveTimer;                                  		// 0x1C94 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              s_fUltDurationModifier;                           		// 0x1C98 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2841 );

		return pClassPointer;
	};

	void eventReplicatedEvent ( struct FName VarName );
	void eventChargeCollisionProxyOnTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void OnFinishedShrinking ( );
	void BeginShrinking ( );
	void OnFinishedGrowing ( );
	void BeginGrowing ( );
	void GrowCollision ( float NewRadius, float NewHeight );
	void UpdateVamanaSizeState ( unsigned char NewSize );
	void DeviceOnStopFire ( class ATgDevice* Dev, unsigned long WasInterrupted );
	void DeviceOnFire ( class ATgDevice* Dev );
	void DeviceOnStartFire ( class ATgDevice* Dev );
	void FinishTransition ( );
	void Tick ( float DeltaSeconds );
	void OnRespawn ( );
	void eventSetTargetingDevice ( class ATgDevice* Dev );
	bool GetPassiveAuxMax ( float* fResult );
	bool GetPassiveAux ( float* fResult );
	bool GetPassiveInt1 ( int* nResult );
	float GetDefaultMeshScale ( );
	void CorrectLocationWhileChangingSize ( float HeightDelta );
	void GetSmallCollisionCylinderSize ( float* Radius, float* Height );
	void GetGiantCollisionCylinderSize ( float* Radius, float* Height );
	void SwapToGiantMesh ( );
	bool DeviceOnCanDeviceFireNow ( class ATgDevice* Dev, unsigned char FireModeNum, unsigned long bDeviceFailLog, struct FAimData* Aim );
	bool AreAnyOtherOffhandsLockingFiring ( class ATgDevice* CurrentDevice );
	float GetPhysicalPowerItem ( struct FImpactInfo Impact, float PowerScaling );
	void PawnOnDamaged ( struct FOnDamagedParams* Params );
};

UClass* ATgPawn_Vamana::pClassPointer = NULL;

// Class TgGame.TgPawn_Vulcan
// 0x0008 (0x1C74 - 0x1C6C)
class ATgPawn_Vulcan : public ATgPawn_Character
{
public:
	class UTgMarkComponent*                            m_BackFireMarks;                                  		// 0x1C6C (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	unsigned long                                      m_bInTurretRange : 1;                             		// 0x1C70 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2842 );

		return pClassPointer;
	};

	void ApplyBackFireMark ( class AActor* Target );
	bool GetPassiveAux ( float* fResult );
	void DeviceOnStopFire ( class ATgDevice* Dev, unsigned long bWasInterrupted );
	void DeviceOnFire ( class ATgDevice* Dev );
	void DeviceOnHit ( class ATgDevice* Dev, struct FImpactInfo* Impact );
};

UClass* ATgPawn_Vulcan::pClassPointer = NULL;

// Class TgGame.TgPawn_VulcanV2
// 0x0004 (0x1C70 - 0x1C6C)
class ATgPawn_VulcanV2 : public ATgPawn_Character
{
public:
	class UTgMarkComponent*                            m_TurretTargetMarks;                              		// 0x1C6C (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2843 );

		return pClassPointer;
	};

	void DeviceOnHit ( class ATgDevice* Dev, struct FImpactInfo* Impact );
};

UClass* ATgPawn_VulcanV2::pClassPointer = NULL;

// Class TgGame.TgPawn_Xbalanque
// 0x0064 (0x1CD0 - 0x1C6C)
class ATgPawn_Xbalanque : public ATgPawn_Character
{
public:
	TArray< class UTgDeviceFire* >                     m_SplitProjectileDeviceModes;                     		// 0x1C6C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UTgDeviceFire* >                     m_RainingDartsDeviceModes;                        		// 0x1C78 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UTgDeviceFire* >                     m_RainingPoisonDartsDeviceModes;                  		// 0x1C84 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                m_RainingDartsTargetCount;                        		// 0x1C90 (0x0004) [0x0000000000000000]              
	TArray< class AActor* >                            m_RainingDartsTargets;                            		// 0x1C94 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class AActor* >                            m_RainingDartsHitTargets;                         		// 0x1CA0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	unsigned long                                      r_HasRainingDartsTargets : 1;                     		// 0x1CAC (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )
	unsigned long                                      m_bHasInitializedPassiveEnergy : 1;               		// 0x1CAC (0x0004) [0x0000000000000000] [0x00000002] 
	class UTgSpecialFx*                                c_RainingDartsTargeterSpecialFX;                  		// 0x1CB0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	TArray< class UTgDeviceFire* >                     m_ApocalyseShroudStunDeviceModes;                 		// 0x1CB4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class UTgDeviceFire*                               m_DarkestOfNightsLastFireMode;                    		// 0x1CC0 (0x0004) [0x0000000000000000]              
	TArray< class UTgSpecialFx* >                      c_BolaGlowFXs;                                    		// 0x1CC4 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2844 );

		return pClassPointer;
	};

	void eventTick ( float DeltaSeconds );
	void OnDeviceFormInterruptFire ( int nEquipSlot );
	void OnDeviceFormStopFire ( int nEquipSlot );
	void OnDeviceFormStartFire ( int nEquipSlot, float FireDuration, int nFireMode );
	void ToggleBolaFX ( unsigned long bEnable );
	void SpawnRainingDartProjectile ( class AActor* TargetActor );
	void CalculateRainingDartProjectileTargets ( TArray< class AActor* >* Targets );
	class UTgDeviceFire* GetCurrentSplitProjectileMode ( int* nMode );
	void PostPawnSetupServer ( );
	void SetSpawnEnergy ( );
	bool DeviceOverrideTargetingAim ( class ATgDevice* Dev, struct FAimData* Aim, TArray< struct FImpactInfo >* ImpactList );
	void EndDarkestOfNights ( );
	void DeviceOnStopFire ( class ATgDevice* Dev, unsigned long WasInterrupted );
	void DeviceOnHit ( class ATgDevice* Dev, struct FImpactInfo* Impact );
	void DeviceOnFire ( class ATgDevice* Dev );
	void DeviceOnStartFire ( class ATgDevice* Dev );
	bool InitializeBolaGlowFX ( );
	void InitializeRainingDartsTargeterSpecialFX ( );
	bool eventPostPawnSetup ( );
};

UClass* ATgPawn_Xbalanque::pClassPointer = NULL;

// Class TgGame.TgPawn_XingTian
// 0x0062 (0x1CCE - 0x1C6C)
class ATgPawn_XingTian : public ATgPawn_Character
{
public:
	int                                                c_nMaxRageStacks;                                 		// 0x1C6C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_fOutOfCombatEnrageTimer;                        		// 0x1C70 (0x0004) [0x0000000000000000]              
	float                                              m_fHealingTimer;                                  		// 0x1C74 (0x0004) [0x0000000000000000]              
	int                                                m_nHealthPercentSituationalType;                  		// 0x1C78 (0x0004) [0x0000000000000000]              
	struct FVector                                     m_vCachedPrimaryTarget;                           		// 0x1C7C (0x000C) [0x0000000000000000]              
	struct FAimData                                    m_aCachedShieldBashLocation;                      		// 0x1C88 (0x002C) [0x0000000000000000]              
	unsigned long                                      c_bIsHittable : 1;                                		// 0x1CB4 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      r_SkyCuttingAxeSetAsTargetingDevice : 1;          		// 0x1CB4 (0x0004) [0x0000000000000020] [0x00000002] ( CPF_Net )
	TArray< class UTgAnimNodeBlendList* >              m_HeroicChargeNodes;                              		// 0x1CB8 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FName                                       m_HeroicChargeNodeName;                           		// 0x1CC4 (0x0008) [0x0000000000000000]              
	unsigned char                                      r_CurrentUltimateState;                           		// 0x1CCC (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      c_LocalUltimateState;                             		// 0x1CCD (0x0001) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2845 );

		return pClassPointer;
	};

	void eventTick ( float DeltaSeconds );
	void ForceLeapTargetingIfNeeded ( );
	void OnGrabTargetDetach ( unsigned char endingGrabState, class ATgPawn* Target, unsigned long bInterrupted );
	void OnRightMousePressed ( );
	void EndTween ( unsigned char endingTweenState, unsigned long bInterrupted );
	void BeginTween ( unsigned char newTweenState );
	void OnDeviceFormStartFire ( int nEquipSlot, float FireDuration, int nFireMode );
	void CacheMultiMeshAnimNodeReferences ( class UTgSkeletalMeshComponent* smcomp );
	void ClearMultiMeshAnimNodeReferences ( );
	void eventAddRageStack ( );
	bool eventPostPawnSetup ( );
	void eventSetTargetingDevice ( class ATgDevice* Dev );
	void OnRespawn ( );
	bool ShowImmunityHighlight ( );
	void InitializePassiveVars ( );
	bool GetPassiveAuxMax ( float* fResult );
	bool GetPassiveAux ( float* fResult );
	void DeviceOnStopFire ( class ATgDevice* Dev, unsigned long WasInterrupted );
	void DeviceOnStartFire ( class ATgDevice* Dev );
	void DeviceOnSetFireMode ( class ATgDevice* Dev );
	void DeviceOnHit ( class ATgDevice* Dev, struct FImpactInfo* Impact );
	void DeviceOnStartBuildup ( class ATgDevice* Dev );
};

UClass* ATgPawn_XingTian::pClassPointer = NULL;

// Class TgGame.TgPawn_Ymir
// 0x0038 (0x1CA4 - 0x1C6C)
class ATgPawn_Ymir : public ATgPawn_Character
{
public:
	class UTgSkeletalMeshComponent*                    m_DeathMeshComponent;                             		// 0x1C6C (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class ATgCollisionProxy_Cylinder*                  m_ShardsOfIceCollisionProxy;                      		// 0x1C70 (0x0004) [0x0000000000000000]              
	TArray< class AActor* >                            m_ActorsAffectedByShardsOfIce;                    		// 0x1C74 (0x000C) [0x0000000000500000]              ( CPF_NeedCtorLink )
	float                                              m_fPercentShardsOfIceDamage;                      		// 0x1C80 (0x0004) [0x0000000000000000]              
	float                                              m_fChargeTimeStart;                               		// 0x1C84 (0x0004) [0x0000000000000000]              
	TArray< class UTgAnimNodeYmirShards* >             c_ShardsOfIceBlendNodes;                          		// 0x1C88 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	float                                              m_fShardsOfIceDelay;                              		// 0x1C94 (0x0004) [0x0000000000000002]              ( CPF_Const )
	class UTgDeviceFire*                               s_ShardsOfIceHitMode;                             		// 0x1C98 (0x0004) [0x0000000000000000]              
	class UAudioComponent*                             m_ShardsOfIceAC;                                  		// 0x1C9C (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )
	class UTgSpecialFx*                                m_ShardsOfIceFX;                                  		// 0x1CA0 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2846 );

		return pClassPointer;
	};

	void Destroyed ( );
	void PlayShardsExplosion ( );
	void OnDeviceFormInterruptFire ( int nEquipSlot );
	void OnDeviceFormStopFire ( int nEquipSlot );
	void OnDeviceFormStartFire ( int nEquipSlot, float FireDuration, int nFireMode );
	float ApplyPitchLimit ( float fPitch );
	void CleanUpDyingEffects ( );
	void PlayDyingEffects ( );
	void eventRemoveShardsOfIceSlow ( class AActor* Other );
	void eventApplyShardsOfIceSlow ( class AActor* Other );
	void eventPostInitAnimTree ( class USkeletalMeshComponent* SkelComp );
	void eventShardsOfIceCollisionProxyOnUntouch ( class AActor* Other );
	void eventShardsOfIceCollisionProxyOnTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	bool IgnoreFaceRotationWithInterp ( );
	bool CannotJumpNow ( );
	bool eventCanBePulled ( );
	void eventAudioComponentAttached ( class UAudioComponent* AC, int DatabaseID, int LoopIndex );
	bool PostPawnSetup ( );
	bool InitializeShardsExplosionFX ( );
	void OnPostureChange ( );
	void ApplyShardsOfIceHit ( );
	void EndShardsOfIce ( unsigned long bSkipHit );
	void SpawnIceSpikes ( );
	bool DeviceOnCanDeviceFireNow ( class ATgDevice* Dev, unsigned char FireModeNum, unsigned long bDeviceFailLog, struct FAimData* Aim );
	void DeviceOnFire ( class ATgDevice* Dev );
	void DeviceOnStopFire ( class ATgDevice* Dev, unsigned long WasInterrupted );
	void DeviceOnStartFire ( class ATgDevice* Dev );
	bool DeviceOverrideTargetingAim ( class ATgDevice* Dev, struct FAimData* Aim, TArray< struct FImpactInfo >* ImpactList );
	void DeviceAdjustDamage ( class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage );
};

UClass* ATgPawn_Ymir::pClassPointer = NULL;

// Class TgGame.TgPawn_Zeus
// 0x0038 (0x1CA4 - 0x1C6C)
class ATgPawn_Zeus : public ATgPawn_Character
{
public:
	class UTgMarkComponent_Zeus_Lockon*                m_ChargeComponent;                                		// 0x1C6C (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )
	TArray< class UTgDeviceFire* >                     m_DetonateFxModes;                                		// 0x1C70 (0x000C) [0x0000000000500000]              ( CPF_NeedCtorLink )
	int                                                r_nLocksActive;                                   		// 0x1C7C (0x0004) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      r_eShieldThrowState;                              		// 0x1C80 (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      c_eLocalShieldThrowState;                         		// 0x1C81 (0x0001) [0x0000000000000000]              
	TArray< class USkelControlBase* >                  c_ShieldThrowSkelControls;                        		// 0x1C84 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FName                                       c_ShieldThrowSkelControlName;                     		// 0x1C90 (0x0008) [0x0000000000000000]              
	TArray< class UTgAnimBlendByZeusShieldRecover* >   c_ShieldReturnAnimNodes;                          		// 0x1C98 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2847 );

		return pClassPointer;
	};

	void PlayDying ( class UClass* dmgType, struct FVector HitLoc );
	void ForceShieldAttach ( );
	void QueueUpForceShieldAttach ( );
	void eventTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void UpdateShieldState ( unsigned char NewState );
	void eventOnRespawn ( );
	bool eventDeviceOverrideLockedDown ( class ATgDevice* Dev );
	void eventReplicatedEvent ( struct FName VarName );
	void CacheMultiMeshAnimNodeReferences ( class UTgSkeletalMeshComponent* smcomp );
	void ClearMultiMeshAnimNodeReferences ( );
	void PawnOnDamaged ( struct FOnDamagedParams* Params );
	void DetonateMarks ( );
	void ApplyMark ( class AActor* Target );
	void DeviceAdjustDamage ( class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage );
	void DeviceOnHit ( class ATgDevice* Dev, struct FImpactInfo* Impact );
	void DeviceOnFire ( class ATgDevice* Dev );
	bool DeviceOnCanDeviceFireNow ( class ATgDevice* Dev, unsigned char FireModeNum, unsigned long bDeviceFailLog, struct FAimData* Aim );
};

UClass* ATgPawn_Zeus::pClassPointer = NULL;

// Class TgGame.TgPawn_ZeusV2
// 0x000C (0x1CB0 - 0x1CA4)
class ATgPawn_ZeusV2 : public ATgPawn_Zeus
{
public:
	int                                                m_nMaxPassiveDamageMultiplier;                    		// 0x1CA4 (0x0004) [0x0000000000000000]              
	int                                                m_nPassiveIncreasedDamagePerCharge;               		// 0x1CA8 (0x0004) [0x0000000000000000]              
	class ATgProj_Zeus_LightningBolt*                  m_LightningBolt;                                  		// 0x1CAC (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2848 );

		return pClassPointer;
	};

	void eventSetLightningBolt ( class ATgProj_Zeus_LightningBolt* Proj );
	void EndTween ( unsigned char endingTweenState, unsigned long bInterrupted );
	void BeginTween ( unsigned char newTweenState );
	void DeviceOnSetFireMode ( class ATgDevice* Dev );
	void DetonateMarks ( );
	void DeviceAdjustDamage ( class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage );
	void DeviceOnHit ( class ATgDevice* Dev, struct FImpactInfo* Impact );
};

UClass* ATgPawn_ZeusV2::pClassPointer = NULL;

// Class TgGame.TgPawn_ZhongKui
// 0x01F0 (0x1E5C - 0x1C6C)
class ATgPawn_ZhongKui : public ATgPawn_Character
{
public:
	TArray< int >                                      c_BagFxIds;                                       		// 0x1C6C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UTgSpecialFx* >                      c_BagFxs;                                         		// 0x1C78 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	float                                              c_fBagFxInterval;                                 		// 0x1C84 (0x0004) [0x0000000000000000]              
	unsigned long                                      c_bEnableBagFxLevelZero : 1;                      		// 0x1C88 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      c_bCanPlayBagConsumeFx : 1;                       		// 0x1C88 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      r_bIsExorcismCharged : 1;                         		// 0x1C88 (0x0004) [0x0000000000000020] [0x00000004] ( CPF_Net )
	unsigned long                                      c_bEnableBagMorph : 1;                            		// 0x1C88 (0x0004) [0x0000000000000000] [0x00000008] 
	float                                              c_fLastEnergyChange;                              		// 0x1C8C (0x0004) [0x0000000000000000]              
	int                                                c_nCurrentBagFxLevel;                             		// 0x1C90 (0x0004) [0x0000000000000000]              
	int                                                r_nFierceGlareQueueIndex;                         		// 0x1C94 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                c_nFierceGlareQueueIndex;                         		// 0x1C98 (0x0004) [0x0000000000000000]              
	struct FVector                                     r_FierceGlareLocations[ 0x10 ];                   		// 0x1C9C (0x00C0) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      r_FierceGlareGoToBag[ 0x10 ];                     		// 0x1D5C (0x0010) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      c_eLocalAbsorbState;                              		// 0x1D6C (0x0001) [0x0000000000002000]              ( CPF_Transient )
	float                                              r_FierceGlareReturnTime[ 0x10 ];                  		// 0x1D70 (0x0040) [0x0000000000000020]              ( CPF_Net )
	struct FVector2D                                   m_FierceGlareReturnTimeRange;                     		// 0x1DB0 (0x0008) [0x0000000000000000]              
	TArray< struct FFierceGlareInfo >                  c_FierceGlareInfos;                               		// 0x1DB8 (0x000C) [0x0000000000482000]              ( CPF_Transient | CPF_Component | CPF_NeedCtorLink )
	TArray< class UTgDeviceFire* >                     s_FierceGlareHealModes;                           		// 0x1DC4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< struct FFierceGlareHealInfo >              s_FierceGlareHeals;                               		// 0x1DD0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	float                                              s_FierceGlareHealDelayBase;                       		// 0x1DDC (0x0004) [0x0000000000000000]              
	float                                              c_fBagConsumeFxDelay;                             		// 0x1DE0 (0x0004) [0x0000000000000000]              
	float                                              c_nAbsorbMICPercentage;                           		// 0x1DE4 (0x0004) [0x0000000000000000]              
	int                                                r_nExorcismTicker;                                		// 0x1DE8 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class USkeletalMeshComponent*                      c_Scroll;                                         		// 0x1DEC (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class UTgAnimNodeSlot*                             m_ScrollFullBodyNode;                             		// 0x1DF0 (0x0004) [0x0000000000000000]              
	float                                              c_fBagTime;                                       		// 0x1DF4 (0x0004) [0x0000000000000000]              
	struct FInterpCurveFloat                           m_BagMorphCurve;                                  		// 0x1DF8 (0x0010) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class UMorphNodePose*                              c_BagMorphNode;                                   		// 0x1E08 (0x0004) [0x0000000000000000]              
	float                                              r_ReplicatedBagMorphCurve[ 0xA ];                 		// 0x1E0C (0x0028) [0x0000000000000020]              ( CPF_Net )
	class UTgSkelCon_ZhongKui_BagGrowth*               c_SkelConBag;                                     		// 0x1E34 (0x0004) [0x0000000000000000]              
	float                                              s_fEnergyConsumePerShot;                          		// 0x1E38 (0x0004) [0x0000000000000000]              
	int                                                s_nDemonConsumeCount;                             		// 0x1E3C (0x0004) [0x0000000000000000]              
	class ATgDevice*                                   s_ScrollInHand;                                   		// 0x1E40 (0x0004) [0x0000000000000000]              
	struct FVector                                     m_ScrollInHandOffset;                             		// 0x1E44 (0x000C) [0x0000000000000000]              
	struct FVector                                     m_ScrollEndTraceOffset;                           		// 0x1E50 (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2849 );

		return pClassPointer;
	};

	void eventToggleDemonBagMorph ( unsigned long bEnable );
	void DisableAbsorbGhostMIC ( );
	void UpdateAbsorbGhostMIC ( float DeltaSeconds );
	void EnableAbsorbGhostMIC ( );
	void UpdateBagFxs ( );
	void eventHandleFierceGlareMesh ( class USkeletalMeshComponent* FierceMesh );
	void eventFireScrollInHand ( );
	void ResetBagConsumeFxTimer ( );
	void eventPropertySet ( int nPropertyId, float fPreviousValue, float fNewValue );
	void OnRespawn ( );
	void StopFullBodyAnimation ( float BlendOutTime );
	struct FVector GetFireLocationOffset ( class ATgDevice* Dev );
	void eventSetExorcismCharged ( unsigned long bCharged );
	void ForceExorcismSync ( );
	void OnDeviceFormInterruptFire ( int nEquipSlot );
	void OnDeviceFormStartFire ( int nEquipSlot, float FireDuration, int nFireMode );
	struct FRotator GetAdjustedAimFor ( class AWeapon* W, struct FVector StartFireLoc );
	void Tick ( float DeltaSeconds );
	void CacheMainMeshReferences ( class UTgSkeletalMeshComponent* smcomp );
	void eventPostInitAnimTree ( class USkeletalMeshComponent* SkelComp );
	void eventReceivedPropValues ( );
	void eventPreDemoRewind ( );
	void eventReplicatedEvent ( struct FName VarName );
	bool eventPostPawnSetup ( );
	bool ConsumeDemon ( );
	bool RemoveFierceGlareInfo ( int nIndex );
	void UpdateFierceGlareLocations ( );
	void FlashFierceGlare ( struct FVector Loc, float ReturnTime, unsigned long bGoToBag );
	void MakeBagMorphCurveFromReplicatedData ( );
	bool InitializeBagOfDemonsFXs ( );
	int GetPassiveStackCount ( );
	struct FVector CalcScrollProjEndTrace ( struct FAimData* BasicAim );
	bool DeviceOverrideTargetingAim ( class ATgDevice* Dev, struct FAimData* Aim, TArray< struct FImpactInfo >* ImpactList );
	void DeviceOnSetFireMode ( class ATgDevice* Dev );
	void DeviceOnHit ( class ATgDevice* Dev, struct FImpactInfo* Impact );
	void DeviceAdjustDamage ( class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage );
	void DeviceOnFire ( class ATgDevice* Dev );
	void DeviceOnStartFire ( class ATgDevice* Dev );
	void AdjustMeshTranslation ( );
	bool PlayFullBodyAnim ( struct FName AnimName, float Rate, float BlendInTime, float BlendOutTime, unsigned long bLooping, unsigned long bOverride, unsigned long bBlendOutIfVelocityIsGreaterThanZero, unsigned long bHideInHandDevice );
	void SetMeshVisibility ( unsigned long bVisible );
	void InitScrollMesh ( );
	void SwapToLiveMesh ( );
};

UClass* ATgPawn_ZhongKui::pClassPointer = NULL;

// Class TgGame.TgPawn_Guardian
// 0x0070 (0x1C8C - 0x1C1C)
class ATgPawn_Guardian : public ATgPawn_Biped
{
public:
	float                                              s_fLastDamageTime;                                		// 0x1C1C (0x0004) [0x0000000000000000]              
	float                                              s_fDamageNotificationDelay;                       		// 0x1C20 (0x0004) [0x0000000000000000]              
	class UTgMarkComponent*                            s_DamageScaler;                                   		// 0x1C24 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	int                                                m_RestPostureID;                                  		// 0x1C28 (0x0004) [0x0000000000000000]              
	int                                                m_ThronePostureID;                                		// 0x1C2C (0x0004) [0x0000000000000000]              
	int                                                s_nCurrentLevel;                                  		// 0x1C30 (0x0004) [0x0000000000000000]              
	unsigned long                                      s_bWillHeal : 1;                                  		// 0x1C34 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_IsInTransition : 1;                             		// 0x1C34 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_bDeathCameraIntialized : 1;                     		// 0x1C34 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned char                                      r_ThroneState;                                    		// 0x1C38 (0x0001) [0x0000000000000020]              ( CPF_Net )
	class UTgSkeletalMeshComponent*                    m_DeathMeshComponent;                             		// 0x1C3C (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	struct FVector                                     m_vCameraLocation;                                		// 0x1C40 (0x000C) [0x0000000000000000]              
	struct FRotator                                    m_rCameraRotation;                                		// 0x1C4C (0x000C) [0x0000000000000000]              
	float                                              m_fDeathCamTweenSpeed;                            		// 0x1C58 (0x0004) [0x0000000000000000]              
	struct FVector                                     m_vDeathCamTweenDir;                              		// 0x1C5C (0x000C) [0x0000000000000000]              
	struct FRotator                                    m_rTargetDeathCamRotation;                        		// 0x1C68 (0x000C) [0x0000000000000000]              
	float                                              m_fQueuedTotalDeathCamRotationTime;               		// 0x1C74 (0x0004) [0x0000000000000000]              
	struct FRotator                                    m_rQueuedTargetRotation;                          		// 0x1C78 (0x000C) [0x0000000000000000]              
	float                                              m_fRemainingDeathCamRotationTime;                 		// 0x1C84 (0x0004) [0x0000000000000000]              
	float                                              m_fTotalDeathCamRotationTime;                     		// 0x1C88 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2850 );

		return pClassPointer;
	};

	void FindGoodViewPoint ( struct FVector* Loc, struct FRotator* Rot );
	void StartDeathCamRotation ( );
	void eventOnCameraCutAnimNotify ( class UTgAnimNotify_CameraCut* CameraCutNotify );
	void eventCompletedTransition ( );
	bool DeviceOnCanDeviceFireNow ( class ATgDevice* Dev, unsigned char FireModeNum, unsigned long bDeviceFailLog, struct FAimData* Aim );
	void CleanUpDyingEffects ( );
	void PlayDyingEffects ( );
	void GetOffThroneEnd ( );
	void eventGetOffThroneStart ( );
	void eventBump ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitNormal );
	void eventSetInitialState ( );
	bool eventIsIdle ( );
	void eventTakeDamage ( int Damage, class AController* InstigatedBy, struct FVector HitLocation, struct FVector Momentum, class UClass* DamageType, struct FTraceHitInfo HitInfo, class AActor* DamageCauser );
	bool eventDied ( class AController* Killer, class UClass* dmgType, struct FVector HitLocation );
	void PossessedBy ( class AController* C, unsigned long bVehicleTransition );
	void eventReplicatedEvent ( struct FName VarName );
	void RegainPools ( float fDelta );
	bool CanMove ( );
	void PostPawnSetupServer ( );
	void UpdateLevel ( );
	void TriggerResetHeal ( );
	void PawnOnExitCombat ( );
	void PawnOnDamaged ( struct FOnDamagedParams* Params );
	void PawnOnDamageMitigation ( class ATgPawn* attacker, class UTgEffectGroup* eg, int nPropertyId, float* fDamage );
	void CheckLastTarget ( );
	void DeviceOnDamaged ( struct FOnDamagedParams* Params );
	void DeviceAdjustDamage ( class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage );
	void SetTargetActor ( class AActor* Target );
	void SendDeathAlert ( );
	void SendAttackAlert ( );
};

UClass* ATgPawn_Guardian::pClassPointer = NULL;

// Class TgGame.TgPawn_Minotaur
// 0x0000 (0x1C8C - 0x1C8C)
class ATgPawn_Minotaur : public ATgPawn_Guardian
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2851 );

		return pClassPointer;
	};

};

UClass* ATgPawn_Minotaur::pClassPointer = NULL;

// Class TgGame.TgPawn_Manticore
// 0x0000 (0x1C1C - 0x1C1C)
class ATgPawn_Manticore : public ATgPawn_Biped
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2852 );

		return pClassPointer;
	};

	void eventTakeDamage ( int Damage, class AController* InstigatedBy, struct FVector HitLocation, struct FVector Momentum, class UClass* DamageType, struct FTraceHitInfo HitInfo, class AActor* DamageCauser );
	void UpdateLevel ( );
};

UClass* ATgPawn_Manticore::pClassPointer = NULL;

// Class TgGame.TgPawn_Minion
// 0x0008 (0x1C24 - 0x1C1C)
class ATgPawn_Minion : public ATgPawn_Biped
{
public:
	float                                              s_fSpeedMultiplierToCatchUpToSquad;               		// 0x1C1C (0x0004) [0x0000000000000000]              
	class ATgPawn_Character*                           s_PlayerAttacker;                                 		// 0x1C20 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2853 );

		return pClassPointer;
	};

	void PlayDeathAnimation ( );
	void ToggleAggroAlert ( unsigned long bOn );
	void eventReplicatedEvent ( struct FName VarName );
	void eventTargetActorUpdated ( );
	void RememberPlayerAttackerExpired ( );
	void eventTakeDamage ( int Damage, class AController* InstigatedBy, struct FVector HitLocation, struct FVector Momentum, class UClass* DamageType, struct FTraceHitInfo HitInfo, class AActor* DamageCauser );
	void eventDespawn ( );
	bool CanDespawn ( );
	void SetTargetActor ( class AActor* Target );
	void PostPawnSetupServer ( );
	void SetInitialLevel ( );
	void PawnOnDamageMitigation ( class ATgPawn* attacker, class UTgEffectGroup* eg, int nPropertyId, float* fDamage );
	void DeviceAdjustDamage ( class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage );
};

UClass* ATgPawn_Minion::pClassPointer = NULL;

// Class TgGame.TgPawn_Chicken_PVE
// 0x0008 (0x1C2C - 0x1C24)
class ATgPawn_Chicken_PVE : public ATgPawn_Minion
{
public:
	unsigned long                                      r_bUnhatched : 1;                                 		// 0x1C24 (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )
	int                                                c_nHatchedPostureId;                              		// 0x1C28 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2854 );

		return pClassPointer;
	};

	void Tick ( float DeltaSeconds );
};

UClass* ATgPawn_Chicken_PVE::pClassPointer = NULL;

// Class TgGame.TgPawn_LanePusher
// 0x000C (0x1C30 - 0x1C24)
class ATgPawn_LanePusher : public ATgPawn_Minion
{
public:
	float                                              s_fTimeSinceLastPing;                             		// 0x1C24 (0x0004) [0x0000000000000000]              
	unsigned char                                      c_eDestroyedAnimStage;                            		// 0x1C28 (0x0001) [0x0000000000000000]              
	class UTgSpecialFx*                                c_BeamFX;                                         		// 0x1C2C (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2855 );

		return pClassPointer;
	};

	void eventReceivedPropValues ( );
	void Tick ( float DeltaSeconds );
	void eventModifyHealthProp ( int nDamage );
	void OnPawnDied ( );
	void SetInitialLevel ( );
	void SendPing ( );
};

UClass* ATgPawn_LanePusher::pClassPointer = NULL;

// Class TgGame.TgPawn_Juggernaut
// 0x007C (0x1CAC - 0x1C30)
class ATgPawn_Juggernaut : public ATgPawn_LanePusher
{
public:
	struct FVector                                     m_vArcherNestOffset;                              		// 0x1C30 (0x000C) [0x0000000000000000]              
	struct FVector                                     m_vArcherFiringOffsets[ 0x2 ];                    		// 0x1C3C (0x0018) [0x0000000000000000]              
	TArray< class UAnimNodeBlend* >                    c_ActiveArcherBlendNodes;                         		// 0x1C54 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FName                                       c_ActiveArcherBlendName;                          		// 0x1C60 (0x0008) [0x0000000000000000]              
	unsigned char                                      r_eActiveArcher;                                  		// 0x1C68 (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      c_eLocalActiveArcher;                             		// 0x1C69 (0x0001) [0x0000000000000000]              
	float                                              c_fActiveArcherBlendTime;                         		// 0x1C6C (0x0004) [0x0000000000000000]              
	TArray< struct FMinionSpawnInfo >                  m_MinionSpawnProfiles;                            		// 0x1C70 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                r_nActiveMinionSpawnProfile;                      		// 0x1C7C (0x0004) [0x0000000000000020]              ( CPF_Net )
	class AActor*                                      r_SpawnedMinions[ 0x2 ];                          		// 0x1C80 (0x0008) [0x0000000000000020]              ( CPF_Net )
	class USkelControlBase*                            c_MinionSkelControls[ 0x2 ];                      		// 0x1C88 (0x0008) [0x0000000000000000]              
	struct FName                                       c_MinionSkelControlNames[ 0x2 ];                  		// 0x1C90 (0x0010) [0x0000000000000000]              
	int                                                m_nMinionBotId;                                   		// 0x1CA0 (0x0004) [0x0000000000000002]              ( CPF_Const )
	int                                                m_nMinionSkinId[ 0x2 ];                           		// 0x1CA4 (0x0008) [0x0000000000000002]              ( CPF_Const )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2856 );

		return pClassPointer;
	};

	void eventScaleOutMinions ( );
	void eventUpdateActiveArcher ( unsigned char NewArcher );
	void PlayDying ( class UClass* dmgType, struct FVector HitLoc );
	struct FName GetDeathAnimName ( );
	void eventReplicatedEvent ( struct FName VarName );
	void CacheMultiMeshAnimNodeReferences ( class UTgSkeletalMeshComponent* smcomp );
	void CacheMainMeshReferences ( class UTgSkeletalMeshComponent* smcomp );
	void ClearMultiMeshAnimNodeReferences ( );
	void PostPawnSetupServer ( );
	void SpawnMinions ( );
};

UClass* ATgPawn_Juggernaut::pClassPointer = NULL;

// Class TgGame.TgPawn_SiegeMinion
// 0x0000 (0x1C24 - 0x1C24)
class ATgPawn_SiegeMinion : public ATgPawn_Minion
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2857 );

		return pClassPointer;
	};

};

UClass* ATgPawn_SiegeMinion::pClassPointer = NULL;

// Class TgGame.TgPawn_WiseCleric
// 0x0001 (0x1C25 - 0x1C24)
class ATgPawn_WiseCleric : public ATgPawn_SiegeMinion
{
public:
	unsigned char                                      c_eDestroyAnimStage;                              		// 0x1C24 (0x0001) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2858 );

		return pClassPointer;
	};

	void PostPawnSetupServer ( );
	void eventReceivedPropValues ( );
	void eventModifyHealthProp ( int nDamage );
	void eventDespawn ( );
};

UClass* ATgPawn_WiseCleric::pClassPointer = NULL;

// Class TgGame.TgPawn_Monster
// 0x0020 (0x1C3C - 0x1C1C)
class ATgPawn_Monster : public ATgPawn_Biped
{
public:
	float                                              m_fSecondsBeforeRest;                             		// 0x1C1C (0x0004) [0x0000000000000000]              
	int                                                m_RestPostureID;                                  		// 0x1C20 (0x0004) [0x0000000000000000]              
	int                                                m_FussyPostureID;                                 		// 0x1C24 (0x0004) [0x0000000000000000]              
	int                                                s_nApplyOnDeathItemId;                            		// 0x1C28 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bResetHealthOnEvade : 1;                        		// 0x1C2C (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bLookAtAggressor : 1;                           		// 0x1C2C (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      r_bAggressorInLeashVolume : 1;                    		// 0x1C2C (0x0004) [0x0000000000000020] [0x00000004] ( CPF_Net )
	unsigned long                                      m_bTrackObjectiveSteal : 1;                       		// 0x1C2C (0x0004) [0x0000000000000000] [0x00000008] 
	class AActor*                                      s_BestAggressor;                                  		// 0x1C30 (0x0004) [0x0000000000000000]              
	int                                                m_nTaskforceDamage[ 0x2 ];                        		// 0x1C34 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2859 );

		return pClassPointer;
	};

	void NotifyTouchers ( );
	void eventSetCustomLightingChannels ( );
	bool StartIdleInRestPosture ( struct FName PrevStateName );
	void RemoveHealthRegenBuff ( );
	void ApplyHealthRegenBuff ( );
	void EnterRestPosture ( );
	void UpdateAgressorInLeashVolume ( unsigned long bInVolume );
	void eventSetInitialState ( );
	void eventLanded ( struct FVector HitNormal, class AActor* FloorActor );
	void eventIntoxicate ( unsigned long bIntoxicated, float Duration, int FxId );
	void eventStun ( unsigned long bStunController, unsigned char eType );
	bool eventIsFussy ( );
	bool eventIsEvading ( );
	bool eventIsIdle ( );
	void eventReplicatedEvent ( struct FName VarName );
	void TrackDamageTaken ( class ATgPawn* theInstigator, int nDamage, int nDamageType );
	void PawnOnDamageMitigation ( class ATgPawn* attacker, class UTgEffectGroup* eg, int nPropertyId, float* fDamage );
	bool CheckForAggressorInLeashVolume ( );
	bool IsNonCombat ( );
	void SetTargetActor ( class AActor* Target );
	void PostPawnSetupServer ( );
	void SetInitialLevel ( );
	void ApplyDeathItem ( class AController* Killer );
};

UClass* ATgPawn_Monster::pClassPointer = NULL;

// Class TgGame.TgPawn_Centaur
// 0x0000 (0x1C3C - 0x1C3C)
class ATgPawn_Centaur : public ATgPawn_Monster
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2860 );

		return pClassPointer;
	};

};

UClass* ATgPawn_Centaur::pClassPointer = NULL;

// Class TgGame.TgPawn_Cyclops
// 0x0000 (0x1C3C - 0x1C3C)
class ATgPawn_Cyclops : public ATgPawn_Monster
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2861 );

		return pClassPointer;
	};

	void ApplyDeathItem ( class AController* Killer );
};

UClass* ATgPawn_Cyclops::pClassPointer = NULL;

// Class TgGame.TgPawn_Apep
// 0x0000 (0x1C3C - 0x1C3C)
class ATgPawn_Apep : public ATgPawn_Cyclops
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2862 );

		return pClassPointer;
	};

	void PlayTeleportFx ( int nTeleportState, struct FVector vLoc );
};

UClass* ATgPawn_Apep::pClassPointer = NULL;

// Class TgGame.TgPawn_Cyclops_Dom2016a
// 0x0000 (0x1C3C - 0x1C3C)
class ATgPawn_Cyclops_Dom2016a : public ATgPawn_Monster
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2863 );

		return pClassPointer;
	};

	void ApplyDeathItem ( class AController* Killer );
};

UClass* ATgPawn_Cyclops_Dom2016a::pClassPointer = NULL;

// Class TgGame.TgPawn_Elemental
// 0x0000 (0x1C3C - 0x1C3C)
class ATgPawn_Elemental : public ATgPawn_Monster
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2864 );

		return pClassPointer;
	};

	void PossessedBy ( class AController* C, unsigned long bVehicleTransition );
	void ApplyDeathItem ( class AController* Killer );
};

UClass* ATgPawn_Elemental::pClassPointer = NULL;

// Class TgGame.TgPawn_FireGiant
// 0x0010 (0x1C4C - 0x1C3C)
class ATgPawn_FireGiant : public ATgPawn_Monster
{
public:
	unsigned long                                      m_IsInTransition : 1;                             		// 0x1C3C (0x0004) [0x0000000000000000] [0x00000001] 
	float                                              m_fInitialTransitionTime;                         		// 0x1C40 (0x0004) [0x0000000000000000]              
	float                                              m_fRegularTransitionTime;                         		// 0x1C44 (0x0004) [0x0000000000000000]              
	class UParticleSystemComponent*                    m_FlamingBoulderPSC;                              		// 0x1C48 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2865 );

		return pClassPointer;
	};

	void eventSetCustomLightingChannels ( );
	void Tick ( float fDeltaTime );
	void eventCompletedTransition ( );
	void PlayInitialSpawnFX ( );
	void PostBeginPlay ( );
	bool Died ( class AController* Killer, class UClass* dmgType, struct FVector HitLocation );
	bool DeviceOnCanDeviceFireNow ( class ATgDevice* Dev, unsigned char FireModeNum, unsigned long bDeviceFailLog, struct FAimData* Aim );
	void OnDeviceFormStopFire ( int nEquipSlot );
	void OnDeviceFormStartFire ( int nEquipSlot, float FireDuration, int nFireMode );
	void DeviceOnStartFire ( class ATgDevice* Dev );
	bool CanMove ( );
	bool AreAnyOtherOffhandsLockingFiring ( class ATgDevice* CurrentDevice );
	void ApplyDeathItem ( class AController* Killer );
	void SendDeathAlert ( int taskforce );
};

UClass* ATgPawn_FireGiant::pClassPointer = NULL;

// Class TgGame.TgPawn_FireGiant_GC2015a
// 0x0020 (0x1C6C - 0x1C4C)
class ATgPawn_FireGiant_GC2015a : public ATgPawn_FireGiant
{
public:
	float                                              fSpawnFromChestIntroTime;                         		// 0x1C4C (0x0004) [0x0000000000000000]              
	float                                              fChestTriggeredTime;                              		// 0x1C50 (0x0004) [0x0000000000000000]              
	unsigned long                                      bChestTriggered : 1;                              		// 0x1C54 (0x0004) [0x0000000000000000] [0x00000001] 
	int                                                nChestIntroMeshAssembyForAnimSetsId;              		// 0x1C58 (0x0004) [0x0000000000000000]              
	TArray< class UAnimSet* >                          FromChestAnimSets;                                		// 0x1C5C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FPointer                                    ChestIntroMeshAssembyForAnimSets;                 		// 0x1C68 (0x0004) [0x0000000000001000]              ( CPF_Native )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2866 );

		return pClassPointer;
	};

	bool StartIdleInRestPosture ( struct FName PrevStateName );
	void AttemptToTriggerChest ( );
	void SetChestOpened ( );
	void eventDoIntroduction ( unsigned long bUseInitialIntro );
	void eventReplicatedEvent ( struct FName VarName );
	void SwapToLiveMesh ( );
};

UClass* ATgPawn_FireGiant_GC2015a::pClassPointer = NULL;

// Class TgGame.TgPawn_SiegeBoss
// 0x0010 (0x1C7C - 0x1C6C)
class ATgPawn_SiegeBoss : public ATgPawn_FireGiant_GC2015a
{
public:
	TArray< class ATgPawn* >                           s_Attackers;                                      		// 0x1C6C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                s_nBackupDeployableId;                            		// 0x1C78 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2867 );

		return pClassPointer;
	};

	bool GiveDevice ( int nItemId, class ATgInventoryManager* TargetInv );
	void PawnOnDamaged ( struct FOnDamagedParams* Params );
	void ApplyDeathItem ( class AController* Killer );
};

UClass* ATgPawn_SiegeBoss::pClassPointer = NULL;

// Class TgGame.TgPawn_Fury
// 0x0000 (0x1C3C - 0x1C3C)
class ATgPawn_Fury : public ATgPawn_Monster
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2868 );

		return pClassPointer;
	};

	void ApplyDeathItem ( class AController* Killer );
};

UClass* ATgPawn_Fury::pClassPointer = NULL;

// Class TgGame.TgPawn_GoldFury
// 0x0000 (0x1C3C - 0x1C3C)
class ATgPawn_GoldFury : public ATgPawn_Fury
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2869 );

		return pClassPointer;
	};

	void eventSetCustomLightingChannels ( );
	bool Died ( class AController* Killer, class UClass* dmgType, struct FVector HitLocation );
	void ApplyDeathItem ( class AController* Killer );
	void SendDeathAlert ( int taskforce );
};

UClass* ATgPawn_GoldFury::pClassPointer = NULL;

// Class TgGame.TgPawn_GoldFury_GC2015a
// 0x0030 (0x1C6C - 0x1C3C)
class ATgPawn_GoldFury_GC2015a : public ATgPawn_GoldFury
{
public:
	float                                              fSpawnFromInitialIntroTime;                       		// 0x1C3C (0x0004) [0x0000000000000000]              
	unsigned long                                      bInitialIntroSetLoaded : 1;                       		// 0x1C40 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      bSpectatorInitialIntroSetLoaded : 1;              		// 0x1C40 (0x0004) [0x0000000000000000] [0x00000002] 
	int                                                nInitialIntroMeshAssembyForAnimSetsId;            		// 0x1C44 (0x0004) [0x0000000000000000]              
	TArray< class UAnimSet* >                          InitialIntroAnimSets;                             		// 0x1C48 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FPointer                                    InitialIntroMeshAssembyForAnimSets;               		// 0x1C54 (0x0004) [0x0000000000001000]              ( CPF_Native )
	int                                                nSpectatorInitialIntroMeshAssembyForAnimSetsId;   		// 0x1C58 (0x0004) [0x0000000000000000]              
	TArray< class UAnimSet* >                          SpectatorInitialIntroAnimSets;                    		// 0x1C5C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FPointer                                    SpectatorInitialIntroMeshAssembyForAnimSets;      		// 0x1C68 (0x0004) [0x0000000000001000]              ( CPF_Native )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2870 );

		return pClassPointer;
	};

	bool StartIdleInRestPosture ( struct FName PrevStateName );
	void eventDoIntroduction ( unsigned long bUseInitialIntro );
	void SwapToLiveMesh ( );
};

UClass* ATgPawn_GoldFury_GC2015a::pClassPointer = NULL;

// Class TgGame.TgPawn_JoustBoss
// 0x0004 (0x1C40 - 0x1C3C)
class ATgPawn_JoustBoss : public ATgPawn_GoldFury
{
public:
	int                                                s_nStructureDebuffItemId;                         		// 0x1C3C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2871 );

		return pClassPointer;
	};

	void ApplyDeathItemToStructures ( class AController* Killer );
	void ApplyDeathItem ( class AController* Killer );
};

UClass* ATgPawn_JoustBoss::pClassPointer = NULL;

// Class TgGame.TgPawn_JuggernautJungle
// 0x0004 (0x1C40 - 0x1C3C)
class ATgPawn_JuggernautJungle : public ATgPawn_GoldFury
{
public:
	unsigned long                                      m_bMeshSwapped : 1;                               		// 0x1C3C (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2872 );

		return pClassPointer;
	};

	void OnSwapToDestroyedMesh ( );
	void eventPlayDeathAnimation ( );
	void PossessedBy ( class AController* C, unsigned long bVehicleTransition );
	void SendDeathAlert ( int taskforce );
};

UClass* ATgPawn_JuggernautJungle::pClassPointer = NULL;

// Class TgGame.TgPawn_Familiar
// 0x0064 (0x1B8C - 0x1B28)
class ATgPawn_Familiar : public ATgPawn
{
public:
	float                                              m_fOwnerPhysPowerBotPercent;                      		// 0x1B28 (0x0004) [0x0000000000000000]              
	float                                              m_fOwnerPhysPowerItemPercent;                     		// 0x1B2C (0x0004) [0x0000000000000000]              
	float                                              m_fOwnerMagicalPowerBotPercent;                   		// 0x1B30 (0x0004) [0x0000000000000000]              
	float                                              m_fOwnerMagicalPowerItemPercent;                  		// 0x1B34 (0x0004) [0x0000000000000000]              
	float                                              m_fOwnerUltilityPowerItemPercent;                 		// 0x1B38 (0x0004) [0x0000000000000000]              
	float                                              m_fOwnerFlatPenetrationPercent;                   		// 0x1B3C (0x0004) [0x0000000000000000]              
	float                                              m_fOwnerPercPenetrationPercent;                   		// 0x1B40 (0x0004) [0x0000000000000000]              
	float                                              m_fOwnerAttackSpeedPercent;                       		// 0x1B44 (0x0004) [0x0000000000000000]              
	float                                              m_fOwnerPhysicalProtectionPercent;                		// 0x1B48 (0x0004) [0x0000000000000000]              
	float                                              m_fOwnerMagicalProtectionPercent;                 		// 0x1B4C (0x0004) [0x0000000000000000]              
	float                                              m_fOwnerHealthProtectionPercent;                  		// 0x1B50 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bAffectedByBumbas : 1;                          		// 0x1B54 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      s_bLastPositionAdjustmentRotationValid : 1;       		// 0x1B54 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned char                                      s_PetPhase;                                       		// 0x1B58 (0x0001) [0x0000000000000000]              
	unsigned char                                      s_PetPosition;                                    		// 0x1B59 (0x0001) [0x0000000000000000]              
	struct FRotator                                    s_LastPositionAdjustmentRotation;                 		// 0x1B5C (0x000C) [0x0000000000000000]              
	struct FVector                                     s_InterpolatedPetPosition;                        		// 0x1B68 (0x000C) [0x0000000000000000]              
	struct FVector                                     s_InterpolatedPetOwnerPosition;                   		// 0x1B74 (0x000C) [0x0000000000000000]              
	float                                              s_fPetPositionDistanceMultiplier;                 		// 0x1B80 (0x0004) [0x0000000000000000]              
	float                                              s_fOwnerVelocityTime;                             		// 0x1B84 (0x0004) [0x0000000000000000]              
	float                                              s_fSmoothedMaxSpeed;                              		// 0x1B88 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2873 );

		return pClassPointer;
	};

	void eventUpdatePetPhase ( unsigned char NewPhase );
	bool TakeDamageSpecial ( int Damage, class AController* InstigatedBy, struct FVector HitLocation, struct FVector Momentum, class UClass* DamageType, struct FTraceHitInfo HitInfo, class AActor* DamageCauser );
	void eventTakeDamage ( int Damage, class AController* InstigatedBy, struct FVector HitLocation, struct FVector Momentum, class UClass* DamageType, struct FTraceHitInfo HitInfo, class AActor* DamageCauser );
	void EffectGroupOnApplied ( class UTgEffectGroup* effectGroup, unsigned long bInterval );
	void EffectGroupOnSetActive ( unsigned long bActive, unsigned long bRemoving, class UTgEffectGroup* effectGroup );
	void DeviceOnKilled ( class ATgDevice* Dev, float fDamage, struct FImpactInfo* Impact );
	void DeviceOnDamaged ( struct FOnDamagedParams* Params );
	void DeviceOnHit ( class ATgDevice* Dev, struct FImpactInfo* Impact );
	void DeviceAdjustDamage ( class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage );
	void PostPawnSetupServer ( );
	float GetMagicalProtection ( );
	float GetPhysicalProtection ( );
	float GetAttackSpeed ( );
	float GetPercPenetration ( int nProtectionType, class AActor* Target );
	float GetFlatPenetration ( int nProtectionType, class AActor* Target );
	float GetUtilityPowerItem ( );
	float GetMagicalPowerItem ( struct FImpactInfo Impact, float PowerScaling );
	float GetMagicalPowerBot ( );
	float GetPhysicalPowerItem ( struct FImpactInfo Impact, float PowerScaling );
	float GetPhysicalPowerBot ( );
};

UClass* ATgPawn_Familiar::pClassPointer = NULL;

// Class TgGame.TgPawn_AhMuzenCab_BeeFlock
// 0x0008 (0x1B94 - 0x1B8C)
class ATgPawn_AhMuzenCab_BeeFlock : public ATgPawn_Familiar
{
public:
	class ATgDeployable_AhMuzenCab_Hive*               m_TargetHive;                                     		// 0x1B8C (0x0004) [0x0000000000000000]              
	class ATgCollisionProxy*                           s_CollisionProxy;                                 		// 0x1B90 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2874 );

		return pClassPointer;
	};

	void JumpOffPawn ( );
	void eventBaseChange ( );
	void eventDestroyed ( );
};

UClass* ATgPawn_AhMuzenCab_BeeFlock::pClassPointer = NULL;

// Class TgGame.TgPawn_Arachne_Broodling
// 0x0000 (0x1B8C - 0x1B8C)
class ATgPawn_Arachne_Broodling : public ATgPawn_Familiar
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2875 );

		return pClassPointer;
	};

	void PlayInitialSpawnFX ( );
};

UClass* ATgPawn_Arachne_Broodling::pClassPointer = NULL;

// Class TgGame.TgPawn_Arachne_Broodling_PVE
// 0x0004 (0x1B90 - 0x1B8C)
class ATgPawn_Arachne_Broodling_PVE : public ATgPawn_Arachne_Broodling
{
public:
	unsigned long                                      m_bSpecialDamage : 1;                             		// 0x1B8C (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2876 );

		return pClassPointer;
	};

	bool TakeDamageSpecial ( int Damage, class AController* InstigatedBy, struct FVector HitLocation, struct FVector Momentum, class UClass* DamageType, struct FTraceHitInfo HitInfo, class AActor* DamageCauser );
	void PawnOnDamaged ( struct FOnDamagedParams* Params );
};

UClass* ATgPawn_Arachne_Broodling_PVE::pClassPointer = NULL;

// Class TgGame.TgPawn_Artemis_Boar
// 0x0024 (0x1BB0 - 0x1B8C)
class ATgPawn_Artemis_Boar : public ATgPawn_Familiar
{
public:
	TArray< class UTgDeviceFire* >                     m_RushMinionKnockupDeviceModes;                   		// 0x1B8C (0x000C) [0x0000000000500000]              ( CPF_NeedCtorLink )
	class ATgCollisionProxy_Cylinder*                  m_ChargeCollisionProxy;                           		// 0x1B98 (0x0004) [0x0000000000000000]              
	TArray< class AActor* >                            m_HitActors;                                      		// 0x1B9C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	unsigned long                                      m_ShouldSuicide : 1;                              		// 0x1BA8 (0x0004) [0x0000000000000000] [0x00000001] 
	int                                                m_nChargePostureId;                               		// 0x1BAC (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2877 );

		return pClassPointer;
	};

	void EndTween ( unsigned char endingTweenState, unsigned long bInterrupted );
	void BeginTween ( unsigned char newTweenState );
	struct FVector eventGetPhysTweenTargetLocation ( );
	void eventProxyTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void Suicide ( );
	void eventTick ( float DeltaTime );
	bool CanSeeActor ( class AActor* Other );
	void DeviceOnStopFire ( class ATgDevice* Dev, unsigned long WasInterrupted );
	void DeviceOnHit ( class ATgDevice* Dev, struct FImpactInfo* Impact );
	void DeviceOnStartFire ( class ATgDevice* Dev );
	void PostPawnSetupServer ( );
};

UClass* ATgPawn_Artemis_Boar::pClassPointer = NULL;

// Class TgGame.TgPawn_Bastet_Cat
// 0x0000 (0x1B8C - 0x1B8C)
class ATgPawn_Bastet_Cat : public ATgPawn_Familiar
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2878 );

		return pClassPointer;
	};

	struct FName eventGetDeathAnimName ( );
};

UClass* ATgPawn_Bastet_Cat::pClassPointer = NULL;

// Class TgGame.TgPawn_Chiron_Arrow
// 0x0044 (0x1BD0 - 0x1B8C)
class ATgPawn_Chiron_Arrow : public ATgPawn_Familiar
{
public:
	class ATgCollisionProxy*                           s_CollisionProxy;                                 		// 0x1B8C (0x0004) [0x0000000000000000]              
	class UTgDeviceFire*                               s_OwnerFireMode;                                  		// 0x1B90 (0x0004) [0x0000000000000000]              
	TArray< class AActor* >                            s_HitActors;                                      		// 0x1B94 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                s_nFiringInstance;                                		// 0x1BA0 (0x0004) [0x0000000000000000]              
	struct FVector                                     s_vSpawnLocation;                                 		// 0x1BA4 (0x000C) [0x0000000000000000]              
	float                                              s_fRange;                                         		// 0x1BB0 (0x0004) [0x0000000000000000]              
	float                                              s_fProximityDistance;                             		// 0x1BB4 (0x0004) [0x0000000000000000]              
	TArray< struct FVector >                           s_WallEntrances;                                  		// 0x1BB8 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FVector                                     s_LastLocation;                                   		// 0x1BC4 (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2879 );

		return pClassPointer;
	};

	void eventProxyUnTouch ( class AActor* Other );
	void eventProxyTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void Tick ( float DeltaSeconds );
	void FaceRotation ( struct FRotator NewRotation, float DeltaTime );
	bool CheckProjectileRange ( struct FVector vLocOverride );
	bool IsNonCombat ( );
};

UClass* ATgPawn_Chiron_Arrow::pClassPointer = NULL;

// Class TgGame.TgPawn_Familiar_LongTerm
// 0x0024 (0x1BB0 - 0x1B8C)
class ATgPawn_Familiar_LongTerm : public ATgPawn_Familiar
{
public:
	struct FString                                     PetSoundSuffix;                                   		// 0x1B8C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	float                                              m_fOwnerGroundSpeedPercent;                       		// 0x1B98 (0x0004) [0x0000000000000000]              
	float                                              m_fLastInheritedGroundSpeed;                      		// 0x1B9C (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bBoostTexturesForLocalOwner : 1;                		// 0x1BA0 (0x0004) [0x0000000000000000] [0x00000001] 
	TArray< struct FTG_HUD_INFO >                      c_HudInfos;                                       		// 0x1BA4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2880 );

		return pClassPointer;
	};

	void PlaySpawnFx ( );
	void PrepareIntro ( );
	void eventUpdatePetPhase ( unsigned char NewPhase );
	void OnOwnerAddPercentVitals ( float pctHealth );
	void OnOwnerGivenPercentVitals ( float pctHealth );
	void OnOwnerGivenFullVitals ( );
	void OnOwnerPostTeleport ( );
	void OnOwnerJumped ( );
	struct FString GetEmoteCustomSuffix ( unsigned char Emote, int ExtraInfo );
	bool OwnerPlayedSound ( class USoundCue* Cue );
	void UpdateGroundSpeed ( );
	void OnOwnerGroundSpeedChange ( );
};

UClass* ATgPawn_Familiar_LongTerm::pClassPointer = NULL;

// Class TgGame.TgPawn_Courier
// 0x0020 (0x1BD0 - 0x1BB0)
class ATgPawn_Courier : public ATgPawn_Familiar_LongTerm
{
public:
	struct FCourierPhaseState                          r_CourierPhaseState;                              		// 0x1BB0 (0x0008) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      m_DefaultCourierPhase;                            		// 0x1BB8 (0x0001) [0x0000000000000000]              
	struct FCourierPhaseState                          c_CourierPhaseState;                              		// 0x1BBC (0x0008) [0x0000000000000000]              
	unsigned long                                      c_bClientShowPackage : 1;                         		// 0x1BC4 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      s_CanOnlyBeUsedByOwner : 1;                       		// 0x1BC4 (0x0004) [0x0000000000000000] [0x00000002] 
	float                                              c_fPackageBoneScale;                              		// 0x1BC8 (0x0004) [0x0000000000000000]              
	class USkelControlSingleBone*                      c_PackageSkelControl;                             		// 0x1BCC (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2881 );

		return pClassPointer;
	};

	bool eventCanApplyEffects ( );
	void eventReturnToDefaultPhase ( );
	void AnimHidePackage ( );
	void AnimShowPackage ( );
	void ClientPhaseChanged ( );
	void UpdatePhaseEnergy ( );
	void eventSetCourierPhase ( unsigned char Phase );
	void AtStore ( );
	void ArrivedAtStore ( );
	void TickClientVisuals ( float DeltaSeconds );
	void Tick ( float DeltaSeconds );
	void ReplicatedEvent ( struct FName VarName );
	void eventPostInitAnimTree ( class USkeletalMeshComponent* SkelComp );
	void PostBeginPlay ( );
	bool IsAvailable ( class ATgPawn* Customer );
	void SetCustomer ( class ATgPawn* Customer );
	bool BeginTransaction ( class ATgPawn* Customer, unsigned char Type );
	void DropOff ( );
	void TransactionCancelled ( );
	void TransactionComplete ( );
	void PostPawnSetupServer ( );
	void UpdateGroundSpeed ( );
	void SetSpawnEnergy ( );
	void OnPawnDied ( );
};

UClass* ATgPawn_Courier::pClassPointer = NULL;

// Class TgGame.TgPawn_ChangE_Rabbit
// 0x0000 (0x1BD0 - 0x1BD0)
class ATgPawn_ChangE_Rabbit : public ATgPawn_Courier
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2882 );

		return pClassPointer;
	};

	void PlaySpawnFx ( );
	void PrepareIntro ( );
	bool OwnerPlayedSound ( class USoundCue* Cue );
	void PlayTeleportFx ( int nTeleportState, struct FVector vLoc );
	bool IsNonCombat ( );
};

UClass* ATgPawn_ChangE_Rabbit::pClassPointer = NULL;

// Class TgGame.TgPawn_ErlangShen_Dog
// 0x0010 (0x1BC0 - 0x1BB0)
class ATgPawn_ErlangShen_Dog : public ATgPawn_Familiar_LongTerm
{
public:
	float                                              m_fOwnerCriticalStrikePercent;                    		// 0x1BB0 (0x0004) [0x0000000000000000]              
	float                                              r_fLeashRange;                                    		// 0x1BB4 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              r_fPhysPowerScaling;                              		// 0x1BB8 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgPawn*                                     m_LastCombatTarget;                               		// 0x1BBC (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2883 );

		return pClassPointer;
	};

	void OwnerJumpedTimer ( );
	void Tick ( float DeltaSeconds );
	void PlayTeleportFx ( int nTeleportState, struct FVector vLoc );
	struct FVector GetDesiredRelativePosition ( );
	void CatchUpToOwner ( float Distance );
	void TeleportToOwner ( );
	void OnOwnerPostTeleport ( );
	void OnOwnerJumped ( );
	void DeviceOnKilled ( class ATgDevice* Dev, float fDamage, struct FImpactInfo* Impact );
	void DeviceOnDamaged ( struct FOnDamagedParams* Params );
	void DeviceOnHit ( class ATgDevice* Dev, struct FImpactInfo* Impact );
	void DeviceAdjustDamage ( class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage );
	bool IsNonCombat ( );
	float GetCriticalDamage ( );
	float GetCriticalStrike ( );
};

UClass* ATgPawn_ErlangShen_Dog::pClassPointer = NULL;

// Class TgGame.TgPawn_Kaldr
// 0x0248 (0x1DF8 - 0x1BB0)
class ATgPawn_Kaldr : public ATgPawn_Familiar_LongTerm
{
public:
	struct FTG_HUD_INFO                                c_TargetingHudInfo;                               		// 0x1BB0 (0x0130) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class ATgPawn*                                     r_GuardTarget;                                    		// 0x1CE0 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              r_fRespawnTime;                                   		// 0x1CE4 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              s_fLeashRange;                                    		// 0x1CE8 (0x0004) [0x0000000000000000]              
	int                                                r_nCurrentHealth;                                 		// 0x1CEC (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                c_nPreviousHealth;                                		// 0x1CF0 (0x0004) [0x0000000000000000]              
	int                                                r_nMaxHealth;                                     		// 0x1CF4 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              c_fNextHealth;                                    		// 0x1CF8 (0x0004) [0x0000000000000000]              
	float                                              r_nHUDHealthFractional;                           		// 0x1CFC (0x0004) [0x0000000000000020]              ( CPF_Net )
	struct FVector                                     s_vRespawnLoc;                                    		// 0x1D00 (0x000C) [0x0000000000000000]              
	unsigned long                                      s_bRecallingToBase : 1;                           		// 0x1D0C (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      r_bIsDefensive : 1;                               		// 0x1D0C (0x0004) [0x0000000000000020] [0x00000002] ( CPF_Net )
	unsigned long                                      r_bDefensiveTransition : 1;                       		// 0x1D0C (0x0004) [0x0000000000000020] [0x00000004] ( CPF_Net )
	unsigned long                                      r_bIsUlting : 1;                                  		// 0x1D0C (0x0004) [0x0000000000000020] [0x00000008] ( CPF_Net )
	unsigned long                                      s_bSelfTargetRemoval : 1;                         		// 0x1D0C (0x0004) [0x0000000000000000] [0x00000010] 
	int                                                m_nTeleportEnterFXId;                             		// 0x1D10 (0x0004) [0x0000000000000000]              
	int                                                m_nTeleportExitFXId;                              		// 0x1D14 (0x0004) [0x0000000000000000]              
	int                                                c_nCurrentPostureId;                              		// 0x1D18 (0x0004) [0x0000000000000000]              
	float                                              r_fComboRadius;                                   		// 0x1D1C (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              r_fUltRadius;                                     		// 0x1D20 (0x0004) [0x0000000000000020]              ( CPF_Net )
	struct FKaldrDamageInstance                        s_DamageHistory[ 0x10 ];                          		// 0x1D24 (0x00C0) [0x0000000000000000]              
	int                                                s_nCurrentDamageIndex;                            		// 0x1DE4 (0x0004) [0x0000000000000000]              
	int                                                s_nKaldrDamagePerHit;                             		// 0x1DE8 (0x0004) [0x0000000000000000]              
	int                                                s_nKaldrDamageFromMinions;                        		// 0x1DEC (0x0004) [0x0000000000000000]              
	int                                                s_nKaldrHealthPerTick;                            		// 0x1DF0 (0x0004) [0x0000000000000000]              
	int                                                s_nLastTargetBotRank;                             		// 0x1DF4 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2884 );

		return pClassPointer;
	};

	struct FString eventAIDebugString ( );
	void OwnerJumpedTimer ( );
	bool eventCanGiveNewTarget ( );
	bool eventCanCombo ( );
	void eventClearGuardTarget ( unsigned long bLookForNext );
	void eventTriggerCombo ( );
	void eventPrepKaldrImmunity ( );
	void eventIncrementHealthBy ( int nHealth );
	void ResetKaldr ( );
	bool Died ( class AController* Killer, class UClass* dmgType, struct FVector HitLocation );
	void eventKilledBy ( class APawn* EventInstigator );
	void PostTeleport ( class ATeleporter* OutTeleporter );
	void OnTeleportToBaseNotify ( class AActor* TeleportingActor );
	void eventRecallKaldr ( unsigned long bViaDevice );
	void eventSetAsAggressive ( );
	void eventSetAsDefensive ( );
	int eventGetOffhandDRDamage ( class ATgDevice* Dev, int nGroupFiringInstance );
	int eventCalculateDamageFrom ( class ATgDevice* damagingDevice, int nGroupFiringInstance );
	bool TakeDamageSpecial ( int Damage, class AController* InstigatedBy, struct FVector HitLocation, struct FVector Momentum, class UClass* DamageType, struct FTraceHitInfo HitInfo, class AActor* DamageCauser );
	void Tick ( float DeltaSeconds );
	void EndTween ( unsigned char endingTweenState, unsigned long bInterrupted );
	void BeginTween ( unsigned char newTweenState );
	void PlaySpawnFx ( );
	void PrepareIntro ( );
	void eventReplicatedEvent ( struct FName VarName );
	void PlayTeleportFx ( int nTeleportState, struct FVector vLoc );
	void MoveToDesiredRelativePosition ( );
	void TeleportToOwner ( );
	struct FVector GetDesiredRelativePosition ( );
	void UpdateVisualState ( );
	void OnOwnerAddPercentVitals ( float pctHealth );
	void OnOwnerGivenPercentVitals ( float pctHealth );
	void OnOwnerGivenFullVitals ( );
	void OnOwnerPostTeleport ( );
	void OnOwnerJumped ( );
	void SetTargetActor ( class AActor* Target );
	void TrackGuardedTarget ( class AActor* Target );
	void TrackDamageFrom ( class ATgDevice* owningDevice, int nFiringInstance );
	void PawnOnDamaged ( struct FOnDamagedParams* Params );
	bool DeviceOnCanDeviceFireNow ( class ATgDevice* Dev, unsigned char FireModeNum, unsigned long bDeviceFailLog, struct FAimData* Aim );
	void EffectGroupOnSetActive ( unsigned long bActive, unsigned long bRemoving, class UTgEffectGroup* effectGroup );
	void EffectGroupOnApplied ( class UTgEffectGroup* effectGroup, unsigned long bInterval );
	void DeviceAdjustDamage ( class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage );
	void DeviceOnHit ( class ATgDevice* Dev, struct FImpactInfo* Impact );
	void DeviceOnStopFire ( class ATgDevice* Dev, unsigned long WasInterrupted );
	void DeviceOnStartFire ( class ATgDevice* Dev );
	bool IsNonCombat ( );
};

UClass* ATgPawn_Kaldr::pClassPointer = NULL;

// Class TgGame.TgPawn_Loki_Decoy
// 0x0000 (0x1B8C - 0x1B8C)
class ATgPawn_Loki_Decoy : public ATgPawn_Familiar
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2885 );

		return pClassPointer;
	};

	void PlayDyingEffects ( );
	bool eventDied ( class AController* Killer, class UClass* dmgType, struct FVector HitLocation );
};

UClass* ATgPawn_Loki_Decoy::pClassPointer = NULL;

// Class TgGame.TgPawn_NuWa_Fog
// 0x0000 (0x1B8C - 0x1B8C)
class ATgPawn_NuWa_Fog : public ATgPawn_Familiar
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2886 );

		return pClassPointer;
	};

	bool eventCanApplyEffects ( );
	void OnMeshSwapped ( );
	void PostPawnSetupServer ( );
	void OnOwnerGroundSpeedChange ( );
	bool IsNonCombat ( );
};

UClass* ATgPawn_NuWa_Fog::pClassPointer = NULL;

// Class TgGame.TgPawn_NuWa_FogV2
// 0x0000 (0x1B8C - 0x1B8C)
class ATgPawn_NuWa_FogV2 : public ATgPawn_NuWa_Fog
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2887 );

		return pClassPointer;
	};

	void PostPawnSetupServer ( );
	void OnOwnerGroundSpeedChange ( );
};

UClass* ATgPawn_NuWa_FogV2::pClassPointer = NULL;

// Class TgGame.TgPawn_SunWukong_Decoy
// 0x0008 (0x1B94 - 0x1B8C)
class ATgPawn_SunWukong_Decoy : public ATgPawn_Familiar
{
public:
	float                                              m_fSpawnHealthPercent;                            		// 0x1B8C (0x0004) [0x0000000000000000]              
	unsigned long                                      s_bTriggerSuicide : 1;                            		// 0x1B90 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2888 );

		return pClassPointer;
	};

	void Tick ( float DeltaSeconds );
	void SpawnReturnProjectile ( );
	void PawnOnHardCCed ( struct FImpactInfo Impact, class UTgEffectGroup* eg );
	void OnOwnerGroundSpeedChange ( );
	void SetSpawnHealth ( );
	void PostPawnSetupServer ( );
};

UClass* ATgPawn_SunWukong_Decoy::pClassPointer = NULL;

// Class TgGame.TgPawn_Terracotta
// 0x0004 (0x1B90 - 0x1B8C)
class ATgPawn_Terracotta : public ATgPawn_Familiar
{
public:
	unsigned long                                      r_bDiarrhea : 1;                                  		// 0x1B8C (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2889 );

		return pClassPointer;
	};

	void eventPlayDeathAnimation ( );
	struct FName eventGetDeathAnimName ( );
	void PlayExplosiveDiarrhea ( );
	void ExplosiveDiarrhea ( );
	void eventReplicatedEvent ( struct FName VarName );
	void DeviceOnStopFire ( class ATgDevice* Dev, unsigned long bWasInterrupted );
};

UClass* ATgPawn_Terracotta::pClassPointer = NULL;

// Class TgGame.TgPawn_Vulcan_Familiar
// 0x0014 (0x1BA0 - 0x1B8C)
class ATgPawn_Vulcan_Familiar : public ATgPawn_Familiar
{
public:
	class ATgDevice*                                   m_BasicDevice;                                    		// 0x1B8C (0x0004) [0x0000000000000000]              
	class ATgDevice*                                   m_UltimateDevice;                                 		// 0x1B90 (0x0004) [0x0000000000000000]              
	class UMaterialInstanceConstant*                   c_UltimateMIC;                                    		// 0x1B94 (0x0004) [0x0000000000000000]              
	unsigned long                                      r_IsBuffedByUltimate : 1;                         		// 0x1B98 (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )
	float                                              m_ScalingProgress;                                		// 0x1B9C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2890 );

		return pClassPointer;
	};

	void PlayDeathAnimation ( );
	void eventTick ( float DeltaSeconds );
	bool eventPostPawnSetup ( );
	void PawnOnDamageMitigation ( class ATgPawn* attacker, class UTgEffectGroup* eg, int nPropertyId, float* fDamage );
	void DeviceAdjustDamage ( class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage );
	void DirtyAttachmentTransforms ( );
	float GetDefaultMeshScale ( );
	void CorrectLocationWhileChangingSize ( float HeightDelta );
	void GetSmallCollisionCylinderSize ( float* Radius, float* Height );
	void GetGiantCollisionCylinderSize ( float* Radius, float* Height );
};

UClass* ATgPawn_Vulcan_Familiar::pClassPointer = NULL;

// Class TgGame.TgPawn_Vulcan_ConeTurret
// 0x0018 (0x1BB8 - 0x1BA0)
class ATgPawn_Vulcan_ConeTurret : public ATgPawn_Vulcan_Familiar
{
public:
	class UTgSpecialFx*                                c_BeamFX;                                         		// 0x1BA0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FRotator                                    r_InitialOrientation;                             		// 0x1BA4 (0x000C) [0x0000000000000020]              ( CPF_Net )
	class UParticleSystemComponent*                    c_AimVisibilityMesh;                              		// 0x1BB0 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class UParticleSystemComponent*                    c_AimVisibilityMeshUlt;                           		// 0x1BB4 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2891 );

		return pClassPointer;
	};

	void PlayDyingEffects ( );
	void SetAimVisibilityMesh ( );
	void eventReplicatedEvent ( struct FName VarName );
	void PostBeginPlay ( );
	void PossessedBy ( class AController* C, unsigned long bVehicleTransition );
	void InitTargetingFx ( );
	void DeviceOnStopFire ( class ATgDevice* Dev, unsigned long WasInterrupted );
	void DeviceOnDamaged ( struct FOnDamagedParams* Params );
	void DeviceOnHit ( class ATgDevice* Dev, struct FImpactInfo* Impact );
	bool CanSeeActor ( class AActor* Other );
};

UClass* ATgPawn_Vulcan_ConeTurret::pClassPointer = NULL;

// Class TgGame.TgPawn_Vulcan_Thumper
// 0x0000 (0x1BA0 - 0x1BA0)
class ATgPawn_Vulcan_Thumper : public ATgPawn_Vulcan_Familiar
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2892 );

		return pClassPointer;
	};

};

UClass* ATgPawn_Vulcan_Thumper::pClassPointer = NULL;

// Class TgGame.TgPawn_VulcanV2_ConeTurret
// 0x0010 (0x1B9C - 0x1B8C)
class ATgPawn_VulcanV2_ConeTurret : public ATgPawn_Familiar
{
public:
	struct FRotator                                    r_InitialOrientation;                             		// 0x1B8C (0x000C) [0x0000000000000020]              ( CPF_Net )
	class UParticleSystemComponent*                    c_AimVisibilityMesh;                              		// 0x1B98 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2893 );

		return pClassPointer;
	};

	void PlayDyingEffects ( );
	void SetAimVisibilityMesh ( );
	void eventReplicatedEvent ( struct FName VarName );
	void PostBeginPlay ( );
	bool CanSeeActor ( class AActor* Other );
	void PawnOnDamageMitigation ( class ATgPawn* attacker, class UTgEffectGroup* eg, int nPropertyId, float* fDamage );
	void DeviceAdjustDamage ( class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage );
};

UClass* ATgPawn_VulcanV2_ConeTurret::pClassPointer = NULL;

// Class TgGame.TgPawn_Fountain
// 0x0000 (0x1B28 - 0x1B28)
class ATgPawn_Fountain : public ATgPawn
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2894 );

		return pClassPointer;
	};

	bool IsNonCombat ( );
};

UClass* ATgPawn_Fountain::pClassPointer = NULL;

// Class TgGame.TgPawn_Structure
// 0x0008 (0x1B30 - 0x1B28)
class ATgPawn_Structure : public ATgPawn
{
public:
	float                                              s_fLastDamageTime;                                		// 0x1B28 (0x0004) [0x0000000000000000]              
	float                                              s_fDamageNotificationDelay;                       		// 0x1B2C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2895 );

		return pClassPointer;
	};

	void SetMovementPhysics ( );
	void eventPostDemoRewind ( );
	bool eventDied ( class AController* Killer, class UClass* dmgType, struct FVector HitLocation );
	void eventTakeDamage ( int Damage, class AController* InstigatedBy, struct FVector HitLocation, struct FVector Momentum, class UClass* DamageType, struct FTraceHitInfo HitInfo, class AActor* DamageCauser );
	void SendDeathAlert ( );
	void SendAttackAlert ( );
	bool CanMove ( );
};

UClass* ATgPawn_Structure::pClassPointer = NULL;

// Class TgGame.TgPawn_Inhibitor
// 0x0000 (0x1B30 - 0x1B30)
class ATgPawn_Inhibitor : public ATgPawn_Structure
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2896 );

		return pClassPointer;
	};

	void PlaySpawnFx ( );
	void SendDeathAlert ( );
	void SendAttackAlert ( );
};

UClass* ATgPawn_Inhibitor::pClassPointer = NULL;

// Class TgGame.TgPawn_Nexus
// 0x0000 (0x1B30 - 0x1B30)
class ATgPawn_Nexus : public ATgPawn_Structure
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2897 );

		return pClassPointer;
	};

	bool eventDied ( class AController* Killer, class UClass* dmgType, struct FVector HitLocation );
	void SendDeathAlert ( );
	void SendAttackAlert ( );
};

UClass* ATgPawn_Nexus::pClassPointer = NULL;

// Class TgGame.TgPawn_TowerBase
// 0x001C (0x1B4C - 0x1B30)
class ATgPawn_TowerBase : public ATgPawn_Structure
{
public:
	class UTgSpecialFx*                                c_BeamFX;                                         		// 0x1B30 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UTgMarkComponent*                            s_DamageScaler;                                   		// 0x1B34 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	int                                                m_nNumGuardianLevels;                             		// 0x1B38 (0x0004) [0x0000000000000000]              
	unsigned long                                      r_bLocked : 1;                                    		// 0x1B3C (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )
	unsigned long                                      m_bShouldBeFaded : 1;                             		// 0x1B3C (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	float                                              m_fTransparentFadeSpeed;                          		// 0x1B40 (0x0004) [0x0000000000000000]              
	float                                              m_fMaxFadeTransparency;                           		// 0x1B44 (0x0004) [0x0000000000000000]              
	float                                              m_fFadeDistance2D;                                		// 0x1B48 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2898 );

		return pClassPointer;
	};

	bool eventDied ( class AController* Killer, class UClass* dmgType, struct FVector HitLocation );
	bool eventPostPawnSetup ( );
	void PossessedBy ( class AController* C, unsigned long bVehicleTransition );
	void SendDeathInputLightingEffects ( );
	void PostPawnSetupServer ( );
	void SetTransparencyFaded ( unsigned long bShouldBeFaded );
	void CalcDistanceFadeValue ( float fDeltaTime );
	bool InitializeTeleportIncomingFx ( );
	void PawnOnDamageMitigation ( class ATgPawn* attacker, class UTgEffectGroup* eg, int nPropertyId, float* fDamage );
	void DeviceAdjustDamage ( class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage );
	void DeviceOnDamaged ( struct FOnDamagedParams* Params );
	void SendTargetedAlert ( class ATgPawn* Target );
	void SetTargetActor ( class AActor* Target );
	void UpdateGuardian ( );
};

UClass* ATgPawn_TowerBase::pClassPointer = NULL;

// Class TgGame.TgPawn_Phoenix
// 0x0014 (0x1B60 - 0x1B4C)
class ATgPawn_Phoenix : public ATgPawn_TowerBase
{
public:
	float                                              m_fRespawnHealthPct;                              		// 0x1B4C (0x0004) [0x0000000000000000]              
	unsigned long                                      s_bIsRespawnedPhoenix : 1;                        		// 0x1B50 (0x0004) [0x0000000000000000] [0x00000001] 
	TArray< struct FNavMeshBorderEdges >               BorderEdges;                                      		// 0x1B54 (0x000C) [0x0000000000500000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2899 );

		return pClassPointer;
	};

	bool eventShouldRecharge ( );
	void eventSetCustomLightingChannels ( );
	void PlayInitialSpawnFX ( );
	bool eventDied ( class AController* Killer, class UClass* dmgType, struct FVector HitLocation );
	void SetSpawnHealth ( );
	void PostPawnSetupServer ( );
	void SendTargetedAlert ( class ATgPawn* Target );
	void SendRespawnAlert ( );
	void SendDeathAlert ( );
	void SendAttackAlert ( );
	void QueryBorderEdges ( );
};

UClass* ATgPawn_Phoenix::pClassPointer = NULL;

// Class TgGame.TgPawn_Djinni
// 0x002C (0x1B8C - 0x1B60)
class ATgPawn_Djinni : public ATgPawn_Phoenix
{
public:
	float                                              m_fScalingTime;                                   		// 0x1B60 (0x0004) [0x0000000000000000]              
	TArray< struct FScalingProp >                      m_ScalingProperties;                              		// 0x1B64 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class USoundCue*                                   m_EnemyAgroVoxSound;                              		// 0x1B70 (0x0004) [0x0000000000000000]              
	class USoundCue*                                   m_FriendlyAgroVoxSound;                           		// 0x1B74 (0x0004) [0x0000000000000000]              
	float                                              m_fLastAgroTimestamp;                             		// 0x1B78 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class USoundCue*                                   m_IdleVoxSound;                                   		// 0x1B7C (0x0004) [0x0000000000000000]              
	class USoundCue*                                   m_EnemyKilledVoxSound;                            		// 0x1B80 (0x0004) [0x0000000000000000]              
	int                                                m_AttackEscalationThreshold;                      		// 0x1B84 (0x0004) [0x0000000000000000]              
	float                                              m_AttackEscalationDamageBonus;                    		// 0x1B88 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2900 );

		return pClassPointer;
	};

	bool eventCanApplyEffects ( );
	void eventTakeDamage ( int Damage, class AController* InstigatedBy, struct FVector HitLocation, struct FVector Momentum, class UClass* DamageType, struct FTraceHitInfo HitInfo, class AActor* DamageCauser );
	void PawnOnDamageMitigation ( class ATgPawn* attacker, class UTgEffectGroup* eg, int nPropertyId, float* fDamage );
	void PlayIdleSound ( );
	void PostBeginPlay ( );
	void DeviceAdjustDamage ( class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage );
	void PostPawnSetupServer ( );
	void SendTargetedAlert ( class ATgPawn* Target );
	void SendDeathAlert ( );
	void SendAttackAlert ( );
	void ScaleProperties ( );
};

UClass* ATgPawn_Djinni::pClassPointer = NULL;

// Class TgGame.TgPawn_Phoenix_ClashV3
// 0x0000 (0x1B60 - 0x1B60)
class ATgPawn_Phoenix_ClashV3 : public ATgPawn_Phoenix
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2901 );

		return pClassPointer;
	};

	void DeviceAdjustDamage ( class ATgDevice* Dev, int nPropertyId, struct FImpactInfo* Impact, float* fDamage );
};

UClass* ATgPawn_Phoenix_ClashV3::pClassPointer = NULL;

// Class TgGame.TgPawn_Phoenix_PVE
// 0x0000 (0x1B60 - 0x1B60)
class ATgPawn_Phoenix_PVE : public ATgPawn_Phoenix
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2902 );

		return pClassPointer;
	};

	bool eventShouldRecharge ( );
	void PawnOnDamageMitigation ( class ATgPawn* attacker, class UTgEffectGroup* eg, int nPropertyId, float* fDamage );
};

UClass* ATgPawn_Phoenix_PVE::pClassPointer = NULL;

// Class TgGame.TgPawn_Tower
// 0x005C (0x1BA8 - 0x1B4C)
class ATgPawn_Tower : public ATgPawn_TowerBase
{
public:
	float                                              m_TimeSinceDeath;                                 		// 0x1B4C (0x0004) [0x0000000000000000]              
	TArray< class UMaterialInstanceConstant* >         m_DestroyedMICs;                                  		// 0x1B50 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	float                                              m_fFadeOutStartTime;                              		// 0x1B5C (0x0004) [0x0000000000000000]              
	float                                              m_fFadeOutEndTime;                                		// 0x1B60 (0x0004) [0x0000000000000000]              
	float                                              m_fDamageAngleOffset;                             		// 0x1B64 (0x0004) [0x0000000000000002]              ( CPF_Const )
	struct FVector                                     r_vInitialRotation;                               		// 0x1B68 (0x000C) [0x0000000000000020]              ( CPF_Net )
	unsigned long                                      m_bUseDestruction : 1;                            		// 0x1B74 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned char                                      r_nTowerSideHealth[ 0x4 ];                        		// 0x1B78 (0x0004) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      c_nLocalTowerSideHealth[ 0x4 ];                   		// 0x1B7C (0x0004) [0x0000000000000000]              
	unsigned char                                      c_bTowerSideDestroyedLocally[ 0x4 ];              		// 0x1B80 (0x0004) [0x0000000000000000]              
	unsigned char                                      m_nStartSideHealth;                               		// 0x1B84 (0x0001) [0x0000000000000002]              ( CPF_Const )
	class USkelControlBase*                            c_TowerSideSkelControls[ 0x4 ];                   		// 0x1B88 (0x0010) [0x0000000000000000]              
	int                                                m_nTowerSideMeshIds[ 0x4 ];                       		// 0x1B98 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2903 );

		return pClassPointer;
	};

	void eventSetCustomLightingChannels ( );
	void eventPostDemoRewind ( );
	struct FVector GetFireLocationOffset ( class ATgDevice* Dev );
	void OnSwapToDestroyedMesh ( );
	bool eventDied ( class AController* Killer, class UClass* dmgType, struct FVector HitLocation );
	void CheckSideDestructionSkelControls ( int ForceSideIndexHidden );
	void PlaySideDestructionAnim ( int SideIndex );
	void UpdateTowerSideHealth ( );
	void eventTakeDamage ( int Damage, class AController* InstigatedBy, struct FVector HitLocation, struct FVector Momentum, class UClass* DamageType, struct FTraceHitInfo HitInfo, class AActor* DamageCauser );
	void eventReplicatedEvent ( struct FName VarName );
	void CacheMainMeshReferences ( class UTgSkeletalMeshComponent* smcomp );
	bool eventPostPawnSetup ( );
	void PostBeginPlay ( );
	float NormalizeDamageAngle ( float fAngle );
	void BroadcastDiedToGame ( );
	void SwapToBrokenMesh ( );
	void SendTargetedAlert ( class ATgPawn* Target );
	void SendDeathAlert ( );
	void SendAttackAlert ( );
};

UClass* ATgPawn_Tower::pClassPointer = NULL;

// Class TgGame.TgPawn_Tower_ArenaBase
// 0x0000 (0x1BA8 - 0x1BA8)
class ATgPawn_Tower_ArenaBase : public ATgPawn_Tower
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2904 );

		return pClassPointer;
	};

};

UClass* ATgPawn_Tower_ArenaBase::pClassPointer = NULL;

// Class TgGame.TgPawn_Tower_PointCapture
// 0x0000 (0x1BA8 - 0x1BA8)
class ATgPawn_Tower_PointCapture : public ATgPawn_Tower
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2905 );

		return pClassPointer;
	};

	bool eventCanApplyEffects ( );
	void SendTargetedAlert ( class ATgPawn* Target );
};

UClass* ATgPawn_Tower_PointCapture::pClassPointer = NULL;

// Class TgGame.TgPawn_Tower_PVE
// 0x0000 (0x1BA8 - 0x1BA8)
class ATgPawn_Tower_PVE : public ATgPawn_Tower
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2906 );

		return pClassPointer;
	};

	void PawnOnDamageMitigation ( class ATgPawn* attacker, class UTgEffectGroup* eg, int nPropertyId, float* fDamage );
};

UClass* ATgPawn_Tower_PVE::pClassPointer = NULL;

// Class TgGame.TgPawn_Tower_ImmunePVE
// 0x0008 (0x1BB0 - 0x1BA8)
class ATgPawn_Tower_ImmunePVE : public ATgPawn_Tower_PVE
{
public:
	class UTgSpecialFx*                                c_ImmuneFx;                                       		// 0x1BA8 (0x0004) [0x0000000000000000]              
	unsigned long                                      r_GodModeActivated : 1;                           		// 0x1BAC (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2907 );

		return pClassPointer;
	};

	void eventReplicatedEvent ( struct FName VarName );
	void SetTowerImmuneFx ( unsigned long bTurnOn );
};

UClass* ATgPawn_Tower_ImmunePVE::pClassPointer = NULL;

// Class TgGame.TgPawn_Tower_Obelisk
// 0x0028 (0x1BD0 - 0x1BA8)
class ATgPawn_Tower_Obelisk : public ATgPawn_Tower_PVE
{
public:
	TArray< class ATgPawn* >                           m_BuffedAllies;                                   		// 0x1BA8 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FTowerBeamInfo                              c_BeamTargetInfo;                                 		// 0x1BB4 (0x0008) [0x0000000000000000]              
	int                                                m_nTowerBeamFxId;                                 		// 0x1BBC (0x0004) [0x0000000000000000]              
	struct FVector                                     m_vSpineOffset;                                   		// 0x1BC0 (0x000C) [0x0000000000000000]              
	class ATgPawn*                                     r_TargetPawn;                                     		// 0x1BCC (0x0004) [0x0000000000000020]              ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2908 );

		return pClassPointer;
	};

	void eventCreateBeamInfo ( class ATgPawn* Target );
	void eventDeactivateBeam ( );
	void RemoveAllEffectsOnDeath ( );
	void UpdateBeamToTarget ( struct FTowerBeamInfo Info, float DeltaTime );
	void Tick ( float DeltaSeconds );
	void eventReplicatedEvent ( struct FName VarName );
	class UTgSpecialFx* GetBeamFx ( );
	void CalcLinkedTargetLocation ( class ATgPawn* TargetPawn, struct FVector* LinkLocation );
	void DeviceOnFire ( class ATgDevice* Dev );
};

UClass* ATgPawn_Tower_Obelisk::pClassPointer = NULL;

// Class TgGame.TgPawn_Tower_TP_PVE
// 0x0000 (0x1BA8 - 0x1BA8)
class ATgPawn_Tower_TP_PVE : public ATgPawn_Tower_PVE
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2909 );

		return pClassPointer;
	};

	void AddIncomingTeleport ( );
	void PostPawnSetupServer ( );
};

UClass* ATgPawn_Tower_TP_PVE::pClassPointer = NULL;

// Class TgGame.TgSpectatorController
// 0x021C (0x0DF8 - 0x0BDC)
class ATgSpectatorController : public ATgPlayerController
{
public:
	unsigned char                                      m_CameraMode;                                     		// 0x0BDC (0x0001) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      m_CurrentCycle;                                   		// 0x0BDD (0x0001) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      m_PendingCycle;                                   		// 0x0BDE (0x0001) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      m_eHelicopterFlight;                              		// 0x0BDF (0x0001) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      m_CurrentSpectatorMode;                           		// 0x0BE0 (0x0001) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      m_CurrentZoomState;                               		// 0x0BE1 (0x0001) [0x0000000000002000]              ( CPF_Transient )
	class ATgSpectatorTempCam*                         m_BookmarkCamera;                                 		// 0x0BE4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FSpectatorBookmark                          m_Bookmarks[ 0xA ];                               		// 0x0BE8 (0x0168) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_fDefaultTweenTime;                              		// 0x0D50 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bOutlineCharacters : 1;                         		// 0x0D54 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	unsigned long                                      m_bIsMapSquashed : 1;                             		// 0x0D54 (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	unsigned long                                      m_bIgnoreCullDistanceVolumes : 1;                 		// 0x0D54 (0x0004) [0x0000000000004001] [0x00000004] ( CPF_Edit | CPF_Config )
	unsigned long                                      m_bPlayerMappingComplete : 1;                     		// 0x0D54 (0x0004) [0x0000000000002000] [0x00000008] ( CPF_Transient )
	unsigned long                                      m_bFlippedSides : 1;                              		// 0x0D54 (0x0004) [0x0000000000002000] [0x00000010] ( CPF_Transient )
	unsigned long                                      bIgnoreConsoleLock : 1;                           		// 0x0D54 (0x0004) [0x0000000000002000] [0x00000020] ( CPF_Transient )
	unsigned long                                      m_bSpectatorHideOverlayMesh : 1;                  		// 0x0D54 (0x0004) [0x0000000000000000] [0x00000040] 
	float                                              m_fNameplateFadeMinDist;                          		// 0x0D58 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fNameplateFadeMaxDist;                          		// 0x0D5C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fNameplateFadeMaxAmount;                        		// 0x0D60 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fNameplateScaleMinDist;                         		// 0x0D64 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fNameplateScaleMaxDist;                         		// 0x0D68 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fNameplateScaleMaxAmount;                       		// 0x0D6C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fInterpolateCameraDistance;                     		// 0x0D70 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FBroadcastChannel                           m_BroadcastChannels[ 0x4 ];                       		// 0x0D74 (0x0020) [0x0000000000000000]              
	struct FVector                                     c_vMouseClickDeprojectionExtent;                  		// 0x0D94 (0x000C) [0x0000000000004000]              ( CPF_Config )
	float                                              m_fOverviewCenterpointOffset;                     		// 0x0DA0 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_fMouseCursorVisibleTime;                        		// 0x0DA4 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_fRemainingCursorVisibleTime;                    		// 0x0DA8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FVector                                     m_vWorldScreenCenterLocation;                     		// 0x0DAC (0x000C) [0x0000000000002000]              ( CPF_Transient )
	struct FVector                                     m_vWorldScreenCenterDirection;                    		// 0x0DB8 (0x000C) [0x0000000000002000]              ( CPF_Transient )
	class ATgPawn*                                     m_PlayerPanelPawn;                                		// 0x0DC4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                PlayerMapping[ 0xA ];                             		// 0x0DC8 (0x0028) [0x0000000000002000]              ( CPF_Transient )
	int                                                CurrentViewTargetIdx;                             		// 0x0DF0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                IntendedViewTargetIdx;                            		// 0x0DF4 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2910 );

		return pClassPointer;
	};

	void eventPlayerMappingUpdated ( );
	void ToggleConsoleLock ( );
	void TogglePawnOverlay ( );
	void SetIntendedPanel ( );
	void ShowPreviousInfoPanel ( );
	void ShowNextInfoPanel ( );
	void ToggleStatPanel ( );
	void ShowPreviousStatPanel ( );
	void ShowNextStatPanel ( );
	void SetIntendedTarget ( );
	void OnCancel ( );
	void OnSelection ( );
	void SelectTeamStat ( );
	void TeamStatBack ( );
	void GoToNextIntendedTarget ( );
	void GoToPrevIntendedTarget ( );
	void SetCameraTargetByPawnId ( int pawnId );
	void GoToPrevViewTarget ( );
	void GoToNextViewTarget ( );
	int GetViewTargetIndex ( );
	void eventPreRender ( class UCanvas* Canvas );
	void CacheScreenCenter ( class UCanvas* Canvas );
	void SpectatorSelectPlayer ( int pawnId );
	void SpectatePlayerIndex ( int nPlayerIndex, unsigned long bSelectOnly );
	void UpdateBroadcastChannels ( );
	void ChangeZoomState ( unsigned char NewZoomState );
	void SpectateZoomOut ( unsigned long bEnabled );
	void SpectateZoomIn ( unsigned long bEnabled );
	void GetActorListFrom2DCoordinate ( struct FVector2D Coordinate, TArray< class AActor* >* ActorList );
	class APawn* GetPawnFrom2DCoordinate ( struct FVector2D Coordinate );
	class APawn* GetPawnFromScreenCenter ( );
	void SpectateSetTarget ( );
	void FlipOverviewSides ( );
	void SpecTest ( );
	void SquashMap ( );
	float eventGetFOVAngle ( );
	void SetOutlineCharacters ( unsigned long bNewOutlineCharacters );
	void ToggleOutlineCharacters ( );
	struct FString StripClanTag ( struct FString PlayerName );
	void DecreaseCameraSpeed ( );
	void IncreaseCameraSpeeed ( );
	void CameraSpeed ( float NewSpeed );
	void GotoCinematicCam ( struct FString sCamName );
	void ToggleHelicopterMode ( );
	void SpecSetFlightMode ( unsigned char sfm );
	void RecallSpectatorBookmark ( int nNum );
	void SetSpectatorBookmark ( int nNum );
	struct FViewTargetTransitionParams GetSnapBlendParams ( );
	struct FViewTargetTransitionParams GetDefaultBlendParams ( );
	struct FViewTargetTransitionParams GetBlendParams ( class AActor* Target );
	void SwitchToPlayer ( struct FString PlayerName );
	void SpecViewPlayer ( unsigned long bAltView, struct FString PlayerName );
	void SpecViewAction ( );
	unsigned char GetDefaultModeFor ( class AActor* Target );
	TArray< class AActor* > GetActionList ( );
	TArray< class AActor* > GetOutermostTowerList ( );
	TArray< class AActor* > GetPlayerList ( );
	TArray< class AActor* > GetViewTargetListForMode ( unsigned char cycle );
	void CycleNext ( unsigned long bSkipIfPresent, unsigned long bReverse );
	void SnapViewToLocation ( struct FVector WorldLocation, unsigned long bUseFocalPoint );
	void SetPendingOnDirectorMode ( );
	bool PingMap ( struct FVector WorldLocation, unsigned char Type, TArray< class AReplicationInfo* >* worldActorRepInfo );
	void SnapViewToHoverTarget ( unsigned long bUseAltView );
	void ToggleRigidFreeCam ( );
	void LockedViewCam ( unsigned long bEnabled );
	bool InterceptFlashInput ( struct FName ButtonName, unsigned char Event );
	void OnRightMouseReleased ( );
	void OnRightMousePressed ( );
	void OnLeftMousePressed ( );
	void ClearPendingSpecCycle ( );
	void SetPendingSpecCycle ( unsigned char Mode );
	void ClientSetReadyState ( unsigned long bReadyToPlay );
	void SetSpectatorCameraMode ( unsigned char Mode, unsigned long bCameraTween );
	void SetNewSpectatorMode ( unsigned char NewMode );
	bool ShouldFlyFromInput ( );
	void SpectatorSetViewTarget ( class AActor* VT, struct FViewTargetTransitionParams TransitionParams );
	void SwitchCamera ( struct FString sCamera );
	void ClientForwardToSpectatingMatch ( );
	void ForwardToSpectatingMatch ( );
	void EndIntro ( );
	void SetupIntro ( );
	void SetNetTarget ( struct FQWord qwId, int nTaskForce );
	class UClass* GetHudClass ( class UClass* pNewHudType );
};

UClass* ATgSpectatorController::pClassPointer = NULL;

// Class TgGame.TgDemoRecSpectator
// 0x0074 (0x0E6C - 0x0DF8)
class ATgDemoRecSpectator : public ATgSpectatorController
{
public:
	TArray< struct FSpectatorCommand >                 PendingCommands;                                  		// 0x0DF8 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                m_TimeIndex;                                      		// 0x0E04 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	TArray< struct FDilationData >                     m_TimeDilations;                                  		// 0x0E08 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	struct FPointer                                    m_pTgCallbackDevice;                              		// 0x0E14 (0x0004) [0x0000000000001000]              ( CPF_Native )
	int                                                m_1xTimeIndex;                                    		// 0x0E18 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned long                                      m_bIsPaused : 1;                                  		// 0x0E1C (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	unsigned long                                      m_bInStasis : 1;                                  		// 0x0E1C (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	unsigned long                                      m_bSpectatorMaster : 1;                           		// 0x0E1C (0x0004) [0x0000000000002000] [0x00000004] ( CPF_Transient )
	unsigned long                                      m_bSyncWithMasterEnabled : 1;                     		// 0x0E1C (0x0004) [0x0000000000002000] [0x00000008] ( CPF_Transient )
	unsigned long                                      m_bIsSyncingWithMaster : 1;                       		// 0x0E1C (0x0004) [0x0000000000002000] [0x00000010] ( CPF_Transient )
	unsigned long                                      m_bAutoSlomo : 1;                                 		// 0x0E1C (0x0004) [0x0000000000006000] [0x00000020] ( CPF_Transient | CPF_Config )
	unsigned long                                      m_bReceiveCamSync : 1;                            		// 0x0E1C (0x0004) [0x0000000000006000] [0x00000040] ( CPF_Transient | CPF_Config )
	int                                                m_nLastReceivedMasterFrame;                       		// 0x0E20 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_fLastReceivedMasterTimeDilation;                		// 0x0E24 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_fLastReceievedRealTimeStamp;                    		// 0x0E28 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_nSyncFrameThreshold;                            		// 0x0E2C (0x0004) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	int                                                m_nSyncFrameCheckThreshold;                       		// 0x0E30 (0x0004) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	int                                                m_nSyncAheadFrameThreshold;                       		// 0x0E34 (0x0004) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	int                                                m_nLastTimerValue;                                		// 0x0E38 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class ATgSpectatorDirector*                        m_SpectatorDirector;                              		// 0x0E3C (0x0004) [0x0000000000000000]              
	class ATgCollisionProxy_SpectatorActionListener*   m_ActionListener;                                 		// 0x0E40 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_fActionListenerRadius;                          		// 0x0E44 (0x0004) [0x0000000000006000]              ( CPF_Transient | CPF_Config )
	float                                              m_fActionListenerHeight;                          		// 0x0E48 (0x0004) [0x0000000000006000]              ( CPF_Transient | CPF_Config )
	int                                                m_nCurrentActionListenerRating;                   		// 0x0E4C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_nActionListenerRatingThreshold;                 		// 0x0E50 (0x0004) [0x0000000000006000]              ( CPF_Transient | CPF_Config )
	float                                              m_fRemainingAutoSlomoTime;                        		// 0x0E54 (0x0004) [0x0000000000000000]              
	float                                              m_fAutoSlomoExpirationTime;                       		// 0x0E58 (0x0004) [0x0000000000006000]              ( CPF_Transient | CPF_Config )
	int                                                m_nAutoSlomoSpeedIndex;                           		// 0x0E5C (0x0004) [0x0000000000006000]              ( CPF_Transient | CPF_Config )
	int                                                m_nAutoSlomoNearbyPlayersNum;                     		// 0x0E60 (0x0004) [0x0000000000006000]              ( CPF_Transient | CPF_Config )
	float                                              m_fAutoSlomoFrequency;                            		// 0x0E64 (0x0004) [0x0000000000006000]              ( CPF_Transient | CPF_Config )
	float                                              m_fRemainingAutoSlomoTimeoutTime;                 		// 0x0E68 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2911 );

		return pClassPointer;
	};

	void eventPlayerMappingUpdated ( );
	void SetSpectatorCameraMode ( unsigned char Mode, unsigned long bCameraTween );
	void SetIntendedTarget ( );
	void ReceiveCamSyncTarget ( int pawnId, int SourcePlayerId );
	void SendCamSyncTarget ( );
	void eventSpectatorReceivedViewTarget ( class AActor* VT );
	void SpectatorSetViewTarget ( class AActor* VT, struct FViewTargetTransitionParams TransitionParams );
	void EnableCamSync ( unsigned long bEnabled );
	void TriggerAutoSlomo ( float SlomoTime );
	void OnActionListenerStartFire ( class ATgPawn* FiringPawn, int nEquipSlot );
	void EnableAutoSlomo ( unsigned long bEnabled );
	void ToggleAutoSlomo ( );
	void SpecViewPlayer ( unsigned long bAltView, struct FString PlayerName );
	bool PingMap ( struct FVector WorldLocation, unsigned char Type, TArray< class AReplicationInfo* >* worldActorRepInfo );
	void SetNewSpectatorMode ( unsigned char NewMode );
	void eventFindNextClosestAssistedViewTarget ( );
	void eventFindNearbyAssistedViewTarget ( );
	void DirectorModeToggle ( );
	void eventPostDemoRewind ( );
	void CheckSpectatorMasterSlave ( );
	void ToggleHeightRestriction ( );
	void ToggleWorldCollision ( );
	void ToggleSync ( );
	void EnableSync ( unsigned long bEnabled );
	bool IsSyncedWithMaster ( int Threshold );
	int GetSyncTargetFrame ( );
	void SetSyncTargetFrame ( int FrameNum, float TimeDilation );
	void RewindGraphs ( );
	void PauseEx ( );
	bool SetSpectatorMasterSlave ( );
	bool CanFastForward ( );
	void GoToFrame ( float fPercent );
	void SpecRewindPoint ( int nPoint, unsigned long bUseOnlyMajorIntervals );
	void Rewind ( int JumpAmount, int FrameNum, unsigned long bUseOnlyMajorIntervals );
	void UpdateSpectatorUI ( );
	void DilateTime ( float Amount, unsigned long bForceReset );
	void Pause ( );
	void Slomo ( float NewTimeDilation );
	void eventPostBeginPlay ( );
	void eventReceivedPlayer ( );
	void SetViewTarget ( class AActor* NewViewTarget, struct FViewTargetTransitionParams TransitionParams );
	void StartAutoCombatLog ( );
	void ToggleThirdPersonView ( );
	void CreateManualRewindPoint ( );
	class UClass* GetHudClass ( class UClass* pNewHudType );
	void UnregisterEngineCallbacks ( );
	void RegisterEngineCallbacks ( );
	void UpdateCameraModeUI ( );
	bool UpdateSyncingUI ( );
	void UpdateTimeDilation ( );
	void RequestSync ( );
	void OnSynced ( );
};

UClass* ATgDemoRecSpectator::pClassPointer = NULL;

// Class TgGame.TgDemoRecSpectator_Debug
// 0x0008 (0x0E74 - 0x0E6C)
class ATgDemoRecSpectator_Debug : public ATgDemoRecSpectator
{
public:
	class UPlayer*                                     m_OriginalPlayer;                                 		// 0x0E6C (0x0004) [0x0000000000000000]              
	class APlayerController*                           m_OriginalPlayerController;                       		// 0x0E70 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2912 );

		return pClassPointer;
	};

};

UClass* ATgDemoRecSpectator_Debug::pClassPointer = NULL;

// Class TgGame.TgPlayerInput
// 0x0058 (0x031C - 0x02C4)
class UTgPlayerInput : public UPComPlayerInput
{
public:
	class ATgPlayerController*                         c_TgPC;                                           		// 0x02C4 (0x0004) [0x0000000000000000]              
	unsigned long                                      c_bASKeyBlock : 1;                                		// 0x02C8 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      c_bASKeyCapture : 1;                              		// 0x02C8 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      c_bASSpecKeyCapture : 1;                          		// 0x02C8 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      c_bMiniMapPinging : 1;                            		// 0x02C8 (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      c_bAutoRun : 1;                                   		// 0x02C8 (0x0004) [0x0000000000000000] [0x00000010] 
	TArray< struct FName >                             CaptureModifierKeys;                              		// 0x02CC (0x000C) [0x0000000000502000]              ( CPF_Transient | CPF_NeedCtorLink )
	float                                              fLookAttractorAmount;                             		// 0x02D8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              fLookAttractorTarget;                             		// 0x02DC (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              fLookAttractorSpeed;                              		// 0x02E0 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              fLastTurn;                                        		// 0x02E4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              fLookAccelAmount;                                 		// 0x02E8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              fLookAccelTarget;                                 		// 0x02EC (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              fLookAccelExponent;                               		// 0x02F0 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              fLookAccelSpeed;                                  		// 0x02F4 (0x0004) [0x0000000000004000]              ( CPF_Config )
	struct FScriptDelegate                             __OnRawInputKey__Delegate;                        		// 0x02F8 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FScriptDelegate                             __OnInputAxis__Delegate;                          		// 0x0304 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FScriptDelegate                             __OnInputChar__Delegate;                          		// 0x0310 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2913 );

		return pClassPointer;
	};

	void UnbindCommand ( struct FString Command, int nAlternate );
	void UnbindCommandAll ( struct FString Command );
	void SetCommandBind ( struct FString Command, int nAlternate, struct FString ExtendedBinding, unsigned long bStoreToServer );
	void SetBindExtended ( struct FString ExtendedBinding, struct FString Command, unsigned long bStoreToServer );
	void SetLookSensitivity ( float fSensitivity, float fSensitivityY );
	void SetMouseInput ( unsigned long bInvert, unsigned long bSmooth, float fSensitivity );
	void CancelAutoRun ( );
	void ToggleAutoRun ( );
	void PreProcessInput ( float DeltaTime );
	void eventPlayerInput ( float DeltaTime );
	unsigned char CheckForDoubleClickMove ( float DeltaTime );
	void Duck ( );
	bool eventInputChar ( int ControllerId, struct FString Unicode );
	void PreProcessJoystickInput ( float fDeltaTime );
	struct FKeyBind GenerateKeybindFromButton ( struct FString ButtonName );
	void SetKeyCaptureModifier ( struct FName ButtonName, unsigned long bPressed );
	void SetKeyCaptureState ( unsigned long bSpectator, unsigned long bCaptureKey );
	void SetKeyBlockState ( unsigned long bBlock );
	void ResetKeysToDefault ( struct FString PresetName );
	void ReadMouseSettings ( );
	void ReadBindings ( );
	void InitKeyBindingsMap ( );
	bool OnInputChar ( int ControllerId, struct FString Unicode );
	bool OnInputAxis ( int ControllerId, struct FName Key, float Delta, float DeltaTime );
	bool OnRawInputKey ( int ControllerId, struct FName Key, unsigned char Event, float AmountDepressed );
};

UClass* UTgPlayerInput::pClassPointer = NULL;

// Class TgGame.TgSpectatorInput
// 0x0008 (0x0324 - 0x031C)
class UTgSpectatorInput : public UTgPlayerInput
{
public:
	float                                              SpectatorSensitivity;                             		// 0x031C (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              RawTriggerUp;                                     		// 0x0320 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2914 );

		return pClassPointer;
	};

	void eventPlayerInput ( float DeltaTime );
	void AdjustMouseSensitivity ( float FOVScale );
	TArray< struct FKeyBind > GetDefaultSpectatorBindings ( );
	void CheckIdleBreak ( );
};

UClass* UTgSpectatorInput::pClassPointer = NULL;

// Class TgGame.TgSkeletalMeshActor_FireGiantIntro_GC2015a
// 0x0014 (0x027C - 0x0268)
class ATgSkeletalMeshActor_FireGiantIntro_GC2015a : public ATgSkeletalMeshActor
{
public:
	class USkeletalMesh*                               SpectatorSkeletalMesh;                            		// 0x0268 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class USkeletalMesh*                               DefaultSkeletalMesh;                              		// 0x026C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	TArray< class UTgAnimBlendByFireGiantChest* >      FireGiantChestNodes;                              		// 0x0270 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2915 );

		return pClassPointer;
	};

	void eventPostInitAnimTree ( class USkeletalMeshComponent* SkelComp );
	void SetOpened ( unsigned long bForce );
	void OpenChest ( float fOffset );
	void ForceClosed ( );
	void eventPostBeginPlay ( );
};

UClass* ATgSkeletalMeshActor_FireGiantIntro_GC2015a::pClassPointer = NULL;

// Class TgGame.TgSkeletalMeshActor_Loader
// 0x006C (0x02D4 - 0x0268)
class ATgSkeletalMeshActor_Loader : public ATgSkeletalMeshActor
{
public:
	class UTgMenuMeshInfo*                             m_PendingMeshInfo;                                		// 0x0268 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UTgMenuMeshInfo*                             m_CurrentMeshInfo;                                		// 0x026C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UTgManifestGroup*                            c_AssetManifestGroup;                             		// 0x0270 (0x0004) [0x0000000004400008]              ( CPF_ExportObject | CPF_NeedCtorLink | CPF_EditInline )
	struct FPointer                                    m_PendingBot;                                     		// 0x0274 (0x0004) [0x0000000000001000]              ( CPF_Native )
	struct FPointer                                    m_PendingSkin;                                    		// 0x0278 (0x0004) [0x0000000000001000]              ( CPF_Native )
	unsigned char                                      m_PendingPose;                                    		// 0x027C (0x0001) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      m_CurrentPose;                                    		// 0x027D (0x0001) [0x0000000000002000]              ( CPF_Transient )
	struct FPointer                                    m_CurrentBot;                                     		// 0x0280 (0x0004) [0x0000000000001000]              ( CPF_Native )
	struct FPointer                                    m_CurrentSkin;                                    		// 0x0284 (0x0004) [0x0000000000001000]              ( CPF_Native )
	unsigned long                                      m_bWaitingForTextures : 1;                        		// 0x0288 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	unsigned long                                      m_bIsAsyncLoading : 1;                            		// 0x0288 (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	unsigned long                                      m_bAllowOverlays : 1;                             		// 0x0288 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      m_bAllowSkinLevel : 1;                            		// 0x0288 (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )
	unsigned long                                      m_bOverrideLightingChannels : 1;                  		// 0x0288 (0x0004) [0x0000000000000001] [0x00000010] ( CPF_Edit )
	int                                                m_nAsyncLoadDelayTicksDefault;                    		// 0x028C (0x0004) [0x0000000000000000]              
	int                                                m_nAsyncLoadDelayTicks;                           		// 0x0290 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	TArray< class UMeshComponent* >                    m_ChildMeshes;                                    		// 0x0294 (0x000C) [0x0000000004482008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_NeedCtorLink | CPF_EditInline )
	class ULightEnvironmentComponent*                  m_AlternateLightEnvironmentTemplate;              		// 0x02A0 (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )
	TArray< class ULightEnvironmentComponent* >        m_AlternateLightEnvironments;                     		// 0x02A4 (0x000C) [0x0000000004482008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_NeedCtorLink | CPF_EditInline )
	class UMaterialInterface*                          m_OverlayMaterial;                                		// 0x02B0 (0x0004) [0x0000000000000000]              
	int                                                m_nSkinLevel;                                     		// 0x02B4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FLightingChannelContainer                   m_LightingChannels;                               		// 0x02B8 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	TArray< class UTgAnimBlendByEmote* >               m_EmoteBlendNodes;                                		// 0x02BC (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	TArray< class UTgAnimNodeEmoteSequence* >          m_EmoteSequenceNodes;                             		// 0x02C8 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2916 );

		return pClassPointer;
	};

	bool eventPlayParticleEffect ( class UAnimNotify_PlayParticleEffect* AnimNotifyData );
	void eventPlayChildAnim ( class UTgSkeletalMeshComponent* notifySource, struct FName AnimSeqName );
	void eventEndTransition ( );
	void eventBeginTransition ( unsigned long bPlayFx );
	void UpdateComponentTickGroup ( );
	void CancelEmote ( unsigned long bVerifyNoRelevantEmotes, class UTgAnimNodeEmoteSequence* Exclude );
	float PlayEmote ( int nVgsId );
	void RecalculateMaterial ( unsigned long bIsFriendlyWithLocalPawn, unsigned long bForce );
	void ForceRecalculateMaterial ( );
	void CleanupForAssetSwap ( unsigned long bReset );
	void SwapAssets ( class UTgMenuMeshInfo* MeshInfo );
	void SetActive ( unsigned long bActive );
	void AllManifestsLoaded ( );
	void ResetAnims ( );
};

UClass* ATgSkeletalMeshActor_Loader::pClassPointer = NULL;

// Class TgGame.TgSkeletalMeshActor_FlagStand
// 0x0018 (0x02EC - 0x02D4)
class ATgSkeletalMeshActor_FlagStand : public ATgSkeletalMeshActor_Loader
{
public:
	struct FString                                     m_FlagContentDataClassName;                       		// 0x02D4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class UTgFlagContentData*                          m_FlagContentData;                                		// 0x02E0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_nGameTaskForce;                                 		// 0x02E4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_nTeamIndex;                                     		// 0x02E8 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2917 );

		return pClassPointer;
	};

	void PostBeginPlay ( );
	void eventPreBeginPlay ( );
	void ChangeTaskForceFlag ( int nTaskForce, int nTeamIndex );
};

UClass* ATgSkeletalMeshActor_FlagStand::pClassPointer = NULL;

// Class TgGame.TgSkeletalMeshActor_LobbyBase
// 0x0014 (0x02E8 - 0x02D4)
class ATgSkeletalMeshActor_LobbyBase : public ATgSkeletalMeshActor_Loader
{
public:
	unsigned long                                      m_bPlayTransitionOutro : 1;                       		// 0x02D4 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	struct FString                                     m_TransitionActorClassName;                       		// 0x02D8 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class ATgMenuTransitionActor*                      m_TransitionActor;                                		// 0x02E4 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2918 );

		return pClassPointer;
	};

	void eventDestroyed ( );
	void eventEndTransition ( );
	void eventBeginTransition ( unsigned long bPlayFx );
	void eventPostBeginPlay ( );
	void eventPreBeginPlay ( );
};

UClass* ATgSkeletalMeshActor_LobbyBase::pClassPointer = NULL;

// Class TgGame.TgSkeletalMeshActor_Lobby
// 0x0050 (0x0338 - 0x02E8)
class ATgSkeletalMeshActor_Lobby : public ATgSkeletalMeshActor_LobbyBase
{
public:
	int                                                m_CardMICBotIdPending;                            		// 0x02E8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_CardMICTransitionDesiredAlpha;                  		// 0x02EC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_CardMICTransitionAlpha;                         		// 0x02F0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class ATgSkeletalMeshActor_FlagStand*              m_FlagStandActor;                                 		// 0x02F4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class ATgSkeletalMeshActor_Pedestal*               m_PedestalActor;                                  		// 0x02F8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	TArray< class UMaterialInstanceConstant* >         m_CardMICs;                                       		// 0x02FC (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	unsigned long                                      m_bCanBeRotated : 1;                              		// 0x0308 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_bWallEnable : 1;                                		// 0x0308 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	float                                              m_fRotationAmount;                                		// 0x030C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_fDesiredRotationAmount;                         		// 0x0310 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FRotator                                    m_rOriginalRotation;                              		// 0x0314 (0x000C) [0x0000000000002000]              ( CPF_Transient )
	struct FVector                                     m_WallOffset;                                     		// 0x0320 (0x000C) [0x0000000000000001]              ( CPF_Edit )
	struct FVector                                     m_WallNormal;                                     		// 0x032C (0x000C) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2919 );

		return pClassPointer;
	};

	void eventEndTransition ( );
	void eventPreBeginPlay ( );
	bool IsSocketBelowLobbyWall ( struct FName SocketName );
	void RotateModel ( float fValue, unsigned long bSnap );
	void SetActive ( unsigned long bActive );
};

UClass* ATgSkeletalMeshActor_Lobby::pClassPointer = NULL;

// Class TgGame.TgSkeletalMeshActor_ProgressTracker
// 0x0000 (0x0338 - 0x0338)
class ATgSkeletalMeshActor_ProgressTracker : public ATgSkeletalMeshActor_Lobby
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2920 );

		return pClassPointer;
	};

	void eventUpdateProgress ( float fVal );
	void SetActive ( unsigned long bActive );
};

UClass* ATgSkeletalMeshActor_ProgressTracker::pClassPointer = NULL;

// Class TgGame.TgSkeletalMeshActor_Pedestal
// 0x0014 (0x02FC - 0x02E8)
class ATgSkeletalMeshActor_Pedestal : public ATgSkeletalMeshActor_LobbyBase
{
public:
	struct FPointer                                    m_DefaultBot;                                     		// 0x02E8 (0x0004) [0x0000000000003000]              ( CPF_Native | CPF_Transient )
	TArray< class AActor* >                            m_DefaultPedestalActors;                          		// 0x02EC (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	unsigned long                                      m_bUsingDefaultPedestal : 1;                      		// 0x02F8 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2921 );

		return pClassPointer;
	};

	void eventEndTransition ( );
	void SwitchToDefaultPedestal ( unsigned char animPose );
};

UClass* ATgSkeletalMeshActor_Pedestal::pClassPointer = NULL;

// Class TgGame.TgSkeletalMeshActor_Leash
// 0x0020 (0x0288 - 0x0268)
class ATgSkeletalMeshActor_Leash : public ATgSkeletalMeshActorSpawnable
{
public:
	class USkeletalMeshComponent*                      m_StartMesh;                                      		// 0x0268 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	struct FName                                       m_StartBoneName;                                  		// 0x026C (0x0008) [0x0000000000000000]              
	class USkeletalMeshComponent*                      m_EndMesh;                                        		// 0x0274 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	struct FName                                       m_EndBoneName;                                    		// 0x0278 (0x0008) [0x0000000000000000]              
	class USkelControlSingleBone*                      m_StartControl;                                   		// 0x0280 (0x0004) [0x0000000000000000]              
	class USkelControlSingleBone*                      m_EndControl;                                     		// 0x0284 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2922 );

		return pClassPointer;
	};

};

UClass* ATgSkeletalMeshActor_Leash::pClassPointer = NULL;

// Class TgGame.TgSkeletalMeshActorSpawnable_ApolloChariot
// 0x0008 (0x0270 - 0x0268)
class ATgSkeletalMeshActorSpawnable_ApolloChariot : public ATgSkeletalMeshActorSpawnable
{
public:
	unsigned long                                      m_bShouldScaleWithLifeSpan : 1;                   		// 0x0268 (0x0004) [0x0000000000000000] [0x00000001] 
	float                                              m_fScaleMeshAtLifeSpan;                           		// 0x026C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2923 );

		return pClassPointer;
	};

};

UClass* ATgSkeletalMeshActorSpawnable_ApolloChariot::pClassPointer = NULL;

// Class TgGame.TgSkeletalMeshComponent
// 0x0054 (0x06D0 - 0x067C)
class UTgSkeletalMeshComponent : public USkeletalMeshComponent
{
public:
	float                                              FOV;                                              		// 0x067C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      c_bFxApplied : 1;                                 		// 0x0680 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      c_bIsFemale : 1;                                  		// 0x0680 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      c_bSkeletonFrozen : 1;                            		// 0x0680 (0x0004) [0x0000000000002000] [0x00000004] ( CPF_Transient )
	TArray< class UTgSpecialFx* >                      c_FxList;                                         		// 0x0684 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UTgSpecialFx* >                      c_DatabaseFxList;                                 		// 0x0690 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                m_nAssemblyId;                                    		// 0x069C (0x0004) [0x0000000000000000]              
	struct FVector                                     FPCTranslation;                                   		// 0x06A0 (0x000C) [0x0000000000000000]              
	struct FRotator                                    FPCRotation;                                      		// 0x06AC (0x000C) [0x0000000000000000]              
	struct FVector                                     FPCScale;                                         		// 0x06B8 (0x000C) [0x0000000000000000]              
	int                                                c_AudioGroupId;                                   		// 0x06C4 (0x0004) [0x0000000000000000]              
	int                                                c_nForceUpdateAttachmentsInTick;                  		// 0x06C8 (0x0004) [0x0000000000000000]              
	int                                                c_nOldForcedLodLevel;                             		// 0x06CC (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2924 );

		return pClassPointer;
	};

	void SetForceUpdateAttachmentsInTick ( unsigned long bSet );
	class UAnimTree* GetAnimTree ( );
	void FreezeSkeleton ( unsigned long bFreeze );
	void OnMeshSetHidden ( unsigned long bHidden );
	void RecalculateFx ( );
	void ActivateWhileAliveFx ( );
	void ActivateOnWhenDeployedFx ( );
	float GetCurrentDeployPercentage ( );
	void SwapMaterial ( class UMaterialInterface* MI, unsigned long bNoParamReaping );
	class UMaterialInterface* GetDefaultMaterial ( int nIndex );
	void SetDefaultSkin ( int nIndex );
	void FxActivateIndependant ( struct FName nmGroup, int nMode, struct FVector HitLocation, struct FVector HitNormal, int nSocketIndex, int nEquipSlot, unsigned long bUseSocketOverride, float fScale );
	void FxSpawnSound ( struct FName nmGroup, int nMode, struct FVector SoundLocation, int nSocketIndex, int nEquipSlot );
	void FxSpawnEmitter ( struct FName nmGroup, int nMode, struct FVector HitLocation, struct FVector HitNormal, int nSocketIndex, int nEquipSlot );
	void FxSpawnTracer ( struct FName nmGroup, int nMode, struct FVector HitLocation, int nSocketIndex, int nEquipSlot );
	void FxDeactivateAll ( int nEquipSlot );
	void FxDeactivateGroup ( struct FName nmGroup, int nMode, int nSocketIndex, int nEquipSlot );
	class UObject* FxActivateGroup ( struct FName nmGroup, int nMode, int nSocketIndex, int nEquipSlot, unsigned long bIgnoreRelevancy );
	class UObject* FxGet ( struct FName nmGroup, int nMode, int nIndex, int nSocketIndex, int nEquipSlot );
	void FxRemove ( class UObject* Fx );
	void FxAdd ( class UObject* Fx );
	void EndRagdoll ( );
	void InitRagdoll ( );
};

UClass* UTgSkeletalMeshComponent::pClassPointer = NULL;

// Class TgGame.TgStaticMeshActor
// 0x0000 (0x01FC - 0x01FC)
class ATgStaticMeshActor : public AStaticMeshActor
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2925 );

		return pClassPointer;
	};

};

UClass* ATgStaticMeshActor::pClassPointer = NULL;

// Class TgGame.TgStaticMeshActor_GodMIC
// 0x0008 (0x0204 - 0x01FC)
class ATgStaticMeshActor_GodMIC : public ATgStaticMeshActor
{
public:
	int                                                m_nGameTaskForce;                                 		// 0x01FC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_nTeamIndex;                                     		// 0x0200 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2926 );

		return pClassPointer;
	};

	void eventPreBeginPlay ( );
	void ChangeGodMIC ( int nTaskForce, int nTeamIndex );
};

UClass* ATgStaticMeshActor_GodMIC::pClassPointer = NULL;

// Class TgGame.TgStaticMeshActor_PantheonMIC
// 0x002C (0x0228 - 0x01FC)
class ATgStaticMeshActor_PantheonMIC : public ATgStaticMeshActor
{
public:
	class UMaterialInstanceConstant*                   MICOverrides[ 0x9 ];                              		// 0x01FC (0x0024) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_nGameTaskForce;                                 		// 0x0220 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_nTeamIndex;                                     		// 0x0224 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2927 );

		return pClassPointer;
	};

	void eventPreBeginPlay ( );
	void ChangePantheonMIC ( int nTaskForce, int nTeamIndex );
};

UClass* ATgStaticMeshActor_PantheonMIC::pClassPointer = NULL;

// Class TgGame.TgStaticMeshActorTargeting
// 0x0000 (0x01FC - 0x01FC)
class ATgStaticMeshActorTargeting : public AStaticMeshActor
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2928 );

		return pClassPointer;
	};

};

UClass* ATgStaticMeshActorTargeting::pClassPointer = NULL;

// Class TgGame.TgStaticMeshComponent
// 0x0020 (0x02C4 - 0x02A4)
class UTgStaticMeshComponent : public UStaticMeshComponent
{
public:
	unsigned long                                      c_bFxApplied : 1;                                 		// 0x02A4 (0x0004) [0x0000000000000000] [0x00000001] 
	TArray< class UTgSpecialFx* >                      c_FxList;                                         		// 0x02A8 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UTgSpecialFx* >                      c_DatabaseFxList;                                 		// 0x02B4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                m_nAssemblyId;                                    		// 0x02C0 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2929 );

		return pClassPointer;
	};

	void RecalculateFx ( );
	void OnMeshSetHidden ( unsigned long bHidden );
	class UMaterialInterface* GetDefaultMaterial ( int nIndex );
	void SetDefaultSkin ( int nIndex );
	void SwapMaterial ( class UMaterialInterface* MI, unsigned long bNoParamReaping );
	void FxActivateIndependant ( struct FName nmGroup, int nMode, struct FVector HitLocation, struct FVector HitNormal, int nSocketIndex, int nEquipSlot, unsigned long bUseSocketOverride, float fScale );
	void FxSpawnSound ( struct FName nmGroup, int nMode, struct FVector SoundLocation, int nSocketIndex, int nEquipSlot );
	void FxSpawnEmitter ( struct FName nmGroup, int nMode, struct FVector HitLocation, struct FVector HitNormal, int nSocketIndex, int nEquipSlot );
	void FxSpawnTracer ( struct FName nmGroup, int nMode, struct FVector HitLocation, int nSocketIndex, int nEquipSlot );
	void FxDeactivateAll ( int nEquipSlot );
	void FxDeactivateGroup ( struct FName nmGroup, int nMode, int nSocketIndex, int nEquipSlot );
	class UObject* FxActivateGroup ( struct FName nmGroup, int nMode, int nSocketIndex, int nEquipSlot, unsigned long bIgnoreRelevancy );
	class UObject* FxGet ( struct FName nmGroup, int nMode, int nIndex, int nSocketIndex, int nEquipSlot );
	void FxRemove ( class UObject* Fx );
	void FxAdd ( class UObject* Fx );
};

UClass* UTgStaticMeshComponent::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorObject
// 0x0004 (0x0040 - 0x003C)
class UTgAIBehaviorObject : public UObject
{
public:
	int                                                NodeToken;                                        		// 0x003C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2930 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorObject::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorComment
// 0x0000 (0x0040 - 0x0040)
class UTgAIBehaviorComment : public UTgAIBehaviorObject
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2931 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorComment::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorNode
// 0x0024 (0x0064 - 0x0040)
class UTgAIBehaviorNode : public UTgAIBehaviorObject
{
public:
	class UTgAIBehaviorNode*                           Parent;                                           		// 0x0040 (0x0004) [0x0000000000200000]              
	float                                              InvTickFrequency;                                 		// 0x0044 (0x0004) [0x0000000000000000]              
	struct FString                                     TitleName;                                        		// 0x0048 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FString                                     FriendlyName;                                     		// 0x0054 (0x000C) [0x0000000000500001]              ( CPF_Edit | CPF_NeedCtorLink )
	unsigned long                                      bShownInMenu : 1;                                 		// 0x0060 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2932 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorNode::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorAction
// 0x0000 (0x0064 - 0x0064)
class UTgAIBehaviorAction : public UTgAIBehaviorNode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2933 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorAction::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorAction_PlayVGS
// 0x0004 (0x0068 - 0x0064)
class UTgAIBehaviorAction_PlayVGS : public UTgAIBehaviorAction
{
public:
	int                                                VgsId;                                            		// 0x0064 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2934 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorAction_PlayVGS::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorComposite
// 0x001C (0x0080 - 0x0064)
class UTgAIBehaviorComposite : public UTgAIBehaviorNode
{
public:
	TArray< class UTgAIBehaviorNode* >                 Children;                                         		// 0x0064 (0x000C) [0x0000000004500040]              ( CPF_EditConstArray | CPF_NeedCtorLink | CPF_EditInline )
	TArray< int >                                      ChildrenIndices;                                  		// 0x0070 (0x000C) [0x0000000000502000]              ( CPF_Transient | CPF_NeedCtorLink )
	unsigned long                                      bCompleteOnAll : 1;                               		// 0x007C (0x0004) [0x0000000000020003] [0x00000001] ( CPF_Edit | CPF_Const | CPF_EditConst )
	unsigned long                                      bFailsOnAll : 1;                                  		// 0x007C (0x0004) [0x0000000000020003] [0x00000002] ( CPF_Edit | CPF_Const | CPF_EditConst )
	unsigned long                                      bRetryFailedChild : 1;                            		// 0x007C (0x0004) [0x0000000000020003] [0x00000004] ( CPF_Edit | CPF_Const | CPF_EditConst )
	unsigned long                                      bFixedChildrenSize : 1;                           		// 0x007C (0x0004) [0x0000000000020002] [0x00000008] ( CPF_Const | CPF_EditConst )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2935 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorComposite::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorComposite_Gated
// 0x0000 (0x0080 - 0x0080)
class UTgAIBehaviorComposite_Gated : public UTgAIBehaviorComposite
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2936 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorComposite_Gated::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorComposite_Random
// 0x0014 (0x0094 - 0x0080)
class UTgAIBehaviorComposite_Random : public UTgAIBehaviorComposite
{
public:
	TArray< float >                                    ChildWeights;                                     		// 0x0080 (0x000C) [0x0000000004400041]              ( CPF_Edit | CPF_EditConstArray | CPF_NeedCtorLink | CPF_EditInline )
	float                                              ChildFreezeTime;                                  		// 0x008C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      bRandomizeOnComplete : 1;                         		// 0x0090 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2937 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorComposite_Random::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorComposite_Sequence
// 0x0004 (0x0084 - 0x0080)
class UTgAIBehaviorComposite_Sequence : public UTgAIBehaviorComposite
{
public:
	unsigned long                                      bStopOnRunningChild : 1;                          		// 0x0080 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2938 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorComposite_Sequence::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorComposite_Parallel
// 0x0000 (0x0084 - 0x0084)
class UTgAIBehaviorComposite_Parallel : public UTgAIBehaviorComposite_Sequence
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2939 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorComposite_Parallel::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorComposite_SequenceScripted
// 0x0004 (0x0084 - 0x0080)
class UTgAIBehaviorComposite_SequenceScripted : public UTgAIBehaviorComposite
{
public:
	unsigned long                                      bFreezeOnLast : 1;                                		// 0x0080 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      bIsLooping : 1;                                   		// 0x0080 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      bFirstChildIsResetTest : 1;                       		// 0x0080 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      bResetSequenceOnFailure : 1;                      		// 0x0080 (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2940 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorComposite_SequenceScripted::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorComposite_SubTree
// 0x0004 (0x0084 - 0x0080)
class UTgAIBehaviorComposite_SubTree : public UTgAIBehaviorComposite
{
public:
	class UTgAIBehaviorTree*                           ChildTree;                                        		// 0x0080 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2941 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorComposite_SubTree::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition
// 0x0001 (0x0065 - 0x0064)
class UTgAIBehaviorCondition : public UTgAIBehaviorNode
{
public:
	unsigned char                                      ComparisonOperator;                               		// 0x0064 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2942 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition_CombatTargetHasEffectCategory
// 0x000F (0x0074 - 0x0065)
class UTgAIBehaviorCondition_CombatTargetHasEffectCategory : public UTgAIBehaviorCondition
{
public:
	unsigned long                                      bEffectGroupCategoryCheckInstigator : 1;          		// 0x0068 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	int                                                EffectCategoryId;                                 		// 0x006C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                EffectGroupId;                                    		// 0x0070 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2943 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition_CombatTargetHasEffectCategory::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition_HasEffectCategory
// 0x000B (0x0070 - 0x0065)
class UTgAIBehaviorCondition_HasEffectCategory : public UTgAIBehaviorCondition
{
public:
	int                                                EffectCategoryId;                                 		// 0x0068 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                EffectGroupId;                                    		// 0x006C (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2944 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition_HasEffectCategory::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorSensor
// 0x0000 (0x0064 - 0x0064)
class UTgAIBehaviorSensor : public UTgAIBehaviorNode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2945 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorSensor::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorTree
// 0x0010 (0x0074 - 0x0064)
class UTgAIBehaviorTree : public UTgAIBehaviorNode
{
public:
	class UTgAIBehaviorComposite*                      ChildNode;                                        		// 0x0064 (0x0004) [0x0000000000000000]              
	TArray< class UTgAIBehaviorSensor* >               SensorNodes;                                      		// 0x0068 (0x000C) [0x0000000000500000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2946 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorTree::pClassPointer = NULL;

// Class TgGame.TgAIController
// 0x00EC (0x04B4 - 0x03C8)
class ATgAIController : public AGameAIController
{
public:
	class ATgPawn*                                     m_pOwner;                                         		// 0x03C8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FVector                                     m_vSpawnLocation;                                 		// 0x03CC (0x000C) [0x0000000000002000]              ( CPF_Transient )
	struct FRotator                                    m_rSpawnDirection;                                		// 0x03D8 (0x000C) [0x0000000000002000]              ( CPF_Transient )
	class ATgBotFactory*                               m_pFactory;                                       		// 0x03E4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_nFactorySpawnGroup;                             		// 0x03E8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FPointer                                    m_pBot;                                           		// 0x03EC (0x0004) [0x0000000000003002]              ( CPF_Const | CPF_Native | CPF_Transient )
	struct FPointer                                    m_pSettings;                                      		// 0x03F0 (0x0004) [0x0000000000003002]              ( CPF_Const | CPF_Native | CPF_Transient )
	struct FPointer                                    m_pSkin;                                          		// 0x03F4 (0x0004) [0x0000000000003002]              ( CPF_Const | CPF_Native | CPF_Transient )
	int                                                m_iAssignedLane;                                  		// 0x03F8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      UnknownData00[ 0x3C ];                            		// 0x03FC (0x003C) UNKNOWN PROPERTY: MapProperty TgGame.TgAIController.m_SeePawnCache
	float                                              LastSeePawnCacheTime;                             		// 0x0438 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              SeePawnClearTime;                                 		// 0x043C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class ATgPawn*                                     m_pLastAttacker;                                  		// 0x0440 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class AController*                                 m_pLastKiller;                                    		// 0x0444 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UTgAISquad*                                  m_Squad;                                          		// 0x0448 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_fAILevelUpSecs;                                 		// 0x044C (0x0004) [0x0000000000000000]              
	unsigned char                                      WalkingPhysics;                                   		// 0x0450 (0x0001) [0x0000000000000000]              
	float                                              VisionDistance;                                   		// 0x0454 (0x0004) [0x0000000000000000]              
	unsigned long                                      bUsesObstacleAvoidance : 1;                       		// 0x0458 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      bIsPaused : 1;                                    		// 0x0458 (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	class UTgAIObstacleAvoidance*                      ObstacleAvoidance;                                		// 0x045C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              ObstacleAvoidanceGridPointSize;                   		// 0x0460 (0x0004) [0x0000000000000000]              
	float                                              ObstacleAvoidanceGridExtents;                     		// 0x0464 (0x0004) [0x0000000000000000]              
	struct FVector                                     SpreadLocation;                                   		// 0x0468 (0x000C) [0x0000000000002000]              ( CPF_Transient )
	class ATgRepInfo_Player*                           CachedPRI;                                        		// 0x0474 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      UnknownData01[ 0x3C ];                            		// 0x0478 (0x003C) UNKNOWN PROPERTY: MapProperty TgGame.TgAIController.DeviceTargetingCache

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2947 );

		return pClassPointer;
	};

	void NotifyWeaponFired ( class AWeapon* W, unsigned char FireMode );
	void eventNotifyDamagedTarget ( class ATgPawn* TargetPawn );
	void eventDeviceOnStopFire ( class ATgDevice* Dev, unsigned long WasInterrupted );
	void eventDeviceOnHit ( class ATgDevice* Dev, struct FImpactInfo* Impact );
	void eventDeviceOnFire ( class ATgDevice* Dev );
	void eventDeviceOnStartFire ( class ATgDevice* Dev );
	void eventDeviceOnStopBuildup ( class ATgDevice* Dev, unsigned long WasInterrupted );
	void eventDeviceOnStartBuildup ( class ATgDevice* Dev );
	void OnEnterCombat ( );
	void OnExitCombat ( );
	void NotifyTakeHit ( class AController* InstigatedBy, struct FVector HitLocation, int Damage, class UClass* DamageType, struct FVector Momentum );
	void NotifyKilledBy ( class AController* Killer );
	void SetActionlessPause ( unsigned long bOn );
	void OnToggleImmuneGodMode ( class UTgSeqAct_ToggleImmuneGodMode* inAction );
	void OnSetTaskforce ( class UTgSeqAct_SetTaskforce* Action );
	void OnTriggerBots ( class UTgSeqAct_TriggerBots* Action );
	void PawnDied ( class APawn* P );
	void eventSuicide ( );
	void eventDespawn ( );
	void Destroyed ( );
	void CleanupPRI ( );
	void InitPlayerReplicationInfo ( );
	void eventPossess ( class APawn* inPawn, unsigned long bVehicleTransition );
	void eventPostBeginPlay ( );
	bool CanSpreadOut ( );
	void ClearSpreadLocation ( );
	void SetSpreadLocation ( struct FVector* SpreadLoc );
	void Evade ( );
	void SquadEvade ( );
	void SquadTargetChanged ( );
	void UpdateTargetingList ( TArray< struct FImpactInfo > ImpactList, unsigned char EquipSlot );
	float GetMaxDeviceRange ( );
	bool LineCheckPassThrough ( struct FVector vLocation, class AActor* pTarget, struct FVector vTarget );
	bool LineCheckEx ( struct FVector vLocation, class AActor* pTarget, struct FVector vTarget );
	bool LineCheck ( struct FVector vLocation, class AActor* pTarget );
	bool LineCheckVisibility ( class AActor* pTarget, class AActor* pSource );
	bool LineCheckMovement ( class AActor* pTarget, class AActor* pSource );
	void SetTaskForceNumber ( int nTaskForce );
	int GetTaskForceNumber ( );
	void AddThreat ( class ATgPawn* attacker, float fAmount );
	bool IsDeviceReady ( unsigned char DeviceSlot );
	bool AtLocation ( struct FVector vLocation );
};

UClass* ATgAIController::pClassPointer = NULL;

// Class TgGame.TgAIController_Behavior
// 0x01E4 (0x0698 - 0x04B4)
class ATgAIController_Behavior : public ATgAIController
{
public:
	TArray< struct FDeferredNode >                     DeferredNodes;                                    		// 0x04B4 (0x000C) [0x0000000000502000]              ( CPF_Transient | CPF_NeedCtorLink )
	int                                                BlackboardType;                                   		// 0x04C0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FName                                       BehaviorTreeAsName;                               		// 0x04C4 (0x0008) [0x0000000000000000]              
	struct FPointer                                    SensorTree;                                       		// 0x04CC (0x0004) [0x0000000000003000]              ( CPF_Native | CPF_Transient )
	struct FPointer                                    SensorDynamicMemory;                              		// 0x04D0 (0x0004) [0x0000000000003000]              ( CPF_Native | CPF_Transient )
	struct FPointer                                    SensorStaticMemory;                               		// 0x04D4 (0x0004) [0x0000000000003000]              ( CPF_Native | CPF_Transient )
	struct FPointer                                    WorkerTree;                                       		// 0x04D8 (0x0004) [0x0000000000003000]              ( CPF_Native | CPF_Transient )
	struct FPointer                                    WorkerTreeCachedStatus;                           		// 0x04DC (0x0004) [0x0000000000003000]              ( CPF_Native | CPF_Transient )
	struct FPointer                                    WorkerDynamicMemory;                              		// 0x04E0 (0x0004) [0x0000000000003000]              ( CPF_Native | CPF_Transient )
	struct FPointer                                    WorkerStaticMemory;                               		// 0x04E4 (0x0004) [0x0000000000003000]              ( CPF_Native | CPF_Transient )
	int                                                SensorNodeCount;                                  		// 0x04E8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                WorkerNodeCount;                                  		// 0x04EC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              LastUpdateTime;                                   		// 0x04F0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	TArray< struct FBehaviorStateData >                CachedNodeData;                                   		// 0x04F4 (0x000C) [0x0000000000502000]              ( CPF_Transient | CPF_NeedCtorLink )
	float                                              m_fCooldownModifier;                              		// 0x0500 (0x0004) [0x0000000000000000]              
	float                                              m_fLeadAccuracy;                                  		// 0x0504 (0x0004) [0x0000000000000000]              
	float                                              m_fGoldGainModifier;                              		// 0x0508 (0x0004) [0x0000000000000000]              
	float                                              m_fXpGainModifier;                                		// 0x050C (0x0004) [0x0000000000000000]              
	class UTgAILocalPositionSolver*                    LocalRepulsorSolver;                              		// 0x0510 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UClass*                                      LocalRepulsorSolverClass;                         		// 0x0514 (0x0004) [0x0000000000000000]              
	struct FNavigationQueueEntry                       CurrentNavigation;                                		// 0x0518 (0x0024) [0x0000000000002000]              ( CPF_Transient )
	float                                              NavigationSearchModifier;                         		// 0x053C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              NavigationSearchModifier_Max;                     		// 0x0540 (0x0004) [0x0000000000000000]              
	float                                              NavigationSearchModifier_Min;                     		// 0x0544 (0x0004) [0x0000000000000000]              
	struct FFollowLaneState                            FollowLaneForwardState;                           		// 0x0548 (0x0008) [0x0000000000000000]              
	struct FFollowLaneState                            FollowLaneReverseState;                           		// 0x0550 (0x0008) [0x0000000000000000]              
	unsigned long                                      bIsAlive : 1;                                     		// 0x0558 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	unsigned long                                      bIsRotationLocked : 1;                            		// 0x0558 (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	unsigned long                                      bIsStunned : 1;                                   		// 0x0558 (0x0004) [0x0000000000002000] [0x00000004] ( CPF_Transient )
	unsigned long                                      bCanUpdateAIWhileStunned : 1;                     		// 0x0558 (0x0004) [0x0000000000000002] [0x00000008] ( CPF_Const )
	unsigned long                                      bInHostileAbility : 1;                            		// 0x0558 (0x0004) [0x0000000000002000] [0x00000010] ( CPF_Transient )
	unsigned long                                      bIsSafeToRecall : 1;                              		// 0x0558 (0x0004) [0x0000000000002000] [0x00000020] ( CPF_Transient )
	unsigned long                                      bInEnemyTowerRadius : 1;                          		// 0x0558 (0x0004) [0x0000000000002000] [0x00000040] ( CPF_Transient )
	unsigned long                                      bInFriendlyTowerRadius : 1;                       		// 0x0558 (0x0004) [0x0000000000002000] [0x00000080] ( CPF_Transient )
	unsigned long                                      bInEnemyMinotaurRadius : 1;                       		// 0x0558 (0x0004) [0x0000000000002000] [0x00000100] ( CPF_Transient )
	unsigned long                                      bInFriendlyMinotaurRadius : 1;                    		// 0x0558 (0x0004) [0x0000000000002000] [0x00000200] ( CPF_Transient )
	unsigned long                                      bIsTargetOfEnemyTowerOrMinotaur : 1;              		// 0x0558 (0x0004) [0x0000000000002000] [0x00000400] ( CPF_Transient )
	unsigned long                                      bCombatTargetInEnemyTowerRadius : 1;              		// 0x0558 (0x0004) [0x0000000000002000] [0x00000800] ( CPF_Transient )
	unsigned long                                      bCombatTargetInFriendlyTowerRadius : 1;           		// 0x0558 (0x0004) [0x0000000000002000] [0x00001000] ( CPF_Transient )
	unsigned long                                      bCombatTargetInEnemyMinotaurRadius : 1;           		// 0x0558 (0x0004) [0x0000000000002000] [0x00002000] ( CPF_Transient )
	unsigned long                                      bCombatTargetInFriendlyMinotaurRadius : 1;        		// 0x0558 (0x0004) [0x0000000000002000] [0x00004000] ( CPF_Transient )
	unsigned long                                      bCombatTargetIsTargetOfFriendlyTowerOrMinotaur : 1;		// 0x0558 (0x0004) [0x0000000000002000] [0x00008000] ( CPF_Transient )
	unsigned long                                      bIsAtCachedRallyPoint : 1;                        		// 0x0558 (0x0004) [0x0000000000002000] [0x00010000] ( CPF_Transient )
	unsigned long                                      bBtDebugSpawnPaused : 1;                          		// 0x0558 (0x0004) [0x0000000000000000] [0x00020000] 
	unsigned long                                      bBtDebugPaused : 1;                               		// 0x0558 (0x0004) [0x0000000000002000] [0x00040000] ( CPF_Transient )
	unsigned long                                      bBtDebugStep : 1;                                 		// 0x0558 (0x0004) [0x0000000000002000] [0x00080000] ( CPF_Transient )
	unsigned long                                      bBtDebugClientOverlay : 1;                        		// 0x0558 (0x0004) [0x0000000000002000] [0x00100000] ( CPF_Transient )
	float                                              NextFearDirectionTime;                            		// 0x055C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FVector                                     NextFearDirection;                                		// 0x0560 (0x000C) [0x0000000000002000]              ( CPF_Transient )
	float                                              PawnCollisionHeight;                              		// 0x056C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              PawnCollisionRadius;                              		// 0x0570 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              LastDamageTakenTime;                              		// 0x0574 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FVector                                     LastDamageTakenPosition;                          		// 0x0578 (0x000C) [0x0000000000002000]              ( CPF_Transient )
	float                                              DeviceRanges[ 0x19 ];                             		// 0x0584 (0x0064) [0x0000000000002000]              ( CPF_Transient )
	class AActor*                                      CombatTarget;                                     		// 0x05E8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class ATgPawn*                                     CombatTargetAsPawn;                               		// 0x05EC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                EnemyMinionsInEnemyTowerRadius;                   		// 0x05F0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                FriendlyMinionsInEnemyTowerRadius;                		// 0x05F4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                EnemyMinionsInFriendlyTowerRadius;                		// 0x05F8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                FriendlyMinionsInFriendlyTowerRadius;             		// 0x05FC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                EnemyGodsInEnemyTowerRadius;                      		// 0x0600 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                FriendlyGodsInEnemyTowerRadius;                   		// 0x0604 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                EnemyGodsInFriendlyTowerRadius;                   		// 0x0608 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                FriendlyGodsInFriendlyTowerRadius;                		// 0x060C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              HealthOfNearestEnemyTower;                        		// 0x0610 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              HealthOfNearestFriendlyTower;                     		// 0x0614 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                EnemyMinionsInEnemyMinotaurRadius;                		// 0x0618 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                FriendlyMinionsInEnemyMinotaurRadius;             		// 0x061C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                EnemyMinionsInFriendlyMinotaurRadius;             		// 0x0620 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                FriendlyMinionsInFriendlyMinotaurRadius;          		// 0x0624 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                EnemyGodsInEnemyMinotaurRadius;                   		// 0x0628 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                FriendlyGodsInEnemyMinotaurRadius;                		// 0x062C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                EnemyGodsInFriendlyMinotaurRadius;                		// 0x0630 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                FriendlyGodsInFriendlyMinotaurRadius;             		// 0x0634 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              HealthOfEnemyMinotaur;                            		// 0x0638 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              HealthOfFriendlyMinotaur;                         		// 0x063C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class AActor*                                      LaneMoveTarget;                                   		// 0x0640 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	TArray< class AActor* >                            VisibleActorsToAvoid;                             		// 0x0644 (0x000C) [0x0000000000502000]              ( CPF_Transient | CPF_NeedCtorLink )
	TArray< class ATgPawn* >                           CachedTowers;                                     		// 0x0650 (0x000C) [0x0000000000502000]              ( CPF_Transient | CPF_NeedCtorLink )
	TArray< class ATgPawn_Character* >                 CachedGods;                                       		// 0x065C (0x000C) [0x0000000000502000]              ( CPF_Transient | CPF_NeedCtorLink )
	TArray< class AController* >                       EnemyControllersInSightRadius;                    		// 0x0668 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	TArray< class AController* >                       FriendlyControllersInSightRadius;                 		// 0x0674 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	unsigned char                                      Difficulty;                                       		// 0x0680 (0x0001) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      LastUseDeviceAimType;                             		// 0x0681 (0x0001) [0x0000000000002000]              ( CPF_Transient )
	TArray< struct FIncomingDamageEntry >              IncomingDamage;                                   		// 0x0684 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	class ATgAIVolume*                                 CachedRallyVolume;                                		// 0x0690 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                RandomRallyPointIndex;                            		// 0x0694 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2948 );

		return pClassPointer;
	};

	void GameHasEnded ( class AActor* EndGameFocus, unsigned long bIsWinner );
	void PawnDied ( class APawn* P );
	struct FRotator GetAdjustedAimFor ( class AWeapon* Weap, struct FVector StartFireLoc );
	float GetLeadAccuracy ( );
	float GetCooldownModifier ( );
	float GetAngleToTarget ( );
	void eventDeviceOnStopFire ( class ATgDevice* Dev, unsigned long WasInterrupted );
	bool eventCancelFiring ( );
	bool eventFireDevice ( unsigned char DeviceSlot, unsigned char aimType );
	void NotifyTakeHit ( class AController* InstigatedBy, struct FVector HitLocation, int Damage, class UClass* DamageType, struct FVector Momentum );
	void Stun ( unsigned long bStun, unsigned char eType );
	void UpdateDeviceRanges ( );
	void StopNavigation ( );
	void ClearNavigation ( );
	void AddLocationToNavigationQueue ( int NodeToken, struct FVector TargetLocation, unsigned long bLookAtTarget, unsigned long bMustHaveLOS, float DistanceTolerance );
	void AddActorToNavigationQueue ( int NodeToken, class AActor* TargetActor, unsigned long bLookAtTarget, unsigned long bMustHaveLOS, float DistanceTolerance, unsigned long bStopNavOnReachedDestination );
	bool HasVisibilityToPoint ( struct FVector* TestPoint );
	void eventResetBlackboard ( );
	void eventPossess ( class APawn* inPawn, unsigned long bVehicleTransition );
	void eventDestroyed ( );
	void eventPostBeginPlay ( );
	void eventPreBeginPlay ( );
	void LoadBehaviorTree ( struct FName TreeName );
	void ResetBehaviorTree ( );
	void CleanupBehaviorTree ( );
	void SpawnDebuggerWindow ( );
	void Debug_Reset ( );
	void Debug_Resume ( );
	void Debug_Step ( );
	void Debug_Pause ( );
	void eventUpdatePawnDebug ( );
};

UClass* ATgAIController_Behavior::pClassPointer = NULL;

// Class TgGame.TgAIController_BehaviorGod
// 0x001C (0x06B4 - 0x0698)
class ATgAIController_BehaviorGod : public ATgAIController_Behavior
{
public:
	float                                              WaitForSpawnSecs;                                 		// 0x0698 (0x0004) [0x0000000000000000]              
	int                                                PlayerID;                                         		// 0x069C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned long                                      bCanPurchaseItems : 1;                            		// 0x06A0 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	unsigned long                                      bCanPurchaseSkills : 1;                           		// 0x06A0 (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	float                                              CurrentGoldRemainder;                             		// 0x06A4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                CurrentGold;                                      		// 0x06A8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              CurrentXPRemainder;                               		// 0x06AC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                CurrentXP;                                        		// 0x06B0 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2949 );

		return pClassPointer;
	};

	void SetupIntro ( );
	void ResetPlayer ( );
	void eventCopyPropertiesTo ( class AController* C );
	void PawnDied ( class APawn* P );
	void eventPossess ( class APawn* inPawn, unsigned long bVehicleTransition );
	void eventRevive ( );
	void InitPlayerReplicationInfo ( );
	void SetStartingProperties ( );
	void SetBotPlayerId ( );
	float StartReviveTimer ( );
	void PurchaseSkills ( );
	int GetSkillPointsAvailable ( );
	bool HaveBasicSkillsBeenActivated ( );
	bool CanAllocateSkillPoint ( int DeviceID, class ATgDevice* aDevice );
	void PurchaseItems ( );
};

UClass* ATgAIController_BehaviorGod::pClassPointer = NULL;

// Class TgGame.TgAIController_BehaviorGodDisconnected
// 0x0004 (0x06B8 - 0x06B4)
class ATgAIController_BehaviorGodDisconnected : public ATgAIController_BehaviorGod
{
public:
	unsigned long                                      bInitialController : 1;                           		// 0x06B4 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2950 );

		return pClassPointer;
	};

	void eventPossess ( class APawn* inPawn, unsigned long bVehicleTransition );
	void InitPlayerReplicationInfo ( );
};

UClass* ATgAIController_BehaviorGodDisconnected::pClassPointer = NULL;

// Class TgGame.TgAIController_BehaviorLaneNpc
// 0x0008 (0x06A0 - 0x0698)
class ATgAIController_BehaviorLaneNpc : public ATgAIController_Behavior
{
public:
	class AActor*                                      GoalTarget;                                       		// 0x0698 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned long                                      bDespawnOnLoseCombatTarget : 1;                   		// 0x069C (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	unsigned long                                      bIsBehindSquad : 1;                               		// 0x069C (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	unsigned long                                      bTooFarFromLane : 1;                              		// 0x069C (0x0004) [0x0000000000002000] [0x00000004] ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2951 );

		return pClassPointer;
	};

	bool CanSpreadOut ( );
};

UClass* ATgAIController_BehaviorLaneNpc::pClassPointer = NULL;

// Class TgGame.TgAIController_BehaviorMapNpc
// 0x0024 (0x06BC - 0x0698)
class ATgAIController_BehaviorMapNpc : public ATgAIController_Behavior
{
public:
	TArray< struct FThreatEntry >                      ThreatList;                                       		// 0x0698 (0x000C) [0x0000000000502000]              ( CPF_Transient | CPF_NeedCtorLink )
	unsigned long                                      bThreatListDecays : 1;                            		// 0x06A4 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	unsigned long                                      bOutsideLeash : 1;                                		// 0x06A4 (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	unsigned long                                      bHadCombatTarget : 1;                             		// 0x06A4 (0x0004) [0x0000000000002000] [0x00000004] ( CPF_Transient )
	float                                              LeashDistance;                                    		// 0x06A8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class AVolume*                                     LeashVolume;                                      		// 0x06AC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	TArray< class ATgPawn* >                           LeashActors;                                      		// 0x06B0 (0x000C) [0x0000000000502000]              ( CPF_Transient | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2952 );

		return pClassPointer;
	};

	void NotifyKilledBy ( class AController* Killer );
	void SquadTargetChanged ( );
	void SquadEvade ( );
	void Evade ( );
	bool CanSpreadOut ( );
	void ClearThreatList ( );
	void AddThreat ( class ATgPawn* attacker, float ThreatLevel );
};

UClass* ATgAIController_BehaviorMapNpc::pClassPointer = NULL;

// Class TgGame.TgAIController_BehaviorPet
// 0x0000 (0x0698 - 0x0698)
class ATgAIController_BehaviorPet : public ATgAIController_Behavior
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2953 );

		return pClassPointer;
	};

};

UClass* ATgAIController_BehaviorPet::pClassPointer = NULL;

// Class TgGame.TgAIController_BehaviorPet_LongTerm
// 0x0000 (0x0698 - 0x0698)
class ATgAIController_BehaviorPet_LongTerm : public ATgAIController_BehaviorPet
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2954 );

		return pClassPointer;
	};

};

UClass* ATgAIController_BehaviorPet_LongTerm::pClassPointer = NULL;

// Class TgGame.TgAIController_Behavior_PVEMinion
// 0x0000 (0x0698 - 0x0698)
class ATgAIController_Behavior_PVEMinion : public ATgAIController_BehaviorPet_LongTerm
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2955 );

		return pClassPointer;
	};

};

UClass* ATgAIController_Behavior_PVEMinion::pClassPointer = NULL;

// Class TgGame.TgAIInfluenceMap
// 0x0028 (0x0064 - 0x003C)
class UTgAIInfluenceMap : public UObject
{
public:
	struct FPointer                                    VfTable_FTickableObject;                          		// 0x003C (0x0004) [0x0000000000801002]              ( CPF_Const | CPF_Native | CPF_NoExport )
	TArray< int >                                      Influences;                                       		// 0x0040 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	struct FPointer                                    FalloffTable;                                     		// 0x004C (0x0004) [0x0000000000003000]              ( CPF_Native | CPF_Transient )
	class UHavokNavMeshGrid*                           InfluenceGrid;                                    		// 0x0050 (0x0004) [0x0000000000003002]              ( CPF_Const | CPF_Native | CPF_Transient )
	float                                              TickFrequency;                                    		// 0x0054 (0x0004) [0x0000000000000000]              
	float                                              InvTickFrequency;                                 		// 0x0058 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              Decay;                                            		// 0x005C (0x0004) [0x0000000000000000]              
	float                                              Momentum;                                         		// 0x0060 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2956 );

		return pClassPointer;
	};

	void RegisterInfluence ( struct FVector StartPosition, int PackedInfluence, unsigned long Additive, float Radius );
	void Init ( );
};

UClass* UTgAIInfluenceMap::pClassPointer = NULL;

// Class TgGame.TgAIInfluenceMapRenderingComponent
// 0x0008 (0x0208 - 0x0200)
class UTgAIInfluenceMapRenderingComponent : public UHavokNavigationRenderingComponent
{
public:
	class UTgAIInfluenceMap*                           InfluenceMap;                                     		// 0x0200 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UTexture2DDynamic*                           InfluenceMapTexture;                              		// 0x0204 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2957 );

		return pClassPointer;
	};

};

UClass* UTgAIInfluenceMapRenderingComponent::pClassPointer = NULL;

// Class TgGame.TgAILocalPositionSolver
// 0x0034 (0x0070 - 0x003C)
class UTgAILocalPositionSolver : public UObject
{
public:
	struct FPointer                                    VfTable_IInterface_ActorPathConstraints;          		// 0x003C (0x0004) [0x0000000000801002]              ( CPF_Const | CPF_Native | CPF_NoExport )
	TArray< struct FDefaultRepulsorData >              DefaultWeights;                                   		// 0x0040 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class ATgAIController_Behavior*                    OuterController;                                  		// 0x004C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              LastQueryTime;                                    		// 0x0050 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FVector                                     LastQueryPoint;                                   		// 0x0054 (0x000C) [0x0000000000002000]              ( CPF_Transient )
	struct FVector                                     LastSolvePoint;                                   		// 0x0060 (0x000C) [0x0000000000002000]              ( CPF_Transient )
	unsigned long                                      bSolveDistanceThreshold : 1;                      		// 0x006C (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      bSolveWeights : 1;                                		// 0x006C (0x0004) [0x0000000000000000] [0x00000002] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2958 );

		return pClassPointer;
	};

	void SolveConstraints ( struct FVector InitialPosition, float MaxDistance, struct FVector* OutDesiredPosition );
};

UClass* UTgAILocalPositionSolver::pClassPointer = NULL;

// Class TgGame.TgAIObstacleAvoidance
// 0x0040 (0x007C - 0x003C)
class UTgAIObstacleAvoidance : public UObject
{
public:
	struct FPointer                                    ObstacleGrid;                                     		// 0x003C (0x0004) [0x0000000000003000]              ( CPF_Native | CPF_Transient )
	struct FObstacleQueryCache                         CachedAvoidance;                                  		// 0x0040 (0x0028) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	TArray< class ABlockingVolume* >                   CachedBlockers;                                   		// 0x0068 (0x000C) [0x0000000000502000]              ( CPF_Transient | CPF_NeedCtorLink )
	class ATgAIController_Behavior*                    OuterController;                                  		// 0x0074 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned long                                      bRenderingIsDirty : 1;                            		// 0x0078 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2959 );

		return pClassPointer;
	};

	void TestObstacleAvoidance ( int TestType );
	void Reset ( );
	void Init ( float GridPointSize, float GridExtents );
	unsigned char GetNextMoveLocation ( struct FVector* TargetPoint, struct FVector* IntermediatePoint, float* ArrivalDistance );
	bool FindPath ( TArray< class AActor* >* ActorsToAvoid, struct FVector* TargetPoint, struct FVector* UpdatedTargetPoint );
};

UClass* UTgAIObstacleAvoidance::pClassPointer = NULL;

// Class TgGame.TgAIObstacleAvoidanceRenderingComponent
// 0x0004 (0x0200 - 0x01FC)
class UTgAIObstacleAvoidanceRenderingComponent : public UPrimitiveComponent
{
public:
	class UTgAIObstacleAvoidance*                      ObstacleAvoidance;                                		// 0x01FC (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2960 );

		return pClassPointer;
	};

};

UClass* UTgAIObstacleAvoidanceRenderingComponent::pClassPointer = NULL;

// Class TgGame.TgAISquad
// 0x0030 (0x006C - 0x003C)
class UTgAISquad : public UObject
{
public:
	struct FPointer                                    VfTable_FTickableObject;                          		// 0x003C (0x0004) [0x0000000000801002]              ( CPF_Const | CPF_Native | CPF_NoExport )
	unsigned long                                      s_bOpen : 1;                                      		// 0x0040 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      s_bShouldSpread : 1;                              		// 0x0040 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      s_bHadMembers : 1;                                		// 0x0040 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      s_bDiedWhileOpen : 1;                             		// 0x0040 (0x0004) [0x0000000000000000] [0x00000008] 
	TArray< class ATgAIController* >                   s_MemberList;                                     		// 0x0044 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class ATgBotFactory*                               s_Factory;                                        		// 0x0050 (0x0004) [0x0000000000000000]              
	class AActor*                                      s_CurrentTarget;                                  		// 0x0054 (0x0004) [0x0000000000000000]              
	TArray< class AActor* >                            s_TargetList;                                     		// 0x0058 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class AController*                                 s_LastKiller;                                     		// 0x0064 (0x0004) [0x0000000000000000]              
	float                                              s_fNextSpreadTime;                                		// 0x0068 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2961 );

		return pClassPointer;
	};

	void eventOnSquadCreated ( );
	void NotifyEvade ( );
	void NotifyTargetChanged ( );
	void Evade ( );
	void SuggestEvade ( );
	void UpdateTargetList ( float DeltaTime );
	void DropTarget ( class AActor* TargetToDrop );
	void SuggestDropTarget ( class AActor* TargetToDrop, class ATgAIController* requester );
	class ATgPawn* GetTargetPawn ( );
	class AActor* GetTarget ( );
	void SetTarget ( class AActor* NewTarget );
	void SuggestTarget ( class AActor* NewTarget, class ATgAIController* requester );
	struct FBox GetSquadBounds ( );
	void SpreadSquad ( );
	void SquadDied ( );
	bool MergeWith ( class UTgAISquad* squad );
	void MemberKilledBy ( class AController* Killer );
	void RemoveMember ( class ATgAIController* aic, unsigned long bDied );
	void AddMember ( class ATgAIController* aic );
	bool IsOpen ( );
	void CloseSquad ( );
	void OpenSquad ( );
};

UClass* UTgAISquad::pClassPointer = NULL;

// Class TgGame.TgAISquad_Minion
// 0x0008 (0x0074 - 0x006C)
class UTgAISquad_Minion : public UTgAISquad
{
public:
	float                                              s_fNextClusterTime;                               		// 0x006C (0x0004) [0x0000000000000000]              
	float                                              s_fNextMergeTime;                                 		// 0x0070 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2962 );

		return pClassPointer;
	};

	void CheckForMerge ( );
	void ClusterSquad ( );
};

UClass* UTgAISquad_Minion::pClassPointer = NULL;

// Class TgGame.TgAISquad_Monster
// 0x0000 (0x006C - 0x006C)
class UTgAISquad_Monster : public UTgAISquad
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2963 );

		return pClassPointer;
	};

	void DropTarget ( class AActor* TargetToDrop );
};

UClass* UTgAISquad_Monster::pClassPointer = NULL;

// Class TgGame.TgAISquad_MonsterBehaviorTree
// 0x000C (0x0078 - 0x006C)
class UTgAISquad_MonsterBehaviorTree : public UTgAISquad
{
public:
	struct FName                                       BehaviorTreeAsName;                               		// 0x006C (0x0008) [0x0000000000000000]              
	class ATgAIController_BehaviorMapNpc*              Controller;                                       		// 0x0074 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2964 );

		return pClassPointer;
	};

	void UnpauseSquadController ( );
	void eventOnSquadCreated ( );
	class ATgPawn* GetTargetPawn ( );
	class AActor* GetTarget ( );
	void Evade ( );
	void SquadDied ( );
	void UpdateTargetList ( float DeltaTime );
	void DropTarget ( class AActor* TargetToDrop );
	void SuggestDropTarget ( class AActor* TargetToDrop, class ATgAIController* requester );
	void SetTarget ( class AActor* NewTarget );
	void SuggestTarget ( class AActor* NewTarget, class ATgAIController* requester );
	class ATgAIController_BehaviorMapNpc* SpawnController ( );
};

UClass* UTgAISquad_MonsterBehaviorTree::pClassPointer = NULL;

// Class TgGame.TgMinionGoal
// 0x0010 (0x02C0 - 0x02B0)
class ATgMinionGoal : public ANavigationPoint
{
public:
	int                                                m_nLaneNum;                                       		// 0x02B0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_nTaskForce;                                     		// 0x02B4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class ATgActionPoint*                              m_EndPoint;                                       		// 0x02B8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_bUseForFinalDestination : 1;                    		// 0x02BC (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2965 );

		return pClassPointer;
	};

	void eventTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
};

UClass* ATgMinionGoal::pClassPointer = NULL;

// Class TgGame.TgMinionGoal_Aphrodite
// 0x0000 (0x02C0 - 0x02C0)
class ATgMinionGoal_Aphrodite : public ATgMinionGoal
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2966 );

		return pClassPointer;
	};

	void eventTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
};

UClass* ATgMinionGoal_Aphrodite::pClassPointer = NULL;

// Class TgGame.TgCameraModifier_EmoteZoom
// 0x0034 (0x008C - 0x0058)
class UTgCameraModifier_EmoteZoom : public UCameraModifier
{
public:
	class UTgAnimMetaData_LobbyCameraModifier*         ActiveMetaData;                                   		// 0x0058 (0x0004) [0x0000000000000000]              
	struct FVector                                     vTranslationOffset;                               		// 0x005C (0x000C) [0x0000000000000000]              
	struct FRotator                                    rRotationOffset;                                  		// 0x0068 (0x000C) [0x0000000000000000]              
	struct FVector                                     vTargetTranslationOffset;                         		// 0x0074 (0x000C) [0x0000000000000000]              
	struct FRotator                                    rTargetRotationOffset;                            		// 0x0080 (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2967 );

		return pClassPointer;
	};

	bool ModifyCamera ( class ACamera* Camera, float DeltaTime, struct FTPOV* OutPOV );
	void eventDisableModifier ( unsigned long bImmediate );
	void eventAddCameraModifierAsEvent ( class ACamera* Cam );
	void eventEnableModifierAsEvent ( );
	void SetActiveMetaData ( class UTgAnimMetaData_LobbyCameraModifier* MetaData );
};

UClass* UTgCameraModifier_EmoteZoom::pClassPointer = NULL;

// Class TgGame.TgCameraModifier_LobbyCameraTransition
// 0x0010 (0x0068 - 0x0058)
class UTgCameraModifier_LobbyCameraTransition : public UCameraModifier
{
public:
	class ATgLobbyCamera*                              SourceCamera;                                     		// 0x0058 (0x0004) [0x0000000000000000]              
	class ATgLobbyCamera*                              DestinationCamera;                                		// 0x005C (0x0004) [0x0000000000000000]              
	unsigned char                                      TransitionType;                                   		// 0x0060 (0x0001) [0x0000000000000000]              
	float                                              fSlideDistance;                                   		// 0x0064 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2968 );

		return pClassPointer;
	};

	bool RemoveCameraModifier ( class ACamera* Camera );
	bool AddCameraModifier ( class ACamera* Camera );
	void eventDisableModifier ( unsigned long bImmediate );
	void eventRemoveCameraModifierAsEvent ( class ACamera* Cam );
	void eventAddCameraModifierAsEvent ( class ACamera* Cam );
	void StreamDestinationTextures ( );
	bool ChangeDestination ( class ATgLobbyCamera* NewDestination );
	bool ModifyCamera ( class ACamera* Camera, float DeltaTime, struct FTPOV* OutPOV );
};

UClass* UTgCameraModifier_LobbyCameraTransition::pClassPointer = NULL;

// Class TgGame.TgCameraModifier_LobbyFade
// 0x0000 (0x0058 - 0x0058)
class UTgCameraModifier_LobbyFade : public UCameraModifier
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2969 );

		return pClassPointer;
	};

	bool ModifyCamera ( class ACamera* Camera, float DeltaTime, struct FTPOV* OutPOV );
};

UClass* UTgCameraModifier_LobbyFade::pClassPointer = NULL;

// Class TgGame.TgCameraModule
// 0x0004 (0x0040 - 0x003C)
class UTgCameraModule : public UObject
{
public:
	class ATgPlayerCamera*                             PlayerCamera;                                     		// 0x003C (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2970 );

		return pClassPointer;
	};

	void ZoomOut ( );
	void ZoomIn ( );
	void BecomeViewTarget ( class ATgPlayerController* PC );
	void ProcessInput ( class UPlayerInput* PlayerInput, float DeltaTime );
	void UpdateCamera ( class APawn* P, class ATgPlayerCamera* CameraActor, float DeltaTime, struct FTViewTarget* OutVT );
	void OnBecomeInActive ( class UTgCameraModule* NewCamera );
	void OnBecomeActive ( class UTgCameraModule* OldCamera );
	void Init ( );
};

UClass* UTgCameraModule::pClassPointer = NULL;

// Class TgGame.TgCameraModule_Free
// 0x0014 (0x0054 - 0x0040)
class UTgCameraModule_Free : public UTgCameraModule
{
public:
	float                                              CamAltitude;                                      		// 0x0040 (0x0004) [0x0000000000000000]              
	float                                              DesiredCamAltitude;                               		// 0x0044 (0x0004) [0x0000000000000000]              
	float                                              MaxCamAltitude;                                   		// 0x0048 (0x0004) [0x0000000000000000]              
	float                                              MinCamAltitude;                                   		// 0x004C (0x0004) [0x0000000000000000]              
	float                                              CamZoomIncrement;                                 		// 0x0050 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2971 );

		return pClassPointer;
	};

	void ZoomOut ( );
	void ZoomIn ( );
	void BecomeViewTarget ( class ATgPlayerController* PC );
	void UpdateCamera ( class APawn* P, class ATgPlayerCamera* CameraActor, float DeltaTime, struct FTViewTarget* OutVT );
	struct FVector GetCamLocationOffset ( );
	void ProcessInput ( class UPlayerInput* PlayerInput, float DeltaTime );
};

UClass* UTgCameraModule_Free::pClassPointer = NULL;

// Class TgGame.TgCameraModule_GroundTarget
// 0x0000 (0x0054 - 0x0054)
class UTgCameraModule_GroundTarget : public UTgCameraModule_Free
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2972 );

		return pClassPointer;
	};

	void ZoomOut ( );
	void ZoomIn ( );
	void UpdateCamera ( class APawn* P, class ATgPlayerCamera* CameraActor, float DeltaTime, struct FTViewTarget* OutVT );
	struct FVector GetCamLocationOffset ( );
};

UClass* UTgCameraModule_GroundTarget::pClassPointer = NULL;

// Class TgGame.TgCameraModule_Server
// 0x0000 (0x0040 - 0x0040)
class UTgCameraModule_Server : public UTgCameraModule
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2973 );

		return pClassPointer;
	};

};

UClass* UTgCameraModule_Server::pClassPointer = NULL;

// Class TgGame.TgCameraModule_Spectator
// 0x002C (0x006C - 0x0040)
class UTgCameraModule_Spectator : public UTgCameraModule
{
public:
	int                                                WorldViewPitch;                                   		// 0x0040 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FTPOV                                       OldViewpoint;                                     		// 0x0044 (0x001C) [0x0000000000002000]              ( CPF_Transient )
	float                                              RemainingBlendTime;                               		// 0x0060 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              TotalBlendTime;                                   		// 0x0064 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned long                                      bCollideWorld : 1;                                		// 0x0068 (0x0004) [0x0000000000000002] [0x00000001] ( CPF_Const )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2974 );

		return pClassPointer;
	};

	void BlendCameraToLocation ( struct FVector NewLocation, float BlendTime, unsigned long bUseFocalPoint );
	void OnBecomeInActive ( class UTgCameraModule* NewCamera );
	void OnBecomeActive ( class UTgCameraModule* OldCamera );
	void DecreaseCameraSpeed ( );
	void IncreaseCameraSpeeed ( );
	void ZoomOut ( );
	void ZoomIn ( );
	float GetFOVAngle ( );
	void UpdateCamera ( class APawn* P, class ATgPlayerCamera* CameraActor, float DeltaTime, struct FTViewTarget* OutVT );
};

UClass* UTgCameraModule_Spectator::pClassPointer = NULL;

// Class TgGame.TgCameraModule_SpectatorOverview
// 0x00A8 (0x0114 - 0x006C)
class UTgCameraModule_SpectatorOverview : public UTgCameraModule_Spectator
{
public:
	struct FRotator                                    WorldViewRotation;                                		// 0x006C (0x000C) [0x0000000000000001]              ( CPF_Edit )
	float                                              FOV;                                              		// 0x0078 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              TargetZoomedFOV;                                  		// 0x007C (0x0004) [0x0000000000000000]              
	float                                              ZoomIncrement;                                    		// 0x0080 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              MinZoom;                                          		// 0x0084 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              MaxZoom;                                          		// 0x0088 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              ZoomInterpTime;                                   		// 0x008C (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	struct FVector                                     CurrentSpringLocation;                            		// 0x0090 (0x000C) [0x0000000000000000]              
	float                                              PawnTargetSpringDamping;                          		// 0x009C (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              FreeCamSpringDamping;                             		// 0x00A0 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              IgnoreSpringDistance;                             		// 0x00A4 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	TArray< struct FCameraPitchInfo >                  CameraPitchData;                                  		// 0x00A8 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	unsigned long                                      bFlippedSides : 1;                                		// 0x00B4 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      bJustBecameActive : 1;                            		// 0x00B4 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      bAutoZoomEnabled : 1;                             		// 0x00B4 (0x0004) [0x0000000000004001] [0x00000004] ( CPF_Edit | CPF_Config )
	float                                              OverviewCameraInfluenceDist;                      		// 0x00B8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	TArray< class ATgOverviewCameraActor* >            OverviewCameras;                                  		// 0x00BC (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class ATgPawn_TowerBase* >                 TransparentTowerList;                             		// 0x00C8 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FVector                                     ObstacleTransparentExtent;                        		// 0x00D4 (0x000C) [0x0000000000000001]              ( CPF_Edit )
	float                                              fMinAutoZoomFOVAngle;                             		// 0x00E0 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              fMaxAutoZoomFOVAngle;                             		// 0x00E4 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              fMinAutoZoomDistance;                             		// 0x00E8 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              fMaxAutoZoomDistance;                             		// 0x00EC (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              fAutoZoomDetectionRadius;                         		// 0x00F0 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              fAutoZoomInSpeed;                                 		// 0x00F4 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              fAutoZoomOutSpeed;                                		// 0x00F8 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              fAutoZoomInLockOutTime;                           		// 0x00FC (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              fAutoZoomOutLockOutTime;                          		// 0x0100 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_RemainingAutoZoomInLockOutTime;                 		// 0x0104 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_RemainingAutoZoomOutLockOutTime;                		// 0x0108 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_fInputZoomAxis;                                 		// 0x010C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_fZoomAxisScale;                                 		// 0x0110 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2975 );

		return pClassPointer;
	};

	void SetFlipSides ( unsigned long bFlipped );
	float GetFOVAngle ( );
	void ZoomOut ( );
	void ZoomIn ( );
	void UpdateCamera ( class APawn* P, class ATgPlayerCamera* CameraActor, float DeltaTime, struct FTViewTarget* OutVT );
	void ProcessInput ( class UPlayerInput* PlayerInput, float DeltaTime );
	void OverridePawnTargetLocation ( class ATgPawn* TgP, struct FVector* TargetLocation );
	void BlendCameraToLocation ( struct FVector NewLocation, float BlendTime, unsigned long bUseFocalPoint );
	void OnBecomeInActive ( class UTgCameraModule* NewCamera );
	void OnBecomeActive ( class UTgCameraModule* OldCamera );
	void ClearObstacleTransparency ( );
	void CheckObstacleTransparency ( );
	bool UpdateAutoZoom ( float DeltaTime );
	struct FRotator GetWorldViewRotation ( );
};

UClass* UTgCameraModule_SpectatorOverview::pClassPointer = NULL;

// Class TgGame.TgCameraModule_ThirdPerson
// 0x003C (0x007C - 0x0040)
class UTgCameraModule_ThirdPerson : public UTgCameraModule
{
public:
	struct FVector                                     CameraOffset;                                     		// 0x0040 (0x000C) [0x0000000000000000]              
	float                                              fZoomFactorInterp;                                		// 0x004C (0x0004) [0x0000000000000000]              
	float                                              fZoomFactor;                                      		// 0x0050 (0x0004) [0x0000000000000000]              
	float                                              fZoomStep;                                        		// 0x0054 (0x0004) [0x0000000000000000]              
	float                                              fZoomMax;                                         		// 0x0058 (0x0004) [0x0000000000000000]              
	float                                              fZoomMin;                                         		// 0x005C (0x0004) [0x0000000000000000]              
	unsigned long                                      bPlaceInLineOfSight : 1;                          		// 0x0060 (0x0004) [0x0000000000000000] [0x00000001] 
	struct FVector                                     vCachedCameraAttachPoint;                         		// 0x0064 (0x000C) [0x0000000000000000]              
	struct FVector                                     vFloorPortalProgressiveAdjust;                    		// 0x0070 (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2976 );

		return pClassPointer;
	};

	void ZoomOut ( );
	void ZoomIn ( );
	void AdjustFloorPortalCamOrigin ( class ATgPawn* P, float DeltaTime, struct FVector* Offset );
	void BecomeViewTarget ( class ATgPlayerController* PC );
	void UpdateCamera ( class APawn* P, class ATgPlayerCamera* CameraActor, float DeltaTime, struct FTViewTarget* OutVT );
	struct FVector GetCamAttachPoint ( class AActor* ViewTarget );
	struct FVector GetCamLocationOffset ( struct FRotator PawnRot, class AActor* ViewTarget );
	void OnBecomeActive ( class UTgCameraModule* OldCamera );
};

UClass* UTgCameraModule_ThirdPerson::pClassPointer = NULL;

// Class TgGame.TgCameraModule_AoKuangUltimate
// 0x0034 (0x00B0 - 0x007C)
class UTgCameraModule_AoKuangUltimate : public UTgCameraModule_ThirdPerson
{
public:
	float                                              fStoredZoomFactor;                                		// 0x007C (0x0004) [0x0000000000000000]              
	float                                              fStoredZoomFactorInterp;                          		// 0x0080 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bOutroCurveActive : 1;                          		// 0x0084 (0x0004) [0x0000000000000000] [0x00000001] 
	float                                              m_fIntroTime;                                     		// 0x0088 (0x0004) [0x0000000000000000]              
	float                                              m_fOutroTime;                                     		// 0x008C (0x0004) [0x0000000000000000]              
	struct FInterpCurveFloat                           m_IntroCurve;                                     		// 0x0090 (0x0010) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FInterpCurveFloat                           m_OutroCurve;                                     		// 0x00A0 (0x0010) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2977 );

		return pClassPointer;
	};

	void UpdateOffsetFromCurves ( float DeltaSeconds );
	void UpdateCamera ( class APawn* P, class ATgPlayerCamera* CameraActor, float DeltaTime, struct FTViewTarget* OutVT );
	void ActivateOutroCurve ( );
	void OnBecomeInActive ( class UTgCameraModule* NewCamera );
	void OnBecomeActive ( class UTgCameraModule* OldCamera );
	void CalculateCurveTangents ( );
};

UClass* UTgCameraModule_AoKuangUltimate::pClassPointer = NULL;

// Class TgGame.TgCameraModule_SpectatorThirdPerson
// 0x0024 (0x00A0 - 0x007C)
class UTgCameraModule_SpectatorThirdPerson : public UTgCameraModule_ThirdPerson
{
public:
	struct FTPOV                                       OldViewpoint;                                     		// 0x007C (0x001C) [0x0000000000002000]              ( CPF_Transient )
	float                                              RemainingBlendTime;                               		// 0x0098 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              TotalBlendTime;                                   		// 0x009C (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2978 );

		return pClassPointer;
	};

	void BlendToTarget ( float BlendTime );
	void UpdateCamera ( class APawn* P, class ATgPlayerCamera* CameraActor, float DeltaTime, struct FTViewTarget* OutVT );
	bool GetNearestGod ( class ATgPawn* FromGod, float MaxDistance, class ATgPawn** NearestGod );
};

UClass* UTgCameraModule_SpectatorThirdPerson::pClassPointer = NULL;

// Class TgGame.TgLobbyCamera
// 0x0030 (0x03A4 - 0x0374)
class ATgLobbyCamera : public ACameraActor
{
public:
	class ATgSkeletalMeshActor_Lobby*                  m_ViewTarget;                                     		// 0x0374 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	TArray< class ATgSkeletalMeshActor_Lobby* >        m_FriendlyTargets;                                		// 0x0378 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< class ATgSkeletalMeshActor_Lobby* >        m_EnemyTargets;                                   		// 0x0384 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	struct FVector                                     m_RenderCenterPointOffset;                        		// 0x0390 (0x000C) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_bActive : 1;                                    		// 0x039C (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	int                                                m_nPosition;                                      		// 0x03A0 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2979 );

		return pClassPointer;
	};

	void eventSetPosition ( int nPosition );
	void eventTriggerKismetActivationEvent ( unsigned long bActive, int nPosition );
	void ClearEnemyTargets ( );
	void ClearFriendlyTargets ( );
	void SetActive ( unsigned long bActive );
};

UClass* ATgLobbyCamera::pClassPointer = NULL;

// Class TgGame.TgLobbyCamera_ProgressTracker
// 0x000C (0x03B0 - 0x03A4)
class ATgLobbyCamera_ProgressTracker : public ATgLobbyCamera
{
public:
	TArray< class ASkeletalMeshActor* >                m_ProgressActors;                                 		// 0x03A4 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2980 );

		return pClassPointer;
	};

	void SetActive ( unsigned long bActive );
};

UClass* ATgLobbyCamera_ProgressTracker::pClassPointer = NULL;

// Class TgGame.TgLobbyCamera_ResetTargets
// 0x0000 (0x03A4 - 0x03A4)
class ATgLobbyCamera_ResetTargets : public ATgLobbyCamera
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2981 );

		return pClassPointer;
	};

	void SetActive ( unsigned long bActive );
};

UClass* ATgLobbyCamera_ResetTargets::pClassPointer = NULL;

// Class TgGame.TgLobbyCaptureActor
// 0x0004 (0x01FC - 0x01F8)
class ATgLobbyCaptureActor : public ASceneCapture2DActor
{
public:
	class ATgSkeletalMeshActor_Lobby*                  m_ViewTarget;                                     		// 0x01F8 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2982 );

		return pClassPointer;
	};

};

UClass* ATgLobbyCaptureActor::pClassPointer = NULL;

// Class TgGame.TgOverviewCameraActor
// 0x0004 (0x0378 - 0x0374)
class ATgOverviewCameraActor : public ACameraActor
{
public:
	unsigned long                                      m_bFlipped : 1;                                   		// 0x0374 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2983 );

		return pClassPointer;
	};

};

UClass* ATgOverviewCameraActor::pClassPointer = NULL;

// Class TgGame.TgPlayerCamera
// 0x0044 (0x052C - 0x04E8)
class ATgPlayerCamera : public ACamera
{
public:
	class ATgPlayerController*                         PlayerOwner;                                      		// 0x04E8 (0x0004) [0x0000000000000000]              
	class UTgCameraModule*                             CurrentCameraMod;                                 		// 0x04EC (0x0004) [0x0000000004000001]              ( CPF_Edit | CPF_EditInline )
	class UClass*                                      DefaultCameraModuleClass;                         		// 0x04F0 (0x0004) [0x0000000000000000]              
	TArray< class UTgCameraModule* >                   CameraModuleList;                                 		// 0x04F4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FRotator                                    CamAngle;                                         		// 0x0500 (0x000C) [0x0000000000000000]              
	float                                              m_fDefaultFOVPC;                                  		// 0x050C (0x0004) [0x0000000000000000]              
	float                                              m_fDefaultFOVConsole;                             		// 0x0510 (0x0004) [0x0000000000000000]              
	unsigned long                                      bTweening : 1;                                    		// 0x0514 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bSupportFadingEnvironment : 1;                  		// 0x0514 (0x0004) [0x0000000000000002] [0x00000002] ( CPF_Const )
	unsigned long                                      m_bFadingFadingEnvironmentActive : 1;             		// 0x0514 (0x0004) [0x0000000000002000] [0x00000004] ( CPF_Transient )
	float                                              fTweenStart;                                      		// 0x0518 (0x0004) [0x0000000000000000]              
	float                                              fTweenDuration;                                   		// 0x051C (0x0004) [0x0000000000000000]              
	class UTgCameraModule*                             LastCameraMod;                                    		// 0x0520 (0x0004) [0x0000000000000000]              
	float                                              m_fCollisionTraceExtent;                          		// 0x0524 (0x0004) [0x0000000000000000]              
	float                                              m_fFadingHeight;                                  		// 0x0528 (0x0004) [0x0000000000000002]              ( CPF_Const )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2984 );

		return pClassPointer;
	};

	float GetFadingEnvironmentHeight ( );
	void ProcessFadingEnvironment ( float DeltaTime );
	void PostUpdateCamera ( float DeltaTime );
	void FillCameraCache ( struct FTPOV* NewPOV );
	void eventUpdateCamera ( float DeltaTime );
	void ZoomOut ( );
	void ZoomIn ( );
	void ProcessInput ( class UPlayerInput* PlayerInput, float DeltaTime );
	void UpdateViewTarget ( float DeltaTime, struct FTViewTarget* OutVT );
	class UTgCameraModule* CreateCamera ( class UClass* CameraClass );
	class UTgCameraModule* eventSwitchCameras ( class UClass* CameraClass, float fTweenTime );
	void SetFOV ( float NewFOV );
	void InitializeFor ( class APlayerController* PC );
	void PostBeginPlay ( );
	void SetDefaultFOV ( float ForceFOV );
	void CheckPenetration ( struct FVector CheckLocation, float CheckRadius );
	void CameraTrace ( struct FVector End, struct FVector Start, class AActor* Target, unsigned long bZeroExtent, unsigned long bWorldOnly, struct FVector* HitLocation, struct FVector* HitNormal );
};

UClass* ATgPlayerCamera::pClassPointer = NULL;

// Class TgGame.TgSpectatorCamera
// 0x0028 (0x0554 - 0x052C)
class ATgSpectatorCamera : public ATgPlayerCamera
{
public:
	struct FViewTargetTransitionParams                 m_DefaultBlendParams;                             		// 0x052C (0x0010) [0x0000000000000000]              
	struct FViewTargetTransitionParams                 m_SnapBlendParams;                                		// 0x053C (0x0010) [0x0000000000000000]              
	class UCameraAnim*                                 m_CinematicAnim;                                  		// 0x054C (0x0004) [0x0000000000000000]              
	class UCameraAnimInst*                             m_AnimInstance;                                   		// 0x0550 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2985 );

		return pClassPointer;
	};

	void EndCinematicAnim ( );
	void StartCinematicAnim ( );
	void DoUpdateCamera ( float DeltaTime );
};

UClass* ATgSpectatorCamera::pClassPointer = NULL;

// Class TgGame.TgBlockingVolume
// 0x0000 (0x0220 - 0x0220)
class ATgBlockingVolume : public ABlockingVolume
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2986 );

		return pClassPointer;
	};

};

UClass* ATgBlockingVolume::pClassPointer = NULL;

// Class TgGame.TgBossBlockDynamicVolume
// 0x0000 (0x0224 - 0x0224)
class ATgBossBlockDynamicVolume : public ADynamicBlockingVolume
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2987 );

		return pClassPointer;
	};

};

UClass* ATgBossBlockDynamicVolume::pClassPointer = NULL;

// Class TgGame.TgBossBlockVolume
// 0x0000 (0x0220 - 0x0220)
class ATgBossBlockVolume : public ABlockingVolume
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2988 );

		return pClassPointer;
	};

};

UClass* ATgBossBlockVolume::pClassPointer = NULL;

// Class TgGame.TgBotEncounterVolume
// 0x0010 (0x022C - 0x021C)
class ATgBotEncounterVolume : public AVolume
{
public:
	TArray< class ATgBotFactory* >                     m_Factories;                                      		// 0x021C (0x000C) [0x0000000000400003]              ( CPF_Edit | CPF_Const | CPF_NeedCtorLink )
	int                                                m_nPlayers;                                       		// 0x0228 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2989 );

		return pClassPointer;
	};

	void CheckTouching ( );
	void PostBeginPlay ( );
};

UClass* ATgBotEncounterVolume::pClassPointer = NULL;

// Class TgGame.TgCameraVolume
// 0x0004 (0x0220 - 0x021C)
class ATgCameraVolume : public AVolume
{
public:
	class ACameraActor*                                AssociatedCamera;                                 		// 0x021C (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2990 );

		return pClassPointer;
	};

};

UClass* ATgCameraVolume::pClassPointer = NULL;

// Class TgGame.TgDeviceVolume
// 0x003C (0x0258 - 0x021C)
class ATgDeviceVolume : public AVolume
{
public:
	unsigned long                                      bPainCausing : 1;                                 		// 0x021C (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      BACKUP_bPainCausing : 1;                          		// 0x021C (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      s_bDeviceActive : 1;                              		// 0x021C (0x0004) [0x0000000000000000] [0x00000004] 
	class AInfo*                                       PainTimer;                                        		// 0x0220 (0x0004) [0x0000000000000000]              
	class AController*                                 DamageInstigator;                                 		// 0x0224 (0x0004) [0x0000000000000000]              
	class ATgActorFactory*                             DamageFactory;                                    		// 0x0228 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_nMapObjectId;                                   		// 0x022C (0x0004) [0x0000000000020001]              ( CPF_Edit | CPF_EditConst )
	int                                                s_nDeviceId;                                      		// 0x0230 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UTgDeviceFire*                               s_DeviceFireMode;                                 		// 0x0234 (0x0004) [0x0000000000000000]              
	int                                                s_nTeamNumber;                                    		// 0x0238 (0x0004) [0x0000000000000000]              
	unsigned char                                      s_nTaskForce;                                     		// 0x023C (0x0001) [0x0000000000000001]              ( CPF_Edit )
	struct FVector                                     s_vImpactNormal;                                  		// 0x0240 (0x000C) [0x0000000000000001]              ( CPF_Edit )
	struct FVector                                     s_vImpactRayDir;                                  		// 0x024C (0x000C) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2991 );

		return pClassPointer;
	};

	void ApplyHit ( class AActor* Target );
	void OnSetDamageInstigator ( class USeqAct_SetDamageInstigator* Action );
	void CausePainTo ( class AActor* Other );
	bool CanCausePainTo ( class AActor* Other );
	void eventTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void TimerPop ( class ATgDeviceVolumeInfo* T );
	void OnToggle ( class USeqAct_Toggle* inAction );
	void Reset ( );
	void eventPostBeginPlay ( );
	bool SetupDevice ( );
};

UClass* ATgDeviceVolume::pClassPointer = NULL;

// Class TgGame.TgDeviceVolume_BattleEncounterRound
// 0x0000 (0x0258 - 0x0258)
class ATgDeviceVolume_BattleEncounterRound : public ATgDeviceVolume
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2992 );

		return pClassPointer;
	};

	void ApplyHitSpecial ( class AActor* Target );
	void eventUnTouch ( class AActor* Other );
	void eventTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void OnToggle ( class USeqAct_Toggle* inAction );
};

UClass* ATgDeviceVolume_BattleEncounterRound::pClassPointer = NULL;

// Class TgGame.TgDeviceVolume_Pulse
// 0x0019 (0x0235 - 0x021C)
class ATgDeviceVolume_Pulse : public AVolume
{
public:
	class AController*                                 DamageInstigator;                                 		// 0x021C (0x0004) [0x0000000000000000]              
	class ATgActorFactory*                             DamageFactory;                                    		// 0x0220 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_nMapObjectId;                                   		// 0x0224 (0x0004) [0x0000000000020001]              ( CPF_Edit | CPF_EditConst )
	int                                                s_nDeviceId;                                      		// 0x0228 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UTgDeviceFire*                               m_FireMode;                                       		// 0x022C (0x0004) [0x0000000000000000]              
	int                                                s_nTeamNumber;                                    		// 0x0230 (0x0004) [0x0000000000000000]              
	unsigned char                                      s_nTaskForce;                                     		// 0x0234 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2993 );

		return pClassPointer;
	};

	struct FImpactInfo CalcDeviceFire ( struct FVector StartTrace, struct FVector EndTrace, TArray< struct FImpactInfo >* ImpactList );
	void FindTouchingActorsFromScript ( );
	void Fire ( );
	void TurnOff ( );
	void TurnOn ( );
	void OnToggle ( class USeqAct_Toggle* inAction );
	void OnSetDamageInstigator ( class USeqAct_SetDamageInstigator* Action );
	void eventPostBeginPlay ( );
	bool SetupDevice ( );
};

UClass* ATgDeviceVolume_Pulse::pClassPointer = NULL;

// Class TgGame.TgEndOfWorldVolume
// 0x0000 (0x0220 - 0x0220)
class ATgEndOfWorldVolume : public ABlockingVolume
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2994 );

		return pClassPointer;
	};

};

UClass* ATgEndOfWorldVolume::pClassPointer = NULL;

// Class TgGame.TgHeightFog
// 0x0004 (0x01F4 - 0x01F0)
class ATgHeightFog : public AInfo
{
public:
	class UHeightFogComponent*                         FogComponent;                                     		// 0x01F0 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2995 );

		return pClassPointer;
	};

};

UClass* ATgHeightFog::pClassPointer = NULL;

// Class TgGame.TgHelpAlertVolume
// 0x0010 (0x022C - 0x021C)
class ATgHelpAlertVolume : public AVolume
{
public:
	int                                                TaskForceNumber;                                  		// 0x021C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	TArray< int >                                      GameTipIdList;                                    		// 0x0220 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2996 );

		return pClassPointer;
	};

	void eventUnTouch ( class AActor* Other );
	void eventTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void RemoveGameTips ( class ATgPlayerController* aPC );
	void AddGameTips ( class ATgPlayerController* aPC );
};

UClass* ATgHelpAlertVolume::pClassPointer = NULL;

// Class TgGame.TgItemShopVolume
// 0x0000 (0x021C - 0x021C)
class ATgItemShopVolume : public AVolume
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2997 );

		return pClassPointer;
	};

	void eventSetPurchaseFlag ( class AActor* Other, unsigned long bCanPurchase );
	void eventUnTouch ( class AActor* Other );
	void eventTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
};

UClass* ATgItemShopVolume::pClassPointer = NULL;

// Class TgGame.TgMissionListVolume
// 0x0010 (0x022C - 0x021C)
class ATgMissionListVolume : public AVolume
{
public:
	int                                                m_nMapObjectId;                                   		// 0x021C (0x0004) [0x0000000000020001]              ( CPF_Edit | CPF_EditConst )
	int                                                s_nQueueTableId;                                  		// 0x0220 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                s_nQueueTableMsgId;                               		// 0x0224 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class ATeleporter*                                 m_Teleporter;                                     		// 0x0228 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2998 );

		return pClassPointer;
	};

};

UClass* ATgMissionListVolume::pClassPointer = NULL;

// Class TgGame.TgModifyPawnPropertiesVolume
// 0x001C (0x0238 - 0x021C)
class ATgModifyPawnPropertiesVolume : public AVolume
{
public:
	int                                                m_nMapObjectId;                                   		// 0x021C (0x0004) [0x0000000000020001]              ( CPF_Edit | CPF_EditConst )
	unsigned long                                      m_bDisableJump : 1;                               		// 0x0220 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_bDisableBlockActors : 1;                        		// 0x0220 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_bDisableHanging : 1;                            		// 0x0220 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      m_bDisableAllDevices : 1;                         		// 0x0220 (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )
	unsigned long                                      m_bTriggerUseEvent : 1;                           		// 0x0220 (0x0004) [0x0000000000000001] [0x00000010] ( CPF_Edit )
	unsigned long                                      m_bOneWayMovement : 1;                            		// 0x0220 (0x0004) [0x0000000000000001] [0x00000020] ( CPF_Edit )
	struct FRotator                                    m_vOnewWay;                                       		// 0x0224 (0x000C) [0x0000000000000000]              
	class UArrowComponent*                             m_DirArrow;                                       		// 0x0230 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	int                                                s_nLootTableId;                                   		// 0x0234 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 2999 );

		return pClassPointer;
	};

	void eventUnTouch ( class AActor* Other );
	void eventTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void eventPostBeginPlay ( );
	void Used ( class AActor* Other );
	void LoadObjectConfig ( );
};

UClass* ATgModifyPawnPropertiesVolume::pClassPointer = NULL;

// Class TgGame.TgObjectiveVolume
// 0x0004 (0x0220 - 0x021C)
class ATgObjectiveVolume : public AVolume
{
public:
	int                                                m_nCurrentObjectiveCount;                         		// 0x021C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3000 );

		return pClassPointer;
	};

	void eventUnTouch ( class AActor* Other );
	void eventTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void ObjectiveRefresh ( class ATgPawn* PlayerPawn, unsigned long bExcludeSelf );
	void ObjectiveDied ( class ATgPawn* ObjectivePawn );
	void OnObjectiveSpawned ( class ATgPawn* ObjectivePawn );
	void ClearCurrentObjective ( );
	void SetCurrentObjective ( class AActor* Other );
	bool IsObjective ( class AActor* Other );
};

UClass* ATgObjectiveVolume::pClassPointer = NULL;

// Class TgGame.TgObjectiveVolume_BotList
// 0x0010 (0x0230 - 0x0220)
class ATgObjectiveVolume_BotList : public ATgObjectiveVolume
{
public:
	TArray< int >                                      m_nValidObjectives;                               		// 0x0220 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	unsigned long                                      r_bDisabled : 1;                                  		// 0x022C (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3001 );

		return pClassPointer;
	};

	bool IsObjective ( class AActor* Other );
	void eventReplicatedEvent ( struct FName VarName );
};

UClass* ATgObjectiveVolume_BotList::pClassPointer = NULL;

// Class TgGame.TgPlayerBlockingVolume
// 0x0000 (0x0220 - 0x0220)
class ATgPlayerBlockingVolume : public ABlockingVolume
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3002 );

		return pClassPointer;
	};

};

UClass* ATgPlayerBlockingVolume::pClassPointer = NULL;

// Class TgGame.TgPlayerBlockingVolume_TaskforceFriendly
// 0x000C (0x022C - 0x0220)
class ATgPlayerBlockingVolume_TaskforceFriendly : public ATgPlayerBlockingVolume
{
public:
	TArray< int >                                      m_FriendlyTaskforces;                             		// 0x0220 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3003 );

		return pClassPointer;
	};

};

UClass* ATgPlayerBlockingVolume_TaskforceFriendly::pClassPointer = NULL;

// Class TgGame.TgPlayerCountVolume
// 0x001C (0x0238 - 0x021C)
class ATgPlayerCountVolume : public AVolume
{
public:
	int                                                PlayerCountTarget;                                		// 0x021C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                TaskForceNumber;                                  		// 0x0220 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                MessageId;                                        		// 0x0224 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	TArray< class APawn* >                             Players;                                          		// 0x0228 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	unsigned long                                      Enabled : 1;                                      		// 0x0234 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3004 );

		return pClassPointer;
	};

	int eventGetCount ( );
	void eventTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void Update ( class ATgPawn* Other );
};

UClass* ATgPlayerCountVolume::pClassPointer = NULL;

// Class TgGame.TgPostProcessVolume
// 0x001C (0x03B0 - 0x0394)
class ATgPostProcessVolume : public APostProcessVolume
{
public:
	class UMaterialInterface*                          m_Material;                                       		// 0x0394 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_SceneDPG;                                       		// 0x0398 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	class UMaterialInstanceConstant*                   m_MaterialMIC;                                    		// 0x039C (0x0004) [0x0000000000000000]              
	float                                              m_FadeInTime;                                     		// 0x03A0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_FadeOutTime;                                    		// 0x03A4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_FadeScalarParameterName;                        		// 0x03A8 (0x0008) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3005 );

		return pClassPointer;
	};

	void eventPostBeginPlay ( );
};

UClass* ATgPostProcessVolume::pClassPointer = NULL;

// Class TgGame.TgTeleportPlayerVolume
// 0x000C (0x0228 - 0x021C)
class ATgTeleportPlayerVolume : public AVolume
{
public:
	unsigned char                                      TeleportLocation;                                 		// 0x021C (0x0001) [0x0000000000000001]              ( CPF_Edit )
	int                                                nMessageId;                                       		// 0x0220 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      bTeleportBots : 1;                                		// 0x0224 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      bTeleportPlayers : 1;                             		// 0x0224 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3006 );

		return pClassPointer;
	};

	void eventTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
};

UClass* ATgTeleportPlayerVolume::pClassPointer = NULL;

// Class TgGame.TgVisibilityVolume
// 0x0000 (0x021C - 0x021C)
class ATgVisibilityVolume : public AVolume
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3007 );

		return pClassPointer;
	};

	void eventUnTouch ( class AActor* Other );
	void eventTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
};

UClass* ATgVisibilityVolume::pClassPointer = NULL;

// Class TgGame.TgAhMuzenCabSwarmInstance
// 0x0020 (0x0210 - 0x01F0)
class ATgAhMuzenCabSwarmInstance : public AInfo
{
public:
	int                                                m_nStrainId;                                      		// 0x01F0 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bBasicAttackStrain : 1;                         		// 0x01F4 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bDoNotAdjustStrainLifeSpan : 1;                 		// 0x01F4 (0x0004) [0x0000000000000000] [0x00000002] 
	TArray< class AActor* >                            m_PreviouslyInfected;                             		// 0x01F8 (0x000C) [0x0000000000400002]              ( CPF_Const | CPF_NeedCtorLink )
	TArray< struct FInfectedInfo >                     m_CurrentlyInfected;                              		// 0x0204 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3008 );

		return pClassPointer;
	};

	void eventDestroyed ( );
	void Timer ( );
	void PostBeginPlay ( );
	float GetSpreadTime ( );
	void SetStrainLifeSpan ( float fNewLifeSpan );
	bool ImmuneToThisStrain ( class AActor* Target );
	void AddToInfectionList ( class AActor* Target, float fInfectionDuration );
};

UClass* ATgAhMuzenCabSwarmInstance::pClassPointer = NULL;

// Class TgGame.TgCapturePoint
// 0x0040 (0x0230 - 0x01F0)
class ATgCapturePoint : public AActor
{
public:
	class ATgRepInfo_CapturePoint*                     r_RepInfo;                                        		// 0x01F0 (0x0004) [0x0000000000000020]              ( CPF_Net )
	TArray< class ATgPawn_Character* >                 m_NearByPlayers;                                  		// 0x01F4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class UPrimitiveComponent*                         m_Collision;                                      		// 0x0200 (0x0004) [0x0000000004080009]              ( CPF_Edit | CPF_ExportObject | CPF_Component | CPF_EditInline )
	float                                              m_fBaseTransitionSpeed;                           		// 0x0204 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	float                                              m_fTransitionSpeedBuff;                           		// 0x0208 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	float                                              m_fCurrentTransitionSpeed;                        		// 0x020C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UTgSeqEvent_ControlPointOwnershipChange*     c_OwnershipChangedKismetNode;                     		// 0x0210 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_CapturePointIndex;                              		// 0x0214 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	class ATgGame_Mission*                             s_GameInfo;                                       		// 0x0218 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_nTF1Count;                                      		// 0x021C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_nTF2Count;                                      		// 0x0220 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class USpriteComponent*                            m_WorldIconSprite;                                		// 0x0224 (0x0004) [0x0000000004080009]              ( CPF_Edit | CPF_ExportObject | CPF_Component | CPF_EditInline )
	int                                                m_nCapturedMessageId;                             		// 0x0228 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	int                                                m_nLostMessageId;                                 		// 0x022C (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3009 );

		return pClassPointer;
	};

	void OnGetTaskForceNumber ( class UTgSeqAct_GetTaskForceNumber* Action );
	void UpdateLockEffects ( );
	void OnLockCapturePoint ( class UTgSeqAct_LockCapturePoint* inAction );
	void OnSetCapturePointOwner ( class UTgSeqAct_SetCapturePointOwner* inAction );
	void OnSetCapturePointPct ( class UTgSeqAct_SetCapturePointPct* inAction );
	void OnToggle ( class USeqAct_Toggle* Action );
	void OnTaskForceControlChanged ( int NewTaskForce );
	int GetCapturePointIndex ( );
	void eventOnPointReclaimed ( );
	void eventOnPointCaptureOwnershipChanged ( int NewTaskForceOwner, int PreviousTaskForceOwner );
	void NearbyPawnsUpdated ( );
	float ComputeTransitionSpeed ( int TF1Count, int TF2Count );
	void RemoveNearbyPlayer ( class ATgPawn_Character* aPawn );
	void AddNearbyPlayer ( class ATgPawn_Character* aPawn );
	void eventUnTouch ( class AActor* Other );
	void eventTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void eventPreBeginPlay ( );
	void eventTakeDamage ( int Damage, class AController* InstigatedBy, struct FVector HitLocation, struct FVector Momentum, class UClass* DamageType, struct FTraceHitInfo HitInfo, class AActor* DamageCauser );
	void AlertPointChanged ( );
};

UClass* ATgCapturePoint::pClassPointer = NULL;

// Class TgGame.TgCapturePoint_OwnedEffect
// 0x0000 (0x0230 - 0x0230)
class ATgCapturePoint_OwnedEffect : public ATgCapturePoint
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3010 );

		return pClassPointer;
	};

};

UClass* ATgCapturePoint_OwnedEffect::pClassPointer = NULL;

// Class TgGame.TgCapturePoint_WithBot
// 0x0028 (0x0258 - 0x0230)
class ATgCapturePoint_WithBot : public ATgCapturePoint
{
public:
	float                                              m_fTransitionSpeedGuardModifier;                  		// 0x0230 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	class ATgBotFactory_PointCapture*                  s_BotSpawners[ 0x2 ];                             		// 0x0234 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	class ATgBotFactory_PointCapture*                  s_NeutralBotSpawner;                              		// 0x023C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class ATgBotFactory_PointCapture*                  m_CurrentBotSpawners[ 0x2 ];                      		// 0x0240 (0x0008) [0x0000000000002000]              ( CPF_Transient )
	float                                              s_fReplenishBotTime;                              		// 0x0248 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	float                                              s_fFriendlyReplenishBuffPct;                      		// 0x024C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              s_fRemainingReplenishBotTime;                     		// 0x0250 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_fLastEnemyKillVoxTimestamp;                     		// 0x0254 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3011 );

		return pClassPointer;
	};

	void OnNearbyEnemyPlayerDied ( class ATgPawn* DeadPawn );
	void DestroyBotsFromOldTaskForce ( );
	void eventSpawnBotsForCurrentTaskForce ( );
	void eventOnBotDied ( int DeadBotTaskForce );
	void eventOnPointCaptureOwnershipChanged ( int NewTaskForceOwner, int PreviousTaskForceOwner );
	void NearbyPawnsUpdated ( );
	float ComputeTransitionSpeed ( int PlayerCount, int opposingGuards );
	void eventPostBeginPlay ( );
	void SpawnNeutralBot ( );
};

UClass* ATgCapturePoint_WithBot::pClassPointer = NULL;

// Class TgGame.TgGame
// 0x00A4 (0x044C - 0x03A8)
class ATgGame : public AFrameworkGame
{
public:
	class UClass*                                      m_ContentPackageReference;                        		// 0x03A8 (0x0004) [0x0000000000000000]              
	unsigned char                                      m_GameWinState;                                   		// 0x03AC (0x0001) [0x0000000000000000]              
	unsigned char                                      m_GameType;                                       		// 0x03AD (0x0001) [0x0000000000000000]              
	unsigned char                                      m_GameSeason;                                     		// 0x03AE (0x0001) [0x0000000000000000]              
	float                                              m_fSpawnProtectionTime;                           		// 0x03B0 (0x0004) [0x0000000000000000]              
	float                                              m_fMaxRepawnTime;                                 		// 0x03B4 (0x0004) [0x0000000000000000]              
	float                                              m_fUnpauseCountdownRemaining;                     		// 0x03B8 (0x0004) [0x0000000000000000]              
	float                                              m_fPauseSpamProtection;                           		// 0x03BC (0x0004) [0x0000000000000000]              
	float                                              m_fMaxCooldownOverride;                           		// 0x03C0 (0x0004) [0x0000000000000000]              
	float                                              m_fMinCooldownOverride;                           		// 0x03C4 (0x0004) [0x0000000000000000]              
	float                                              m_fStartingCooldownOverride;                      		// 0x03C8 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bIsMaxCooldownOverriden : 1;                    		// 0x03CC (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bIsMinCooldownOverriden : 1;                    		// 0x03CC (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_bIsStartingCooldownOverriden : 1;               		// 0x03CC (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_bInfiniteEnergy : 1;                            		// 0x03CC (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      s_bGameInitialized : 1;                           		// 0x03CC (0x0004) [0x0000000000000000] [0x00000010] 
	unsigned long                                      s_bGameEndMissionProcessed : 1;                   		// 0x03CC (0x0004) [0x0000000000000000] [0x00000020] 
	unsigned long                                      s_bMissionSealed : 1;                             		// 0x03CC (0x0004) [0x0000000000000000] [0x00000040] 
	unsigned long                                      m_bRewardCalculated : 1;                          		// 0x03CC (0x0004) [0x0000000000000000] [0x00000080] 
	unsigned long                                      m_bStatsCanTie : 1;                               		// 0x03CC (0x0004) [0x0000000000000000] [0x00000100] 
	unsigned long                                      m_bStatsIsSymmetric : 1;                          		// 0x03CC (0x0004) [0x0000000000000000] [0x00000200] 
	unsigned long                                      m_bUnpauseQueued : 1;                             		// 0x03CC (0x0004) [0x0000000000000000] [0x00000400] 
	unsigned long                                      m_bIsTutorialGametype : 1;                        		// 0x03CC (0x0004) [0x0000000000000000] [0x00000800] 
	unsigned long                                      m_bIsPracticeGametype : 1;                        		// 0x03CC (0x0004) [0x0000000000000000] [0x00001000] 
	int                                                s_nBotPlayerCount;                                		// 0x03D0 (0x0004) [0x0000000000000000]              
	float                                              m_fBotSpawnHealthModifier;                        		// 0x03D4 (0x0004) [0x0000000000000000]              
	int                                                s_nNextActorInstanceId;                           		// 0x03D8 (0x0004) [0x0000000000000000]              
	int                                                s_nNextProjectileInstanceId;                      		// 0x03DC (0x0004) [0x0000000000000000]              
	class AActor*                                      s_GameEndFocus;                                   		// 0x03E0 (0x0004) [0x0000000000000000]              
	int                                                m_nDefaultBotId;                                  		// 0x03E4 (0x0004) [0x0000000000004000]              ( CPF_Config )
	TArray< class ATgAIVolume* >                       s_AIVolumes;                                      		// 0x03E8 (0x000C) [0x0000000000500000]              ( CPF_NeedCtorLink )
	TArray< int >                                      s_Taskforce1AIVolumesIndices;                     		// 0x03F4 (0x000C) [0x0000000000500000]              ( CPF_NeedCtorLink )
	TArray< int >                                      s_Taskforce2AIVolumesIndices;                     		// 0x0400 (0x000C) [0x0000000000500000]              ( CPF_NeedCtorLink )
	TArray< class ATgActorFactory* >                   s_ActorFactories;                                 		// 0x040C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< int >                                      m_ClientLogins;                                   		// 0x0418 (0x000C) [0x0000000000500000]              ( CPF_NeedCtorLink )
	class APlayerReplicationInfo*                      m_AttemptedPauser;                                		// 0x0424 (0x0004) [0x0000000000000000]              
	TArray< struct FTgPlayerWardSkins >                m_PlayerWardSkins;                                		// 0x0428 (0x000C) [0x0000000000500000]              ( CPF_NeedCtorLink )
	TArray< struct FTgPlayerGlobalEmoteSkins >         m_PlayerGlobalEmoteSkins;                         		// 0x0434 (0x000C) [0x0000000000500000]              ( CPF_NeedCtorLink )
	struct FScriptDelegate                             __CanUnpauseTgGame__Delegate;                     		// 0x0440 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3012 );

		return pClassPointer;
	};

	bool eventIsPracticeGametype ( );
	bool eventIsTutorialGametype ( );
	void eventKickIdler ( class APlayerController* PC );
	void eventClearPauseAfterCountdown ( );
	void eventClearPause ( );
	bool SetPause ( class APlayerController* PC, struct FScriptDelegate CanUnpauseDelegate );
	bool CanUnpauseTgGame ( );
	bool PreventDeath ( class APawn* KilledPawn, class AController* Killer, class UClass* DamageType, struct FVector HitLocation );
	bool CanSpectate ( class APlayerController* Viewer, class APlayerReplicationInfo* ViewTarget );
	void eventPostCommitMapChange ( );
	void eventPostLogin ( class APlayerController* NewPlayer );
	bool FindInactivePRI ( class APlayerController* PC );
	void AddInactivePRI ( class APlayerReplicationInfo* PRI, class APlayerController* PC );
	void StartMatch ( );
	bool ChangeTeam ( class AController* Other, int Num, unsigned long bNewTeam );
	float RatePlayerStart ( class APlayerStart* P, unsigned char Team, class AController* Player );
	float eventRatePlayerStartPoint ( class APlayerStart* P, class AController* Player );
	class ANavigationPoint* FindPlayerGroupStart ( class AController* Player, int groupNumber, unsigned char InTeam, struct FString IncomingName );
	class ANavigationPoint* FindPlayerStart ( class AController* Player, unsigned char InTeam, struct FString IncomingName );
	class ANavigationPoint* eventGetReviveLocation ( class AController* Player, struct FVector* OutLocation, struct FRotator* OutRotation );
	class ANavigationPoint* eventFindPlayerStartPoint ( class AController* Player, struct FString SpawnTagName );
	void SetPlayerDefaults ( class APawn* PlayerPawn );
	void AddDefaultInventory ( class APawn* PlayerPawn );
	void RestartPlayer ( class AController* aPlayer );
	void eventAllPlayersEndGame ( class AActor* EndGameFocus );
	class APawn* SpawnDefaultPawnFor ( class AController* NewPlayer, class ANavigationPoint* StartSpot );
	void StartBots ( );
	void eventInitGame ( struct FString Options, struct FString* ErrorMessage );
	void Reset ( );
	int eventGetNextProjectileInstanceId ( );
	int eventGetNextActorInstanceId ( );
	void InitGameReplicationInfo ( );
	void eventPostBeginPlay ( );
	void eventPreBeginPlay ( );
	bool IsRA2015 ( );
	bool IsTraining ( );
	int GetGameEndingScore ( );
	int GetStartingScore ( );
	void SendPauseNotification ( class APlayerController* PC );
	void EndUnpauseCountdown ( );
	void BeginUnpauseCountdown ( float fSeconds );
	bool AllowPausing ( class APlayerController* PC );
	void ResetStats ( );
	void NotifyPostCommitMapChange ( );
	struct FString GetGameVersion ( );
	bool IsCombatPause ( class APlayerController* pPc );
	float GetRespawnTime ( class AController* C );
	void BotDied ( class ATgAIController* aic );
	void PlayerDied ( class ATgPlayerController* PC );
	bool SpawnDefaultBotPlayers ( unsigned long bStartPaused, TArray< struct FTgAIBotPlayersToSpawn >* BotPlayersToSpawn );
	bool SwapToNewAIController ( class AController* C, class ATgPawn_Character* TgPawn );
	void EnsureBotPrecache ( int nBotId, int nSkinId );
	class ATgPawn* SpawnTemplatePlayer ( class ATgPlayerController* pTgPC, int nProfileId, int nSkinId );
	class ATgPawn* SpawnBotPawn ( class ATgAIController* pTgAI, struct FVector vLocation, struct FRotator rRotation, unsigned long bIgnoreCollision, class ATgPawn* pOwnerPawn, float fDeploySecs );
	class ATgPawn* SpawnBotById ( int nBotId, int nSkinId, struct FVector vLocation, struct FRotator rRotation, class ATgBotFactory* pFactory, unsigned long bIgnoreCollision, class ATgPawn* pOwnerPawn, class UTgDeviceFire* DeviceFire, float fDeployAnimLength, struct FName ControllerClassName, struct FName BehaviorTreeName );
	bool FinishEndMission ( );
	bool BeginEndMission ( unsigned long bClearNextMapGame, class AActor* EndMissionFocus, float fDelayOverride );
	int GetWinningTaskforce ( );
	class ATgPawn* SpawnPlayerCharacter ( class AController* C, struct FVector vLocation );
	class ANavigationPoint* TgFindPlayerStart ( class AController* pPlayer, struct FString fsIncomingName );
	void InitGameRepInfo ( );
	void LoadGameOverrides ( );
	void LoadGameConfig ( );
};

UClass* ATgGame::pClassPointer = NULL;

// Class TgGame.TgGame_City
// 0x0000 (0x044C - 0x044C)
class ATgGame_City : public ATgGame
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3013 );

		return pClassPointer;
	};

	class APawn* SpawnDefaultPawnFor ( class AController* NewPlayer, class ANavigationPoint* StartSpot );
};

UClass* ATgGame_City::pClassPointer = NULL;

// Class TgGame.TgGame_Mission
// 0x00EC (0x0538 - 0x044C)
class ATgGame_Mission : public ATgGame
{
public:
	unsigned long                                      m_bSpawnInTaskForceArea : 1;                      		// 0x044C (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      s_bPreGuardianPhasePulsed : 1;                    		// 0x044C (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      s_bGuardianPhasePulsed : 1;                       		// 0x044C (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_bCurrencySpooling : 1;                          		// 0x044C (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      m_bXPSpooling : 1;                                		// 0x044C (0x0004) [0x0000000000000000] [0x00000010] 
	unsigned long                                      s_bWasSurrendered : 1;                            		// 0x044C (0x0004) [0x0000000000000000] [0x00000020] 
	unsigned long                                      m_bSurrenderAvailable : 1;                        		// 0x044C (0x0004) [0x0000000000000000] [0x00000040] 
	unsigned long                                      m_bFirstBloodAwarded : 1;                         		// 0x044C (0x0004) [0x0000000000000000] [0x00000080] 
	unsigned long                                      m_bAllowAutoUpgrades : 1;                         		// 0x044C (0x0004) [0x0000000000000000] [0x00000100] 
	unsigned long                                      m_bFountainHealingIsOn : 1;                       		// 0x044C (0x0004) [0x0000000000000000] [0x00000200] 
	unsigned long                                      m_bFountainDamageIsOn : 1;                        		// 0x044C (0x0004) [0x0000000000000000] [0x00000400] 
	unsigned long                                      m_bDoNotSpawnMinionWave : 1;                      		// 0x044C (0x0004) [0x0000000000000000] [0x00000800] 
	unsigned long                                      m_bDoNotSpawnJungleCamps : 1;                     		// 0x044C (0x0004) [0x0000000000000000] [0x00001000] 
	unsigned long                                      m_bDoNotSpawnFireGiant : 1;                       		// 0x044C (0x0004) [0x0000000000000000] [0x00002000] 
	unsigned long                                      m_bDoNotSpawnGoldFury : 1;                        		// 0x044C (0x0004) [0x0000000000000000] [0x00004000] 
	unsigned char                                      m_eTimerState;                                    		// 0x0450 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_eTimerStatePaused;                              		// 0x0451 (0x0001) [0x0000000000000000]              
	float                                              m_fMissionTime;                                   		// 0x0454 (0x0004) [0x0000000000000000]              
	float                                              m_fPausedAtTime;                                  		// 0x0458 (0x0004) [0x0000000000000000]              
	float                                              m_fGameMissionTime;                               		// 0x045C (0x0004) [0x0000000000000000]              
	float                                              s_MissionTimeAccumulator;                         		// 0x0460 (0x0004) [0x0000000000000000]              
	TArray< class UPlayer* >                           s_ReadyPlayers;                                   		// 0x0464 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	float                                              m_fTickCurrencyFreq;                              		// 0x0470 (0x0004) [0x0000000000000000]              
	float                                              m_fCurrencyToGivePerTick;                         		// 0x0474 (0x0004) [0x0000000000000000]              
	float                                              m_fXpToGivePerTick;                               		// 0x0478 (0x0004) [0x0000000000000000]              
	int                                                m_nStartingCurrency;                              		// 0x047C (0x0004) [0x0000000000000000]              
	int                                                m_nStartingLevel;                                 		// 0x0480 (0x0004) [0x0000000000000000]              
	int                                                m_nWinPlayerXp;                                   		// 0x0484 (0x0004) [0x0000000000000000]              
	int                                                m_nLosePlayerXp;                                  		// 0x0488 (0x0004) [0x0000000000000000]              
	int                                                m_nGoldCapMin;                                    		// 0x048C (0x0004) [0x0000000000000000]              
	int                                                m_nGoldCapMax;                                    		// 0x0490 (0x0004) [0x0000000000000000]              
	float                                              m_fGodXpCoefficient;                              		// 0x0494 (0x0004) [0x0000000000000000]              
	float                                              m_fGodXpCoefficientLoss;                          		// 0x0498 (0x0004) [0x0000000000000000]              
	float                                              m_fGodXpWinBonus;                                 		// 0x049C (0x0004) [0x0000000000000000]              
	float                                              m_fBaseTokens;                                    		// 0x04A0 (0x0004) [0x0000000000000000]              
	class UClass*                                      m_MinimapManagerClass;                            		// 0x04A4 (0x0004) [0x0000000000000000]              
	struct FSurrenderData                              s_SurrenderData[ 0x2 ];                           		// 0x04A8 (0x0040) [0x0000000000400000]              ( CPF_NeedCtorLink )
	float                                              m_fSurrenderTime[ 0x2 ];                          		// 0x04E8 (0x0008) [0x0000000000000000]              
	float                                              m_fUnbalancedSurrenderTime;                       		// 0x04F0 (0x0004) [0x0000000000000000]              
	int                                                m_XPRadius;                                       		// 0x04F4 (0x0004) [0x0000000000000000]              
	float                                              m_MinionKillerBonus;                              		// 0x04F8 (0x0004) [0x0000000000000000]              
	float                                              m_BasePlayerGoldReward;                           		// 0x04FC (0x0004) [0x0000000000000000]              
	float                                              m_fFirstBloodGoldReward;                          		// 0x0500 (0x0004) [0x0000000000000000]              
	float                                              m_fBasePlayerAssistGoldRewardMultipler;           		// 0x0504 (0x0004) [0x0000000000000000]              
	float                                              m_fBasePlayerAssistXpRewardMultipler;             		// 0x0508 (0x0004) [0x0000000000000000]              
	float                                              m_fBaseNPCAssistGoldRewardMultipler;              		// 0x050C (0x0004) [0x0000000000000000]              
	float                                              m_fBaseNPCAssistXpRewardMultipler;                		// 0x0510 (0x0004) [0x0000000000000000]              
	int                                                m_nGoldFuryTeamGoldPerMin;                        		// 0x0514 (0x0004) [0x0000000000000000]              
	int                                                m_nGoldFuryTeamGoldMax;                           		// 0x0518 (0x0004) [0x0000000000000000]              
	int                                                m_nGoldFuryTeamXPPerMin;                          		// 0x051C (0x0004) [0x0000000000000000]              
	int                                                m_nGoldFuryTeamXPMax;                             		// 0x0520 (0x0004) [0x0000000000000000]              
	int                                                m_nMaxInvItems;                                   		// 0x0524 (0x0004) [0x0000000000000000]              
	int                                                m_nLockedDevices;                                 		// 0x0528 (0x0004) [0x0000000000000000]              
	TArray< class ATgMinionGoal* >                     m_MinionGoals;                                    		// 0x052C (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3014 );

		return pClassPointer;
	};

	void eventSetXpSpooling ( unsigned long bSpooling );
	void eventSetCurrencySpooling ( unsigned long bSpooling );
	unsigned char eventGetMissionTimerStatus ( );
	float GetSetupTime ( );
	float GetPlayerConnectTime ( );
	void eventSendMissionTimerNotify ( unsigned char eState, float fRemainingSecs );
	void eventMissionTimeIncrement ( float fInc );
	void eventMissionTimerModify ( unsigned long bPause, int nNewTime );
	float eventMatchDuration ( );
	float eventElapsedTime ( );
	bool eventMissionTimerActive ( );
	void eventChangeTimerState ( unsigned char eTimerState );
	void eventEnableMovementOnAllPlayers ( );
	void eventAllPlayersReady ( );
	void eventMissionTimer ( );
	void eventMissionTimerPause ( );
	void eventMissionTimerStop ( );
	void eventMissionTimerStart ( );
	void eventSetMissionTime ( float fTime );
	void KeepClientsInSync ( );
	bool StartGameTimer ( );
	void eventTgTimer ( struct FString* sTimerCommand );
	void eventQuickEndGame ( int nWinnerTF );
	bool CheckScore ( class APlayerReplicationInfo* Scorer );
	void UpdateLockedPointStatus ( );
	void OnPointCaptureOwnershipChanged ( class ATgCapturePoint* Point, int NewTaskForceOwner, int PreviousTaskForceOwner );
	void AddObjectiveScore ( class APlayerReplicationInfo* Scorer, int Score );
	void StartMatch ( );
	void eventPostLogin ( class APlayerController* NewPlayer );
	void CreateMinimapManagers ( class UClass* managerClass );
	void eventSendMissionTimerEvent ( int nEventId, int nWinningTaskForce );
	void eventPostBeginPlay ( );
	void NativeUpdateTimerState ( );
	bool SwapToNewAIController ( class AController* C, class ATgPawn_Character* TgPawn );
	bool GetScoreKillData ( class AController* Killer, class AController* Other, struct FScoreKillData* Data );
	void ScoreKillAchievements ( struct FScoreKillData* Data );
	void ScoreKillGameType ( struct FScoreKillData* Data );
	void ScoreKillCommon ( struct FScoreKillData* Data );
	void ScoreKill ( class AController* Killer, class AController* Other );
	float GetMinIntroWait ( );
	void CapturePointReclaimed ( class ATgPawn_Character* PC );
	void CapturedPoint ( class ATgPawn_Character* PC );
	void EndGameBySurrender ( int SurrenderingTaskForce );
	void SurrenderComplete ( int nTaskForce );
	void SurrenderCompleteTimer2 ( );
	void SurrenderCompleteTimer1 ( );
	void RemoveSurrenderVote ( int nPlayerId, int nTaskForce );
	void PlayerSurrender ( int nPlayerId, unsigned long bSurrender );
	void AllPlayersRecall ( );
	void AllPlayersFullVitals ( );
	void AllPlayersRevive ( );
	void MarkAsReady ( class UPlayer* P );
	float MissionTimeElapsed ( );
	float MissionTimeRemaining ( );
	void UpdateMissionTimerEventWinVar ( );
	void PauseMinionSpawns ( struct FName Command );
	class ATgPawn* SpawnPlayerCharacter ( class AController* C, struct FVector vLocation );
	void SpoolXp ( );
	void SpoolCurrency ( );
	void LoadGameOverrides ( );
	void LoadGameConfig ( );
	bool BeginEndMission ( unsigned long bClearNextMapGame, class AActor* EndMissionFocus, float fDelayOverride );
};

UClass* ATgGame_Mission::pClassPointer = NULL;

// Class TgGame.TgGame_Battle
// 0x0060 (0x0598 - 0x0538)
class ATgGame_Battle : public ATgGame_Mission
{
public:
	TArray< int >                                      m_StartingItems;                                  		// 0x0538 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                m_StartingSkills[ 0x4 ];                          		// 0x0544 (0x0010) [0x0000000000000000]              
	float                                              m_MultiLaneXpBonus;                               		// 0x0554 (0x0004) [0x0000000000000000]              
	float                                              m_FireGiantRewardDuration;                        		// 0x0558 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bRespawnInhibitors : 1;                         		// 0x055C (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bEnableCrowdEvents : 1;                         		// 0x055C (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_bRestrictStoreInteractions : 1;                 		// 0x055C (0x0004) [0x0000000000000000] [0x00000004] 
	TArray< struct FTgAIBotPlayersToSpawn >            m_MercsToSpawn;                                   		// 0x0560 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	unsigned char                                      m_eCurrentQuestType;                              		// 0x056C (0x0001) [0x0000000000000000]              
	int                                                m_nCurrentQuestID;                                		// 0x0570 (0x0004) [0x0000000000000000]              
	int                                                m_nCurrentQuestMsgID;                             		// 0x0574 (0x0004) [0x0000000000000000]              
	class UClass*                                      m_CurrentQuestClass;                              		// 0x0578 (0x0004) [0x0000000000000000]              
	int                                                m_nObjectiveCount;                                		// 0x057C (0x0004) [0x0000000000000000]              
	int                                                m_nObjectiveGoal;                                 		// 0x0580 (0x0004) [0x0000000000000000]              
	class ATgPawn*                                     m_CurrentTrainingPlayer;                          		// 0x0584 (0x0004) [0x0000000000000000]              
	int                                                m_nTutorialSpawnTable;                            		// 0x0588 (0x0004) [0x0000000000000000]              
	int                                                m_nNumberTutorialGods;                            		// 0x058C (0x0004) [0x0000000000000000]              
	int                                                m_nPIESpawnTable;                                 		// 0x0590 (0x0004) [0x0000000000000000]              
	int                                                m_nTargetPlayerCountForMercs;                     		// 0x0594 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3015 );

		return pClassPointer;
	};

	void eventUpdateQuest ( int QuestID, int Amount );
	void eventCheckCurrentQuest ( );
	void SpawnBots ( );
	int eventGetPlayerCount ( );
	void CreateMinimapManagers ( class UClass* managerClass );
	void eventChangeTimerState ( unsigned char eTimerState );
	bool StartGameTimer ( );
	void eventAdjustScore ( class ATgRepInfo_TaskForce* tf );
	void eventTriggerBonusMinions ( class ATgRepInfo_TaskForce* tf, int nLane );
	void eventOnBossMonsterKilled ( class ATgPawn* BossMonster, class ATgPawn* KillerPawn );
	void eventNexusWasDestroyed ( class ATgPawn* nexus );
	class AActor* GetEndMissionFocus ( class ATgPawn_Guardian* DestroyedMinotaur );
	void ScoreKillGameType ( struct FScoreKillData* Data );
	void ForceLoadMercenaries ( int SpawnTableID );
	void CheckMercenaries ( );
	bool ShouldSpawnSuperMinions ( class ATgBotFactory_Minions* minionFactory );
	void SetInhibitorRespawn ( unsigned long bRespawn );
	void CheckTeamAce ( class AController* Killer, class AController* Killed );
	int GetNextVulnerableTowerId ( int nBotId );
	void ApplyTowerImmunity ( );
	float GetRespawnTime ( class AController* C );
	void BotDied ( class ATgAIController* aic );
	void PlayerDied ( class ATgPlayerController* PC );
	void StructureDied ( class ATgPawn_Structure* theStructure );
	void SendGameStartAlert ( );
	void SendBonusMinionAlerts ( class ATgRepInfo_TaskForce* tf, int nLane );
	void UpdateGameWinState ( class ATgPawn* nexus );
};

UClass* ATgGame_Battle::pClassPointer = NULL;

// Class TgGame.TgGame_Arena
// 0x002C (0x05C4 - 0x0598)
class ATgGame_Arena : public ATgGame_Battle
{
public:
	float                                              s_fLastDespawnTime[ 0x2 ];                        		// 0x0598 (0x0008) [0x0000000000000000]              
	float                                              s_fDespawnNotificationDelay;                      		// 0x05A0 (0x0004) [0x0000000000000000]              
	int                                                m_nKillValueHero;                                 		// 0x05A4 (0x0004) [0x0000000000000000]              
	int                                                m_nKillValueMinion;                               		// 0x05A8 (0x0004) [0x0000000000000000]              
	int                                                m_nKillValueTower;                                		// 0x05AC (0x0004) [0x0000000000000000]              
	int                                                m_MinScoreToTrackMinionKills;                     		// 0x05B0 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bDoNotScoreMinionKills : 1;                     		// 0x05B4 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bDoNotScorePortalKills : 1;                     		// 0x05B4 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_bIsCrowdOnFeet : 1;                             		// 0x05B4 (0x0004) [0x0000000000002000] [0x00000004] ( CPF_Transient )
	int                                                m_nSpawnWaveTime;                                 		// 0x05B8 (0x0004) [0x0000000000000000]              
	int                                                m_nSpawnWaveDominatingTime;                       		// 0x05BC (0x0004) [0x0000000000000000]              
	int                                                m_nMaxDominatingPoints;                           		// 0x05C0 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3016 );

		return pClassPointer;
	};

	void eventChangeTimerState ( unsigned char eTimerState );
	float GetTaskForceDominatingFactor ( int TaskforceNum );
	void SpawnWaveTeam2Timer ( );
	void SpawnWaveTeam1Timer ( );
	class AActor* eventGetEndFocusActor ( );
	void eventCheckGameState ( );
	void OnMinionDespawn ( int taskforce, class ATgPawn* VictimPawn );
	bool StartGameTimer ( );
	float GetSetupTime ( );
	int GetGameEndingScore ( );
	int GetStartingScore ( );
	void ForwardOnMinionDespawn ( class ATgRepInfo_TaskForce* tf );
	void SendDespawnAlert ( class ATgRepInfo_TaskForce* tfri );
	void ApplyTowerImmunity ( );
	bool BeginEndMission ( unsigned long bClearNextMapGame, class AActor* EndMissionFocus, float fDelayOverride );
	void EndGameBySurrender ( int SurrenderingTaskForce );
	float GetRespawnTime ( class AController* C );
	void MarkAsReady ( class UPlayer* P );
	void ScoreKillGameType ( struct FScoreKillData* Data );
	void LoadGameConfig ( );
};

UClass* ATgGame_Arena::pClassPointer = NULL;

// Class TgGame.TgGame_Arena_Capture
// 0x0018 (0x05DC - 0x05C4)
class ATgGame_Arena_Capture : public ATgGame_Arena
{
public:
	int                                                s_nCaptureHostilePointXP;                         		// 0x05C4 (0x0004) [0x0000000000000000]              
	int                                                s_nCaptureHostilePointGold;                       		// 0x05C8 (0x0004) [0x0000000000000000]              
	int                                                s_nReclaimPointXP;                                		// 0x05CC (0x0004) [0x0000000000000000]              
	int                                                s_nReclaimPointGold;                              		// 0x05D0 (0x0004) [0x0000000000000000]              
	int                                                m_nCurrentActiveCapturePointIndex;                		// 0x05D4 (0x0004) [0x0000000000000000]              
	float                                              m_fNewPointTime;                                  		// 0x05D8 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3017 );

		return pClassPointer;
	};

	void UpdateLockedPointStatus ( );
	void OnPointCaptureOwnershipChanged ( class ATgCapturePoint* Point, int NewTaskForceOwner, int PreviousTaskForceOwner );
	void SpawnNeutralBots ( );
	void CapturePointReclaimed ( class ATgPawn_Character* PC );
	void CapturedPoint ( class ATgPawn_Character* PC );
	void eventChangeTimerState ( unsigned char eTimerState );
	void eventPostBeginPlay ( );
};

UClass* ATgGame_Arena_Capture::pClassPointer = NULL;

// Class TgGame.TgGame_Arena_Escort
// 0x001C (0x05E0 - 0x05C4)
class ATgGame_Arena_Escort : public ATgGame_Arena
{
public:
	int                                                m_nSpawnEscortTime;                               		// 0x05C4 (0x0004) [0x0000000000000000]              
	int                                                m_nEscortSuccessValue;                            		// 0x05C8 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bDoNotSpawnEscort : 1;                          		// 0x05CC (0x0004) [0x0000000000000000] [0x00000001] 
	class UTgSeqEvent_SpawnWise*                       s_pEvt[ 0x2 ];                                    		// 0x05D0 (0x0008) [0x0000000000000000]              
	class UTgSeqEvent_Escort_Despawn_Success*          s_pDespawnEvt[ 0x2 ];                             		// 0x05D8 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3018 );

		return pClassPointer;
	};

	void OnEscortDespawn ( int taskforce );
	void LoadGameConfig ( );
	void SendEscortSpawnAlert ( class ATgRepInfo_TaskForce* tfri );
};

UClass* ATgGame_Arena_Escort::pClassPointer = NULL;

// Class TgGame.TgGame_Arena_Escort_Practice
// 0x0000 (0x05E0 - 0x05E0)
class ATgGame_Arena_Escort_Practice : public ATgGame_Arena_Escort
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3019 );

		return pClassPointer;
	};

};

UClass* ATgGame_Arena_Escort_Practice::pClassPointer = NULL;

// Class TgGame.TgGame_Arena_SuddenDeath
// 0x0010 (0x05F0 - 0x05E0)
class ATgGame_Arena_SuddenDeath : public ATgGame_Arena_Escort
{
public:
	unsigned char                                      m_BonusGameWinState;                              		// 0x05E0 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_TempWinState;                                   		// 0x05E1 (0x0001) [0x0000000000000000]              
	unsigned long                                      m_bOvertimeTimedOut : 1;                          		// 0x05E4 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bHasEnteredOvertime : 1;                        		// 0x05E4 (0x0004) [0x0000000000000000] [0x00000002] 
	float                                              m_fBonusWorshipers;                               		// 0x05E8 (0x0004) [0x0000000000000000]              
	float                                              m_fStandardMissionTimer;                          		// 0x05EC (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3020 );

		return pClassPointer;
	};

	float eventElapsedTime ( );
	bool eventIsInOvertime ( );
	void OnEscortDespawn ( int taskforce );
	void OnMinionDespawn ( int taskforce, class ATgPawn* VictimPawn );
	void eventCheckSuddenDeathWinner ( );
	void eventCheckGameState ( );
	void eventChangeTimerState ( unsigned char eTimerState );
	void eventMissionTimer ( );
	void eventPushDeviceRestartTo ( class ATgPawn* PlayerPawn );
	void StartOvertime ( );
	void PrepPlayersForSuddenDeath ( );
	void PseudoRoundEnd ( );
	void EndGameBySurrender ( int SurrenderingTaskForce );
	float MissionTimeElapsed ( );
	float GetRespawnTime ( class AController* C );
	void ScoreKillGameType ( struct FScoreKillData* Data );
	void BotDied ( class ATgAIController* aic );
	void PlayerDied ( class ATgPlayerController* PC );
};

UClass* ATgGame_Arena_SuddenDeath::pClassPointer = NULL;

// Class TgGame.TgGame_Arena_Practice
// 0x0000 (0x05C4 - 0x05C4)
class ATgGame_Arena_Practice : public ATgGame_Arena
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3021 );

		return pClassPointer;
	};

};

UClass* ATgGame_Arena_Practice::pClassPointer = NULL;

// Class TgGame.TgGame_Arena_Training
// 0x0008 (0x05CC - 0x05C4)
class ATgGame_Arena_Training : public ATgGame_Arena_Practice
{
public:
	unsigned long                                      m_bEnableGameCompletion : 1;                      		// 0x05C4 (0x0004) [0x0000000000000000] [0x00000001] 
	int                                                m_nScoreCap;                                      		// 0x05C8 (0x0004) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3022 );

		return pClassPointer;
	};

	void OnMinionDespawn ( int taskforce, class ATgPawn* VictimPawn );
	void eventAdjustScore ( class ATgRepInfo_TaskForce* tf );
	void eventUseTickets ( int taskforce, int Tickets );
	class ATgPawn* SpawnPlayerCharacter ( class AController* C, struct FVector vLocation );
};

UClass* ATgGame_Arena_Training::pClassPointer = NULL;

// Class TgGame.TgGame_Battle_Casual
// 0x0000 (0x0598 - 0x0598)
class ATgGame_Battle_Casual : public ATgGame_Battle
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3023 );

		return pClassPointer;
	};

	void StructureDied ( class ATgPawn_Structure* theStructure );
	bool ShouldSpawnSuperMinions ( class ATgBotFactory_Minions* minionFactory );
	float GetRespawnTime ( class AController* C );
};

UClass* ATgGame_Battle_Casual::pClassPointer = NULL;

// Class TgGame.TgGame_Battle_Clash
// 0x0000 (0x0598 - 0x0598)
class ATgGame_Battle_Clash : public ATgGame_Battle
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3024 );

		return pClassPointer;
	};

	void eventChangeTimerState ( unsigned char eTimerState );
	float GetSetupTime ( );
	float GetRespawnTime ( class AController* C );
	int GetNextVulnerableTowerId ( int nBotId );
};

UClass* ATgGame_Battle_Clash::pClassPointer = NULL;

// Class TgGame.TgGame_Battle_Clash_Practice
// 0x0000 (0x0598 - 0x0598)
class ATgGame_Battle_Clash_Practice : public ATgGame_Battle_Clash
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3025 );

		return pClassPointer;
	};

};

UClass* ATgGame_Battle_Clash_Practice::pClassPointer = NULL;

// Class TgGame.TgGame_Battle_ClashV2
// 0x0010 (0x05A8 - 0x0598)
class ATgGame_Battle_ClashV2 : public ATgGame_Battle_Clash
{
public:
	float                                              m_RespawnTimeStart;                               		// 0x0598 (0x0004) [0x0000000000000000]              
	float                                              m_RespawnTimeIncreasePerInterval;                 		// 0x059C (0x0004) [0x0000000000000000]              
	float                                              m_RespawnTimeInterval;                            		// 0x05A0 (0x0004) [0x0000000000000000]              
	float                                              m_RespawnTimeMax;                                 		// 0x05A4 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3026 );

		return pClassPointer;
	};

	int GetNextVulnerableTowerId ( int nBotId );
	float GetRespawnTime ( class AController* C );
};

UClass* ATgGame_Battle_ClashV2::pClassPointer = NULL;

// Class TgGame.TgGame_Battle_Conquest
// 0x0000 (0x0598 - 0x0598)
class ATgGame_Battle_Conquest : public ATgGame_Battle
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3027 );

		return pClassPointer;
	};

	void eventChangeTimerState ( unsigned char eTimerState );
};

UClass* ATgGame_Battle_Conquest::pClassPointer = NULL;

// Class TgGame.TgGame_Battle_Aram
// 0x0000 (0x0598 - 0x0598)
class ATgGame_Battle_Aram : public ATgGame_Battle_Conquest
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3028 );

		return pClassPointer;
	};

	float GetRespawnTime ( class AController* C );
};

UClass* ATgGame_Battle_Aram::pClassPointer = NULL;

// Class TgGame.TgGame_Battle_Aram_Practice
// 0x0000 (0x0598 - 0x0598)
class ATgGame_Battle_Aram_Practice : public ATgGame_Battle_Aram
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3029 );

		return pClassPointer;
	};

};

UClass* ATgGame_Battle_Aram_Practice::pClassPointer = NULL;

// Class TgGame.TgGame_Battle_Conquest_Erez
// 0x0008 (0x05A0 - 0x0598)
class ATgGame_Battle_Conquest_Erez : public ATgGame_Battle_Conquest
{
public:
	int                                                m_nSpawnSiegeWeaponThreshold;                     		// 0x0598 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bDoNotSpawnSiegeWeaponFromTickets : 1;          		// 0x059C (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3030 );

		return pClassPointer;
	};

	void eventSendLanePusherUpdateAlert ( unsigned long isAlive, int tf );
	void eventTriggerLanePusher ( class ATgRepInfo_TaskForce* tf, int nLane );
	void eventPostBeginPlay ( );
	void OnLanePusherSpawned ( class AActor* LanePusher, class ATgRepInfo_TaskForce* taskforce );
	float GetRespawnTime ( class AController* C );
	void SendLanePusherSpawnAlert ( int taskforce );
	void ScoreKillGameType ( struct FScoreKillData* Data );
	int GetNextVulnerableTowerId ( int nBotId );
	void LoadGameConfig ( );
};

UClass* ATgGame_Battle_Conquest_Erez::pClassPointer = NULL;

// Class TgGame.TgGame_Battle_Conquest_Practice
// 0x0000 (0x0598 - 0x0598)
class ATgGame_Battle_Conquest_Practice : public ATgGame_Battle_Conquest
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3031 );

		return pClassPointer;
	};

};

UClass* ATgGame_Battle_Conquest_Practice::pClassPointer = NULL;

// Class TgGame.TgGame_Battle_Conquest_Training
// 0x0000 (0x0598 - 0x0598)
class ATgGame_Battle_Conquest_Training : public ATgGame_Battle_Conquest_Practice
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3032 );

		return pClassPointer;
	};

	class ATgPawn* SpawnPlayerCharacter ( class AController* C, struct FVector vLocation );
};

UClass* ATgGame_Battle_Conquest_Training::pClassPointer = NULL;

// Class TgGame.TgGame_Battle_Conquest_Tc
// 0x0000 (0x0598 - 0x0598)
class ATgGame_Battle_Conquest_Tc : public ATgGame_Battle_Conquest
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3033 );

		return pClassPointer;
	};

	float GetRespawnTime ( class AController* C );
};

UClass* ATgGame_Battle_Conquest_Tc::pClassPointer = NULL;

// Class TgGame.TgGame_Battle_Siege2
// 0x0001 (0x0599 - 0x0598)
class ATgGame_Battle_Siege2 : public ATgGame_Battle_Conquest
{
public:
	unsigned char                                      m_BattlePhase;                                    		// 0x0598 (0x0001) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3034 );

		return pClassPointer;
	};

	float GetSetupTime ( );
	int GetNextVulnerableTowerId ( int nBotId );
};

UClass* ATgGame_Battle_Siege2::pClassPointer = NULL;

// Class TgGame.TgGame_Battle_Encounters
// 0x0028 (0x05C0 - 0x0598)
class ATgGame_Battle_Encounters : public ATgGame_Battle
{
public:
	unsigned char                                      s_eRoundState;                                    		// 0x0598 (0x0001) [0x0000000000000000]              
	int                                                s_nCurrentRound;                                  		// 0x059C (0x0004) [0x0000000000000000]              
	float                                              m_fCumulativePlayTime;                            		// 0x05A0 (0x0004) [0x0000000000000000]              
	TArray< class ATgAIController* >                   m_ControllersToDestroy;                           		// 0x05A4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class ATgPawn* >                           m_PawnsToDestroy;                                 		// 0x05B0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class ATgObjectiveVolume_BotList*                  m_ObjectiveVolume;                                		// 0x05BC (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3035 );

		return pClassPointer;
	};

	void eventAllPlayersReady ( );
	void eventPushDeviceRestartTo ( class ATgPawn* PlayerPawn );
	void eventForceEndGame ( );
	void eventCheckGameState ( );
	float eventMatchDuration ( );
	void eventMissionTimer ( );
	void eventMissionTimerStart ( );
	void eventDestroyPendingBots ( );
	void eventHandleBotDied ( class ATgAIController* aic );
	float GetSetupTime ( );
	int GetNumPlayersAlive ( );
	bool SwapToNewAIController ( class AController* C, class ATgPawn_Character* TgPawn );
	float GetDifficultyMultiplier ( );
	int GetDifficulty ( );
	float MissionTimeElapsed ( );
	float MissionTimeRemaining ( );
	void FailedRound ( );
	float GetRespawnTime ( class AController* C );
	void PlayerDied ( class ATgPlayerController* PC );
	void BotDied ( class ATgAIController* aic );
};

UClass* ATgGame_Battle_Encounters::pClassPointer = NULL;

// Class TgGame.TgGame_Battle_Expert
// 0x0000 (0x0598 - 0x0598)
class ATgGame_Battle_Expert : public ATgGame_Battle
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3036 );

		return pClassPointer;
	};

	void eventTriggerBonusMinions ( class ATgRepInfo_TaskForce* tf, int nLane );
};

UClass* ATgGame_Battle_Expert::pClassPointer = NULL;

// Class TgGame.TgGame_Battle_Joust
// 0x0000 (0x0598 - 0x0598)
class ATgGame_Battle_Joust : public ATgGame_Battle
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3037 );

		return pClassPointer;
	};

	void eventChangeTimerState ( unsigned char eTimerState );
	float GetSetupTime ( );
	void AutoForfeit ( );
	bool Is1v1 ( );
	void MarkAsReady ( class UPlayer* P );
	float GetRespawnTime ( class AController* C );
	void CheckTeamAce ( class AController* Killer, class AController* Killed );
	int GetNextVulnerableTowerId ( int nBotId );
};

UClass* ATgGame_Battle_Joust::pClassPointer = NULL;

// Class TgGame.TgGame_Battle_Joust_Practice
// 0x0000 (0x0598 - 0x0598)
class ATgGame_Battle_Joust_Practice : public ATgGame_Battle_Joust
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3038 );

		return pClassPointer;
	};

	void MarkAsReady ( class UPlayer* P );
};

UClass* ATgGame_Battle_Joust_Practice::pClassPointer = NULL;

// Class TgGame.TgGame_Battle_ShootingRange
// 0x0000 (0x0598 - 0x0598)
class ATgGame_Battle_ShootingRange : public ATgGame_Battle_Joust_Practice
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3039 );

		return pClassPointer;
	};

	void SpawnBots ( );
	float GetSetupTime ( );
	bool Is1v1 ( );
	float GetRespawnTime ( class AController* C );
};

UClass* ATgGame_Battle_ShootingRange::pClassPointer = NULL;

// Class TgGame.TgGame_Battle_Training
// 0x0010 (0x05A8 - 0x0598)
class ATgGame_Battle_Training : public ATgGame_Battle_Joust_Practice
{
public:
	unsigned long                                      m_bNewTutorial : 1;                               		// 0x0598 (0x0004) [0x0000000000000000] [0x00000001] 
	TArray< int >                                      m_RecommendedItems;                               		// 0x059C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3040 );

		return pClassPointer;
	};

	void SpawnBots ( );
	float GetSetupTime ( );
	bool Is1v1 ( );
	class ATgPawn* SpawnPlayerCharacter ( class AController* C, struct FVector vLocation );
	float GetRespawnTime ( class AController* C );
};

UClass* ATgGame_Battle_Training::pClassPointer = NULL;

// Class TgGame.TgGame_Battle_Racer
// 0x0018 (0x05B0 - 0x0598)
class ATgGame_Battle_Racer : public ATgGame_Battle
{
public:
	TArray< class ATgRacingCheckpoint* >               m_Checkpoints;                                    		// 0x0598 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class ATgRacingCheckpoint*                         m_StartingCheckpoint;                             		// 0x05A4 (0x0004) [0x0000000000000000]              
	class ATgRacingCheckpoint*                         m_LastCheckpoint;                                 		// 0x05A8 (0x0004) [0x0000000000000000]              
	float                                              m_fTotalTrackDistance;                            		// 0x05AC (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3041 );

		return pClassPointer;
	};

	void CollectCheckpoints ( );
	void eventAllPlayersEndGame ( class AActor* EndGameFocus );
	void eventPostBeginPlay ( );
	void DeterminePlayerPlacements ( );
	void SetTotalDistanceTraveled ( class ATgPawn_Racer* Racer );
	void SetLapDistanceTraveled ( class ATgPawn_Racer* Racer );
	void SetCurrentCheckpointAndLap ( class ATgPawn_Racer* Racer );
	bool SwapToNewAIController ( class AController* C, class ATgPawn_Character* TgPawn );
};

UClass* ATgGame_Battle_Racer::pClassPointer = NULL;

// Class TgGame.TgGame_PointCapture
// 0x0030 (0x05C8 - 0x0598)
class ATgGame_PointCapture : public ATgGame_Battle
{
public:
	float                                              s_TicketCheckInterval;                            		// 0x0598 (0x0004) [0x0000000000000000]              
	int                                                s_nCaptureHostilePointXP;                         		// 0x059C (0x0004) [0x0000000000000000]              
	int                                                s_nCaptureHostilePointGold;                       		// 0x05A0 (0x0004) [0x0000000000000000]              
	int                                                s_nReclaimPointXP;                                		// 0x05A4 (0x0004) [0x0000000000000000]              
	int                                                s_nReclaimPointGold;                              		// 0x05A8 (0x0004) [0x0000000000000000]              
	int                                                s_nCurrentPhase;                                  		// 0x05AC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                s_nPhase2Threshold;                               		// 0x05B0 (0x0004) [0x0000000000000000]              
	int                                                s_nPhase3Threshold;                               		// 0x05B4 (0x0004) [0x0000000000000000]              
	int                                                m_nSpawnWaveTime;                                 		// 0x05B8 (0x0004) [0x0000000000000000]              
	int                                                m_nSpawnWaveDominatingTime;                       		// 0x05BC (0x0004) [0x0000000000000000]              
	int                                                m_nMaxDominatingPoints;                           		// 0x05C0 (0x0004) [0x0000000000000000]              
	int                                                s_nAboutToLoseThreshold;                          		// 0x05C4 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3042 );

		return pClassPointer;
	};

	void OnPointCaptureOwnershipChanged ( class ATgCapturePoint* Point, int NewTaskForceOwner, int PreviousTaskForceOwner );
	void UpdateLockedPointStatus ( );
	float GetTaskForceDominatingFactor ( int TaskforceNum );
	void SpawnWaveTeam2Timer ( );
	void SpawnWaveTeam1Timer ( );
	void eventCheckWinState ( );
	void eventTrophyMonsterKilled ( class ATgPawn* Killer, int RewardAmount );
	void CheckWinCondition ( );
	void SubtractTicketsFromTaskForce ( class ATgRepInfo_TaskForce* tf, int Amount );
	void CheckTicketsForTeam ( int TaskForceNumber, int OpposingTaskForceNumber );
	void CheckTickets ( );
	void eventChangeTimerState ( unsigned char eTimerState );
	void SpawnNeutralBots ( );
	bool StartGameTimer ( );
	float GetSetupTime ( );
	class AActor* eventGetEndFocusActor ( );
	int GetGameEndingScore ( );
	int GetStartingScore ( );
	bool ShouldSpawnSuperMinions ( class ATgBotFactory_Minions* minionFactory );
	int GetNextVulnerableTowerId ( int nBotId );
	void ApplyTowerImmunity ( );
	void StructureDied ( class ATgPawn_Structure* theStructure );
	void SendBonusMinionAlerts ( class ATgRepInfo_TaskForce* tf, int nLane );
	void UpdateGameWinState ( class ATgPawn* nexus );
	void AlertAboutToLose ( int nTaskForce );
	void CapturePointReclaimed ( class ATgPawn_Character* PC );
	void CapturedPoint ( class ATgPawn_Character* PC );
	void ScoreKillGameType ( struct FScoreKillData* Data );
	bool BeginEndMission ( unsigned long bClearNextMapGame, class AActor* EndMissionFocus, float fDelayOverride );
	void EndGameBySurrender ( int SurrenderingTaskForce );
	void MarkAsReady ( class UPlayer* P );
	float GetRespawnTime ( class AController* C );
};

UClass* ATgGame_PointCapture::pClassPointer = NULL;

// Class TgGame.TgGame_Domination
// 0x0004 (0x05CC - 0x05C8)
class ATgGame_Domination : public ATgGame_PointCapture
{
public:
	float                                              m_fRespawnTime;                                   		// 0x05C8 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3043 );

		return pClassPointer;
	};

	void UpdateLockedPointStatus ( );
	float GetRespawnTime ( class AController* C );
};

UClass* ATgGame_Domination::pClassPointer = NULL;

// Class TgGame.TgGame_SinglePointCaptureAndHold
// 0x0014 (0x05DC - 0x05C8)
class ATgGame_SinglePointCaptureAndHold : public ATgGame_PointCapture
{
public:
	int                                                m_nCurrentActiveCapturePointIndex;                		// 0x05C8 (0x0004) [0x0000000000000000]              
	int                                                m_nNumTicketsForCapturingPoint;                   		// 0x05CC (0x0004) [0x0000000000000000]              
	int                                                m_nNumTicketsForHoldingPoint;                     		// 0x05D0 (0x0004) [0x0000000000000000]              
	float                                              m_fNewPointTime;                                  		// 0x05D4 (0x0004) [0x0000000000000000]              
	float                                              m_fDefendingTeamRespawnTime;                      		// 0x05D8 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3044 );

		return pClassPointer;
	};

	void UpdateLockedPointStatus ( );
	void CheckTickets ( );
	void OnPointCaptureOwnershipChanged ( class ATgCapturePoint* Point, int NewTaskForceOwner, int PreviousTaskForceOwner );
	void SpawnNeutralBots ( );
	float GetRespawnTime ( class AController* C );
};

UClass* ATgGame_SinglePointCaptureAndHold::pClassPointer = NULL;

// Class TgGame.TgGame_CTF
// 0x0020 (0x0558 - 0x0538)
class ATgGame_CTF : public ATgGame_Mission
{
public:
	class ATgCTFFlagBase*                              m_FlagBases[ 0x2 ];                               		// 0x0538 (0x0008) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_fRoundTime;                                     		// 0x0540 (0x0004) [0x0000000000000000]              
	float                                              m_fRoundSetupTime;                                		// 0x0544 (0x0004) [0x0000000000000000]              
	float                                              m_fEndOfRoundTime;                                		// 0x0548 (0x0004) [0x0000000000000000]              
	int                                                m_nCurrentRound;                                  		// 0x054C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_nNumRounds;                                     		// 0x0550 (0x0004) [0x0000000000000000]              
	int                                                m_nSpawnWaveTime;                                 		// 0x0554 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3045 );

		return pClassPointer;
	};

	void SpawnWaveTimer ( );
	void ScoreFlag ( class ATgPawn_Character* FlagCarrier );
	void RegisterFlagBase ( class ATgCTFFlagBase* FlagBase );
	void eventMissionTimer ( );
	void eventChangeTimerState ( unsigned char eTimerState );
	bool StartGameTimer ( );
	float GetSetupTime ( );
	void ScoreKillGameType ( struct FScoreKillData* Data );
	float GetRespawnTime ( class AController* C );
};

UClass* ATgGame_CTF::pClassPointer = NULL;

// Class TgGame.TgGame_Idol
// 0x000C (0x0544 - 0x0538)
class ATgGame_Idol : public ATgGame_Mission
{
public:
	class ATgIdol*                                     m_Idols[ 0x2 ];                                   		// 0x0538 (0x0008) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_nSpawnWaveTime;                                 		// 0x0540 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3046 );

		return pClassPointer;
	};

	void SpawnWaveTimer ( );
	void eventMissionTimer ( );
	bool StartGameTimer ( );
	float GetSetupTime ( );
	void ScoreKillGameType ( struct FScoreKillData* Data );
	float GetRespawnTime ( class AController* C );
};

UClass* ATgGame_Idol::pClassPointer = NULL;

// Class TgGame.TgGameTipManager
// 0x0028 (0x0218 - 0x01F0)
class ATgGameTipManager : public AActor
{
public:
	TArray< struct FTipSavedState >                    m_TipSavedState;                                  		// 0x01F0 (0x000C) [0x0000000000444000]              ( CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink )
	TArray< struct FGameTipInfo >                      m_GameTipQueue;                                   		// 0x01FC (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	unsigned long                                      m_bIsActive : 1;                                  		// 0x0208 (0x0004) [0x0000000000000000] [0x00000001] 
	class UTgAudioComponent*                           m_AudioComponent;                                 		// 0x020C (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	int                                                m_nActiveTip;                                     		// 0x0210 (0x0004) [0x0000000000000000]              
	int                                                m_nPlaySoundTip;                                  		// 0x0214 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3047 );

		return pClassPointer;
	};

	int GameTipQueueSort ( struct FGameTipInfo A, struct FGameTipInfo B );
	void eventSortGameTipQueue ( );
	void SetActive ( );
	void UnsuppressAllGameTips ( );
	void CompleteHelpText ( int nGameTipId );
	void SuppressHelpText ( int nGameTipId );
	void RemoveHelpText ( int nGameTipId, unsigned long bDoNotSuppress );
	void DismissHelpText ( int nGameTipId, unsigned long bDoNotSuppress );
	bool RequestHelpText ( int nGameTipId, unsigned long bIsFriend, unsigned long bWaitForDismiss );
	bool IsSuppressed ( int nGameTipId );
};

UClass* ATgGameTipManager::pClassPointer = NULL;

// Class TgGame.TgMapInfo
// 0x0030 (0x006C - 0x003C)
class UTgMapInfo : public UMapInfo
{
public:
	class AActor*                                      m_EndFocusActor_TF1;                              		// 0x003C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class AActor*                                      m_EndFocusActor_TF2;                              		// 0x0040 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class AStaticMeshActor*                            m_OverlayPathMesh;                                		// 0x0044 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FVector2D                                   m_vMapCenter;                                     		// 0x0048 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FVector2D                                   m_vTaskForce1BaseLocation;                        		// 0x0050 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FVector2D                                   m_vTaskForce2BaseLocation;                        		// 0x0058 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fLockViewBufferZoneSize;                        		// 0x0060 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_bSupportsGuardianThrone : 1;                    		// 0x0064 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	int                                                m_nDefaultMusicThemeItemId;                       		// 0x0068 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3048 );

		return pClassPointer;
	};

};

UClass* UTgMapInfo::pClassPointer = NULL;

// Class TgGame.TgMinimapManager
// 0x005C (0x0098 - 0x003C)
class UTgMinimapManager : public UObject
{
public:
	unsigned char                                      m_LocalTeam;                                      		// 0x003C (0x0001) [0x0000000000000000]              
	unsigned char                                      UnknownData00[ 0x3C ];                            		// 0x0040 (0x003C) UNKNOWN PROPERTY: MapProperty TgGame.TgMinimapManager.m_EntityMap
	unsigned long                                      m_bShouldDisableVisionRange : 1;                  		// 0x007C (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bSkipWorldGeometryLOS : 1;                      		// 0x007C (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_bRequiresVisionUpdate : 1;                      		// 0x007C (0x0004) [0x0000000000000000] [0x00000004] 
	float                                              m_fFogOfWarAreaRevealTime;                        		// 0x0080 (0x0004) [0x0000000000000000]              
	float                                              m_fUpdateTimer;                                   		// 0x0084 (0x0004) [0x0000000000000000]              
	float                                              m_fLastEntityUpdateTime;                          		// 0x0088 (0x0004) [0x0000000000000000]              
	TArray< class AReplicationInfo* >                  m_ReferencedRepInfos;                             		// 0x008C (0x000C) [0x0000000000500000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3049 );

		return pClassPointer;
	};

	void eventInitForTaskforce ( class ATgRepInfo_TaskForce* tf );
	void ForceUpdate ( class AReplicationInfo* ri );
	void RemoveAllEntities ( );
	void UpdateThreaded ( );
	void Update ( unsigned long bForce );
};

UClass* UTgMinimapManager::pClassPointer = NULL;

// Class TgGame.TgRepInfo_CapturePoint
// 0x001C (0x020C - 0x01F0)
class ATgRepInfo_CapturePoint : public AReplicationInfo
{
public:
	class ATgCapturePoint*                             r_OwningCapturePoint;                             		// 0x01F0 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nUniqueCapturePointId;                          		// 0x01F4 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nControlledByTaskForce;                         		// 0x01F8 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              r_fOwnershipPct;                                  		// 0x01FC (0x0004) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      r_nTransitionDirection;                           		// 0x0200 (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned long                                      r_bIsLocked : 1;                                  		// 0x0204 (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )
	class UTgSeqEvent_ControlPointOwnershipPercent*    c_OwnershipPercentKismetNode;                     		// 0x0208 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3050 );

		return pClassPointer;
	};

	int eventGetCapturePointIndex ( );
	void eventOnOwnershipPctChanged ( );
	void OnTaskForceControlChanged ( );
	void eventPostBeginPlay ( );
	void eventReplicatedEvent ( struct FName VarName );
	struct FVector GetCurrentLocation ( );
	void UpdateCapturePointControlUI ( int Index );
};

UClass* ATgRepInfo_CapturePoint::pClassPointer = NULL;

// Class TgGame.TgRepInfo_Deployable
// 0x0174 (0x0364 - 0x01F0)
class ATgRepInfo_Deployable : public AReplicationInfo
{
public:
	int                                                r_nHealthCurrent;                                 		// 0x01F0 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nHealthMaximum;                                 		// 0x01F4 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              r_fDeployMaxHealthPCT;                            		// 0x01F8 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nDeployableId;                                  		// 0x01FC (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nUniqueDeployableId;                            		// 0x0200 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              r_fLifespanInitial;                               		// 0x0204 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              r_fLifespanSync;                                  		// 0x0208 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgDeployable*                               r_DeployableOwner;                                		// 0x020C (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgRepInfo_Player*                           r_InstigatorInfo;                                 		// 0x0210 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgRepInfo_TaskForce*                        r_TaskforceInfo;                                  		// 0x0214 (0x0004) [0x0000000000000020]              ( CPF_Net )
	unsigned long                                      r_bOwnedByTaskforce : 1;                          		// 0x0218 (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )
	unsigned long                                      c_bReceivedOwner : 1;                             		// 0x0218 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      r_bMinimapOnlyOwnerSee : 1;                       		// 0x0218 (0x0004) [0x0000000000000020] [0x00000004] ( CPF_Net )
	unsigned long                                      r_bOverlayAlwaysVisible : 1;                      		// 0x0218 (0x0004) [0x0000000000000020] [0x00000008] ( CPF_Net )
	unsigned long                                      r_bInDestroyedState : 1;                          		// 0x0218 (0x0004) [0x0000000000000020] [0x00000010] ( CPF_Net )
	unsigned long                                      c_bShowHUDLifespanTimer : 1;                      		// 0x0218 (0x0004) [0x0000000000000000] [0x00000020] 
	unsigned long                                      bIsTargeted : 1;                                  		// 0x0218 (0x0004) [0x0000000000002000] [0x00000040] ( CPF_Transient )
	struct FVector                                     r_ApproxLocation;                                 		// 0x021C (0x000C) [0x0000000000000020]              ( CPF_Net )
	struct FTG_HUD_INFO                                c_HudInfo;                                        		// 0x0228 (0x0130) [0x0000000000400000]              ( CPF_NeedCtorLink )
	unsigned char                                      r_bVisibleOnMap[ 0x3 ];                           		// 0x0358 (0x0003) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      r_bOverlayType;                                   		// 0x035B (0x0001) [0x0000000000000020]              ( CPF_Net )
	float                                              r_fVisionRange;                                   		// 0x035C (0x0004) [0x0000000000000020]              ( CPF_Net )
	class UClass*                                      r_cMinimapOnlyClassSee;                           		// 0x0360 (0x0004) [0x0000000000000020]              ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3051 );

		return pClassPointer;
	};

	void LifespanTimer ( );
	void UpdateLifespanTimer ( );
	void SyncLifespanTimer ( );
	void StartLifespanTimer ( float fTime );
	void UpdateDeployableLocation ( );
	void ReceivedDeployableOwner ( );
	void eventReplicatedEvent ( struct FName VarName );
	void eventDestroyed ( );
	void eventPostBeginPlay ( );
	void CheckNotifyGroupChanged ( );
	bool IsVisibleToLocalPlayer ( );
	bool IsVisibleToPlayer ( class ATgRepInfo_Player* PRI );
	bool IsVisibleToMapTeam ( unsigned char MAPTEAM );
	bool IsVisibleToAnEnemyTeam ( );
	void UpdateMapVisibility ( unsigned char MAPTEAM, unsigned char bVisible, float fVisionRange, unsigned long bDetected );
	float GetMaxLifespan ( );
	float GetLifespan ( );
	int GetCurrentMaxHealth ( );
	int GetCurrentHealth ( );
	struct FVector GetCurrentLocation ( );
	void SetTaskForce ( class ATgRepInfo_TaskForce* tf );
	class ATgRepInfo_TaskForce* GetTaskForce ( );
};

UClass* ATgRepInfo_Deployable::pClassPointer = NULL;

// Class TgGame.TgRepInfo_Portal
// 0x0008 (0x036C - 0x0364)
class ATgRepInfo_Portal : public ATgRepInfo_Deployable
{
public:
	class ATgRepInfo_Portal*                           r_TwinDRI;                                        		// 0x0364 (0x0004) [0x0000000000000020]              ( CPF_Net )
	unsigned long                                      c_bMasterEntity : 1;                              		// 0x0368 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3052 );

		return pClassPointer;
	};

};

UClass* ATgRepInfo_Portal::pClassPointer = NULL;

// Class TgGame.TgRepInfo_Ward
// 0x0008 (0x036C - 0x0364)
class ATgRepInfo_Ward : public ATgRepInfo_Deployable
{
public:
	float                                              r_MinimapDetectionRange;                          		// 0x0364 (0x0004) [0x0000000000000020]              ( CPF_Net )
	unsigned long                                      r_bRequireLOS : 1;                                		// 0x0368 (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )
	unsigned long                                      s_bTeleportIncoming : 1;                          		// 0x0368 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      s_bRevealOtherWards : 1;                          		// 0x0368 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      s_bMustBeRevealed : 1;                            		// 0x0368 (0x0004) [0x0000000000000000] [0x00000008] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3053 );

		return pClassPointer;
	};

	float eventGetMinimapDetectionRange ( );
	void UpdateMapVisibility ( unsigned char MAPTEAM, unsigned char bVisible, float fVisionRange, unsigned long bDetected );
};

UClass* ATgRepInfo_Ward::pClassPointer = NULL;

// Class TgGame.TgRepInfo_TriggerableWard
// 0x0008 (0x0374 - 0x036C)
class ATgRepInfo_TriggerableWard : public ATgRepInfo_Ward
{
public:
	unsigned long                                      r_IsTriggered : 1;                                		// 0x036C (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )
	unsigned long                                      r_bRevealOnlyOnTrigger : 1;                       		// 0x036C (0x0004) [0x0000000000000000] [0x00000002] 
	class ATgRepInfo_Player*                           r_TriggererPRI;                                   		// 0x0370 (0x0004) [0x0000000000000020]              ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3054 );

		return pClassPointer;
	};

	float eventGetMinimapDetectionRange ( );
};

UClass* ATgRepInfo_TriggerableWard::pClassPointer = NULL;

// Class TgGame.TgRepInfo_WayPoint
// 0x0000 (0x0364 - 0x0364)
class ATgRepInfo_WayPoint : public ATgRepInfo_Deployable
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3055 );

		return pClassPointer;
	};

};

UClass* ATgRepInfo_WayPoint::pClassPointer = NULL;

// Class TgGame.TgRepInfo_Factory
// 0x0048 (0x0238 - 0x01F0)
class ATgRepInfo_Factory : public AReplicationInfo
{
public:
	unsigned char                                      s_FactoryState;                                   		// 0x01F0 (0x0001) [0x0000000000000000]              
	unsigned char                                      r_FactoryState[ 0x3 ];                            		// 0x01F1 (0x0003) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      r_bVisibleOnMap[ 0x3 ];                           		// 0x01F4 (0x0003) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      r_bRespawnVisible[ 0x3 ];                         		// 0x01F7 (0x0003) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      r_MinimapType;                                    		// 0x01FA (0x0001) [0x0000000000000020]              ( CPF_Net )
	class ATgActorFactory*                             r_FactoryOwner;                                   		// 0x01FC (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgRepInfo_TaskForce*                        r_TaskforceInfo;                                  		// 0x0200 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nFactoryId;                                     		// 0x0204 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class AReplicationInfo*                            r_LastSpawnedRepInfo;                             		// 0x0208 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              r_fRespawnDelay;                                  		// 0x020C (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              r_fRespawnTimer;                                  		// 0x0210 (0x0004) [0x0000000000000020]              ( CPF_Net )
	unsigned long                                      r_bFirstSpawnWave : 1;                            		// 0x0214 (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )
	unsigned long                                      r_bBlockRespawnMesh : 1;                          		// 0x0214 (0x0004) [0x0000000000000020] [0x00000002] ( CPF_Net )
	unsigned long                                      r_bSpawnModified : 1;                             		// 0x0214 (0x0004) [0x0000000000000020] [0x00000004] ( CPF_Net )
	TArray< class ATgPawn* >                           m_TrackedPawns;                                   		// 0x0218 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                r_nTotalSpawns;                                   		// 0x0224 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nTotalDeaths;                                   		// 0x0228 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nTotalEmpties;                                  		// 0x022C (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              r_fModifiedSpawnDuration;                         		// 0x0230 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              r_fModifiedSpawnTimer;                            		// 0x0234 (0x0004) [0x0000000000000020]              ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3056 );

		return pClassPointer;
	};

	void UpdateFactoryPlaceHolderMesh ( );
	void eventRemoveTrackedPawn ( class ATgPawn* Pawn );
	void eventAddTrackedPawn ( class ATgPawn* Pawn );
	void eventStopSpawnModifiedTimer ( );
	void eventUpdateSpawnModifiedTimer ( );
	void eventStartSpawnModifiedTimer ( float fSeconds );
	void eventStopRespawnTimer ( );
	void UpdateRespawnTimer ( );
	void eventStartRespawnTimer ( float fSeconds );
	void UpdateInWorldIndicators ( );
	void eventDestroyed ( );
	void eventReplicatedEvent ( struct FName VarName );
	void PostBeginPlay ( );
	void InitFor ( class ATgActorFactory* Factory );
	float GetModifiedSpawnElapsedPercent ( );
	float GetRespawnElapsedPercent ( );
	bool IsVisibleToLocalPlayer ( );
	void UpdateMapVisibility ( unsigned char MAPTEAM, unsigned char bVisible, float fVisionRange, unsigned long bDetected );
};

UClass* ATgRepInfo_Factory::pClassPointer = NULL;

// Class TgGame.TgRepInfo_Game
// 0x00F8 (0x034C - 0x0254)
class ATgRepInfo_Game : public APComRepInfo_Game
{
public:
	TArray< struct FGraphData >                        m_GraphData;                                      		// 0x0254 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FGraphData                                  r_LastDataPoint;                                  		// 0x0260 (0x000C) [0x0000000000000000]              
	float                                              m_GraphUpdateWaitTime;                            		// 0x026C (0x0004) [0x0000000000000000]              
	int                                                m_nQuestID;                                       		// 0x0270 (0x0004) [0x0000000000000000]              
	int                                                m_nQuestCount;                                    		// 0x0274 (0x0004) [0x0000000000000000]              
	int                                                m_nQuestGoal;                                     		// 0x0278 (0x0004) [0x0000000000000000]              
	unsigned char                                      r_GameType;                                       		// 0x027C (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      r_GameSeason;                                     		// 0x027D (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      r_nMissionTimerState;                             		// 0x027E (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      r_eGameTimerState;                                		// 0x027F (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      r_FlagState[ 0x2 ];                               		// 0x0280 (0x0002) [0x0000000000000020]              ( CPF_Net )
	unsigned long                                      r_bIsMission : 1;                                 		// 0x0284 (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )
	unsigned long                                      r_bIntroPlayed : 1;                               		// 0x0284 (0x0004) [0x0000000000000020] [0x00000002] ( CPF_Net )
	unsigned long                                      r_bEnableDistanceFOW : 1;                         		// 0x0284 (0x0004) [0x0000000000000020] [0x00000004] ( CPF_Net )
	unsigned long                                      r_bCinematicHidesNameplates : 1;                  		// 0x0284 (0x0004) [0x0000000000000020] [0x00000008] ( CPF_Net )
	float                                              r_fMissionRemainingTime;                          		// 0x0288 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nMissionTimerStateChange;                       		// 0x028C (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              r_fMissionTime;                                   		// 0x0290 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              c_fMissionTime;                                   		// 0x0294 (0x0004) [0x0000000000000000]              
	float                                              c_fMissionTimeSeconds;                            		// 0x0298 (0x0004) [0x0000000000000000]              
	int                                                r_nCapturePoints[ 0x5 ];                          		// 0x029C (0x0014) [0x0000000000000000]              
	class ATgRepInfo_TaskForce*                        r_Winner;                                         		// 0x02B0 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              r_fPhysicsThreshold;                              		// 0x02B4 (0x0004) [0x0000000000000020]              ( CPF_Net )
	struct FString                                     r_sQueueName;                                     		// 0x02B8 (0x000C) [0x0000000000400020]              ( CPF_Net | CPF_NeedCtorLink )
	int                                                r_nMaxInvItems;                                   		// 0x02C4 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nLockedDevices;                                 		// 0x02C8 (0x0004) [0x0000000000000020]              ( CPF_Net )
	TArray< class ATgDeployable* >                     m_Deployables;                                    		// 0x02CC (0x000C) [0x0000000000502000]              ( CPF_Transient | CPF_NeedCtorLink )
	TArray< class ATgProjectile* >                     m_Projectiles;                                    		// 0x02D8 (0x000C) [0x0000000000502000]              ( CPF_Transient | CPF_NeedCtorLink )
	TArray< class ATgDestructible* >                   m_Destructibles;                                  		// 0x02E4 (0x000C) [0x0000000000502000]              ( CPF_Transient | CPF_NeedCtorLink )
	TArray< class ATgBotFactory* >                     m_BotFactories;                                   		// 0x02F0 (0x000C) [0x0000000000502000]              ( CPF_Transient | CPF_NeedCtorLink )
	TArray< class ATgRepInfo_Deployable* >             m_DRIArray;                                       		// 0x02FC (0x000C) [0x0000000000502000]              ( CPF_Transient | CPF_NeedCtorLink )
	TArray< class ATgRepInfo_CapturePoint* >           m_CPRIArray;                                      		// 0x0308 (0x000C) [0x0000000000502000]              ( CPF_Transient | CPF_NeedCtorLink )
	int                                                r_nCurrentCheckpoint[ 0x2 ];                      		// 0x0314 (0x0008) [0x0000000000002020]              ( CPF_Net | CPF_Transient )
	int                                                c_nNextClientOnlyProjectileInstanceId;            		// 0x031C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                r_BannedGodsList[ 0x8 ];                          		// 0x0320 (0x0020) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nGameTipId;                                     		// 0x0340 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nRoundTitleId;                                  		// 0x0344 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nCurrentRound;                                  		// 0x0348 (0x0004) [0x0000000000000020]              ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3057 );

		return pClassPointer;
	};

	float eventGetMissionTime ( );
	void eventSetCheckpoint ( int NewCheckpoint, int taskforce );
	bool FlagIsDown ( int TeamIndex );
	void SetFlagDown ( int TeamIndex );
	bool FlagIsHeldEnemy ( int TeamIndex );
	void ProcessMissionTimerEvent ( int nEventId, int nWinningTaskForce );
	void SendMissionTimerEvent ( int nEventId, int nWinningTaskForce );
	void SetFlagHeldEnemy ( int TeamIndex );
	bool FlagIsHeldFriendly ( int TeamIndex );
	void SetFlagHeldFriendly ( int TeamIndex );
	bool FlagsAreHome ( );
	bool FlagIsHome ( int TeamIndex );
	void SetFlagHome ( int TeamIndex );
	int eventGetNextClientOnlyProjectileInstanceId ( );
	void RemoveDestructible ( class ATgDestructible* Dest );
	void AddDestructible ( class ATgDestructible* Dest );
	void RemoveCPRI ( class ATgRepInfo_CapturePoint* CPRI );
	void AddCPRI ( class ATgRepInfo_CapturePoint* CPRI );
	void RemoveDRI ( class ATgRepInfo_Deployable* dri );
	void AddDRI ( class ATgRepInfo_Deployable* dri );
	void MissionTimeUpdateAllClients ( );
	void UpdateMissionTimer ( );
	void InitMissionTime ( );
	void eventPostBeginPlay ( );
	void eventReplicatedEvent ( struct FName VarName );
	void UpdateRoundUI ( );
	unsigned char GetLane ( int nLane, class ATgRepInfo_TaskForce* tfri );
	class ATgProj_Simulated* SpawnSimulatedProjectile ( int nProjectileInstanceId, int nFireModeId, class AActor* pOwner, struct FVector vLocation, struct FVector vRotation, int nProjectileIdOverride );
	class ATgProj_Simulated* GetSimulatedProjectile ( int nProjectileId );
	void UpdateBannedGodsList ( );
	void UpdateQuest ( int Id, int Count, int Goal, int msgId );
	void GameBansUpdate ( );
	void GameTypeSet ( );
	void GameStateChanged ( );
	void UpdateGameTransitionUI ( );
	void UpdateGameScoreUI ( );
	void UpdateGameClockUI ( );
	bool AreTaskForcesEnemies ( class ATgRepInfo_TaskForce* TaskForceA, class ATgRepInfo_TaskForce* TaskForceB );
	bool CheckIsEnemy ( class AActor* A, class AActor* B );
	bool TaskForceEnumerate ( unsigned long bPlayerOnly, class ATgRepInfo_TaskForce** rpTaskForce, int* rnTaskForceNum );
	class ATgRepInfo_TaskForce* CreateTaskForce ( int nTaskForceNum );
	class ATgRepInfo_TaskForce* GetTaskForce ( int nTaskForceNum, unsigned long bCreate );
	class ATgRepInfo_TaskForce* GetTaskForceFor ( class AActor* Actor );
	class ATgProjectile* GetProjectile ( int nIndex );
	class ATgDeployable* GetDeployable ( int nIndex );
	int GetDeployableCount ( );
};

UClass* ATgRepInfo_Game::pClassPointer = NULL;

// Class TgGame.TgRepInfo_Player
// 0x06E0 (0x0A84 - 0x03A4)
class ATgRepInfo_Player : public APlayerReplicationInfo
{
public:
	int                                                r_nPlayerId;                                      		// 0x03A4 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nPawnId;                                        		// 0x03A8 (0x0004) [0x0000000000000020]              ( CPF_Net )
	unsigned long                                      r_bForceNotBot : 1;                               		// 0x03AC (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )
	unsigned long                                      r_bIsInCombat : 1;                                		// 0x03AC (0x0004) [0x0000000000000020] [0x00000002] ( CPF_Net )
	unsigned long                                      r_bIsInGodCombat : 1;                             		// 0x03AC (0x0004) [0x0000000000000020] [0x00000004] ( CPF_Net )
	unsigned long                                      r_bMapHasLoaded : 1;                              		// 0x03AC (0x0004) [0x0000000000000020] [0x00000008] ( CPF_Net )
	unsigned long                                      r_bHasBeenSeenByEnemyTeam : 1;                    		// 0x03AC (0x0004) [0x0000000000000020] [0x00000010] ( CPF_Net )
	unsigned long                                      r_bHasFlag : 1;                                   		// 0x03AC (0x0004) [0x0000000000002020] [0x00000020] ( CPF_Net | CPF_Transient )
	unsigned long                                      m_bRegisteredForVoice : 1;                        		// 0x03AC (0x0004) [0x0000000000000000] [0x00000040] 
	unsigned long                                      r_bHasRegisteredForVoiceLocally : 1;              		// 0x03AC (0x0004) [0x0000000000000020] [0x00000080] ( CPF_Net )
	unsigned long                                      c_bSpeaking : 1;                                  		// 0x03AC (0x0004) [0x0000000000000000] [0x00000100] 
	unsigned long                                      r_bDropped : 1;                                   		// 0x03AC (0x0004) [0x0000000000000020] [0x00000200] ( CPF_Net )
	unsigned long                                      r_bDisconnected : 1;                              		// 0x03AC (0x0004) [0x0000000000000020] [0x00000400] ( CPF_Net )
	unsigned long                                      c_bIsDying : 1;                                   		// 0x03AC (0x0004) [0x0000000000000000] [0x00000800] 
	unsigned long                                      r_bIsStealthed : 1;                               		// 0x03AC (0x0004) [0x0000000000000020] [0x00001000] ( CPF_Net )
	unsigned long                                      r_bStealthBrokenByWard : 1;                       		// 0x03AC (0x0004) [0x0000000000000000] [0x00002000] 
	unsigned long                                      r_bIsVolumeStealthed : 1;                         		// 0x03AC (0x0004) [0x0000000000000000] [0x00004000] 
	unsigned long                                      r_bIsRecalling : 1;                               		// 0x03AC (0x0004) [0x0000000000000020] [0x00008000] ( CPF_Net )
	unsigned long                                      r_bHasFakeName : 1;                               		// 0x03AC (0x0004) [0x0000000000000020] [0x00010000] ( CPF_Net )
	float                                              c_fLastUpdateTime;                                		// 0x03B0 (0x0004) [0x0000000000000000]              
	int                                                r_nHealthCurrent;                                 		// 0x03B4 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nHealthMaximum;                                 		// 0x03B8 (0x0004) [0x0000000000000020]              ( CPF_Net )
	struct FVector                                     r_ApproxLocation;                                 		// 0x03BC (0x000C) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nPowerCurrent;                                  		// 0x03C8 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nPowerMaximum;                                  		// 0x03CC (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nPacingType;                                    		// 0x03D0 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nShieldCurrent;                                 		// 0x03D4 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nShieldMaximum;                                 		// 0x03D8 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgRepInfo_Player*                           r_MasterPrep;                                     		// 0x03DC (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgRepInfo_TaskForce*                        r_TaskForce;                                      		// 0x03E0 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgTeamPlayerStart*                          r_SpawnPoint;                                     		// 0x03E4 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              r_fReviveSecs;                                    		// 0x03E8 (0x0004) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      r_nSurrenderVote;                                 		// 0x03EC (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      r_bVisibleOnMap[ 0x3 ];                           		// 0x03ED (0x0003) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      r_nVisibilityMask;                                		// 0x03F0 (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      s_nPreferedMask;                                  		// 0x03F1 (0x0001) [0x0000000000000000]              
	unsigned char                                      r_DeviceTiers[ 0x19 ];                            		// 0x03F2 (0x0019) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      s_IsRevealed[ 0x3 ];                              		// 0x040B (0x0003) [0x0000000000000000]              
	TArray< class ATgRepInfo_Player* >                 m_PRIArray;                                       		// 0x0410 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class ATgRepInfo_Deployable* >             m_DRIArray;                                       		// 0x041C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class ATgRepInfo_Player*                           c_PriorMasterPrep;                                		// 0x0428 (0x0004) [0x0000000000000000]              
	class ATgRepInfo_TaskForce*                        c_PriorTaskForce;                                 		// 0x042C (0x0004) [0x0000000000000000]              
	int                                                c_fLastHealth;                                    		// 0x0430 (0x0004) [0x0000000000000000]              
	float                                              c_fLastDamageTime;                                		// 0x0434 (0x0004) [0x0000000000000000]              
	float                                              r_fVisionRange;                                   		// 0x0438 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgCarriedFlag*                              s_CarriedFlag;                                    		// 0x043C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FString                                     r_ClanTag;                                        		// 0x0440 (0x000C) [0x0000000000500020]              ( CPF_Net | CPF_NeedCtorLink )
	int                                                r_ClanId;                                         		// 0x044C (0x0004) [0x0000000000000020]              ( CPF_Net )
	struct FString                                     c_PlayerNameWithTag;                              		// 0x0450 (0x000C) [0x0000000000500000]              ( CPF_NeedCtorLink )
	int                                                r_Scores[ 0x16 ];                                 		// 0x045C (0x0058) [0x0000000000000020]              ( CPF_Net )
	struct FDeviceTeamInfo                             r_PlayerDevices[ 0x19 ];                          		// 0x04B4 (0x0320) [0x0000000000000020]              ( CPF_Net )
	int                                                r_bDeviceIsReady;                                 		// 0x07D4 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              c_fDeviceReadyInSecs[ 0x19 ];                     		// 0x07D8 (0x0064) [0x0000000000000000]              
	float                                              c_fDeviceCooldown[ 0x19 ];                        		// 0x083C (0x0064) [0x0000000000000000]              
	float                                              r_fUltReadyInSecs;                                		// 0x08A0 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              c_fLastSpeakingTime;                              		// 0x08A4 (0x0004) [0x0000000000000000]              
	int                                                r_nXp;                                            		// 0x08A8 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nLevel;                                         		// 0x08AC (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nProfileId;                                     		// 0x08B0 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                c_nSavedSkinId;                                   		// 0x08B4 (0x0004) [0x0000000000000000]              
	int                                                r_nSkinId;                                        		// 0x08B8 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgPawn*                                     r_PawnOwner;                                      		// 0x08BC (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nLaneId;                                        		// 0x08C0 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgRepInfo_Factory*                          s_FactoryInfo;                                    		// 0x08C4 (0x0004) [0x0000000000000000]              
	int                                                s_KillOrDeathStreakModifier;                      		// 0x08C8 (0x0004) [0x0000000000000000]              
	struct FsPingInfo                                  r_PingInfo[ 0x4 ];                                		// 0x08CC (0x0070) [0x0000000000000020]              ( CPF_Net )
	struct FVector                                     c_DeathLocation;                                  		// 0x093C (0x000C) [0x0000000000000000]              
	struct FTG_HUD_INFO                                c_HudInfo;                                        		// 0x0948 (0x0130) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< struct FSocialEmoteInfo >                  m_SocialEmotes;                                   		// 0x0A78 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3058 );

		return pClassPointer;
	};

	void UnregisterPlayerFromSession ( );
	void eventRegisterAsRemoteTalker ( );
	void ServerNotifyLocallyRegisteredForVoice ( );
	void OnRegisterLocalTalkerComplete ( unsigned char LocalUserNum, unsigned long bWasSuccessful );
	void eventRegisterAsLocalTalker ( unsigned char ControllerId );
	void eventUpdateDeviceReadyTimer ( float fTimeRemaining, unsigned char eqpPoint );
	void SetFlag ( class ATgCarriedFlag* NewFlag );
	void OnDeath ( );
	void TransferMinionOwnershipTo ( class ATgRepInfo_Player* NewOwner );
	void CopyProperties ( class APlayerReplicationInfo* PRI );
	void OverrideWith ( class APlayerReplicationInfo* PRI );
	class APlayerReplicationInfo* Duplicate ( );
	bool ShouldBroadCastWelcomeMessage ( unsigned long bExiting );
	class ATgPawn* FindLocalPlayerPawn ( );
	class APlayerController* FindLocalController ( );
	void eventReplicatedEvent ( struct FName VarName );
	void eventUpdatedTaskForce ( );
	void UpdatedApproxLocation ( );
	void UpdatedHealthCurrent ( );
	unsigned char GetTaskForceNumber ( );
	void eventUpdateShield ( int nCurrentShield, int nMaxShield );
	void eventUpdatePower ( int nCurrentPower, int nMaxPower );
	void eventUpdateHealth ( int nCurrentHealth, int nMaxHealth );
	void UpdatePlayerLocation ( );
	void eventUpdateIdAndProfile ( );
	void eventTimer ( );
	void RecalculateTeamColor ( );
	void ClientInitialize ( class AController* C );
	void TimerIsInGodCombat ( );
	void TimerIsInCombat ( );
	void PostBeginPlay ( );
	void SetBotRankIdFromProfileId ( );
	void SetFactoryInfo ( class ATgRepInfo_Factory* factorInfo );
	void GetPlayableVGSEmotes ( TArray< struct FSocialEmoteInfo >* PlayableVGSEmotes );
	bool CanPlayEmote ( unsigned char Emote );
	void UpdatePlayerSocialEmotes ( );
	void UpdatePlayerNameWithTag ( );
	void UpdatePlayerReady ( );
	void UpdateSurrenderVoting ( );
	void ClientUpdateItemStoreItems ( );
	bool SetTaskForceNumber ( unsigned char nTaskForce, unsigned long bForce );
	void SetVisibilityMask ( unsigned char NewMask );
	void UpdateMapVisibility ( unsigned char MAPTEAM, unsigned char bVisible, float fVisionRange, unsigned long bDetected );
	void UpdatePingInfo ( class ATgRepInfo_Player* pingedPri, struct FVector pingedLoc, unsigned char Type );
	void CheckPingingList ( );
	bool IsVisibleToLocalPlayer ( );
	bool IsVisibleToPlayer ( class ATgRepInfo_Player* PRI );
	bool IsVisibleToMapTeam ( unsigned char MAPTEAM );
	bool IsVisibleToAnEnemyTeam ( );
	bool HasBeenSeenByEnemyTeam ( );
	void UpdateFX ( );
	void UpdatePlayerTaskforceUI ( );
	void UpdatePlayerInfoUI ( );
	void UpdateSpectatorUI ( );
	struct FString GetPlayerNameForMsgDisplay ( unsigned long bBaseNameOnly );
	void TryRegisterRemoteForVoice ( );
	void TryRegisterSelfForVoice ( );
	bool IsReadyToPause ( );
	bool IsDeviceReady ( unsigned char eqpPoint );
	void UpdateDeviceIsReady ( unsigned char eqpPoint, float fCooldownSecs );
	bool IsHardStealthedClient ( );
	bool IsStealthedClient ( );
	struct FVector GetCurrentLocation ( );
	int GetCurrentMaxShield ( );
	int GetCurrentShield ( );
	int GetCurrentMaxPower ( );
	int GetCurrentPower ( );
	int GetCurrentMaxHealth ( );
	int GetCurrentHealth ( );
	void CheckMembership ( );
	void RemoveMinion ( class AReplicationInfo* pRepInfo );
	void AddMinion ( class AReplicationInfo* pRepInfo );
	void SetTeam ( class ATgRepInfo_TaskForce* pNewTeamRep );
	void UpdateBroadcastedItems ( class ATgInventoryManager* invMgr );
	void UpdateLevel ( );
	void UpdateScoreboard ( );
	int GetPlayerId ( );
	bool IsGodDecoy ( );
	bool IsGod ( );
	bool IsBot ( );
	bool IsFriendlyWithLocalPlayer ( );
};

UClass* ATgRepInfo_Player::pClassPointer = NULL;

// Class TgGame.TgRepInfo_TaskForce
// 0x00AC (0x02B8 - 0x020C)
class ATgRepInfo_TaskForce : public ATeamInfo
{
public:
	struct FString                                     c_fsName;                                         		// 0x020C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                r_nTeamId;                                        		// 0x0218 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nLeaderPlayerId;                                		// 0x021C (0x0004) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      r_nTaskForce;                                     		// 0x0220 (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      r_MapTeam;                                        		// 0x0221 (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      s_nUsedGodVisionMask;                             		// 0x0222 (0x0001) [0x0000000000000000]              
	int                                                s_nTaskForceChatId;                               		// 0x0224 (0x0004) [0x0000000000000000]              
	int                                                s_nStrikeForceId;                                 		// 0x0228 (0x0004) [0x0000000000000000]              
	int                                                s_nTaskTeamNum;                                   		// 0x022C (0x0004) [0x0000000000000000]              
	struct FColor                                      m_Color;                                          		// 0x0230 (0x0004) [0x0000000000000000]              
	unsigned long                                      r_bIsSurrendering : 1;                            		// 0x0234 (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )
	unsigned long                                      r_bSpectator : 1;                                 		// 0x0234 (0x0004) [0x0000000000000020] [0x00000002] ( CPF_Net )
	unsigned long                                      m_bDestroyOnEmpty : 1;                            		// 0x0234 (0x0004) [0x0000000000000000] [0x00000004] 
	int                                                s_nPlayerStartCount;                              		// 0x0238 (0x0004) [0x0000000000000000]              
	TArray< struct FTGTEAM_ENTRY >                     m_TeamPlayers;                                    		// 0x023C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< struct FTGTEAM_ENTRY >                     m_TeamBots;                                       		// 0x0248 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class ATgRepInfo_Factory* >                m_Factories;                                      		// 0x0254 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class ATgBotFactory_Minions* >             m_MinionFactories;                                		// 0x0260 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< struct FTEAMTIMEMANAGER_ENTRY >            s_TeamTimerManagers;                              		// 0x026C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class UTgAIInfluenceMap*                           s_InfluenceMap;                                   		// 0x0278 (0x0004) [0x0000000000000000]              
	class UTgMinimapManager*                           s_MinimapManager;                                 		// 0x027C (0x0004) [0x0000000000000000]              
	int                                                r_nScore;                                         		// 0x0280 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nScorePercent;                                  		// 0x0284 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nGoldBuffCount;                                 		// 0x0288 (0x0004) [0x0000000000000020]              ( CPF_Net )
	TArray< struct FGLOBALEFFECT_ENTRY >               m_GlobalEffectGroups;                             		// 0x028C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                m_nTowersKilled;                                  		// 0x0298 (0x0004) [0x0000000000000000]              
	int                                                m_nPhoenixCount;                                  		// 0x029C (0x0004) [0x0000000000000000]              
	int                                                r_nGodKillCount;                                  		// 0x02A0 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nFireGiantKills;                                		// 0x02A4 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nGoldFuryKills;                                 		// 0x02A8 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nClearedCampCount;                              		// 0x02AC (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                m_nLastGodIndex;                                  		// 0x02B0 (0x0004) [0x0000000000000000]              
	int                                                m_nLastGodList;                                   		// 0x02B4 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3059 );

		return pClassPointer;
	};

	void NotifyScoreChange ( );
	class ATgPlayerController* FindLocalPlayerController ( );
	void UpdateKismetOnScore ( );
	void eventReplicatedEvent ( struct FName VarName );
	void eventReceivedTaskForceNumber ( );
	void eventReceivedScoringChanges ( );
	bool HasActivePlayers ( );
	void RemoveFromTeam ( class AController* Other );
	void eventCreateInfluenceMaps ( );
	void CreateMinimap ( unsigned char Team, class UClass* managerClass );
	void eventPostDemoRewind ( );
	void eventPostInit ( );
	class ATgPawn* GetASiegeWeapon ( );
	int LaneOfSiegeWeapon ( );
	class ATgRepInfo_Player* GetNextGod ( unsigned long bIncrement, unsigned long bReset );
	void ResetGodIterator ( );
	class ATgRepInfo_Player* GetGod ( int nIndex );
	int GetGodCount ( );
	void RemoveAllGlobalEffectGroups ( );
	void ReapplyGlobalEffectGroups ( );
	void RemoveGlobalEffectGroups ( class ATgPawn_Character* aPawn );
	void ApplyGlobalEffectGroups ( class ATgPawn_Character* aPawn );
	void RemoveGlobalEffectGroup ( int nEffectGroupId );
	void AddGlobalEffectGroup ( class UTgEffectGroup* eg, class ATgPawn* InstigatorPawn );
	bool IsReadyToPause ( );
	void UpdateSurrenderTimer ( );
	void TeamRemoveFrom ( class AController* Other );
	bool IsLeader ( class ATgRepInfo_Player* pTgPri );
	class ATgBotFactory_Minions* GetMinionFactory ( int nIndex );
	class ATgRepInfo_Player* GetBot ( int nIndex );
	class ATgRepInfo_Player* GetPlayerById ( int nPawnId );
	class ATgRepInfo_Player* GetPlayer ( int nIndex );
	int GetMinionFactoryCount ( );
	int GetBotCount ( );
	int GetActivePlayerCount ( );
	int GetPlayerCount ( );
	bool RepEvent ( struct FName VarName );
	class ATgRepInfo_Player* CycleFrom ( class ATgRepInfo_Player* pFrom, unsigned long bForward );
};

UClass* ATgRepInfo_TaskForce::pClassPointer = NULL;

// Class TgGame.TgAchievement
// 0x0010 (0x004C - 0x003C)
class UTgAchievement : public UObject
{
public:
	struct FPointer                                    m_pActivity;                                      		// 0x003C (0x0004) [0x0000000000001000]              ( CPF_Native )
	class ATgPlayerController*                         Controller;                                       		// 0x0040 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bCustomValue3IsBotId : 1;                       		// 0x0044 (0x0004) [0x0000000000000002] [0x00000001] ( CPF_Const )
	int                                                m_nBotId;                                         		// 0x0048 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3060 );

		return pClassPointer;
	};

	void StopTracking ( );
	bool BelongsToBot ( int BotID );
	float GetCustomValue5 ( );
	float GetCustomValue4 ( );
	float GetCustomValue3 ( );
	float GetCustomValue2 ( );
	float GetCustomValue1 ( );
};

UClass* UTgAchievement::pClassPointer = NULL;

// Class TgGame.TgAchievement_AbilityCombo
// 0x0010 (0x005C - 0x004C)
class UTgAchievement_AbilityCombo : public UTgAchievement
{
public:
	int                                                m_nDevice1Id;                                     		// 0x004C (0x0004) [0x0000000000000000]              
	int                                                m_nDevice2Id;                                     		// 0x0050 (0x0004) [0x0000000000000000]              
	int                                                m_nTargetGoal;                                    		// 0x0054 (0x0004) [0x0000000000000000]              
	int                                                m_nSuccessCount;                                  		// 0x0058 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3061 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_AbilityCombo::pClassPointer = NULL;

// Class TgGame.TgAchievement_Odin_BirdBomb
// 0x0004 (0x0060 - 0x005C)
class UTgAchievement_Odin_BirdBomb : public UTgAchievement_AbilityCombo
{
public:
	unsigned long                                      m_nValidLunge : 1;                                		// 0x005C (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3062 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_Odin_BirdBomb::pClassPointer = NULL;

// Class TgGame.TgAchievement_AbilityMultiHit
// 0x0024 (0x0070 - 0x004C)
class UTgAchievement_AbilityMultiHit : public UTgAchievement
{
public:
	TArray< struct FDeviceEffectPair >                 m_PostPairs;                                      		// 0x004C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< struct FDeviceHitInfo >                    s_CurrentTrackedInfo;                             		// 0x0058 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	unsigned long                                      m_bCheckPawn : 1;                                 		// 0x0064 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bCheckDevice : 1;                               		// 0x0064 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_bCheckHitPawn : 1;                              		// 0x0064 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_bCheckCustom : 1;                               		// 0x0064 (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      m_bCheckEffects : 1;                              		// 0x0064 (0x0004) [0x0000000000000000] [0x00000010] 
	unsigned long                                      m_bCustomValue2IsDeviceId : 1;                    		// 0x0064 (0x0004) [0x0000000000000000] [0x00000020] 
	unsigned long                                      m_bCustomValue3IsEffectId : 1;                    		// 0x0064 (0x0004) [0x0000000000000000] [0x00000040] 
	int                                                m_nDeviceId;                                      		// 0x0068 (0x0004) [0x0000000000000000]              
	int                                                m_nEffectId;                                      		// 0x006C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3063 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_AbilityMultiHit::pClassPointer = NULL;

// Class TgGame.TgAchievement_AbilityMultiHeal
// 0x0000 (0x0070 - 0x0070)
class UTgAchievement_AbilityMultiHeal : public UTgAchievement_AbilityMultiHit
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3064 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_AbilityMultiHeal::pClassPointer = NULL;

// Class TgGame.TgAchievement_GuanYu_TheWarriorsWill
// 0x0000 (0x0070 - 0x0070)
class UTgAchievement_GuanYu_TheWarriorsWill : public UTgAchievement_AbilityMultiHeal
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3065 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_GuanYu_TheWarriorsWill::pClassPointer = NULL;

// Class TgGame.TgAchievement_AbilityMultiHit_MultiDeviceMultiEffect
// 0x0000 (0x0070 - 0x0070)
class UTgAchievement_AbilityMultiHit_MultiDeviceMultiEffect : public UTgAchievement_AbilityMultiHit
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3066 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_AbilityMultiHit_MultiDeviceMultiEffect::pClassPointer = NULL;

// Class TgGame.TgAchievement_AbilityMultiHit_SingleDeviceSingleEffect
// 0x0000 (0x0070 - 0x0070)
class UTgAchievement_AbilityMultiHit_SingleDeviceSingleEffect : public UTgAchievement_AbilityMultiHit
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3067 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_AbilityMultiHit_SingleDeviceSingleEffect::pClassPointer = NULL;

// Class TgGame.TgAchievement_AbilityMultiKill
// 0x0000 (0x0070 - 0x0070)
class UTgAchievement_AbilityMultiKill : public UTgAchievement_AbilityMultiHit
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3068 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_AbilityMultiKill::pClassPointer = NULL;

// Class TgGame.TgAchievement_MatchHitsByDevice
// 0x0004 (0x0074 - 0x0070)
class UTgAchievement_MatchHitsByDevice : public UTgAchievement_AbilityMultiHit
{
public:
	int                                                m_nNumHits;                                       		// 0x0070 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3069 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_MatchHitsByDevice::pClassPointer = NULL;

// Class TgGame.TgAchievement_MatchHitsByDevice_AnyTarget
// 0x0000 (0x0074 - 0x0074)
class UTgAchievement_MatchHitsByDevice_AnyTarget : public UTgAchievement_MatchHitsByDevice
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3070 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_MatchHitsByDevice_AnyTarget::pClassPointer = NULL;

// Class TgGame.TgAchievement_Ymir_WhySoCold
// 0x0000 (0x0074 - 0x0074)
class UTgAchievement_Ymir_WhySoCold : public UTgAchievement_MatchHitsByDevice
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3071 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_Ymir_WhySoCold::pClassPointer = NULL;

// Class TgGame.TgAchievement_AbilityUnderEffectCat
// 0x0010 (0x005C - 0x004C)
class UTgAchievement_AbilityUnderEffectCat : public UTgAchievement
{
public:
	int                                                m_nDeviceId;                                      		// 0x004C (0x0004) [0x0000000000000000]              
	int                                                m_nEffectCategory;                                		// 0x0050 (0x0004) [0x0000000000000000]              
	int                                                m_nTargetGoal;                                    		// 0x0054 (0x0004) [0x0000000000000000]              
	int                                                m_nSuccessCount;                                  		// 0x0058 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3072 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_AbilityUnderEffectCat::pClassPointer = NULL;

// Class TgGame.TgAchievement_AfterEffect
// 0x0004 (0x0050 - 0x004C)
class UTgAchievement_AfterEffect : public UTgAchievement
{
public:
	int                                                m_nLastScorerPawnId;                              		// 0x004C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3073 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_AfterEffect::pClassPointer = NULL;

// Class TgGame.TgAchievement_AhMuzenCab_HowSweet
// 0x000C (0x0058 - 0x004C)
class UTgAchievement_AhMuzenCab_HowSweet : public UTgAchievement
{
public:
	int                                                m_nSuccessCount;                                  		// 0x004C (0x0004) [0x0000000000000000]              
	int                                                m_nTargetGoal;                                    		// 0x0050 (0x0004) [0x0000000000000000]              
	int                                                m_nDeviceId;                                      		// 0x0054 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3074 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_AhMuzenCab_HowSweet::pClassPointer = NULL;

// Class TgGame.TgAchievement_AhPuch_CorpsesAkaLandmines
// 0x0010 (0x005C - 0x004C)
class UTgAchievement_AhPuch_CorpsesAkaLandmines : public UTgAchievement
{
public:
	int                                                m_nDeviceId;                                      		// 0x004C (0x0004) [0x0000000000000000]              
	int                                                m_nCorpseGoal;                                    		// 0x0050 (0x0004) [0x0000000000000000]              
	int                                                m_nCorpseExplosionCount;                          		// 0x0054 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bHitGod : 1;                                    		// 0x0058 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3075 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_AhPuch_CorpsesAkaLandmines::pClassPointer = NULL;

// Class TgGame.TgAchievement_AhPuch_RiseMyPretties
// 0x0010 (0x005C - 0x004C)
class UTgAchievement_AhPuch_RiseMyPretties : public UTgAchievement
{
public:
	int                                                m_nDevice1Id;                                     		// 0x004C (0x0004) [0x0000000000000000]              
	int                                                m_nDevice3Id;                                     		// 0x0050 (0x0004) [0x0000000000000000]              
	int                                                m_nZombieGoal;                                    		// 0x0054 (0x0004) [0x0000000000000000]              
	int                                                m_nNumZombies;                                    		// 0x0058 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3076 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_AhPuch_RiseMyPretties::pClassPointer = NULL;

// Class TgGame.TgAchievement_Anhur_Wall
// 0x0000 (0x004C - 0x004C)
class UTgAchievement_Anhur_Wall : public UTgAchievement
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3077 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_Anhur_Wall::pClassPointer = NULL;

// Class TgGame.TgAchievement_AoKuang_AMightySword
// 0x0008 (0x0054 - 0x004C)
class UTgAchievement_AoKuang_AMightySword : public UTgAchievement
{
public:
	int                                                m_nAoKuangUltDeviceId;                            		// 0x004C (0x0004) [0x0000000000000000]              
	class AActor*                                      m_ExecutionCandidate;                             		// 0x0050 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3078 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_AoKuang_AMightySword::pClassPointer = NULL;

// Class TgGame.TgAchievement_Aphrodite_KissMe
// 0x0014 (0x0060 - 0x004C)
class UTgAchievement_Aphrodite_KissMe : public UTgAchievement
{
public:
	int                                                m_nDeviceId;                                      		// 0x004C (0x0004) [0x0000000000000000]              
	int                                                m_nNumGods;                                       		// 0x0050 (0x0004) [0x0000000000000000]              
	TArray< class ATgPawn* >                           m_TrackedSaved;                                   		// 0x0054 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3079 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_Aphrodite_KissMe::pClassPointer = NULL;

// Class TgGame.TgAchievement_Arachnophobia
// 0x0000 (0x004C - 0x004C)
class UTgAchievement_Arachnophobia : public UTgAchievement
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3080 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_Arachnophobia::pClassPointer = NULL;

// Class TgGame.TgAchievement_ArtemisStunville
// 0x0020 (0x006C - 0x004C)
class UTgAchievement_ArtemisStunville : public UTgAchievement
{
public:
	int                                                m_nUltDevice;                                     		// 0x004C (0x0004) [0x0000000000000000]              
	TArray< int >                                      m_BoarChargeDevices;                              		// 0x0050 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                m_GoalAmount;                                     		// 0x005C (0x0004) [0x0000000000000000]              
	int                                                m_nFiringInstance;                                		// 0x0060 (0x0004) [0x0000000000000000]              
	int                                                m_nNumHit;                                        		// 0x0064 (0x0004) [0x0000000000000000]              
	int                                                m_nCategoryCode;                                  		// 0x0068 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3081 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_ArtemisStunville::pClassPointer = NULL;

// Class TgGame.TgAchievement_AssistsAfterEvent
// 0x000C (0x0058 - 0x004C)
class UTgAchievement_AssistsAfterEvent : public UTgAchievement
{
public:
	float                                              m_fAllotedTime;                                   		// 0x004C (0x0004) [0x0000000000000000]              
	float                                              s_fRemainingTime;                                 		// 0x0050 (0x0004) [0x0000000000000000]              
	int                                                m_nRequiredAssists;                               		// 0x0054 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3082 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_AssistsAfterEvent::pClassPointer = NULL;

// Class TgGame.TgAchievement_AssistsAfterDevFire
// 0x0004 (0x005C - 0x0058)
class UTgAchievement_AssistsAfterDevFire : public UTgAchievement_AssistsAfterEvent
{
public:
	int                                                m_nDeviceId;                                      		// 0x0058 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3083 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_AssistsAfterDevFire::pClassPointer = NULL;

// Class TgGame.TgAchievement_Baka_Butcher
// 0x0004 (0x0050 - 0x004C)
class UTgAchievement_Baka_Butcher : public UTgAchievement
{
public:
	int                                                m_nNumKills;                                      		// 0x004C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3084 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_Baka_Butcher::pClassPointer = NULL;

// Class TgGame.TgAchievement_Bastet_WheresMyKitties
// 0x000C (0x0058 - 0x004C)
class UTgAchievement_Bastet_WheresMyKitties : public UTgAchievement
{
public:
	int                                                m_nDeviceId;                                      		// 0x004C (0x0004) [0x0000000000000000]              
	int                                                m_nTargetAmount;                                  		// 0x0050 (0x0004) [0x0000000000000000]              
	int                                                m_nSuccessCount;                                  		// 0x0054 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3085 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_Bastet_WheresMyKitties::pClassPointer = NULL;

// Class TgGame.TgAchievement_BeastMaster
// 0x0000 (0x004C - 0x004C)
class UTgAchievement_BeastMaster : public UTgAchievement
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3086 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_BeastMaster::pClassPointer = NULL;

// Class TgGame.TgAchievement_Bellona_Master
// 0x000C (0x0058 - 0x004C)
class UTgAchievement_Bellona_Master : public UTgAchievement
{
public:
	TArray< struct FTrackedHits >                      m_HitInCombat;                                    		// 0x004C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3087 );

		return pClassPointer;
	};

	bool IsShieldDevice ( class ATgDevice* Dev );
	bool IsScourgeDevice ( class ATgDevice* Dev );
	bool IsHammerDevice ( class ATgDevice* Dev );
	bool IsDefaultDevice ( class ATgDevice* Dev );
};

UClass* UTgAchievement_Bellona_Master::pClassPointer = NULL;

// Class TgGame.TgAchievement_Bellona_Rally
// 0x0000 (0x004C - 0x004C)
class UTgAchievement_Bellona_Rally : public UTgAchievement
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3088 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_Bellona_Rally::pClassPointer = NULL;

// Class TgGame.TgAchievement_BotByTime
// 0x0000 (0x004C - 0x004C)
class UTgAchievement_BotByTime : public UTgAchievement
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3089 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_BotByTime::pClassPointer = NULL;

// Class TgGame.TgAchievement_Cabrakan_Tremors
// 0x0014 (0x0060 - 0x004C)
class UTgAchievement_Cabrakan_Tremors : public UTgAchievement
{
public:
	TArray< struct FTremorsData >                      m_TrackedData;                                    		// 0x004C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                m_nTargetTime;                                    		// 0x0058 (0x0004) [0x0000000000000000]              
	int                                                m_nDeviceId;                                      		// 0x005C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3090 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_Cabrakan_Tremors::pClassPointer = NULL;

// Class TgGame.TgAchievement_ChangE_JadeGo
// 0x000C (0x0058 - 0x004C)
class UTgAchievement_ChangE_JadeGo : public UTgAchievement
{
public:
	int                                                m_DeviceId;                                       		// 0x004C (0x0004) [0x0000000000000000]              
	int                                                m_GoalAmount;                                     		// 0x0050 (0x0004) [0x0000000000000000]              
	int                                                m_nNumHits;                                       		// 0x0054 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3091 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_ChangE_JadeGo::pClassPointer = NULL;

// Class TgGame.TgAchievement_ChangE_MyHipsDontLie
// 0x0008 (0x0054 - 0x004C)
class UTgAchievement_ChangE_MyHipsDontLie : public UTgAchievement
{
public:
	int                                                m_nTargetGoal;                                    		// 0x004C (0x0004) [0x0000000000000000]              
	int                                                m_nDeviceId;                                      		// 0x0050 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3092 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_ChangE_MyHipsDontLie::pClassPointer = NULL;

// Class TgGame.TgAchievement_Chronos_HandsOfTime
// 0x0018 (0x0064 - 0x004C)
class UTgAchievement_Chronos_HandsOfTime : public UTgAchievement
{
public:
	TArray< int >                                      m_nAllPassives;                                   		// 0x004C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< int >                                      m_nUsedPassives;                                  		// 0x0058 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3093 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_Chronos_HandsOfTime::pClassPointer = NULL;

// Class TgGame.TgAchievement_Chronos_ReRewind
// 0x0010 (0x005C - 0x004C)
class UTgAchievement_Chronos_ReRewind : public UTgAchievement
{
public:
	int                                                m_nDeviceId;                                      		// 0x004C (0x0004) [0x0000000000000000]              
	int                                                m_nStartAmount;                                   		// 0x0050 (0x0004) [0x0000000000000000]              
	int                                                m_nFinishAmount;                                  		// 0x0054 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_nValidStart : 1;                                		// 0x0058 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3094 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_Chronos_ReRewind::pClassPointer = NULL;

// Class TgGame.TgAchievement_Cupid_SpreadTheLove
// 0x0010 (0x005C - 0x004C)
class UTgAchievement_Cupid_SpreadTheLove : public UTgAchievement
{
public:
	int                                                m_nDeviceId;                                      		// 0x004C (0x0004) [0x0000000000000000]              
	TArray< class ATgPawn* >                           m_TrackedSaved;                                   		// 0x0050 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3095 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_Cupid_SpreadTheLove::pClassPointer = NULL;

// Class TgGame.TgAchievement_DeathFromAbove
// 0x0000 (0x004C - 0x004C)
class UTgAchievement_DeathFromAbove : public UTgAchievement
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3096 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_DeathFromAbove::pClassPointer = NULL;

// Class TgGame.TgAchievement_Destructible
// 0x0000 (0x004C - 0x004C)
class UTgAchievement_Destructible : public UTgAchievement
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3097 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_Destructible::pClassPointer = NULL;

// Class TgGame.TgAchievement_DeviceCleanseStun
// 0x001C (0x0068 - 0x004C)
class UTgAchievement_DeviceCleanseStun : public UTgAchievement
{
public:
	int                                                m_GoalAmount;                                     		// 0x004C (0x0004) [0x0000000000000000]              
	int                                                m_DeviceId;                                       		// 0x0050 (0x0004) [0x0000000000000000]              
	int                                                m_TargetCount;                                    		// 0x0054 (0x0004) [0x0000000000000000]              
	int                                                m_FiringInstance;                                 		// 0x0058 (0x0004) [0x0000000000000000]              
	TArray< class ATgPawn* >                           m_CleanseTargets;                                 		// 0x005C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3098 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_DeviceCleanseStun::pClassPointer = NULL;

// Class TgGame.TgAchievement_DeviceEffectDuration
// 0x0010 (0x005C - 0x004C)
class UTgAchievement_DeviceEffectDuration : public UTgAchievement
{
public:
	int                                                m_nDeviceId;                                      		// 0x004C (0x0004) [0x0000000000000000]              
	int                                                m_nEffectCategory;                                		// 0x0050 (0x0004) [0x0000000000000000]              
	float                                              m_fGoalTime;                                      		// 0x0054 (0x0004) [0x0000000000000000]              
	float                                              m_fStartTime;                                     		// 0x0058 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3099 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_DeviceEffectDuration::pClassPointer = NULL;

// Class TgGame.TgAchievement_DeviceHitAtDistance
// 0x0014 (0x0060 - 0x004C)
class UTgAchievement_DeviceHitAtDistance : public UTgAchievement
{
public:
	int                                                m_nHitCount;                                      		// 0x004C (0x0004) [0x0000000000000000]              
	int                                                m_DeviceId;                                       		// 0x0050 (0x0004) [0x0000000000000000]              
	int                                                m_HitGoal;                                        		// 0x0054 (0x0004) [0x0000000000000000]              
	float                                              m_MinDistance;                                    		// 0x0058 (0x0004) [0x0000000000000000]              
	float                                              m_MaxDistance;                                    		// 0x005C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3100 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_DeviceHitAtDistance::pClassPointer = NULL;

// Class TgGame.TgAchievement_DeviceHits_SingleShotPerTarget
// 0x0018 (0x0064 - 0x004C)
class UTgAchievement_DeviceHits_SingleShotPerTarget : public UTgAchievement
{
public:
	int                                                m_nDeviceId;                                      		// 0x004C (0x0004) [0x0000000000000000]              
	int                                                m_nNumHits;                                       		// 0x0050 (0x0004) [0x0000000000000000]              
	struct FShotHitInfo                                m_HitPawns;                                       		// 0x0054 (0x0010) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3101 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_DeviceHits_SingleShotPerTarget::pClassPointer = NULL;

// Class TgGame.TgAchievement_DeviceKillsSingleShot
// 0x0010 (0x005C - 0x004C)
class UTgAchievement_DeviceKillsSingleShot : public UTgAchievement
{
public:
	struct FTrackedKilledTargets                       m_CurrentTracked;                                 		// 0x004C (0x0010) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3102 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_DeviceKillsSingleShot::pClassPointer = NULL;

// Class TgGame.TgAchievement_Thoth_NarrowEscape
// 0x0000 (0x005C - 0x005C)
class UTgAchievement_Thoth_NarrowEscape : public UTgAchievement_DeviceKillsSingleShot
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3103 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_Thoth_NarrowEscape::pClassPointer = NULL;

// Class TgGame.TgAchievement_Vulcan_LaL
// 0x0000 (0x005C - 0x005C)
class UTgAchievement_Vulcan_LaL : public UTgAchievement_DeviceKillsSingleShot
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3104 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_Vulcan_LaL::pClassPointer = NULL;

// Class TgGame.TgAchievement_Vulcan_Meatball
// 0x0000 (0x005C - 0x005C)
class UTgAchievement_Vulcan_Meatball : public UTgAchievement_DeviceKillsSingleShot
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3105 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_Vulcan_Meatball::pClassPointer = NULL;

// Class TgGame.TgAchievement_Zeus_Detonate
// 0x000C (0x0068 - 0x005C)
class UTgAchievement_Zeus_Detonate : public UTgAchievement_DeviceKillsSingleShot
{
public:
	int                                                m_DeviceId;                                       		// 0x005C (0x0004) [0x0000000000000000]              
	int                                                m_KillGoal;                                       		// 0x0060 (0x0004) [0x0000000000000000]              
	int                                                m_ChargeCount;                                    		// 0x0064 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3106 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_Zeus_Detonate::pClassPointer = NULL;

// Class TgGame.TgAchievement_DeviceKillsWithHitType
// 0x000C (0x0058 - 0x004C)
class UTgAchievement_DeviceKillsWithHitType : public UTgAchievement
{
public:
	int                                                m_nDeviceId;                                      		// 0x004C (0x0004) [0x0000000000000000]              
	int                                                m_nHitType;                                       		// 0x0050 (0x0004) [0x0000000000000000]              
	int                                                m_nCategoryCode;                                  		// 0x0054 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3107 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_DeviceKillsWithHitType::pClassPointer = NULL;

// Class TgGame.TgAchievement_DeviceMultiHit_ByType
// 0x0024 (0x0070 - 0x004C)
class UTgAchievement_DeviceMultiHit_ByType : public UTgAchievement
{
public:
	int                                                m_nDeviceId;                                      		// 0x004C (0x0004) [0x0000000000000000]              
	int                                                m_nHitType;                                       		// 0x0050 (0x0004) [0x0000000000000000]              
	int                                                m_nCategoryCode;                                  		// 0x0054 (0x0004) [0x0000000000000000]              
	int                                                m_nNumToHit;                                      		// 0x0058 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bGodsOnly : 1;                                  		// 0x005C (0x0004) [0x0000000000000000] [0x00000001] 
	struct FTrackedTargets                             m_CurrentTracked;                                 		// 0x0060 (0x0010) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3108 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_DeviceMultiHit_ByType::pClassPointer = NULL;

// Class TgGame.TgAchievement_Camazotz_BatOutOfHell
// 0x0014 (0x0084 - 0x0070)
class UTgAchievement_Camazotz_BatOutOfHell : public UTgAchievement_DeviceMultiHit_ByType
{
public:
	struct FCamazotzTrackedTargets                     m_CurrentCamazotzTracked;                         		// 0x0070 (0x0014) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3109 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_Camazotz_BatOutOfHell::pClassPointer = NULL;

// Class TgGame.TgAchievement_Fenrir_UnleashTheBeast
// 0x0000 (0x0070 - 0x0070)
class UTgAchievement_Fenrir_UnleashTheBeast : public UTgAchievement_DeviceMultiHit_ByType
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3110 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_Fenrir_UnleashTheBeast::pClassPointer = NULL;

// Class TgGame.TgAchievement_MultiDeviceMultiHit_ByType
// 0x0004 (0x0074 - 0x0070)
class UTgAchievement_MultiDeviceMultiHit_ByType : public UTgAchievement_DeviceMultiHit_ByType
{
public:
	int                                                m_nDevice2Id;                                     		// 0x0070 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3111 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_MultiDeviceMultiHit_ByType::pClassPointer = NULL;

// Class TgGame.TgAchievement_Fafnir_TakeThat
// 0x0000 (0x0074 - 0x0074)
class UTgAchievement_Fafnir_TakeThat : public UTgAchievement_MultiDeviceMultiHit_ByType
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3112 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_Fafnir_TakeThat::pClassPointer = NULL;

// Class TgGame.TgAchievement_DeviceOneShot
// 0x0000 (0x004C - 0x004C)
class UTgAchievement_DeviceOneShot : public UTgAchievement
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3113 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_DeviceOneShot::pClassPointer = NULL;

// Class TgGame.TgAchievement_DeviceXHits
// 0x000C (0x0058 - 0x004C)
class UTgAchievement_DeviceXHits : public UTgAchievement
{
public:
	int                                                m_DeviceId;                                       		// 0x004C (0x0004) [0x0000000000000000]              
	int                                                m_GoalAmount;                                     		// 0x0050 (0x0004) [0x0000000000000000]              
	int                                                m_nNumHits;                                       		// 0x0054 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3114 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_DeviceXHits::pClassPointer = NULL;

// Class TgGame.TgAchievement_DeviceXHitsEnemy
// 0x0000 (0x0058 - 0x0058)
class UTgAchievement_DeviceXHitsEnemy : public UTgAchievement_DeviceXHits
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3115 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_DeviceXHitsEnemy::pClassPointer = NULL;

// Class TgGame.TgAchievement_DeviceXHitsWithEffect
// 0x0010 (0x005C - 0x004C)
class UTgAchievement_DeviceXHitsWithEffect : public UTgAchievement
{
public:
	int                                                m_DeviceId;                                       		// 0x004C (0x0004) [0x0000000000000000]              
	int                                                m_GoalAmount;                                     		// 0x0050 (0x0004) [0x0000000000000000]              
	int                                                m_EffectCategory;                                 		// 0x0054 (0x0004) [0x0000000000000000]              
	int                                                m_nNumHits;                                       		// 0x0058 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3116 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_DeviceXHitsWithEffect::pClassPointer = NULL;

// Class TgGame.TgAchievement_DeviceXHitsWithEffect_UniqueGod
// 0x000C (0x0068 - 0x005C)
class UTgAchievement_DeviceXHitsWithEffect_UniqueGod : public UTgAchievement_DeviceXHitsWithEffect
{
public:
	TArray< class ATgPawn* >                           m_HitGods;                                        		// 0x005C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3117 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_DeviceXHitsWithEffect_UniqueGod::pClassPointer = NULL;

// Class TgGame.TgAchievement_Medusa_LookAtMe
// 0x0000 (0x005C - 0x005C)
class UTgAchievement_Medusa_LookAtMe : public UTgAchievement_DeviceXHitsWithEffect
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3118 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_Medusa_LookAtMe::pClassPointer = NULL;

// Class TgGame.TgAchievement_MultiDeviceXHitsWithEffect
// 0x0004 (0x0060 - 0x005C)
class UTgAchievement_MultiDeviceXHitsWithEffect : public UTgAchievement_DeviceXHitsWithEffect
{
public:
	int                                                m_Device2Id;                                      		// 0x005C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3119 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_MultiDeviceXHitsWithEffect::pClassPointer = NULL;

// Class TgGame.TgAchievement_DeviceXKills
// 0x000C (0x0058 - 0x004C)
class UTgAchievement_DeviceXKills : public UTgAchievement
{
public:
	int                                                m_DeviceId;                                       		// 0x004C (0x0004) [0x0000000000000000]              
	int                                                m_KillGoal;                                       		// 0x0050 (0x0004) [0x0000000000000000]              
	int                                                m_nNumKills;                                      		// 0x0054 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3120 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_DeviceXKills::pClassPointer = NULL;

// Class TgGame.TgAchievement_DeviceXKills_BehindWall
// 0x0000 (0x0058 - 0x0058)
class UTgAchievement_DeviceXKills_BehindWall : public UTgAchievement_DeviceXKills
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3121 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_DeviceXKills_BehindWall::pClassPointer = NULL;

// Class TgGame.TgAchievement_DeviceXKillsAtYPercentOrLess
// 0x0004 (0x005C - 0x0058)
class UTgAchievement_DeviceXKillsAtYPercentOrLess : public UTgAchievement_DeviceXKills
{
public:
	int                                                m_HealthPercent;                                  		// 0x0058 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3122 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_DeviceXKillsAtYPercentOrLess::pClassPointer = NULL;

// Class TgGame.TgAchievement_Kali_YouThoughtYouHadMe
// 0x0004 (0x0060 - 0x005C)
class UTgAchievement_Kali_YouThoughtYouHadMe : public UTgAchievement_DeviceXKillsAtYPercentOrLess
{
public:
	unsigned long                                      m_bSuccessfulSetup : 1;                           		// 0x005C (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3123 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_Kali_YouThoughtYouHadMe::pClassPointer = NULL;

// Class TgGame.TgAchievement_MultiDeviceXKills
// 0x0004 (0x005C - 0x0058)
class UTgAchievement_MultiDeviceXKills : public UTgAchievement_DeviceXKills
{
public:
	int                                                m_Device2Id;                                      		// 0x0058 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3124 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_MultiDeviceXKills::pClassPointer = NULL;

// Class TgGame.TgAchievement_DistancePerMatch
// 0x0000 (0x004C - 0x004C)
class UTgAchievement_DistancePerMatch : public UTgAchievement
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3125 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_DistancePerMatch::pClassPointer = NULL;

// Class TgGame.TgAchievement_ErlangShen_Undefeated
// 0x000C (0x0058 - 0x004C)
class UTgAchievement_ErlangShen_Undefeated : public UTgAchievement
{
public:
	int                                                m_nDeviceId;                                      		// 0x004C (0x0004) [0x0000000000000000]              
	int                                                m_nTargetAmount;                                  		// 0x0050 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_nValidStart : 1;                                		// 0x0054 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3126 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_ErlangShen_Undefeated::pClassPointer = NULL;

// Class TgGame.TgAchievement_Fafnir_GetToWork
// 0x0014 (0x0060 - 0x004C)
class UTgAchievement_Fafnir_GetToWork : public UTgAchievement
{
public:
	int                                                m_nDeviceId1;                                     		// 0x004C (0x0004) [0x0000000000000000]              
	int                                                m_nDeviceId2;                                     		// 0x0050 (0x0004) [0x0000000000000000]              
	TArray< class ATgPawn* >                           m_TrackedSaved;                                   		// 0x0054 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3127 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_Fafnir_GetToWork::pClassPointer = NULL;

// Class TgGame.TgAchievement_FamiliarGetsXKills
// 0x0004 (0x0050 - 0x004C)
class UTgAchievement_FamiliarGetsXKills : public UTgAchievement
{
public:
	int                                                m_nKillCount;                                     		// 0x004C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3128 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_FamiliarGetsXKills::pClassPointer = NULL;

// Class TgGame.TgAchievement_FastBlood
// 0x0000 (0x004C - 0x004C)
class UTgAchievement_FastBlood : public UTgAchievement
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3129 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_FastBlood::pClassPointer = NULL;

// Class TgGame.TgAchievement_Fenrir_EndOfDays
// 0x0000 (0x004C - 0x004C)
class UTgAchievement_Fenrir_EndOfDays : public UTgAchievement
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3130 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_Fenrir_EndOfDays::pClassPointer = NULL;

// Class TgGame.TgAchievement_FooledYou
// 0x0000 (0x004C - 0x004C)
class UTgAchievement_FooledYou : public UTgAchievement
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3131 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_FooledYou::pClassPointer = NULL;

// Class TgGame.TgAchievement_Fortitude
// 0x0004 (0x0050 - 0x004C)
class UTgAchievement_Fortitude : public UTgAchievement
{
public:
	int                                                m_nAchievementThreshold;                          		// 0x004C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3132 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_Fortitude::pClassPointer = NULL;

// Class TgGame.TgAchievement_G72_Reflect
// 0x000C (0x0058 - 0x004C)
class UTgAchievement_G72_Reflect : public UTgAchievement
{
public:
	float                                              m_fDuration;                                      		// 0x004C (0x0004) [0x0000000000000000]              
	int                                                m_nDeviceId;                                      		// 0x0050 (0x0004) [0x0000000000000000]              
	float                                              s_fMaxWorldTime;                                  		// 0x0054 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3133 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_G72_Reflect::pClassPointer = NULL;

// Class TgGame.TgAchievement_Geb_IllProtectYou
// 0x0010 (0x005C - 0x004C)
class UTgAchievement_Geb_IllProtectYou : public UTgAchievement
{
public:
	int                                                m_HealthPercent;                                  		// 0x004C (0x0004) [0x0000000000000000]              
	unsigned long                                      m_Successful : 1;                                 		// 0x0050 (0x0004) [0x0000000000000000] [0x00000001] 
	class ATgPawn*                                     m_HitPawn;                                        		// 0x0054 (0x0004) [0x0000000000000000]              
	int                                                m_nDeviceId;                                      		// 0x0058 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3134 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_Geb_IllProtectYou::pClassPointer = NULL;

// Class TgGame.TgAchievement_GetXEffectStacksByYMinutes
// 0x000C (0x0058 - 0x004C)
class UTgAchievement_GetXEffectStacksByYMinutes : public UTgAchievement
{
public:
	int                                                m_nGoalStacks;                                    		// 0x004C (0x0004) [0x0000000000000000]              
	int                                                m_EffectGroupId;                                  		// 0x0050 (0x0004) [0x0000000000000000]              
	int                                                m_nMinutes;                                       		// 0x0054 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3135 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_GetXEffectStacksByYMinutes::pClassPointer = NULL;

// Class TgGame.TgAchievement_GodXKillsAtYPercent
// 0x000C (0x0058 - 0x004C)
class UTgAchievement_GodXKillsAtYPercent : public UTgAchievement
{
public:
	int                                                m_nSuccessCount;                                  		// 0x004C (0x0004) [0x0000000000000000]              
	int                                                m_nTargetGoal;                                    		// 0x0050 (0x0004) [0x0000000000000000]              
	int                                                m_nHealthPercent;                                 		// 0x0054 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3136 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_GodXKillsAtYPercent::pClassPointer = NULL;

// Class TgGame.TgAchievement_GoodGame
// 0x0000 (0x004C - 0x004C)
class UTgAchievement_GoodGame : public UTgAchievement
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3137 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_GoodGame::pClassPointer = NULL;

// Class TgGame.TgAchievement_Hades_Blighted
// 0x0018 (0x0064 - 0x004C)
class UTgAchievement_Hades_Blighted : public UTgAchievement
{
public:
	TArray< int >                                      m_Devices;                                        		// 0x004C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< int >                                      m_Tracking;                                       		// 0x0058 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3138 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_Hades_Blighted::pClassPointer = NULL;

// Class TgGame.TgAchievement_Hades_OhTheAgony
// 0x0010 (0x005C - 0x004C)
class UTgAchievement_Hades_OhTheAgony : public UTgAchievement
{
public:
	TArray< class ATgPawn* >                           m_HitPawns;                                       		// 0x004C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                m_nFiringInstance;                                		// 0x0058 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3139 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_Hades_OhTheAgony::pClassPointer = NULL;

// Class TgGame.TgAchievement_Healer
// 0x0000 (0x004C - 0x004C)
class UTgAchievement_Healer : public UTgAchievement
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3140 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_Healer::pClassPointer = NULL;

// Class TgGame.TgAchievement_Hel_StanceKills
// 0x000C (0x0058 - 0x004C)
class UTgAchievement_Hel_StanceKills : public UTgAchievement
{
public:
	TArray< struct FHelStanceKillTrackingData >        m_TrackingData;                                   		// 0x004C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3141 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_Hel_StanceKills::pClassPointer = NULL;

// Class TgGame.TgAchievement_HelpingHand
// 0x000C (0x0058 - 0x004C)
class UTgAchievement_HelpingHand : public UTgAchievement
{
public:
	TArray< struct FAssistComboData >                  m_CurrentAssistStreaks;                           		// 0x004C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3142 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_HelpingHand::pClassPointer = NULL;

// Class TgGame.TgAchievement_Hercules_Earthbreaker
// 0x0008 (0x0054 - 0x004C)
class UTgAchievement_Hercules_Earthbreaker : public UTgAchievement
{
public:
	int                                                m_GoalAmount;                                     		// 0x004C (0x0004) [0x0000000000000000]              
	int                                                m_nNumHits;                                       		// 0x0050 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3143 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_Hercules_Earthbreaker::pClassPointer = NULL;

// Class TgGame.TgAchievement_Hercules_Ricochet
// 0x0010 (0x005C - 0x004C)
class UTgAchievement_Hercules_Ricochet : public UTgAchievement
{
public:
	TArray< class ATgPawn* >                           m_TrackedSaved;                                   		// 0x004C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                m_nDeviceId;                                      		// 0x0058 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3144 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_Hercules_Ricochet::pClassPointer = NULL;

// Class TgGame.TgAchievement_HouYi_Crow
// 0x0010 (0x005C - 0x004C)
class UTgAchievement_HouYi_Crow : public UTgAchievement
{
public:
	class AActor*                                      m_CrowTarget;                                     		// 0x004C (0x0004) [0x0000000000000000]              
	float                                              m_fLastSlow;                                      		// 0x0050 (0x0004) [0x0000000000000000]              
	float                                              m_fLastKnockUp;                                   		// 0x0054 (0x0004) [0x0000000000000000]              
	float                                              m_fLastStun;                                      		// 0x0058 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3145 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_HouYi_Crow::pClassPointer = NULL;

// Class TgGame.TgAchievement_HouYi_Trick
// 0x000C (0x0058 - 0x004C)
class UTgAchievement_HouYi_Trick : public UTgAchievement
{
public:
	TArray< struct FHitsPerBounce >                    m_SegmentHits;                                    		// 0x004C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3146 );

		return pClassPointer;
	};

	bool UniqueHitPerSegment ( );
};

UClass* UTgAchievement_HouYi_Trick::pClassPointer = NULL;

// Class TgGame.TgAchievement_HunBatz_MonkeyBusiness
// 0x0014 (0x0060 - 0x004C)
class UTgAchievement_HunBatz_MonkeyBusiness : public UTgAchievement
{
public:
	int                                                m_nDeviceId;                                      		// 0x004C (0x0004) [0x0000000000000000]              
	int                                                m_nHitCount;                                      		// 0x0050 (0x0004) [0x0000000000000000]              
	int                                                m_nLastBounceNum;                                 		// 0x0054 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bValidFire : 1;                                 		// 0x0058 (0x0004) [0x0000000000000000] [0x00000001] 
	class ATgPawn*                                     m_pLastHit;                                       		// 0x005C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3147 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_HunBatz_MonkeyBusiness::pClassPointer = NULL;

// Class TgGame.TgAchievement_Isis_StayInTheCircle
// 0x001C (0x0068 - 0x004C)
class UTgAchievement_Isis_StayInTheCircle : public UTgAchievement
{
public:
	TArray< class ATgPawn* >                           m_TrackedSaved;                                   		// 0x004C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                m_nDeviceId;                                      		// 0x0058 (0x0004) [0x0000000000000000]              
	int                                                m_nTargetHealCount;                               		// 0x005C (0x0004) [0x0000000000000000]              
	int                                                m_nTargetKillCount;                               		// 0x0060 (0x0004) [0x0000000000000000]              
	int                                                m_nEarnedKillCount;                               		// 0x0064 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3148 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_Isis_StayInTheCircle::pClassPointer = NULL;

// Class TgGame.TgAchievement_Izanami_WhereYouGoing
// 0x0004 (0x0050 - 0x004C)
class UTgAchievement_Izanami_WhereYouGoing : public UTgAchievement
{
public:
	int                                                m_nDeviceId;                                      		// 0x004C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3149 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_Izanami_WhereYouGoing::pClassPointer = NULL;

// Class TgGame.TgAchievement_JingWei_HeadsUp
// 0x000C (0x0058 - 0x004C)
class UTgAchievement_JingWei_HeadsUp : public UTgAchievement
{
public:
	int                                                m_DeviceId;                                       		// 0x004C (0x0004) [0x0000000000000000]              
	float                                              m_TimeLimit;                                      		// 0x0050 (0x0004) [0x0000000000000000]              
	float                                              m_PassiveStopTime;                                		// 0x0054 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3150 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_JingWei_HeadsUp::pClassPointer = NULL;

// Class TgGame.TgAchievement_JingWei_WaveDash
// 0x0004 (0x0050 - 0x004C)
class UTgAchievement_JingWei_WaveDash : public UTgAchievement
{
public:
	int                                                m_DeviceId;                                       		// 0x004C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3151 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_JingWei_WaveDash::pClassPointer = NULL;

// Class TgGame.TgAchievement_JumpJump
// 0x0000 (0x004C - 0x004C)
class UTgAchievement_JumpJump : public UTgAchievement
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3152 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_JumpJump::pClassPointer = NULL;

// Class TgGame.TgAchievement_Kaboom
// 0x000C (0x0058 - 0x004C)
class UTgAchievement_Kaboom : public UTgAchievement
{
public:
	TArray< struct FDeviceDamageInfo >                 s_CurrentTrackedInfo;                             		// 0x004C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3153 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_Kaboom::pClassPointer = NULL;

// Class TgGame.TgAchievement_Kali_BountyHunter
// 0x000C (0x0058 - 0x004C)
class UTgAchievement_Kali_BountyHunter : public UTgAchievement
{
public:
	int                                                m_nKillCount;                                     		// 0x004C (0x0004) [0x0000000000000000]              
	int                                                m_nTargetGoal;                                    		// 0x0050 (0x0004) [0x0000000000000000]              
	int                                                m_nMarkedId;                                      		// 0x0054 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3154 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_Kali_BountyHunter::pClassPointer = NULL;

// Class TgGame.TgAchievement_KhepriSaveThemAll
// 0x0010 (0x005C - 0x004C)
class UTgAchievement_KhepriSaveThemAll : public UTgAchievement
{
public:
	int                                                m_nDeviceId;                                      		// 0x004C (0x0004) [0x0000000000000000]              
	TArray< class ATgPawn* >                           m_TrackedSaved;                                   		// 0x0050 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3155 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_KhepriSaveThemAll::pClassPointer = NULL;

// Class TgGame.TgAchievement_KillingBlowByBotId
// 0x0000 (0x004C - 0x004C)
class UTgAchievement_KillingBlowByBotId : public UTgAchievement
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3156 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_KillingBlowByBotId::pClassPointer = NULL;

// Class TgGame.TgAchievement_KillingBlowByDeployableId
// 0x0000 (0x004C - 0x004C)
class UTgAchievement_KillingBlowByDeployableId : public UTgAchievement
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3157 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_KillingBlowByDeployableId::pClassPointer = NULL;

// Class TgGame.TgAchievement_KillsSingleAbility
// 0x000C (0x0058 - 0x004C)
class UTgAchievement_KillsSingleAbility : public UTgAchievement
{
public:
	TArray< struct FDeviceKillsInfo >                  s_CurrentTrackedInfo;                             		// 0x004C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3158 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_KillsSingleAbility::pClassPointer = NULL;

// Class TgGame.TgAchievement_KillXWhileTheyAreUnderEffectY
// 0x0010 (0x005C - 0x004C)
class UTgAchievement_KillXWhileTheyAreUnderEffectY : public UTgAchievement
{
public:
	int                                                m_nKillCount;                                     		// 0x004C (0x0004) [0x0000000000000000]              
	int                                                m_nKillGoal;                                      		// 0x0050 (0x0004) [0x0000000000000000]              
	int                                                m_EffectGroupCat;                                 		// 0x0054 (0x0004) [0x0000000000000000]              
	int                                                m_DeviceId;                                       		// 0x0058 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3159 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_KillXWhileTheyAreUnderEffectY::pClassPointer = NULL;

// Class TgGame.TgAchievement_Kumbhakarna_DownSetGut
// 0x0010 (0x005C - 0x004C)
class UTgAchievement_Kumbhakarna_DownSetGut : public UTgAchievement
{
public:
	int                                                m_nSuccessCount;                                  		// 0x004C (0x0004) [0x0000000000000000]              
	int                                                m_nTargetGoal;                                    		// 0x0050 (0x0004) [0x0000000000000000]              
	int                                                m_nDeviceId;                                      		// 0x0054 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bValidThrow : 1;                                		// 0x0058 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3160 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_Kumbhakarna_DownSetGut::pClassPointer = NULL;

// Class TgGame.TgAchievement_LastHit
// 0x0004 (0x0050 - 0x004C)
class UTgAchievement_LastHit : public UTgAchievement
{
public:
	int                                                m_nLastHitCount;                                  		// 0x004C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3161 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_LastHit::pClassPointer = NULL;

// Class TgGame.TgAchievement_LineThemUp
// 0x000C (0x0058 - 0x004C)
class UTgAchievement_LineThemUp : public UTgAchievement
{
public:
	TArray< struct FDeviceHitInfo >                    s_CurrentTrackedInfo;                             		// 0x004C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3162 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_LineThemUp::pClassPointer = NULL;

// Class TgGame.TgAchievement_Loki_MadeYouLook
// 0x000C (0x0058 - 0x004C)
class UTgAchievement_Loki_MadeYouLook : public UTgAchievement
{
public:
	TArray< int >                                      m_DecoyDeviceIds;                                 		// 0x004C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3163 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_Loki_MadeYouLook::pClassPointer = NULL;

// Class TgGame.TgAchievement_MaintainEnergy
// 0x0010 (0x005C - 0x004C)
class UTgAchievement_MaintainEnergy : public UTgAchievement
{
public:
	float                                              m_fDuration;                                      		// 0x004C (0x0004) [0x0000000000000000]              
	float                                              m_fMinWorldTime;                                  		// 0x0050 (0x0004) [0x0000000000000000]              
	float                                              m_fMinEnergy;                                     		// 0x0054 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bIsMaintained : 1;                              		// 0x0058 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3164 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_MaintainEnergy::pClassPointer = NULL;

// Class TgGame.TgAchievement_MaintainStacks
// 0x001C (0x0068 - 0x004C)
class UTgAchievement_MaintainStacks : public UTgAchievement
{
public:
	float                                              m_fDuration;                                      		// 0x004C (0x0004) [0x0000000000000000]              
	float                                              m_fMinWorldTime;                                  		// 0x0050 (0x0004) [0x0000000000000000]              
	int                                                m_nMinStacks;                                     		// 0x0054 (0x0004) [0x0000000000000000]              
	int                                                m_nDeviceId;                                      		// 0x0058 (0x0004) [0x0000000000000000]              
	int                                                m_nCategoryCode;                                  		// 0x005C (0x0004) [0x0000000000000000]              
	int                                                m_nHitType;                                       		// 0x0060 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bIsMaintained : 1;                              		// 0x0064 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3165 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_MaintainStacks::pClassPointer = NULL;

// Class TgGame.TgAchievement_MatchHealingByGod
// 0x0004 (0x0050 - 0x004C)
class UTgAchievement_MatchHealingByGod : public UTgAchievement
{
public:
	int                                                m_nTargetMatchHealing;                            		// 0x004C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3166 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_MatchHealingByGod::pClassPointer = NULL;

// Class TgGame.TgAchievement_MatchKillsByDevice
// 0x0008 (0x0054 - 0x004C)
class UTgAchievement_MatchKillsByDevice : public UTgAchievement
{
public:
	int                                                m_nNumKills;                                      		// 0x004C (0x0004) [0x0000000000000000]              
	int                                                m_nDeviceId;                                      		// 0x0050 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3167 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_MatchKillsByDevice::pClassPointer = NULL;

// Class TgGame.TgAchievement_MatchMovementSpeed
// 0x0000 (0x004C - 0x004C)
class UTgAchievement_MatchMovementSpeed : public UTgAchievement
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3168 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_MatchMovementSpeed::pClassPointer = NULL;

// Class TgGame.TgAchievement_MaxedOutAttackSpeed
// 0x0004 (0x0050 - 0x004C)
class UTgAchievement_MaxedOutAttackSpeed : public UTgAchievement
{
public:
	unsigned long                                      m_bMaxAttackSpeedReached : 1;                     		// 0x004C (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3169 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_MaxedOutAttackSpeed::pClassPointer = NULL;

// Class TgGame.TgAchievement_MonsterHunter
// 0x0010 (0x005C - 0x004C)
class UTgAchievement_MonsterHunter : public UTgAchievement
{
public:
	TArray< int >                                      m_nUniqueKilledIds;                               		// 0x004C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                m_nAchievementValue;                              		// 0x0058 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3170 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_MonsterHunter::pClassPointer = NULL;

// Class TgGame.TgAchievement_MonsterMadness
// 0x0010 (0x005C - 0x004C)
class UTgAchievement_MonsterMadness : public UTgAchievement
{
public:
	TArray< int >                                      m_nUniqueKilledIds;                               		// 0x004C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                m_nAchievementValue;                              		// 0x0058 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3171 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_MonsterMadness::pClassPointer = NULL;

// Class TgGame.TgAchievement_Nemesis_Prots
// 0x0010 (0x005C - 0x004C)
class UTgAchievement_Nemesis_Prots : public UTgAchievement
{
public:
	int                                                m_FiringInstance;                                 		// 0x004C (0x0004) [0x0000000000000000]              
	int                                                m_ProtectionStolen;                               		// 0x0050 (0x0004) [0x0000000000000000]              
	int                                                m_GoalAmount;                                     		// 0x0054 (0x0004) [0x0000000000000000]              
	int                                                m_DeviceId;                                       		// 0x0058 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3172 );

		return pClassPointer;
	};

	float eventGetProtectionsStolen ( class ATgPawn_Nemesis* Nemesis );
};

UClass* UTgAchievement_Nemesis_Prots::pClassPointer = NULL;

// Class TgGame.TgAchievement_NeZha_TwosACrowd
// 0x0018 (0x0064 - 0x004C)
class UTgAchievement_NeZha_TwosACrowd : public UTgAchievement
{
public:
	TArray< struct FBounceData >                       m_TrackedData;                                    		// 0x004C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                m_nTargetPawnCount;                               		// 0x0058 (0x0004) [0x0000000000000000]              
	int                                                m_nTargetHitCount;                                		// 0x005C (0x0004) [0x0000000000000000]              
	int                                                m_nDeviceId;                                      		// 0x0060 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3173 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_NeZha_TwosACrowd::pClassPointer = NULL;

// Class TgGame.TgAchievement_NeZha_WatchThis
// 0x0014 (0x0060 - 0x004C)
class UTgAchievement_NeZha_WatchThis : public UTgAchievement
{
public:
	class ATgPawn*                                     m_TargetGod;                                      		// 0x004C (0x0004) [0x0000000000000000]              
	int                                                m_nTimeLimit;                                     		// 0x0050 (0x0004) [0x0000000000000000]              
	int                                                m_nTimeStamp;                                     		// 0x0054 (0x0004) [0x0000000000000000]              
	int                                                m_nDeviceId;                                      		// 0x0058 (0x0004) [0x0000000000000000]              
	int                                                m_nDevice2Id;                                     		// 0x005C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3174 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_NeZha_WatchThis::pClassPointer = NULL;

// Class TgGame.TgAchievement_Nike_PathToVictory
// 0x0010 (0x005C - 0x004C)
class UTgAchievement_Nike_PathToVictory : public UTgAchievement
{
public:
	unsigned long                                      m_bFilledPassive : 1;                             		// 0x004C (0x0004) [0x0000000000000000] [0x00000001] 
	class ATgPawn_Nike*                                NikeOwner;                                        		// 0x0050 (0x0004) [0x0000000000000000]              
	int                                                m_EffectGroupId;                                  		// 0x0054 (0x0004) [0x0000000000000000]              
	int                                                m_nMinutes;                                       		// 0x0058 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3175 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_Nike_PathToVictory::pClassPointer = NULL;

// Class TgGame.TgAchievement_NoEscape
// 0x0000 (0x004C - 0x004C)
class UTgAchievement_NoEscape : public UTgAchievement
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3176 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_NoEscape::pClassPointer = NULL;

// Class TgGame.TgAchievement_Nox_EmbraceTheDarkness
// 0x0020 (0x006C - 0x004C)
class UTgAchievement_Nox_EmbraceTheDarkness : public UTgAchievement
{
public:
	int                                                m_nSiphonDarkDeviceId;                            		// 0x004C (0x0004) [0x0000000000000000]              
	int                                                m_nShadowLockDeviceId;                            		// 0x0050 (0x0004) [0x0000000000000000]              
	int                                                m_nKillGoal;                                      		// 0x0054 (0x0004) [0x0000000000000000]              
	int                                                m_nComboKills;                                    		// 0x0058 (0x0004) [0x0000000000000000]              
	TArray< class ATgPawn* >                           m_SiphonTargets;                                  		// 0x005C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class ATgPawn*                                     m_ComboTarget;                                    		// 0x0068 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3177 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_Nox_EmbraceTheDarkness::pClassPointer = NULL;

// Class TgGame.TgAchievement_ObjectiveHunter
// 0x0004 (0x0050 - 0x004C)
class UTgAchievement_ObjectiveHunter : public UTgAchievement
{
public:
	unsigned long                                      m_bKilledFireGiant : 1;                           		// 0x004C (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bKilledGoldFury : 1;                            		// 0x004C (0x0004) [0x0000000000000000] [0x00000002] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3178 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_ObjectiveHunter::pClassPointer = NULL;

// Class TgGame.TgAchievement_ObjectiveSteal
// 0x0008 (0x0054 - 0x004C)
class UTgAchievement_ObjectiveSteal : public UTgAchievement
{
public:
	int                                                m_nDeviceId;                                      		// 0x004C (0x0004) [0x0000000000000000]              
	int                                                m_nHitBotId;                                      		// 0x0050 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3179 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_ObjectiveSteal::pClassPointer = NULL;

// Class TgGame.TgAchievement_ObjectiveSteal_FireGiant
// 0x0000 (0x0054 - 0x0054)
class UTgAchievement_ObjectiveSteal_FireGiant : public UTgAchievement_ObjectiveSteal
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3180 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_ObjectiveSteal_FireGiant::pClassPointer = NULL;

// Class TgGame.TgAchievement_Odin_CageMatch
// 0x0008 (0x0054 - 0x004C)
class UTgAchievement_Odin_CageMatch : public UTgAchievement
{
public:
	int                                                m_nSuccessCount;                                  		// 0x004C (0x0004) [0x0000000000000000]              
	int                                                m_nTargetGoal;                                    		// 0x0050 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3181 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_Odin_CageMatch::pClassPointer = NULL;

// Class TgGame.TgAchievement_OnEffectApplied
// 0x001C (0x0068 - 0x004C)
class UTgAchievement_OnEffectApplied : public UTgAchievement
{
public:
	unsigned long                                      m_bUseIgnoreList : 1;                             		// 0x004C (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bAllowRemoveable : 1;                           		// 0x004C (0x0004) [0x0000000000000000] [0x00000002] 
	TArray< int >                                      m_ExtraPropertyIds;                               		// 0x0050 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class AActor* >                            m_IgnoreList;                                     		// 0x005C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3182 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_OnEffectApplied::pClassPointer = NULL;

// Class TgGame.TgAchievement_Plucked
// 0x000C (0x0074 - 0x0068)
class UTgAchievement_Plucked : public UTgAchievement_OnEffectApplied
{
public:
	TArray< class AActor* >                            m_TrackingActors;                                 		// 0x0068 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3183 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_Plucked::pClassPointer = NULL;

// Class TgGame.TgAchievement_UpYouGo
// 0x0000 (0x0068 - 0x0068)
class UTgAchievement_UpYouGo : public UTgAchievement_OnEffectApplied
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3184 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_UpYouGo::pClassPointer = NULL;

// Class TgGame.TgAchievement_WrappedUp
// 0x0010 (0x0078 - 0x0068)
class UTgAchievement_WrappedUp : public UTgAchievement_OnEffectApplied
{
public:
	TArray< int >                                      s_PawnsAlreadyHit;                                		// 0x0068 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                s_nHitsToAchieve;                                 		// 0x0074 (0x0004) [0x0000000000000002]              ( CPF_Const )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3185 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_WrappedUp::pClassPointer = NULL;

// Class TgGame.TgAchievement_Perfect
// 0x0000 (0x004C - 0x004C)
class UTgAchievement_Perfect : public UTgAchievement
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3186 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_Perfect::pClassPointer = NULL;

// Class TgGame.TgAchievement_PreciseShot
// 0x0004 (0x0050 - 0x004C)
class UTgAchievement_PreciseShot : public UTgAchievement
{
public:
	unsigned long                                      m_bLastKillPassedTest : 1;                        		// 0x004C (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bAchievedAtLeastOnce : 1;                       		// 0x004C (0x0004) [0x0000000000000000] [0x00000002] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3187 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_PreciseShot::pClassPointer = NULL;

// Class TgGame.TgAchievement_Push
// 0x0004 (0x0050 - 0x004C)
class UTgAchievement_Push : public UTgAchievement
{
public:
	int                                                m_nMinionsPushed;                                 		// 0x004C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3188 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_Push::pClassPointer = NULL;

// Class TgGame.TgAchievement_QuestionsLater
// 0x0010 (0x005C - 0x004C)
class UTgAchievement_QuestionsLater : public UTgAchievement
{
public:
	unsigned long                                      m_bAchievementValid : 1;                          		// 0x004C (0x0004) [0x0000000000000000] [0x00000001] 
	TArray< int >                                      m_nUniqueDamagedPlayers;                          		// 0x0050 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3189 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_QuestionsLater::pClassPointer = NULL;

// Class TgGame.TgAchievement_Rama_Ouch
// 0x000C (0x0058 - 0x004C)
class UTgAchievement_Rama_Ouch : public UTgAchievement
{
public:
	TArray< class ATgPawn* >                           m_CrippledEnemies;                                		// 0x004C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3190 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_Rama_Ouch::pClassPointer = NULL;

// Class TgGame.TgAchievement_Rama_Pro
// 0x0008 (0x0054 - 0x004C)
class UTgAchievement_Rama_Pro : public UTgAchievement
{
public:
	int                                                m_nKillsDuringUlt;                                		// 0x004C (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bUltActive : 1;                                 		// 0x0050 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3191 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_Rama_Pro::pClassPointer = NULL;

// Class TgGame.TgAchievement_Scylla_YesImAMonster
// 0x0014 (0x0060 - 0x004C)
class UTgAchievement_Scylla_YesImAMonster : public UTgAchievement
{
public:
	int                                                m_DeviceId;                                       		// 0x004C (0x0004) [0x0000000000000000]              
	int                                                m_GoalAmount;                                     		// 0x0050 (0x0004) [0x0000000000000000]              
	int                                                m_nNumResets;                                     		// 0x0054 (0x0004) [0x0000000000000000]              
	int                                                m_nLastKillInstance;                              		// 0x0058 (0x0004) [0x0000000000000000]              
	float                                              m_fLastKillTime;                                  		// 0x005C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3192 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_Scylla_YesImAMonster::pClassPointer = NULL;

// Class TgGame.TgAchievement_Serqet_Critalicious
// 0x0010 (0x005C - 0x004C)
class UTgAchievement_Serqet_Critalicious : public UTgAchievement
{
public:
	int                                                m_nDeviceId;                                      		// 0x004C (0x0004) [0x0000000000000000]              
	int                                                m_nFiringInstance;                                		// 0x0050 (0x0004) [0x0000000000000000]              
	int                                                m_nStrikesWithCrits;                              		// 0x0054 (0x0004) [0x0000000000000000]              
	int                                                m_nTrackedStrike;                                 		// 0x0058 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3193 );

		return pClassPointer;
	};

	int eventGetDeathbaneChargeNum ( class ATgDevice* Dev );
};

UClass* UTgAchievement_Serqet_Critalicious::pClassPointer = NULL;

// Class TgGame.TgAchievement_Serqet_ItsSpreading
// 0x0010 (0x005C - 0x004C)
class UTgAchievement_Serqet_ItsSpreading : public UTgAchievement
{
public:
	int                                                m_nSpreadCount;                                   		// 0x004C (0x0004) [0x0000000000000000]              
	int                                                m_nTargetGoal;                                    		// 0x0050 (0x0004) [0x0000000000000000]              
	int                                                m_nDeviceId;                                      		// 0x0054 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_nValidSpread : 1;                               		// 0x0058 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3194 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_Serqet_ItsSpreading::pClassPointer = NULL;

// Class TgGame.TgAchievement_Sobek_ArentYouATank
// 0x0020 (0x006C - 0x004C)
class UTgAchievement_Sobek_ArentYouATank : public UTgAchievement
{
public:
	TArray< int >                                      m_nDevices;                                       		// 0x004C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< int >                                      m_nTracking;                                      		// 0x0058 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	float                                              m_fDuration;                                      		// 0x0064 (0x0004) [0x0000000000000000]              
	float                                              m_fMinWorldTime;                                  		// 0x0068 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3195 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_Sobek_ArentYouATank::pClassPointer = NULL;

// Class TgGame.TgAchievement_Survivor
// 0x0000 (0x004C - 0x004C)
class UTgAchievement_Survivor : public UTgAchievement
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3196 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_Survivor::pClassPointer = NULL;

// Class TgGame.TgAchievement_Susano_WeatherTheStorm
// 0x0000 (0x004C - 0x004C)
class UTgAchievement_Susano_WeatherTheStorm : public UTgAchievement
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3197 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_Susano_WeatherTheStorm::pClassPointer = NULL;

// Class TgGame.TgAchievement_TagMatchCountGodKill
// 0x0004 (0x0050 - 0x004C)
class UTgAchievement_TagMatchCountGodKill : public UTgAchievement
{
public:
	unsigned long                                      m_bTagMatches : 1;                                		// 0x004C (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3198 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_TagMatchCountGodKill::pClassPointer = NULL;

// Class TgGame.TgAchievement_UseYourFists
// 0x0000 (0x0050 - 0x0050)
class UTgAchievement_UseYourFists : public UTgAchievement_TagMatchCountGodKill
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3199 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_UseYourFists::pClassPointer = NULL;

// Class TgGame.TgAchievement_Thana_Silence
// 0x0000 (0x004C - 0x004C)
class UTgAchievement_Thana_Silence : public UTgAchievement
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3200 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_Thana_Silence::pClassPointer = NULL;

// Class TgGame.TgAchievement_Thoth_WallOfDeath
// 0x0010 (0x005C - 0x004C)
class UTgAchievement_Thoth_WallOfDeath : public UTgAchievement
{
public:
	int                                                m_nWallDeployableId;                              		// 0x004C (0x0004) [0x0000000000000000]              
	int                                                m_nHitObjectiveId;                                		// 0x0050 (0x0004) [0x0000000000000000]              
	int                                                m_nLastTeammateId;                                		// 0x0054 (0x0004) [0x0000000000000000]              
	int                                                m_nTeammateCount;                                 		// 0x0058 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3201 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_Thoth_WallOfDeath::pClassPointer = NULL;

// Class TgGame.TgAchievement_Tyr_ILikeToJuggle
// 0x0020 (0x006C - 0x004C)
class UTgAchievement_Tyr_ILikeToJuggle : public UTgAchievement
{
public:
	TArray< class ATgPawn* >                           m_TrackedSaved;                                   		// 0x004C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                m_nDeviceId;                                      		// 0x0058 (0x0004) [0x0000000000000000]              
	int                                                m_nDevice2Id;                                     		// 0x005C (0x0004) [0x0000000000000000]              
	int                                                m_nFearlessId;                                    		// 0x0060 (0x0004) [0x0000000000000000]              
	int                                                m_nTargetCount;                                   		// 0x0064 (0x0004) [0x0000000000000000]              
	int                                                m_nSuccessCount;                                  		// 0x0068 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3202 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_Tyr_ILikeToJuggle::pClassPointer = NULL;

// Class TgGame.TgAchievement_Vamana_BabySmash
// 0x0010 (0x005C - 0x004C)
class UTgAchievement_Vamana_BabySmash : public UTgAchievement
{
public:
	int                                                m_nTargetKills;                                   		// 0x004C (0x0004) [0x0000000000000000]              
	int                                                m_nDeviceId;                                      		// 0x0050 (0x0004) [0x0000000000000000]              
	int                                                m_nKillCount;                                     		// 0x0054 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bValidStart : 1;                                		// 0x0058 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3203 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_Vamana_BabySmash::pClassPointer = NULL;

// Class TgGame.TgAchievement_WhatAHog
// 0x0000 (0x004C - 0x004C)
class UTgAchievement_WhatAHog : public UTgAchievement
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3204 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_WhatAHog::pClassPointer = NULL;

// Class TgGame.TgAchievement_Zeus_WatchItBounce
// 0x0008 (0x0054 - 0x004C)
class UTgAchievement_Zeus_WatchItBounce : public UTgAchievement
{
public:
	int                                                m_DeviceId;                                       		// 0x004C (0x0004) [0x0000000000000000]              
	int                                                m_BounceGoal;                                     		// 0x0050 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3205 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_Zeus_WatchItBounce::pClassPointer = NULL;

// Class TgGame.TgFadingSpeedTreeActor
// 0x002C (0x0220 - 0x01F4)
class ATgFadingSpeedTreeActor : public ASpeedTreeActor
{
public:
	unsigned long                                      m_bFaded : 1;                                     		// 0x01F4 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	unsigned long                                      bShowFadedInEditor : 1;                           		// 0x01F4 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	float                                              m_fFadeProgress;                                  		// 0x01F8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              FadeOutTime;                                      		// 0x01FC (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	float                                              FadeInTime;                                       		// 0x0200 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	class UMaterialInterface*                          FadingBranch1Material;                            		// 0x0204 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	class UMaterialInterface*                          FadingBranch2Material;                            		// 0x0208 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	class UMaterialInterface*                          FadingFrondMaterial;                              		// 0x020C (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	class UMaterialInterface*                          FadingLeafCardMaterial;                           		// 0x0210 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	class UMaterialInterface*                          FadingLeafMeshMaterial;                           		// 0x0214 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	class UMaterialInterface*                          FadingBillboardMaterial;                          		// 0x0218 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	class USpeedTreeComponent*                         m_FadingSpeedTreeComponent;                       		// 0x021C (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 3206 );

		return pClassPointer;
	};

	void SetFading ( unsigned long bShouldBeFaded, unsigned long bImmediate );
	void UpdateFadeStatus ( float DeltaTime );
};

UClass* ATgFadingSpeedTreeActor::pClassPointer = NULL;

// Class TgGame.TgAchievement_AbilityMultiHit_SingleDevice
// 0x0000 (0x0070 - 0x0070)
class UTgAchievement_AbilityMultiHit_SingleDevice : public UTgAchievement_AbilityMultiHit
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 44162 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_AbilityMultiHit_SingleDevice::pClassPointer = NULL;

// Class TgGame.TgAchievement_Freeze
// 0x0000 (0x0068 - 0x0068)
class UTgAchievement_Freeze : public UTgAchievement_OnEffectApplied
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 44323 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_Freeze::pClassPointer = NULL;

// Class TgGame.TgAchievement_GuanYu_Charge
// 0x0000 (0x0070 - 0x0070)
class UTgAchievement_GuanYu_Charge : public UTgAchievement_AbilityMultiHit_SingleDeviceSingleEffect
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 44338 );

		return pClassPointer;
	};

};

UClass* UTgAchievement_GuanYu_Charge::pClassPointer = NULL;

// Class TgGame.TgDevice_Nemesis_Num4
// 0x0008 (0x038C - 0x0384)
class ATgDevice_Nemesis_Num4 : public ATgDevice_GroundTarget_LockOn
{
public:
	float                                              m_fPhysicalProtectionToAdd;                       		// 0x0384 (0x0004) [0x0000000000000000]              
	float                                              m_fMagicalProtectionToAdd;                        		// 0x0388 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 44458 );

		return pClassPointer;
	};

	bool eventCanBeCanceled ( );
	bool eventCanBeInterrupted ( );
};

UClass* ATgDevice_Nemesis_Num4::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorAction_AssignLane
// 0x0004 (0x0068 - 0x0064)
class UTgAIBehaviorAction_AssignLane : public UTgAIBehaviorAction
{
public:
	int                                                LaneIndex;                                        		// 0x0064 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 45063 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorAction_AssignLane::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorAction_CancelFiring
// 0x0000 (0x0064 - 0x0064)
class UTgAIBehaviorAction_CancelFiring : public UTgAIBehaviorAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 45066 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorAction_CancelFiring::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorAction_ClearCombatTarget
// 0x0000 (0x0064 - 0x0064)
class UTgAIBehaviorAction_ClearCombatTarget : public UTgAIBehaviorAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 45068 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorAction_ClearCombatTarget::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorAction_ClearLaneMoveTarget
// 0x0000 (0x0064 - 0x0064)
class UTgAIBehaviorAction_ClearLaneMoveTarget : public UTgAIBehaviorAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 45070 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorAction_ClearLaneMoveTarget::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorAction_ClearLastAttacker
// 0x0000 (0x0064 - 0x0064)
class UTgAIBehaviorAction_ClearLastAttacker : public UTgAIBehaviorAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 45072 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorAction_ClearLastAttacker::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorAction_ClearLookAtTarget
// 0x0000 (0x0064 - 0x0064)
class UTgAIBehaviorAction_ClearLookAtTarget : public UTgAIBehaviorAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 45074 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorAction_ClearLookAtTarget::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorAction_ClearNavigationQueue
// 0x0000 (0x0064 - 0x0064)
class UTgAIBehaviorAction_ClearNavigationQueue : public UTgAIBehaviorAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 45076 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorAction_ClearNavigationQueue::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorAction_ClearRallyPoint
// 0x0000 (0x0064 - 0x0064)
class UTgAIBehaviorAction_ClearRallyPoint : public UTgAIBehaviorAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 45078 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorAction_ClearRallyPoint::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorAction_ClearSpreadLocation
// 0x0000 (0x0064 - 0x0064)
class UTgAIBehaviorAction_ClearSpreadLocation : public UTgAIBehaviorAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 45080 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorAction_ClearSpreadLocation::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorAction_MoveBase
// 0x0008 (0x006C - 0x0064)
class UTgAIBehaviorAction_MoveBase : public UTgAIBehaviorAction
{
public:
	unsigned long                                      bSubtractPawnRadius : 1;                          		// 0x0064 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      bSubtractTargetPawnRadius : 1;                    		// 0x0064 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      bLookAtTarget : 1;                                		// 0x0064 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      bMustHaveLOS : 1;                                 		// 0x0064 (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )
	float                                              MoveTolerance;                                    		// 0x0068 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 45082 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorAction_MoveBase::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorAction_MoveToTarget
// 0x0000 (0x006C - 0x006C)
class UTgAIBehaviorAction_MoveToTarget : public UTgAIBehaviorAction_MoveBase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 45089 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorAction_MoveToTarget::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorAction_FollowCombatTarget
// 0x0001 (0x006D - 0x006C)
class UTgAIBehaviorAction_FollowCombatTarget : public UTgAIBehaviorAction_MoveToTarget
{
public:
	unsigned char                                      DeviceSlot;                                       		// 0x006C (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 45091 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorAction_FollowCombatTarget::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorAction_FollowLane
// 0x0004 (0x0068 - 0x0064)
class UTgAIBehaviorAction_FollowLane : public UTgAIBehaviorAction
{
public:
	unsigned long                                      bUseReverseDirection : 1;                         		// 0x0064 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 45094 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorAction_FollowLane::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorAction_FollowPatrol
// 0x0000 (0x0064 - 0x0064)
class UTgAIBehaviorAction_FollowPatrol : public UTgAIBehaviorAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 45097 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorAction_FollowPatrol::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorAction_Juke
// 0x0000 (0x0064 - 0x0064)
class UTgAIBehaviorAction_Juke : public UTgAIBehaviorAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 45099 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorAction_Juke::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorAction_Leash
// 0x0000 (0x0064 - 0x0064)
class UTgAIBehaviorAction_Leash : public UTgAIBehaviorAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 45101 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorAction_Leash::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorAction_LookAtCombatTarget
// 0x0000 (0x0064 - 0x0064)
class UTgAIBehaviorAction_LookAtCombatTarget : public UTgAIBehaviorAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 45103 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorAction_LookAtCombatTarget::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorAction_LookAtSpawnRotation
// 0x0000 (0x0064 - 0x0064)
class UTgAIBehaviorAction_LookAtSpawnRotation : public UTgAIBehaviorAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 45105 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorAction_LookAtSpawnRotation::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorAction_MoveToLaneTarget
// 0x0000 (0x006C - 0x006C)
class UTgAIBehaviorAction_MoveToLaneTarget : public UTgAIBehaviorAction_MoveToTarget
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 45107 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorAction_MoveToLaneTarget::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorAction_MoveToLaneVolume
// 0x0004 (0x0070 - 0x006C)
class UTgAIBehaviorAction_MoveToLaneVolume : public UTgAIBehaviorAction_MoveToTarget
{
public:
	unsigned long                                      bMustBeSameLane : 1;                              		// 0x006C (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 45109 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorAction_MoveToLaneVolume::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorAction_MoveToRallyPoint
// 0x0008 (0x0074 - 0x006C)
class UTgAIBehaviorAction_MoveToRallyPoint : public UTgAIBehaviorAction_MoveToTarget
{
public:
	float                                              fMaximumDistanceToRallyPoint;                     		// 0x006C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      bMustBeSameLane : 1;                              		// 0x0070 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      bMustBeSameTaskforce : 1;                         		// 0x0070 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 45112 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorAction_MoveToRallyPoint::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorAction_PauseAI
// 0x0000 (0x0064 - 0x0064)
class UTgAIBehaviorAction_PauseAI : public UTgAIBehaviorAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 45117 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorAction_PauseAI::pClassPointer = NULL;

// Class TgGame.TgSeqAct_GetTeamIndex
// 0x0000 (0x00C4 - 0x00C4)
class UTgSeqAct_GetTeamIndex : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 46387 );

		return pClassPointer;
	};

};

UClass* UTgSeqAct_GetTeamIndex::pClassPointer = NULL;

// Class TgGame.TgSeqAct_GetTaskForceNumber
// 0x0000 (0x00C4 - 0x00C4)
class UTgSeqAct_GetTaskForceNumber : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 46391 );

		return pClassPointer;
	};

};

UClass* UTgSeqAct_GetTaskForceNumber::pClassPointer = NULL;

// Class TgGame.TgSeqAct_SetTaskforce
// 0x0004 (0x00C8 - 0x00C4)
class UTgSeqAct_SetTaskforce : public USequenceAction
{
public:
	int                                                TaskForceNumber;                                  		// 0x00C4 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 46394 );

		return pClassPointer;
	};

};

UClass* UTgSeqAct_SetTaskforce::pClassPointer = NULL;

// Class TgGame.TgSeqAct_KillBots
// 0x0000 (0x00C4 - 0x00C4)
class UTgSeqAct_KillBots : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 46425 );

		return pClassPointer;
	};

};

UClass* UTgSeqAct_KillBots::pClassPointer = NULL;

// Class TgGame.TgSeqAct_Killpawns
// 0x0000 (0x00C4 - 0x00C4)
class UTgSeqAct_Killpawns : public UTgSeqAct_KillBots
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 46424 );

		return pClassPointer;
	};

};

UClass* UTgSeqAct_Killpawns::pClassPointer = NULL;

// Class TgGame.TgSeqAct_DoDamageToPawn
// 0x0008 (0x00CC - 0x00C4)
class UTgSeqAct_DoDamageToPawn : public USequenceAction
{
public:
	unsigned long                                      IsPercentDamage : 1;                              		// 0x00C4 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      DoNotKill : 1;                                    		// 0x00C4 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	int                                                Damage;                                           		// 0x00C8 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 46432 );

		return pClassPointer;
	};

};

UClass* UTgSeqAct_DoDamageToPawn::pClassPointer = NULL;

// Class TgGame.TgSeqAct_DespawnBots
// 0x0000 (0x00C4 - 0x00C4)
class UTgSeqAct_DespawnBots : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 46439 );

		return pClassPointer;
	};

};

UClass* UTgSeqAct_DespawnBots::pClassPointer = NULL;

// Class TgGame.TgSeqAct_ResetCooldown
// 0x0001 (0x00C5 - 0x00C4)
class UTgSeqAct_ResetCooldown : public USequenceAction
{
public:
	unsigned char                                      m_eEquipPoint;                                    		// 0x00C4 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 46444 );

		return pClassPointer;
	};

};

UClass* UTgSeqAct_ResetCooldown::pClassPointer = NULL;

// Class TgGame.TgAnimBlendByFireMode
// 0x0000 (0x011C - 0x011C)
class UTgAnimBlendByFireMode : public UTgAnimNodeBlendList
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 46511 );

		return pClassPointer;
	};

	void SelectFireMode ( int FireMode );
};

UClass* UTgAnimBlendByFireMode::pClassPointer = NULL;

// Class TgGame.TgSeqAct_JoinTeam
// 0x0004 (0x00C8 - 0x00C4)
class UTgSeqAct_JoinTeam : public USequenceAction
{
public:
	class AActor*                                      TeamLeader;                                       		// 0x00C4 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 46556 );

		return pClassPointer;
	};

};

UClass* UTgSeqAct_JoinTeam::pClassPointer = NULL;

// Class TgGame.TgControlModule
// 0x0008 (0x0044 - 0x003C)
class UTgControlModule : public UObject
{
public:
	class ATgPlayerController*                         Controller;                                       		// 0x003C (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bIsActive : 1;                                  		// 0x0040 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 46632 );

		return pClassPointer;
	};

	bool InterceptRawKey ( int ControllerId, struct FName Key, unsigned char Event, float AmountDepressed );
	bool InterceptFlashInput ( struct FName ButtonName, unsigned char Event );
	void AdjustAimingView ( struct FVector* ViewLocation, struct FRotator* ViewRotation );
	void OnRightMouseReleased ( );
	void OnRightMousePressed ( );
	void UpdateRotation ( float DeltaTime );
	void PlayerMove ( float DeltaTime );
	void ProcessMove ( float DeltaTime, struct FVector newAccel, unsigned char DoubleClickMove, struct FRotator DeltaRot );
	struct FRotator GetBaseAimRotation ( class AWeapon* W, unsigned long bIgnoreAutoLock );
	void OnSettingsChanged ( class UTgClientSettings* Settings );
	void OnBecomeInActive ( class UTgControlModule* NewModule );
	void OnBecomeActive ( class UTgControlModule* OldModule );
	void Init ( );
};

UClass* UTgControlModule::pClassPointer = NULL;

// Class TgGame.TgControlModule_ThirdPerson
// 0x0058 (0x009C - 0x0044)
class UTgControlModule_ThirdPerson : public UTgControlModule
{
public:
	int                                                CameraYawOffset;                                  		// 0x0044 (0x0004) [0x0000000000000000]              
	float                                              fRotInterpSpeed;                                  		// 0x0048 (0x0004) [0x0000000000000000]              
	struct FVector2D                                   vIntoxicatedRotError;                             		// 0x004C (0x0008) [0x0000000000000000]              
	float                                              fAimPitch;                                        		// 0x0054 (0x0004) [0x0000000000000000]              
	struct FInterpCurveFloat                           PitchCurve;                                       		// 0x0058 (0x0010) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FInterpCurveFloat                           PitchCurveDown;                                   		// 0x0068 (0x0010) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FInterpCurveFloat                           AimCurve;                                         		// 0x0078 (0x0010) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FInterpCurveFloat                           AimCurveDown;                                     		// 0x0088 (0x0010) [0x0000000000400000]              ( CPF_NeedCtorLink )
	unsigned long                                      bForceUnrestrictedPitch : 1;                      		// 0x0098 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 46631 );

		return pClassPointer;
	};

	void AdjustAimingView ( struct FVector* ViewLocation, struct FRotator* ViewRotation );
	bool IsAimingDown ( );
	bool IsFixedPitchMode ( );
	bool IsYawLocked ( );
	bool IsCameraLocked ( );
	bool IsInputLocked ( );
	void UpdateAimPitch ( );
	void UpdateRotation ( float DeltaTime );
	float EvalUnrestrictedPitch ( float InLookup );
	struct FVector CalcNewAccel ( );
	void PlayerMove ( float DeltaTime );
	void ProcessMove ( float DeltaTime, struct FVector newAccel, unsigned char DoubleClickMove, struct FRotator DeltaRot );
	struct FRotator GetBaseAimRotation ( class AWeapon* W, unsigned long bIgnoreAutoLock );
	void OnBecomeActive ( class UTgControlModule* OldModule );
	void UpdatePitchCurve ( );
	void OnSettingsChanged ( class UTgClientSettings* Settings );
	void Init ( );
};

UClass* UTgControlModule_ThirdPerson::pClassPointer = NULL;

// Class TgGame.TgControlModule_StunTaunted
// 0x000C (0x00A8 - 0x009C)
class UTgControlModule_StunTaunted : public UTgControlModule_ThirdPerson
{
public:
	float                                              m_fInitialYaw;                                    		// 0x009C (0x0004) [0x0000000000000000]              
	float                                              m_fInterpTime;                                    		// 0x00A0 (0x0004) [0x0000000000000002]              ( CPF_Const )
	float                                              m_fRemainingInterpTime;                           		// 0x00A4 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 46630 );

		return pClassPointer;
	};

	void UpdateRotation ( float DeltaTime );
	struct FVector CalcNewAccel ( );
	void OnBecomeInActive ( class UTgControlModule* NewModule );
	void OnBecomeActive ( class UTgControlModule* OldModule );
};

UClass* UTgControlModule_StunTaunted::pClassPointer = NULL;

// Class TgGame.TgDeploy_HitOnLanded
// 0x0010 (0x0320 - 0x0310)
class ATgDeploy_HitOnLanded : public ATgDeploy_EffectVolume
{
public:
	unsigned long                                      m_bShouldFireAmmo : 1;                            		// 0x0310 (0x0004) [0x0000000000000000] [0x00000001] 
	TArray< class AActor* >                            s_LandedList;                                     		// 0x0314 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 47460 );

		return pClassPointer;
	};

	void FireAmmunitionDeployable ( );
	void OnActorLanded ( class AActor* Other );
};

UClass* ATgDeploy_HitOnLanded::pClassPointer = NULL;

// Class TgGame.TgCarriedFlag
// 0x0034 (0x0224 - 0x01F0)
class ATgCarriedFlag : public AActor
{
public:
	int                                                r_nDefenderTaskForce;                             		// 0x01F0 (0x0004) [0x0000000000002020]              ( CPF_Net | CPF_Transient )
	class ATgCTFFlagBase*                              s_FlagBase;                                       		// 0x01F4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned long                                      r_bIsHome : 1;                                    		// 0x01F8 (0x0004) [0x0000000000002020] [0x00000001] ( CPF_Net | CPF_Transient )
	class ATgPawn_Character*                           m_Holder;                                         		// 0x01FC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class ATgRepInfo_Player*                           r_HolderPRI;                                      		// 0x0200 (0x0004) [0x0000000000002020]              ( CPF_Net | CPF_Transient )
	class ATgPawn_Character*                           m_OldHolder;                                      		// 0x0204 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class AController*                                 m_FirstTouch;                                     		// 0x0208 (0x0004) [0x0000000000000000]              
	TArray< class AController* >                       m_Assists;                                        		// 0x020C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	float                                              m_fMaxDropTime;                                   		// 0x0218 (0x0004) [0x0000000000000000]              
	float                                              m_fDefaultRadius;                                 		// 0x021C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_fDefaultHeight;                                 		// 0x0220 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 47485 );

		return pClassPointer;
	};

	void ClearOldHolder ( );
	void eventDrop ( class AController* Killer, unsigned long bNoThrow );
	void CheckFit ( );
	void AutoSendHome ( );
	void Score ( );
	void SendHome ( );
	void ClearHolder ( );
	void SetHolder ( class AController* C );
	bool ValidHolder ( class AActor* Other );
	void CheckTouching ( );
	void eventTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void PostBeginPlay ( );
};

UClass* ATgCarriedFlag::pClassPointer = NULL;

// Class TgGame.TgSeqAct_Stasis
// 0x0000 (0x00C4 - 0x00C4)
class UTgSeqAct_Stasis : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 47697 );

		return pClassPointer;
	};

};

UClass* UTgSeqAct_Stasis::pClassPointer = NULL;

// Class TgGame.TgBasicSilhouetteComponent
// 0x0000 (0x022C - 0x022C)
class UTgBasicSilhouetteComponent : public UTgSilhouetteComponent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 48657 );

		return pClassPointer;
	};

};

UClass* UTgBasicSilhouetteComponent::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorAction_PlayEmote
// 0x0001 (0x0065 - 0x0064)
class UTgAIBehaviorAction_PlayEmote : public UTgAIBehaviorAction
{
public:
	unsigned char                                      EmoteToPlay;                                      		// 0x0064 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 48658 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorAction_PlayEmote::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorAction_PurchaseItems
// 0x0000 (0x0064 - 0x0064)
class UTgAIBehaviorAction_PurchaseItems : public UTgAIBehaviorAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 48662 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorAction_PurchaseItems::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorAction_PurchaseSkills
// 0x0000 (0x0064 - 0x0064)
class UTgAIBehaviorAction_PurchaseSkills : public UTgAIBehaviorAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 48664 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorAction_PurchaseSkills::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorAction_Regen
// 0x0000 (0x0064 - 0x0064)
class UTgAIBehaviorAction_Regen : public UTgAIBehaviorAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 48666 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorAction_Regen::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorAction_RunToOwner
// 0x0000 (0x006C - 0x006C)
class UTgAIBehaviorAction_RunToOwner : public UTgAIBehaviorAction_MoveToTarget
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 48668 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorAction_RunToOwner::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorAction_RunToSpawn
// 0x0000 (0x006C - 0x006C)
class UTgAIBehaviorAction_RunToSpawn : public UTgAIBehaviorAction_MoveToTarget
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 48670 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorAction_RunToSpawn::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorAction_RunToSpreadLocation
// 0x0000 (0x006C - 0x006C)
class UTgAIBehaviorAction_RunToSpreadLocation : public UTgAIBehaviorAction_MoveToTarget
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 48672 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorAction_RunToSpreadLocation::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorAction_SelectCombatTargetsTarget
// 0x0004 (0x0068 - 0x0064)
class UTgAIBehaviorAction_SelectCombatTargetsTarget : public UTgAIBehaviorAction
{
public:
	unsigned long                                      bGodsOnly : 1;                                    		// 0x0064 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 48674 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorAction_SelectCombatTargetsTarget::pClassPointer = NULL;

// Class TgGame.TgSeqAct_ToggleImmuneGodMode
// 0x0000 (0x00C4 - 0x00C4)
class UTgSeqAct_ToggleImmuneGodMode : public USeqAct_ToggleGodMode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 48776 );

		return pClassPointer;
	};

};

UClass* UTgSeqAct_ToggleImmuneGodMode::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorAction_SelectLaneCombatTarget
// 0x0014 (0x0078 - 0x0064)
class UTgAIBehaviorAction_SelectLaneCombatTarget : public UTgAIBehaviorAction
{
public:
	unsigned long                                      bMustBeEnemy : 1;                                 		// 0x0064 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      bMustBeSameLane : 1;                              		// 0x0064 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      bMustBeWeakest : 1;                               		// 0x0064 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      bSelectRandom : 1;                                		// 0x0064 (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )
	unsigned long                                      bMustHaveLineOfSight : 1;                         		// 0x0064 (0x0004) [0x0000000000000001] [0x00000010] ( CPF_Edit )
	unsigned long                                      bMustHaveDamagedGod : 1;                          		// 0x0064 (0x0004) [0x0000000000000001] [0x00000020] ( CPF_Edit )
	unsigned long                                      bMustNotBeImmune : 1;                             		// 0x0064 (0x0004) [0x0000000000000001] [0x00000040] ( CPF_Edit )
	unsigned long                                      bMustBeSafeToTarget : 1;                          		// 0x0064 (0x0004) [0x0000000000000001] [0x00000080] ( CPF_Edit )
	unsigned long                                      bMustBeInForwardCone : 1;                         		// 0x0064 (0x0004) [0x0000000000000001] [0x00000100] ( CPF_Edit )
	unsigned long                                      bEffectGroupCategoryCheckInstigator : 1;          		// 0x0064 (0x0004) [0x0000000000000001] [0x00000200] ( CPF_Edit )
	unsigned long                                      bMustBeHittable : 1;                              		// 0x0064 (0x0004) [0x0000000000000001] [0x00000400] ( CPF_Edit )
	unsigned char                                      TargetType;                                       		// 0x0068 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      IgnoreTargetType;                                 		// 0x0069 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	int                                                EffectCategoryId;                                 		// 0x006C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                ExcludeEffectCategoryId;                          		// 0x0070 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              ForwardConeAngle;                                 		// 0x0074 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49057 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorAction_SelectLaneCombatTarget::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorAction_SelectLaneCombatTarget_Jungle
// 0x0005 (0x0069 - 0x0064)
class UTgAIBehaviorAction_SelectLaneCombatTarget_Jungle : public UTgAIBehaviorAction
{
public:
	unsigned long                                      bMustBeWeakest : 1;                               		// 0x0064 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned char                                      TargetType;                                       		// 0x0068 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49075 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorAction_SelectLaneCombatTarget_Jungle::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorAction_SelectLaneCombatTarget_LastAttacker
// 0x0005 (0x0069 - 0x0064)
class UTgAIBehaviorAction_SelectLaneCombatTarget_LastAttacker : public UTgAIBehaviorAction
{
public:
	unsigned long                                      bSkipPawnNotify : 1;                              		// 0x0064 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      bMustBeHittable : 1;                              		// 0x0064 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned char                                      IgnoreTargetType;                                 		// 0x0068 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49079 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorAction_SelectLaneCombatTarget_LastAttacker::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorAction_SelectLaneMoveTarget
// 0x0004 (0x0068 - 0x0064)
class UTgAIBehaviorAction_SelectLaneMoveTarget : public UTgAIBehaviorAction
{
public:
	unsigned long                                      bMustBeEnemy : 1;                                 		// 0x0064 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      bMustBePhoenix : 1;                               		// 0x0064 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      bMustBeSameLane : 1;                              		// 0x0064 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49084 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorAction_SelectLaneMoveTarget::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorAction_SelectLaneMoveTarget_Jungle
// 0x0001 (0x0065 - 0x0064)
class UTgAIBehaviorAction_SelectLaneMoveTarget_Jungle : public UTgAIBehaviorAction
{
public:
	unsigned char                                      TargetType;                                       		// 0x0064 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49089 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorAction_SelectLaneMoveTarget_Jungle::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorAction_SelectLaneMoveTarget_Minotaur
// 0x0004 (0x0068 - 0x0064)
class UTgAIBehaviorAction_SelectLaneMoveTarget_Minotaur : public UTgAIBehaviorAction
{
public:
	unsigned long                                      bMustBeEnemy : 1;                                 		// 0x0064 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49092 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorAction_SelectLaneMoveTarget_Minotaur::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorAction_SelectLaneMoveTargetAsCombatTarget
// 0x0004 (0x0068 - 0x0064)
class UTgAIBehaviorAction_SelectLaneMoveTargetAsCombatTarget : public UTgAIBehaviorAction
{
public:
	unsigned long                                      bSkipPawnNotify : 1;                              		// 0x0064 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49095 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorAction_SelectLaneMoveTargetAsCombatTarget::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorAction_SelectLeashCombatTarget
// 0x0010 (0x0074 - 0x0064)
class UTgAIBehaviorAction_SelectLeashCombatTarget : public UTgAIBehaviorAction
{
public:
	unsigned long                                      bMustBeEnemy : 1;                                 		// 0x0064 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      bMustBeWeakest : 1;                               		// 0x0064 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      bMustHaveLineOfSight : 1;                         		// 0x0064 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      bMustHaveDamagedGod : 1;                          		// 0x0064 (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )
	unsigned long                                      bMustNotBeImmune : 1;                             		// 0x0064 (0x0004) [0x0000000000000001] [0x00000010] ( CPF_Edit )
	unsigned long                                      bEffectGroupCategoryCheckInstigator : 1;          		// 0x0064 (0x0004) [0x0000000000000001] [0x00000020] ( CPF_Edit )
	unsigned long                                      bMustBeHittable : 1;                              		// 0x0064 (0x0004) [0x0000000000000001] [0x00000040] ( CPF_Edit )
	unsigned char                                      TargetType;                                       		// 0x0068 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      IgnoreTargetType;                                 		// 0x0069 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	int                                                EffectCategoryId;                                 		// 0x006C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                ExcludeEffectCategoryId;                          		// 0x0070 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49098 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorAction_SelectLeashCombatTarget::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorAction_SelectSquadCombatTarget
// 0x0000 (0x0064 - 0x0064)
class UTgAIBehaviorAction_SelectSquadCombatTarget : public UTgAIBehaviorAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49111 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorAction_SelectSquadCombatTarget::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorAction_SelectThreatCombatTarget
// 0x0010 (0x0074 - 0x0064)
class UTgAIBehaviorAction_SelectThreatCombatTarget : public UTgAIBehaviorAction
{
public:
	unsigned long                                      bMustBeHighestThreat : 1;                         		// 0x0064 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      bMustBeInLeash : 1;                               		// 0x0064 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      bMustBeInSightRadius : 1;                         		// 0x0064 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      bEffectGroupCategoryCheckInstigator : 1;          		// 0x0064 (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )
	unsigned long                                      bMustBeHittable : 1;                              		// 0x0064 (0x0004) [0x0000000000000001] [0x00000010] ( CPF_Edit )
	unsigned char                                      TargetType;                                       		// 0x0068 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      IgnoreTargetType;                                 		// 0x0069 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	int                                                EffectCategoryId;                                 		// 0x006C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                ExcludeEffectCategoryId;                          		// 0x0070 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49113 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorAction_SelectThreatCombatTarget::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorAction_SuggestSquadCombatTarget
// 0x0000 (0x0064 - 0x0064)
class UTgAIBehaviorAction_SuggestSquadCombatTarget : public UTgAIBehaviorAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49124 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorAction_SuggestSquadCombatTarget::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorAction_UseActive
// 0x0001 (0x0065 - 0x0064)
class UTgAIBehaviorAction_UseActive : public UTgAIBehaviorAction
{
public:
	unsigned char                                      ActiveType;                                       		// 0x0064 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49126 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorAction_UseActive::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorAction_UseConsumable
// 0x0001 (0x0065 - 0x0064)
class UTgAIBehaviorAction_UseConsumable : public UTgAIBehaviorAction
{
public:
	unsigned char                                      ConsumableType;                                   		// 0x0064 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49129 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorAction_UseConsumable::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorAction_UseDevice
// 0x0002 (0x0066 - 0x0064)
class UTgAIBehaviorAction_UseDevice : public UTgAIBehaviorAction
{
public:
	unsigned char                                      DeviceToUse;                                      		// 0x0064 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      aimType;                                          		// 0x0065 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49132 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorAction_UseDevice::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorComposite_SequenceAND
// 0x0000 (0x0084 - 0x0084)
class UTgAIBehaviorComposite_SequenceAND : public UTgAIBehaviorComposite_Sequence
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49149 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorComposite_SequenceAND::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorComposite_SequenceOR
// 0x0000 (0x0084 - 0x0084)
class UTgAIBehaviorComposite_SequenceOR : public UTgAIBehaviorComposite_Sequence
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49151 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorComposite_SequenceOR::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition_CanPurchaseItems
// 0x0003 (0x0068 - 0x0065)
class UTgAIBehaviorCondition_CanPurchaseItems : public UTgAIBehaviorCondition
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49159 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition_CanPurchaseItems::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition_CanPurchaseSkills
// 0x0003 (0x0068 - 0x0065)
class UTgAIBehaviorCondition_CanPurchaseSkills : public UTgAIBehaviorCondition
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49161 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition_CanPurchaseSkills::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition_CombatTargetDamageable
// 0x0003 (0x0068 - 0x0065)
class UTgAIBehaviorCondition_CombatTargetDamageable : public UTgAIBehaviorCondition
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49163 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition_CombatTargetDamageable::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition_CombatTargetDamageableByDevice
// 0x0004 (0x0069 - 0x0065)
class UTgAIBehaviorCondition_CombatTargetDamageableByDevice : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      DeviceSlot;                                       		// 0x0068 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49165 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition_CombatTargetDamageableByDevice::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition_CombatTargetDamagedFriendlyGod
// 0x0003 (0x0068 - 0x0065)
class UTgAIBehaviorCondition_CombatTargetDamagedFriendlyGod : public UTgAIBehaviorCondition
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49168 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition_CombatTargetDamagedFriendlyGod::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition_CombatTargetDropped
// 0x0003 (0x0068 - 0x0065)
class UTgAIBehaviorCondition_CombatTargetDropped : public UTgAIBehaviorCondition
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49170 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition_CombatTargetDropped::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition_CombatTargetHealthPercent
// 0x0007 (0x006C - 0x0065)
class UTgAIBehaviorCondition_CombatTargetHealthPercent : public UTgAIBehaviorCondition
{
public:
	float                                              HealthPct;                                        		// 0x0068 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49175 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition_CombatTargetHealthPercent::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition_CombatTargetHealthPercentAfterAttack
// 0x000B (0x0070 - 0x0065)
class UTgAIBehaviorCondition_CombatTargetHealthPercentAfterAttack : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      DeviceSlot;                                       		// 0x0068 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	float                                              HealthPct;                                        		// 0x006C (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49178 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition_CombatTargetHealthPercentAfterAttack::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition_CombatTargetIsInMinotaurRadius
// 0x0007 (0x006C - 0x0065)
class UTgAIBehaviorCondition_CombatTargetIsInMinotaurRadius : public UTgAIBehaviorCondition
{
public:
	unsigned long                                      bMustBeEnemy : 1;                                 		// 0x0068 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49182 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition_CombatTargetIsInMinotaurRadius::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition_CombatTargetIsInTowerRadius
// 0x0007 (0x006C - 0x0065)
class UTgAIBehaviorCondition_CombatTargetIsInTowerRadius : public UTgAIBehaviorCondition
{
public:
	unsigned long                                      bMustBeEnemy : 1;                                 		// 0x0068 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49185 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition_CombatTargetIsInTowerRadius::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition_CombatTargetIsTargetOfFriendlyTowerOrMinotaur
// 0x0003 (0x0068 - 0x0065)
class UTgAIBehaviorCondition_CombatTargetIsTargetOfFriendlyTowerOrMinotaur : public UTgAIBehaviorCondition
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49188 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition_CombatTargetIsTargetOfFriendlyTowerOrMinotaur::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition_CombatTargetPhysicsState
// 0x0004 (0x0069 - 0x0065)
class UTgAIBehaviorCondition_CombatTargetPhysicsState : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      PhysicsState;                                     		// 0x0068 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49190 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition_CombatTargetPhysicsState::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition_CurrentLevel
// 0x0007 (0x006C - 0x0065)
class UTgAIBehaviorCondition_CurrentLevel : public UTgAIBehaviorCondition
{
public:
	int                                                LevelThreshold;                                   		// 0x0068 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49193 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition_CurrentLevel::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition_DeviceIsFiring
// 0x0004 (0x0069 - 0x0065)
class UTgAIBehaviorCondition_DeviceIsFiring : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      DeviceSlot;                                       		// 0x0068 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49196 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition_DeviceIsFiring::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition_DeviceReadyToUse
// 0x0004 (0x0069 - 0x0065)
class UTgAIBehaviorCondition_DeviceReadyToUse : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      DeviceSlot;                                       		// 0x0068 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49199 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition_DeviceReadyToUse::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition_DifficultyLevel
// 0x0004 (0x0069 - 0x0065)
class UTgAIBehaviorCondition_DifficultyLevel : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      Difficulty;                                       		// 0x0068 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49202 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition_DifficultyLevel::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition_DistanceFromCombatTarget
// 0x0007 (0x006C - 0x0065)
class UTgAIBehaviorCondition_DistanceFromCombatTarget : public UTgAIBehaviorCondition
{
public:
	float                                              DistanceThreshold;                                		// 0x0068 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49205 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition_DistanceFromCombatTarget::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition_DistanceFromLaneTarget
// 0x0007 (0x006C - 0x0065)
class UTgAIBehaviorCondition_DistanceFromLaneTarget : public UTgAIBehaviorCondition
{
public:
	float                                              DistanceThreshold;                                		// 0x0068 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49208 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition_DistanceFromLaneTarget::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition_DistanceFromNearestGod
// 0x000F (0x0074 - 0x0065)
class UTgAIBehaviorCondition_DistanceFromNearestGod : public UTgAIBehaviorCondition
{
public:
	unsigned long                                      bMustBeEnemy : 1;                                 		// 0x0068 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned char                                      GodType;                                          		// 0x006C (0x0001) [0x0000000000000001]              ( CPF_Edit )
	float                                              DistanceThreshold;                                		// 0x0070 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49211 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition_DistanceFromNearestGod::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition_DistanceFromSpawn
// 0x0007 (0x006C - 0x0065)
class UTgAIBehaviorCondition_DistanceFromSpawn : public UTgAIBehaviorCondition
{
public:
	float                                              DistanceThreshold;                                		// 0x0068 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49216 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition_DistanceFromSpawn::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition_Energy
// 0x0007 (0x006C - 0x0065)
class UTgAIBehaviorCondition_Energy : public UTgAIBehaviorCondition
{
public:
	float                                              Energy;                                           		// 0x0068 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49219 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition_Energy::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition_GameType
// 0x0004 (0x0069 - 0x0065)
class UTgAIBehaviorCondition_GameType : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      GameType;                                         		// 0x0068 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49222 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition_GameType::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition_HasActive
// 0x0004 (0x0069 - 0x0065)
class UTgAIBehaviorCondition_HasActive : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      ActiveType;                                       		// 0x0068 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49225 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition_HasActive::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition_HasCombatTarget
// 0x0003 (0x0068 - 0x0065)
class UTgAIBehaviorCondition_HasCombatTarget : public UTgAIBehaviorCondition
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49228 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition_HasCombatTarget::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition_HasConsumable
// 0x0004 (0x0069 - 0x0065)
class UTgAIBehaviorCondition_HasConsumable : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      ConsumableType;                                   		// 0x0068 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49230 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition_HasConsumable::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition_HasIncomingDamage
// 0x0003 (0x0068 - 0x0065)
class UTgAIBehaviorCondition_HasIncomingDamage : public UTgAIBehaviorCondition
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49235 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition_HasIncomingDamage::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition_HasLaneTarget
// 0x0003 (0x0068 - 0x0065)
class UTgAIBehaviorCondition_HasLaneTarget : public UTgAIBehaviorCondition
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49237 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition_HasLaneTarget::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition_HasMoveTarget
// 0x0003 (0x0068 - 0x0065)
class UTgAIBehaviorCondition_HasMoveTarget : public UTgAIBehaviorCondition
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49239 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition_HasMoveTarget::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition_HasSpreadLocation
// 0x0003 (0x0068 - 0x0065)
class UTgAIBehaviorCondition_HasSpreadLocation : public UTgAIBehaviorCondition
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49241 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition_HasSpreadLocation::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition_HealthPercent
// 0x0007 (0x006C - 0x0065)
class UTgAIBehaviorCondition_HealthPercent : public UTgAIBehaviorCondition
{
public:
	float                                              HealthPct;                                        		// 0x0068 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49243 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition_HealthPercent::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition_IsActiveReady
// 0x0004 (0x0069 - 0x0065)
class UTgAIBehaviorCondition_IsActiveReady : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      ActiveType;                                       		// 0x0068 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49246 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition_IsActiveReady::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition_IsAtRallyPoint
// 0x0003 (0x0068 - 0x0065)
class UTgAIBehaviorCondition_IsAtRallyPoint : public UTgAIBehaviorCondition
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49249 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition_IsAtRallyPoint::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition_IsAtSpawn
// 0x0003 (0x0068 - 0x0065)
class UTgAIBehaviorCondition_IsAtSpawn : public UTgAIBehaviorCondition
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49251 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition_IsAtSpawn::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition_IsCombatTargetHittable
// 0x0003 (0x0068 - 0x0065)
class UTgAIBehaviorCondition_IsCombatTargetHittable : public UTgAIBehaviorCondition
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49253 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition_IsCombatTargetHittable::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition_IsCombatTargetHostile
// 0x0003 (0x0068 - 0x0065)
class UTgAIBehaviorCondition_IsCombatTargetHostile : public UTgAIBehaviorCondition
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49255 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition_IsCombatTargetHostile::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition_IsCombatTargetInFountain
// 0x0003 (0x0068 - 0x0065)
class UTgAIBehaviorCondition_IsCombatTargetInFountain : public UTgAIBehaviorCondition
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49257 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition_IsCombatTargetInFountain::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition_IsCombatTargetInLeash
// 0x0003 (0x0068 - 0x0065)
class UTgAIBehaviorCondition_IsCombatTargetInLeash : public UTgAIBehaviorCondition
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49259 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition_IsCombatTargetInLeash::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition_IsCombatTargetInSightRadius
// 0x0003 (0x0068 - 0x0065)
class UTgAIBehaviorCondition_IsCombatTargetInSightRadius : public UTgAIBehaviorCondition
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49261 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition_IsCombatTargetInSightRadius::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition_IsCombatTargetLastAttacker
// 0x0003 (0x0068 - 0x0065)
class UTgAIBehaviorCondition_IsCombatTargetLastAttacker : public UTgAIBehaviorCondition
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49263 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition_IsCombatTargetLastAttacker::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition_IsCombatTargetOfType
// 0x0004 (0x0069 - 0x0065)
class UTgAIBehaviorCondition_IsCombatTargetOfType : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      TargetType;                                       		// 0x0068 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49265 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition_IsCombatTargetOfType::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition_IsCombatTargetStealthed
// 0x0007 (0x006C - 0x0065)
class UTgAIBehaviorCondition_IsCombatTargetStealthed : public UTgAIBehaviorCondition
{
public:
	unsigned long                                      bTreatUnhittableTargetsAsStealthed : 1;           		// 0x0068 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49268 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition_IsCombatTargetStealthed::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition_IsCombatTargetVisible
// 0x0007 (0x006C - 0x0065)
class UTgAIBehaviorCondition_IsCombatTargetVisible : public UTgAIBehaviorCondition
{
public:
	unsigned long                                      bTreatUnhittableTargetsAsNotVisible : 1;          		// 0x0068 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49271 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition_IsCombatTargetVisible::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition_IsDeviceAimInTowerRadius
// 0x000B (0x0070 - 0x0065)
class UTgAIBehaviorCondition_IsDeviceAimInTowerRadius : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      DeviceSlot;                                       		// 0x0068 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      bMustBeEnemy : 1;                                 		// 0x006C (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49274 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition_IsDeviceAimInTowerRadius::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition_IsInHostileAbility
// 0x0003 (0x0068 - 0x0065)
class UTgAIBehaviorCondition_IsInHostileAbility : public UTgAIBehaviorCondition
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49278 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition_IsInHostileAbility::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition_IsInJungle
// 0x0003 (0x0068 - 0x0065)
class UTgAIBehaviorCondition_IsInJungle : public UTgAIBehaviorCondition
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49280 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition_IsInJungle::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition_IsInMinotaurRadius
// 0x0007 (0x006C - 0x0065)
class UTgAIBehaviorCondition_IsInMinotaurRadius : public UTgAIBehaviorCondition
{
public:
	unsigned long                                      bMustBeEnemy : 1;                                 		// 0x0068 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49282 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition_IsInMinotaurRadius::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition_IsInTowerRadius
// 0x0007 (0x006C - 0x0065)
class UTgAIBehaviorCondition_IsInTowerRadius : public UTgAIBehaviorCondition
{
public:
	unsigned long                                      bMustBeEnemy : 1;                                 		// 0x0068 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49285 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition_IsInTowerRadius::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition_IsLastAttackerOfType
// 0x0004 (0x0069 - 0x0065)
class UTgAIBehaviorCondition_IsLastAttackerOfType : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      TargetType;                                       		// 0x0068 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49288 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition_IsLastAttackerOfType::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition_IsLookingAtCombatTarget
// 0x0007 (0x006C - 0x0065)
class UTgAIBehaviorCondition_IsLookingAtCombatTarget : public UTgAIBehaviorCondition
{
public:
	float                                              VisibilityAngle;                                  		// 0x0068 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49291 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition_IsLookingAtCombatTarget::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition_IsNonCombat
// 0x0003 (0x0068 - 0x0065)
class UTgAIBehaviorCondition_IsNonCombat : public UTgAIBehaviorCondition
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49294 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition_IsNonCombat::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition_IsOutsideLeash
// 0x0003 (0x0068 - 0x0065)
class UTgAIBehaviorCondition_IsOutsideLeash : public UTgAIBehaviorCondition
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49296 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition_IsOutsideLeash::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition_IsSafeToRecall
// 0x0003 (0x0068 - 0x0065)
class UTgAIBehaviorCondition_IsSafeToRecall : public UTgAIBehaviorCondition
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49298 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition_IsSafeToRecall::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition_IsTargetOfEnemyTowerOrMinotaur
// 0x0003 (0x0068 - 0x0065)
class UTgAIBehaviorCondition_IsTargetOfEnemyTowerOrMinotaur : public UTgAIBehaviorCondition
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49300 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition_IsTargetOfEnemyTowerOrMinotaur::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition_IsTargetTypeInLeash
// 0x0004 (0x0069 - 0x0065)
class UTgAIBehaviorCondition_IsTargetTypeInLeash : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      TargetType;                                       		// 0x0068 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49302 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition_IsTargetTypeInLeash::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition_IsTooFarFromLane
// 0x0004 (0x0069 - 0x0065)
class UTgAIBehaviorCondition_IsTooFarFromLane : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      TargetType;                                       		// 0x0068 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49305 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition_IsTooFarFromLane::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition_IsWithinCombatDistance
// 0x0008 (0x006D - 0x0065)
class UTgAIBehaviorCondition_IsWithinCombatDistance : public UTgAIBehaviorCondition
{
public:
	unsigned long                                      bSubtractTargetPawnRadius : 1;                    		// 0x0068 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned char                                      DeviceSlot;                                       		// 0x006C (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49308 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition_IsWithinCombatDistance::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition_IsWithinDistance
// 0x000B (0x0070 - 0x0065)
class UTgAIBehaviorCondition_IsWithinDistance : public UTgAIBehaviorCondition
{
public:
	unsigned long                                      bIsXYOnly : 1;                                    		// 0x0068 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	float                                              DistanceCheck;                                    		// 0x006C (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49312 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition_IsWithinDistance::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition_ManaPercent
// 0x0007 (0x006C - 0x0065)
class UTgAIBehaviorCondition_ManaPercent : public UTgAIBehaviorCondition
{
public:
	float                                              ManaPct;                                          		// 0x0068 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49316 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition_ManaPercent::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition_MinotaurHealthPercent
// 0x000B (0x0070 - 0x0065)
class UTgAIBehaviorCondition_MinotaurHealthPercent : public UTgAIBehaviorCondition
{
public:
	unsigned long                                      bMustBeEnemy : 1;                                 		// 0x0068 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	float                                              HealthPct;                                        		// 0x006C (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49319 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition_MinotaurHealthPercent::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition_NearbyGodCount
// 0x000F (0x0074 - 0x0065)
class UTgAIBehaviorCondition_NearbyGodCount : public UTgAIBehaviorCondition
{
public:
	unsigned long                                      bMustBeEnemy : 1;                                 		// 0x0068 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	int                                                GodThreshold;                                     		// 0x006C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                DistanceThreshold;                                		// 0x0070 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49323 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition_NearbyGodCount::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition_NearbyGodDelta
// 0x000B (0x0070 - 0x0065)
class UTgAIBehaviorCondition_NearbyGodDelta : public UTgAIBehaviorCondition
{
public:
	int                                                GodThreshold;                                     		// 0x0068 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                DistanceThreshold;                                		// 0x006C (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49328 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition_NearbyGodDelta::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition_NearbyMinionCount
// 0x000F (0x0074 - 0x0065)
class UTgAIBehaviorCondition_NearbyMinionCount : public UTgAIBehaviorCondition
{
public:
	unsigned long                                      bMustBeEnemy : 1;                                 		// 0x0068 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	int                                                MinionThreshold;                                  		// 0x006C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                DistanceThreshold;                                		// 0x0070 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49332 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition_NearbyMinionCount::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition_NearbyMinionDelta
// 0x000B (0x0070 - 0x0065)
class UTgAIBehaviorCondition_NearbyMinionDelta : public UTgAIBehaviorCondition
{
public:
	int                                                MinionThreshold;                                  		// 0x0068 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                DistanceThreshold;                                		// 0x006C (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49337 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition_NearbyMinionDelta::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition_NearbyTargetCount
// 0x0013 (0x0078 - 0x0065)
class UTgAIBehaviorCondition_NearbyTargetCount : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      eTargetType;                                      		// 0x0068 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      bMustBeEnemy : 1;                                 		// 0x006C (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	int                                                TargetThreshold;                                  		// 0x0070 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                DistanceThreshold;                                		// 0x0074 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49341 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition_NearbyTargetCount::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition_NearbyTargetDelta
// 0x000F (0x0074 - 0x0065)
class UTgAIBehaviorCondition_NearbyTargetDelta : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      eTargetType;                                      		// 0x0068 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	int                                                TargetThreshold;                                  		// 0x006C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                DistanceThreshold;                                		// 0x0070 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49347 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition_NearbyTargetDelta::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition_NearestGodHealthPercent
// 0x000F (0x0074 - 0x0065)
class UTgAIBehaviorCondition_NearestGodHealthPercent : public UTgAIBehaviorCondition
{
public:
	unsigned long                                      bMustBeEnemy : 1;                                 		// 0x0068 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned char                                      GodType;                                          		// 0x006C (0x0001) [0x0000000000000001]              ( CPF_Edit )
	float                                              HealthPct;                                        		// 0x0070 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49352 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition_NearestGodHealthPercent::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition_NearestPawnInMinotaurRadius
// 0x0008 (0x006D - 0x0065)
class UTgAIBehaviorCondition_NearestPawnInMinotaurRadius : public UTgAIBehaviorCondition
{
public:
	unsigned long                                      bMustBeEnemy : 1;                                 		// 0x0068 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      bMinotaurMustBeEnemy : 1;                         		// 0x0068 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned char                                      GodType;                                          		// 0x006C (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49357 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition_NearestPawnInMinotaurRadius::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition_NearestPawnInTowerRadius
// 0x0008 (0x006D - 0x0065)
class UTgAIBehaviorCondition_NearestPawnInTowerRadius : public UTgAIBehaviorCondition
{
public:
	unsigned long                                      bMustBeEnemy : 1;                                 		// 0x0068 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      bTowerMustBeEnemy : 1;                            		// 0x0068 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned char                                      GodType;                                          		// 0x006C (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49362 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition_NearestPawnInTowerRadius::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition_NearestTargetHealthPercent
// 0x000F (0x0074 - 0x0065)
class UTgAIBehaviorCondition_NearestTargetHealthPercent : public UTgAIBehaviorCondition
{
public:
	unsigned long                                      bMustBeEnemy : 1;                                 		// 0x0068 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned char                                      TargetType;                                       		// 0x006C (0x0001) [0x0000000000000001]              ( CPF_Edit )
	float                                              HealthPct;                                        		// 0x0070 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49367 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition_NearestTargetHealthPercent::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition_NearestTowerHealthPercent
// 0x000B (0x0070 - 0x0065)
class UTgAIBehaviorCondition_NearestTowerHealthPercent : public UTgAIBehaviorCondition
{
public:
	unsigned long                                      bMustBeEnemy : 1;                                 		// 0x0068 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	float                                              HealthPct;                                        		// 0x006C (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49372 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition_NearestTowerHealthPercent::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition_NumGodsInMinotaurRadius
// 0x000B (0x0070 - 0x0065)
class UTgAIBehaviorCondition_NumGodsInMinotaurRadius : public UTgAIBehaviorCondition
{
public:
	unsigned long                                      bGodsMustBeEnemy : 1;                             		// 0x0068 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      bMinotaurMustBeEnemy : 1;                         		// 0x0068 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	int                                                GodThreshold;                                     		// 0x006C (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49376 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition_NumGodsInMinotaurRadius::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition_NumGodsInTowerRadius
// 0x000B (0x0070 - 0x0065)
class UTgAIBehaviorCondition_NumGodsInTowerRadius : public UTgAIBehaviorCondition
{
public:
	unsigned long                                      bGodsMustBeEnemy : 1;                             		// 0x0068 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      bTowerMustBeEnemy : 1;                            		// 0x0068 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	int                                                GodThreshold;                                     		// 0x006C (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49381 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition_NumGodsInTowerRadius::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition_NumMinionsInMinotaurRadius
// 0x000B (0x0070 - 0x0065)
class UTgAIBehaviorCondition_NumMinionsInMinotaurRadius : public UTgAIBehaviorCondition
{
public:
	unsigned long                                      bMinionsMustBeEnemy : 1;                          		// 0x0068 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      bMinotaurMustBeEnemy : 1;                         		// 0x0068 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	int                                                MinionThreshold;                                  		// 0x006C (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49386 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition_NumMinionsInMinotaurRadius::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition_NumMinionsInTowerRadius
// 0x000B (0x0070 - 0x0065)
class UTgAIBehaviorCondition_NumMinionsInTowerRadius : public UTgAIBehaviorCondition
{
public:
	unsigned long                                      bMinionsMustBeEnemy : 1;                          		// 0x0068 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      bTowerMustBeEnemy : 1;                            		// 0x0068 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	int                                                MinionThreshold;                                  		// 0x006C (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49391 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition_NumMinionsInTowerRadius::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition_PetPhase
// 0x0004 (0x0069 - 0x0065)
class UTgAIBehaviorCondition_PetPhase : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      Phase;                                            		// 0x0068 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49396 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition_PetPhase::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition_PhysicsState
// 0x0004 (0x0069 - 0x0065)
class UTgAIBehaviorCondition_PhysicsState : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      PhysicsState;                                     		// 0x0068 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49399 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition_PhysicsState::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition_ReturnAlways
// 0x0004 (0x0069 - 0x0065)
class UTgAIBehaviorCondition_ReturnAlways : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      AlwaysReturn;                                     		// 0x0068 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49402 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition_ReturnAlways::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition_TargetsDamageableByDevice
// 0x000B (0x0070 - 0x0065)
class UTgAIBehaviorCondition_TargetsDamageableByDevice : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      DeviceSlot;                                       		// 0x0068 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      TargetType;                                       		// 0x0069 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	int                                                TargetCount;                                      		// 0x006C (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49405 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition_TargetsDamageableByDevice::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition_Taskforce
// 0x0007 (0x006C - 0x0065)
class UTgAIBehaviorCondition_Taskforce : public UTgAIBehaviorCondition
{
public:
	int                                                taskforce;                                        		// 0x0068 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49410 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition_Taskforce::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition_Timer
// 0x0007 (0x006C - 0x0065)
class UTgAIBehaviorCondition_Timer : public UTgAIBehaviorCondition
{
public:
	float                                              TimerLength;                                      		// 0x0068 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49413 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition_Timer::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition_TimeSinceLastTookDamage
// 0x0007 (0x006C - 0x0065)
class UTgAIBehaviorCondition_TimeSinceLastTookDamage : public UTgAIBehaviorCondition
{
public:
	float                                              TimeThreshold;                                    		// 0x0068 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49416 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition_TimeSinceLastTookDamage::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition_WhatIsCombatTargetTargeting
// 0x0004 (0x0069 - 0x0065)
class UTgAIBehaviorCondition_WhatIsCombatTargetTargeting : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      TargetType;                                       		// 0x0068 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49419 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition_WhatIsCombatTargetTargeting::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorCondition_WhatIsLastAttackerTargeting
// 0x0004 (0x0069 - 0x0065)
class UTgAIBehaviorCondition_WhatIsLastAttackerTargeting : public UTgAIBehaviorCondition
{
public:
	unsigned char                                      TargetType;                                       		// 0x0068 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49422 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorCondition_WhatIsLastAttackerTargeting::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorSensor_Devices
// 0x0000 (0x0064 - 0x0064)
class UTgAIBehaviorSensor_Devices : public UTgAIBehaviorSensor
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49425 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorSensor_Devices::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorSensor_Gods
// 0x0000 (0x0064 - 0x0064)
class UTgAIBehaviorSensor_Gods : public UTgAIBehaviorSensor
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49427 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorSensor_Gods::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorSensor_IncomingDamage
// 0x0000 (0x0064 - 0x0064)
class UTgAIBehaviorSensor_IncomingDamage : public UTgAIBehaviorSensor
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49429 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorSensor_IncomingDamage::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorSensor_InHostileAbility
// 0x0000 (0x0064 - 0x0064)
class UTgAIBehaviorSensor_InHostileAbility : public UTgAIBehaviorSensor
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49431 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorSensor_InHostileAbility::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorSensor_Lane
// 0x0000 (0x0064 - 0x0064)
class UTgAIBehaviorSensor_Lane : public UTgAIBehaviorSensor
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49433 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorSensor_Lane::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorSensor_Leash
// 0x0000 (0x0064 - 0x0064)
class UTgAIBehaviorSensor_Leash : public UTgAIBehaviorSensor
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49435 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorSensor_Leash::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorSensor_PurchaseSkills
// 0x0000 (0x0064 - 0x0064)
class UTgAIBehaviorSensor_PurchaseSkills : public UTgAIBehaviorSensor
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49437 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorSensor_PurchaseSkills::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorSensor_RallyPoints
// 0x0000 (0x0064 - 0x0064)
class UTgAIBehaviorSensor_RallyPoints : public UTgAIBehaviorSensor
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49439 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorSensor_RallyPoints::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorSensor_SafeToRecall
// 0x0004 (0x0068 - 0x0064)
class UTgAIBehaviorSensor_SafeToRecall : public UTgAIBehaviorSensor
{
public:
	float                                              SafeRecallDist;                                   		// 0x0064 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49441 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorSensor_SafeToRecall::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorSensor_SightRadius
// 0x0000 (0x0064 - 0x0064)
class UTgAIBehaviorSensor_SightRadius : public UTgAIBehaviorSensor
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49444 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorSensor_SightRadius::pClassPointer = NULL;

// Class TgGame.TgAIBehaviorSensor_Towers
// 0x0000 (0x0064 - 0x0064)
class UTgAIBehaviorSensor_Towers : public UTgAIBehaviorSensor
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49446 );

		return pClassPointer;
	};

};

UClass* UTgAIBehaviorSensor_Towers::pClassPointer = NULL;

// Class TgGame.TgAILocalPositionSolver_God
// 0x0000 (0x0070 - 0x0070)
class UTgAILocalPositionSolver_God : public UTgAILocalPositionSolver
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49512 );

		return pClassPointer;
	};

};

UClass* UTgAILocalPositionSolver_God::pClassPointer = NULL;

// Class TgGame.TgAILocalPositionSolver_Pet
// 0x0000 (0x0070 - 0x0070)
class UTgAILocalPositionSolver_Pet : public UTgAILocalPositionSolver
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49551 );

		return pClassPointer;
	};

};

UClass* UTgAILocalPositionSolver_Pet::pClassPointer = NULL;

// Class TgGame.TgAIScout
// 0x0000 (0x0518 - 0x0518)
class ATgAIScout : public AScout
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 49621 );

		return pClassPointer;
	};

};

UClass* ATgAIScout::pClassPointer = NULL;

// Class TgGame.TgSkeletalMeshActor_Posture
// 0x0010 (0x0244 - 0x0234)
class ATgSkeletalMeshActor_Posture : public ASkeletalMeshActor
{
public:
	unsigned char                                      r_CurrentPosture;                                 		// 0x0234 (0x0001) [0x0000000000000021]              ( CPF_Edit | CPF_Net )
	TArray< class UTgAnimBlendByPosture* >             m_PostureBlendNodes;                              		// 0x0238 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 50647 );

		return pClassPointer;
	};

	void eventOnSetSkelPosture ( class UTgSeqAct_SetSkelPosture* Action );
	void InitPostureNodes ( );
	void eventPostInitAnimTree ( class USkeletalMeshComponent* SkelComp );
	void SetActivePosture ( unsigned char Posture );
	void eventReplicatedEvent ( struct FName VarName );
	void PostBeginPlay ( );
};

UClass* ATgSkeletalMeshActor_Posture::pClassPointer = NULL;

// Class TgGame.TgAnimMetaData_SkelControlKeyFrame
// 0x0000 (0x006C - 0x006C)
class UTgAnimMetaData_SkelControlKeyFrame : public UTgAnimMetaData_SkelControl_BoneScale_KeyFrame
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 50830 );

		return pClassPointer;
	};

};

UClass* UTgAnimMetaData_SkelControlKeyFrame::pClassPointer = NULL;

// Class TgGame.TgAnimNodeBlendList_JingWei_Dev4
// 0x0003 (0x0120 - 0x011D)
class UTgAnimNodeBlendList_JingWei_Dev4 : public UTgAnimNodeBlendList_Staging_Multi
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 50994 );

		return pClassPointer;
	};

};

UClass* UTgAnimNodeBlendList_JingWei_Dev4::pClassPointer = NULL;

// Class TgGame.TgAnimNodeBlendNPC
// 0x0038 (0x0154 - 0x011C)
class UTgAnimNodeBlendNPC : public UTgAnimNodeBlendList
{
public:
	float                                              m_NoCustomerPresentBlendInTime;                   		// 0x011C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_CustomerPresentBlendInTime;                     		// 0x0120 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_GreetingBlendInTime;                            		// 0x0124 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_NoSaleBlendInTime;                              		// 0x0128 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_CallOutBlendInTime;                             		// 0x012C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_SaleBlendInTime;                                		// 0x0130 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_TransCustomerPresentToNotPresentBlendInTime;    		// 0x0134 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	TArray< struct FName >                             m_UninterruptibleAnims;                           		// 0x0138 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	unsigned char                                      m_QueuedChild;                                    		// 0x0144 (0x0001) [0x0000000000000000]              
	float                                              m_QueuedBlendTime;                                		// 0x0148 (0x0004) [0x0000000000000000]              
	struct FName                                       m_CurrentAnimPlaying;                             		// 0x014C (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 51205 );

		return pClassPointer;
	};

	void eventOnChildAnimEnd ( struct FAnimationEndInformation Information );
	void PlaySaleAnimation ( );
	void PlayNoSaleAnimation ( );
	void PlayCallOutAnimation ( );
	void PlayCustomerPresentAnimation ( );
	void PlayGreetingAnimation ( );
	void PlayNoCustomerPresentAnimation ( );
	void QueueActiveChild ( unsigned char QueuedChild, float BlendTime );
	bool IsAnUninterruptableAnim ( struct FName AnimName );
};

UClass* UTgAnimNodeBlendNPC::pClassPointer = NULL;

// Class TgGame.TgAnimNodeSequenceByBoneRotation
// 0x0018 (0x016C - 0x0154)
class UTgAnimNodeSequenceByBoneRotation : public UAnimNodeSequence
{
public:
	struct FName                                       BoneName;                                         		// 0x0154 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      BoneAxis;                                         		// 0x015C (0x0001) [0x0000000000000001]              ( CPF_Edit )
	TArray< struct FAnimByRotation >                   AnimList;                                         		// 0x0160 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 51351 );

		return pClassPointer;
	};

	void eventOnBecomeRelevant ( );
};

UClass* UTgAnimNodeSequenceByBoneRotation::pClassPointer = NULL;

// Class TgGame.TgCameraModule_SpectatorFreeCam
// 0x001C (0x0088 - 0x006C)
class UTgCameraModule_SpectatorFreeCam : public UTgCameraModule_Spectator
{
public:
	float                                              CurrentZoom;                                      		// 0x006C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              CurrentZoomAmount;                                		// 0x0070 (0x0004) [0x0000000000000000]              
	struct FVector                                     CurrentSpringLocation;                            		// 0x0074 (0x000C) [0x0000000000000000]              
	float                                              ZoomIncrement;                                    		// 0x0080 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              SpringAmount;                                     		// 0x0084 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 51768 );

		return pClassPointer;
	};

	void UpdateZoom ( float DeltaTime, class ATgSpectatorController* Spectator );
	void UpdateCamera ( class APawn* P, class ATgPlayerCamera* CameraActor, float DeltaTime, struct FTViewTarget* OutVT );
	void ProcessInput ( class UPlayerInput* PlayerInput, float DeltaTime );
	void OnBecomeActive ( class UTgCameraModule* OldCamera );
	void GetNextTarget ( );
};

UClass* UTgCameraModule_SpectatorFreeCam::pClassPointer = NULL;

// Class TgGame.TgControlModule_Spectator
// 0x0010 (0x0054 - 0x0044)
class UTgControlModule_Spectator : public UTgControlModule
{
public:
	float                                              RotationLimit;                                    		// 0x0044 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              SpectatorStallZ;                                  		// 0x0048 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              SpectatorMinStallZ;                               		// 0x004C (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	unsigned long                                      bIgnoreCameraHeightRestriction : 1;               		// 0x0050 (0x0004) [0x0000000000004001] [0x00000001] ( CPF_Edit | CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 51770 );

		return pClassPointer;
	};

	void OnLeftMousePressed ( );
	bool InterceptFlashInput ( struct FName ButtonName, unsigned char Event );
	void GetActorListAtCursor ( TArray< class AActor* >* ActorList );
	class APawn* GetPawnAtCursor ( );
	void UpdateRotation ( float DeltaTime );
	void PlayerMove ( float DeltaTime );
	void ProcessMove ( float DeltaTime, struct FVector newAccel, unsigned char DoubleClickMove, struct FRotator DeltaRot );
	struct FRotator GetBaseAimRotation ( class AWeapon* W, unsigned long bIgnoreAutoLock );
};

UClass* UTgControlModule_Spectator::pClassPointer = NULL;

// Class TgGame.TgControlModule_SpectatorFreeCam
// 0x002C (0x0080 - 0x0054)
class UTgControlModule_SpectatorFreeCam : public UTgControlModule_Spectator
{
public:
	float                                              m_RotationVelPitch;                               		// 0x0054 (0x0004) [0x0000000000000000]              
	float                                              m_RotationVelYaw;                                 		// 0x0058 (0x0004) [0x0000000000000000]              
	float                                              m_RotationAccelPitch;                             		// 0x005C (0x0004) [0x0000000000000000]              
	float                                              m_RotationAccelYaw;                               		// 0x0060 (0x0004) [0x0000000000000000]              
	float                                              m_RotationAccelWeightPitch;                       		// 0x0064 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_RotationAccelWeightYaw;                         		// 0x0068 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_RotationDecelWeightPitch;                       		// 0x006C (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_RotationDecelWeightYaw;                         		// 0x0070 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_LastFrameX;                                     		// 0x0074 (0x0004) [0x0000000000000000]              
	float                                              m_LastFrameY;                                     		// 0x0078 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bUseRigidMovement : 1;                          		// 0x007C (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 51769 );

		return pClassPointer;
	};

	void UpdateRotation ( float DeltaTime );
	void ProcessMove ( float DeltaTime, struct FVector newAccel, unsigned char DoubleClickMove, struct FRotator DeltaRot );
	void GetNextTarget ( );
	class APawn* GetNearestPawn ( );
};

UClass* UTgControlModule_SpectatorFreeCam::pClassPointer = NULL;

// Class TgGame.TgSeqAct_ModifyFactorySpawn
// 0x000C (0x00D0 - 0x00C4)
class UTgSeqAct_ModifyFactorySpawn : public USequenceAction
{
public:
	int                                                ItemId;                                           		// 0x00C4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                NumStacks;                                        		// 0x00C8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              Duration;                                         		// 0x00CC (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 52121 );

		return pClassPointer;
	};

};

UClass* UTgSeqAct_ModifyFactorySpawn::pClassPointer = NULL;

// Class TgGame.TgSeqAct_GetBot
// 0x0004 (0x00C8 - 0x00C4)
class UTgSeqAct_GetBot : public USequenceAction
{
public:
	int                                                m_nBotNumber;                                     		// 0x00C4 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 52145 );

		return pClassPointer;
	};

};

UClass* UTgSeqAct_GetBot::pClassPointer = NULL;

// Class TgGame.TgRepInfo_Factory_FireGiantGC2015a
// 0x000C (0x0244 - 0x0238)
class ATgRepInfo_Factory_FireGiantGC2015a : public ATgRepInfo_Factory
{
public:
	unsigned char                                      r_eChestState;                                    		// 0x0238 (0x0001) [0x0000000000000020]              ( CPF_Net )
	float                                              c_ChestOpeningOffset;                             		// 0x023C (0x0004) [0x0000000000000000]              
	unsigned long                                      c_bChestTriggered : 1;                            		// 0x0240 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 52261 );

		return pClassPointer;
	};

	void UpdateChestFromPawn ( float ChestStartOffset );
	void UpdateChestState ( unsigned char NewChestState );
	void eventReplicatedEvent ( struct FName VarName );
};

UClass* ATgRepInfo_Factory_FireGiantGC2015a::pClassPointer = NULL;

// Class TgGame.TgBotFactory_FireGiant_GC2015a
// 0x000D (0x02DD - 0x02D0)
class ATgBotFactory_FireGiant_GC2015a : public ATgBotFactory_Leashed
{
public:
	TArray< class ATgSkeletalMeshActor_FireGiantIntro_GC2015a* > ChestActors;                                      		// 0x02D0 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	unsigned char                                      ChestState;                                       		// 0x02DC (0x0001) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 52270 );

		return pClassPointer;
	};

	void UpdateChestFromPawn ( float fCurrentTimeOffset );
	void UpdateChestFromRepInfo ( unsigned char NewState );
};

UClass* ATgBotFactory_FireGiant_GC2015a::pClassPointer = NULL;

// Class TgGame.TgBotStart
// 0x0000 (0x02B4 - 0x02B4)
class ATgBotStart : public ATgNavigationPoint
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 52317 );

		return pClassPointer;
	};

};

UClass* ATgBotStart::pClassPointer = NULL;

// Class TgGame.TgCameraModule_ApolloChariot
// 0x0000 (0x007C - 0x007C)
class UTgCameraModule_ApolloChariot : public UTgCameraModule_ThirdPerson
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 52454 );

		return pClassPointer;
	};

	void ProcessInput ( class UPlayerInput* PlayerInput, float DeltaTime );
	void OnBecomeInActive ( class UTgCameraModule* NewCamera );
	void UpdateCamera ( class APawn* P, class ATgPlayerCamera* CameraActor, float DeltaTime, struct FTViewTarget* OutVT );
};

UClass* UTgCameraModule_ApolloChariot::pClassPointer = NULL;

// Class TgGame.TgCameraModule_AthenaUlt
// 0x0010 (0x008C - 0x007C)
class UTgCameraModule_AthenaUlt : public UTgCameraModule_ThirdPerson
{
public:
	unsigned long                                      m_bGrabCurrentFOV : 1;                            		// 0x007C (0x0004) [0x0000000000000000] [0x00000001] 
	float                                              m_fInterpSpeed;                                   		// 0x0080 (0x0004) [0x0000000000000000]              
	float                                              m_fAimFOVInterp;                                  		// 0x0084 (0x0004) [0x0000000000000000]              
	float                                              m_fAimFOV;                                        		// 0x0088 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 52474 );

		return pClassPointer;
	};

	void UpdateCamera ( class APawn* P, class ATgPlayerCamera* CameraActor, float DeltaTime, struct FTViewTarget* OutVT );
	void OnBecomeActive ( class UTgCameraModule* OldCamera );
};

UClass* UTgCameraModule_AthenaUlt::pClassPointer = NULL;

// Class TgGame.TgCameraModule_Attached
// 0x0000 (0x0040 - 0x0040)
class UTgCameraModule_Attached : public UTgCameraModule
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 52487 );

		return pClassPointer;
	};

	void UpdateCamera ( class APawn* P, class ATgPlayerCamera* CameraActor, float DeltaTime, struct FTViewTarget* OutVT );
	struct FRotator GetAttachRotation ( class APawn* ViewTarget );
	struct FVector GetAttachLocation ( class APawn* ViewTarget );
};

UClass* UTgCameraModule_Attached::pClassPointer = NULL;

// Class TgGame.TgCameraModule_CamazotzUltimate
// 0x0008 (0x0084 - 0x007C)
class UTgCameraModule_CamazotzUltimate : public UTgCameraModule_ThirdPerson
{
public:
	float                                              fStoredZoomFactor;                                		// 0x007C (0x0004) [0x0000000000000000]              
	float                                              fStoredZoomFactorInterp;                          		// 0x0080 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 52502 );

		return pClassPointer;
	};

	void OnBecomeInActive ( class UTgCameraModule* NewCamera );
	void OnBecomeActive ( class UTgCameraModule* OldCamera );
};

UClass* UTgCameraModule_CamazotzUltimate::pClassPointer = NULL;

// Class TgGame.TgCameraModule_Cinematic
// 0x0000 (0x0040 - 0x0040)
class UTgCameraModule_Cinematic : public UTgCameraModule
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 52512 );

		return pClassPointer;
	};

};

UClass* UTgCameraModule_Cinematic::pClassPointer = NULL;

// Class TgGame.TgCameraModule_Dead
// 0x0000 (0x0054 - 0x0054)
class UTgCameraModule_Dead : public UTgCameraModule_Free
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 52541 );

		return pClassPointer;
	};

};

UClass* UTgCameraModule_Dead::pClassPointer = NULL;

// Class TgGame.TgCameraModule_JingWeiUltimate
// 0x001C (0x0098 - 0x007C)
class UTgCameraModule_JingWeiUltimate : public UTgCameraModule_ThirdPerson
{
public:
	struct FVector                                     m_CamLocation;                                    		// 0x007C (0x000C) [0x0000000000000000]              
	struct FVector                                     m_FollowVelocity;                                 		// 0x0088 (0x000C) [0x0000000000000000]              
	float                                              m_PawnVelocityModifier;                           		// 0x0094 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 52562 );

		return pClassPointer;
	};

	void UpdateCamera ( class APawn* P, class ATgPlayerCamera* CameraActor, float DeltaTime, struct FTViewTarget* OutVT );
	struct FVector GetCamAttachPoint ( class AActor* ViewTarget );
	void OnBecomeActive ( class UTgCameraModule* OldCamera );
	struct FVector GetDefaultCamAttachPoint ( class AActor* ActorTarget );
};

UClass* UTgCameraModule_JingWeiUltimate::pClassPointer = NULL;

// Class TgGame.TgCameraModule_LockToPlane
// 0x0018 (0x0094 - 0x007C)
class UTgCameraModule_LockToPlane : public UTgCameraModule_ThirdPerson
{
public:
	struct FVector                                     m_PlaneNormal;                                    		// 0x007C (0x000C) [0x0000000000000000]              
	struct FVector                                     m_PointOnPlane;                                   		// 0x0088 (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 52583 );

		return pClassPointer;
	};

	struct FVector GetCamAttachPoint ( class AActor* ViewTarget );
	void OnBecomeActive ( class UTgCameraModule* OldCamera );
};

UClass* UTgCameraModule_LockToPlane::pClassPointer = NULL;

// Class TgGame.TgCameraModule_Minotaur
// 0x0000 (0x0040 - 0x0040)
class UTgCameraModule_Minotaur : public UTgCameraModule_Attached
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 52596 );

		return pClassPointer;
	};

	struct FRotator FindGoodActorRotation ( class ATgPawn* P );
	void UpdateCamera ( class APawn* P, class ATgPlayerCamera* CameraActor, float DeltaTime, struct FTViewTarget* OutVT );
};

UClass* UTgCameraModule_Minotaur::pClassPointer = NULL;

// Class TgGame.TgCameraModule_Neith_WorldWeaver
// 0x0010 (0x008C - 0x007C)
class UTgCameraModule_Neith_WorldWeaver : public UTgCameraModule_ThirdPerson
{
public:
	unsigned long                                      m_bGrabCurrentFOV : 1;                            		// 0x007C (0x0004) [0x0000000000000000] [0x00000001] 
	float                                              m_fInterpSpeed;                                   		// 0x0080 (0x0004) [0x0000000000000000]              
	float                                              m_fAimFOVInterp;                                  		// 0x0084 (0x0004) [0x0000000000000000]              
	float                                              m_fAimFOV;                                        		// 0x0088 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 52623 );

		return pClassPointer;
	};

	void UpdateCamera ( class APawn* P, class ATgPlayerCamera* CameraActor, float DeltaTime, struct FTViewTarget* OutVT );
	void OnBecomeActive ( class UTgCameraModule* OldCamera );
};

UClass* UTgCameraModule_Neith_WorldWeaver::pClassPointer = NULL;

// Class TgGame.TgCameraModule_NuWaUltimate
// 0x0000 (0x007C - 0x007C)
class UTgCameraModule_NuWaUltimate : public UTgCameraModule_ThirdPerson
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 52636 );

		return pClassPointer;
	};

};

UClass* UTgCameraModule_NuWaUltimate::pClassPointer = NULL;

// Class TgGame.TgCameraModule_PlayerOverview
// 0x0000 (0x007C - 0x007C)
class UTgCameraModule_PlayerOverview : public UTgCameraModule_ThirdPerson
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 52638 );

		return pClassPointer;
	};

};

UClass* UTgCameraModule_PlayerOverview::pClassPointer = NULL;

// Class TgGame.TgCameraModule_Ram_Ult_AstralArrow
// 0x0008 (0x0084 - 0x007C)
class UTgCameraModule_Ram_Ult_AstralArrow : public UTgCameraModule_ThirdPerson
{
public:
	float                                              fStoredZoomFactor;                                		// 0x007C (0x0004) [0x0000000000000000]              
	float                                              fStoredZoomFactorInterp;                          		// 0x0080 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 52640 );

		return pClassPointer;
	};

	void OnBecomeInActive ( class UTgCameraModule* NewCamera );
	void OnBecomeActive ( class UTgCameraModule* OldCamera );
};

UClass* UTgCameraModule_Ram_Ult_AstralArrow::pClassPointer = NULL;

// Class TgGame.TgCameraModule_SpectatorLockedView
// 0x001C (0x0088 - 0x006C)
class UTgCameraModule_SpectatorLockedView : public UTgCameraModule_Spectator
{
public:
	struct FRotator                                    WorldViewRotation;                                		// 0x006C (0x000C) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      bAutoRotate : 1;                                  		// 0x0078 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	float                                              FOV;                                              		// 0x007C (0x0004) [0x0000000000000000]              
	float                                              ZoomIncrement;                                    		// 0x0080 (0x0004) [0x0000000000000000]              
	int                                                CurrentWorldViewTargetIndex;                      		// 0x0084 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 52719 );

		return pClassPointer;
	};

	void RotateView ( );
	void ZoomOut ( );
	void ZoomIn ( );
	void UpdateCamera ( class APawn* P, class ATgPlayerCamera* CameraActor, float DeltaTime, struct FTViewTarget* OutVT );
	void BlendCameraToLocation ( struct FVector NewLocation, float BlendTime, unsigned long bUseFocalPoint );
	void OnBecomeInActive ( class UTgCameraModule* NewCamera );
	void OnBecomeActive ( class UTgCameraModule* OldCamera );
};

UClass* UTgCameraModule_SpectatorLockedView::pClassPointer = NULL;

// Class TgGame.TgControlModule_SpectatorLockedView
// 0x0008 (0x005C - 0x0054)
class UTgControlModule_SpectatorLockedView : public UTgControlModule_Spectator
{
public:
	float                                              DirectorModeSpectatorStallZ;                      		// 0x0054 (0x0004) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	float                                              DirectorModeSpectatorMinStallZ;                   		// 0x0058 (0x0004) [0x0000000000004002]              ( CPF_Const | CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 52727 );

		return pClassPointer;
	};

	void PlayerMove ( float DeltaTime );
	float GetMinStallZ ( );
	float GetMaxStallZ ( );
};

UClass* UTgControlModule_SpectatorLockedView::pClassPointer = NULL;

// Class TgGame.TgControlModule_SpectatorOverview
// 0x000C (0x0060 - 0x0054)
class UTgControlModule_SpectatorOverview : public UTgControlModule_Spectator
{
public:
	float                                              DirectorModeSpectatorStallZ;                      		// 0x0054 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              DirectorModeSpectatorMinStallZ;                   		// 0x0058 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	unsigned long                                      bIgnoreCapture : 1;                               		// 0x005C (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      bCaptureOnInactive : 1;                           		// 0x005C (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 52822 );

		return pClassPointer;
	};

	void OnRightMouseReleased ( );
	void OnRightMousePressed ( );
	void OnLeftMousePressed ( );
	void UpdateRotation ( float DeltaTime );
	void PlayerMove ( float DeltaTime );
	void ProcessMove ( float DeltaTime, struct FVector newAccel, unsigned char DoubleClickMove, struct FRotator DeltaRot );
	float GetMinStallZ ( );
	float GetMaxStallZ ( );
	void OnBecomeInActive ( class UTgControlModule* NewModule );
	void OnBecomeActive ( class UTgControlModule* OldModule );
};

UClass* UTgControlModule_SpectatorOverview::pClassPointer = NULL;

// Class TgGame.TgCameraModule_SpectatorOverview_Console
// 0x0000 (0x0114 - 0x0114)
class UTgCameraModule_SpectatorOverview_Console : public UTgCameraModule_SpectatorOverview
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 52870 );

		return pClassPointer;
	};

};

UClass* UTgCameraModule_SpectatorOverview_Console::pClassPointer = NULL;

// Class TgGame.TgCameraModule_ThirdPersonVariableHeight
// 0x0004 (0x0080 - 0x007C)
class UTgCameraModule_ThirdPersonVariableHeight : public UTgCameraModule_ThirdPerson
{
public:
	float                                              ZOffset;                                          		// 0x007C (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 52903 );

		return pClassPointer;
	};

	void ZoomOut ( );
	void ZoomIn ( );
	struct FVector GetCamLocationOffset ( struct FRotator PawnRot, class AActor* ViewTarget );
	void OnBecomeActive ( class UTgCameraModule* OldCamera );
};

UClass* UTgCameraModule_ThirdPersonVariableHeight::pClassPointer = NULL;

// Class TgGame.TgCameraModule_Test
// 0x000C (0x008C - 0x0080)
class UTgCameraModule_Test : public UTgCameraModule_ThirdPersonVariableHeight
{
public:
	struct FRotator                                    FixedRotation;                                    		// 0x0080 (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 52915 );

		return pClassPointer;
	};

	void UpdateCamera ( class APawn* P, class ATgPlayerCamera* CameraActor, float DeltaTime, struct FTViewTarget* OutVT );
	struct FVector GetCamLocationOffset ( struct FRotator PawnRot, class AActor* ViewTarget );
};

UClass* UTgCameraModule_Test::pClassPointer = NULL;

// Class TgGame.TgCameraModule_ThirdPerson_Offset
// 0x0000 (0x007C - 0x007C)
class UTgCameraModule_ThirdPerson_Offset : public UTgCameraModule_ThirdPerson
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 52931 );

		return pClassPointer;
	};

};

UClass* UTgCameraModule_ThirdPerson_Offset::pClassPointer = NULL;

// Class TgGame.TgCameraModule_Thor_HammerJump
// 0x0000 (0x007C - 0x007C)
class UTgCameraModule_Thor_HammerJump : public UTgCameraModule_ThirdPerson
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 52933 );

		return pClassPointer;
	};

	void UpdateCamera ( class APawn* P, class ATgPlayerCamera* CameraActor, float DeltaTime, struct FTViewTarget* OutVT );
	struct FVector GetCamAttachPoint ( class AActor* ViewTarget );
};

UClass* UTgCameraModule_Thor_HammerJump::pClassPointer = NULL;

// Class TgGame.TgCameraModule_TopDown
// 0x000C (0x0078 - 0x006C)
class UTgCameraModule_TopDown : public UTgCameraModule_Spectator
{
public:
	struct FRotator                                    WorldViewRotation;                                		// 0x006C (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 52944 );

		return pClassPointer;
	};

	void BlendToTarget ( float BlendTime );
	void OnBecomeInActive ( class UTgCameraModule* NewCamera );
	void OnBecomeActive ( class UTgCameraModule* OldCamera );
	void UpdateCamera ( class APawn* P, class ATgPlayerCamera* CameraActor, float DeltaTime, struct FTViewTarget* OutVT );
};

UClass* UTgCameraModule_TopDown::pClassPointer = NULL;

// Class TgGame.TgControlModule_TopDown
// 0x0004 (0x0058 - 0x0054)
class UTgControlModule_TopDown : public UTgControlModule_Spectator
{
public:
	float                                              DefaultStartHeight;                               		// 0x0054 (0x0004) [0x0000000000004002]              ( CPF_Const | CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 52957 );

		return pClassPointer;
	};

	void PlayerMove ( float DeltaTime );
	void ProcessMove ( float DeltaTime, struct FVector newAccel, unsigned char DoubleClickMove, struct FRotator DeltaRot );
};

UClass* UTgControlModule_TopDown::pClassPointer = NULL;

// Class TgGame.TgSeqEvent_ControlPointOwnershipChange
// 0x0004 (0x00E0 - 0x00DC)
class UTgSeqEvent_ControlPointOwnershipChange : public USequenceEvent
{
public:
	int                                                PointIndex;                                       		// 0x00DC (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 52990 );

		return pClassPointer;
	};

};

UClass* UTgSeqEvent_ControlPointOwnershipChange::pClassPointer = NULL;

// Class TgGame.TgSeqEvent_ControlPointOwnershipChange_Server
// 0x0004 (0x00E0 - 0x00DC)
class UTgSeqEvent_ControlPointOwnershipChange_Server : public USequenceEvent
{
public:
	int                                                PointIndex;                                       		// 0x00DC (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 53037 );

		return pClassPointer;
	};

};

UClass* UTgSeqEvent_ControlPointOwnershipChange_Server::pClassPointer = NULL;

// Class TgGame.TgCTFFlagBase
// 0x000C (0x01FC - 0x01F0)
class ATgCTFFlagBase : public AActor
{
public:
	int                                                m_nDefenderTaskForce;                             		// 0x01F0 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	class ATgCarriedFlag*                              m_SpawnedFlag;                                    		// 0x01F4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class ATgGame_CTF*                                 m_CTFGame;                                        		// 0x01F8 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 53116 );

		return pClassPointer;
	};

	void DestroyFlag ( );
	void SpawnFlag ( );
	void eventTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void CheckTouching ( );
	void eventPostBeginPlay ( );
};

UClass* ATgCTFFlagBase::pClassPointer = NULL;

// Class TgGame.TgControlModule_ApolloChariot
// 0x0010 (0x00AC - 0x009C)
class UTgControlModule_ApolloChariot : public UTgControlModule_ThirdPerson
{
public:
	float                                              m_fPawnTurnMultipler;                             		// 0x009C (0x0004) [0x0000000000000000]              
	struct FRotator                                    m_BodyRotation;                                   		// 0x00A0 (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 53737 );

		return pClassPointer;
	};

	void UpdateRotation ( float DeltaTime );
	struct FVector CalcNewAccel ( );
};

UClass* UTgControlModule_ApolloChariot::pClassPointer = NULL;

// Class TgGame.TgControlModule_Awilix_Reposition
// 0x0000 (0x009C - 0x009C)
class UTgControlModule_Awilix_Reposition : public UTgControlModule_ThirdPerson
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 53754 );

		return pClassPointer;
	};

	void UpdateRotation ( float DeltaTime );
};

UClass* UTgControlModule_Awilix_Reposition::pClassPointer = NULL;

// Class TgGame.TgControlModule_BaseEngine
// 0x0000 (0x0044 - 0x0044)
class UTgControlModule_BaseEngine : public UTgControlModule
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 53764 );

		return pClassPointer;
	};

	void UpdateRotation ( float DeltaTime );
	void PlayerMove ( float DeltaTime );
	void ProcessMove ( float DeltaTime, struct FVector newAccel, unsigned char DoubleClickMove, struct FRotator DeltaRot );
};

UClass* UTgControlModule_BaseEngine::pClassPointer = NULL;

// Class TgGame.TgControlModule_ChironChargeAim
// 0x0010 (0x00AC - 0x009C)
class UTgControlModule_ChironChargeAim : public UTgControlModule_ThirdPerson
{
public:
	float                                              m_fPawnTurnMultipler;                             		// 0x009C (0x0004) [0x0000000000000000]              
	struct FRotator                                    c_DesiredPawnRotation;                            		// 0x00A0 (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 53785 );

		return pClassPointer;
	};

	void UpdateRotation ( float DeltaTime );
	void ProcessMove ( float DeltaTime, struct FVector newAccel, unsigned char DoubleClickMove, struct FRotator DeltaRot );
	struct FVector CalcNewAccel ( );
};

UClass* UTgControlModule_ChironChargeAim::pClassPointer = NULL;

// Class TgGame.TgControlModule_Dead
// 0x0000 (0x0044 - 0x0044)
class UTgControlModule_Dead : public UTgControlModule
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 53803 );

		return pClassPointer;
	};

	void UpdateRotation ( float DeltaTime );
	void PlayerMove ( float DeltaTime );
	void ProcessMove ( float DeltaTime, struct FVector newAccel, unsigned char DoubleClickMove, struct FRotator DeltaRot );
	void OnBecomeActive ( class UTgControlModule* OldModule );
	bool InterceptRawKey ( int ControllerId, struct FName Key, unsigned char Event, float AmountDepressed );
};

UClass* UTgControlModule_Dead::pClassPointer = NULL;

// Class TgGame.TgControlModule_Dummy
// 0x0000 (0x0044 - 0x0044)
class UTgControlModule_Dummy : public UTgControlModule
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 53825 );

		return pClassPointer;
	};

};

UClass* UTgControlModule_Dummy::pClassPointer = NULL;

// Class TgGame.TgControlModule_Free
// 0x0004 (0x0048 - 0x0044)
class UTgControlModule_Free : public UTgControlModule
{
public:
	int                                                CameraYawOffset;                                  		// 0x0044 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 53827 );

		return pClassPointer;
	};

	void UpdateRotation ( float DeltaTime );
	void PlayerMove ( float DeltaTime );
	void ProcessMove ( float DeltaTime, struct FVector newAccel, unsigned char DoubleClickMove, struct FRotator DeltaRot );
	struct FRotator GetBaseAimRotation ( class AWeapon* W, unsigned long bIgnoreAutoLock );
};

UClass* UTgControlModule_Free::pClassPointer = NULL;

// Class TgGame.TgControlModule_Khepri_CrawlBack
// 0x0000 (0x009C - 0x009C)
class UTgControlModule_Khepri_CrawlBack : public UTgControlModule_ThirdPerson
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 53864 );

		return pClassPointer;
	};

	struct FVector CalcNewAccel ( );
};

UClass* UTgControlModule_Khepri_CrawlBack::pClassPointer = NULL;

// Class TgGame.TgControlModule_NeZha_Ultimate
// 0x0000 (0x009C - 0x009C)
class UTgControlModule_NeZha_Ultimate : public UTgControlModule_ThirdPerson
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 53868 );

		return pClassPointer;
	};

	void PlayerMove ( float DeltaTime );
	void ProcessMove ( float DeltaTime, struct FVector newAccel, unsigned char DoubleClickMove, struct FRotator DeltaRot );
};

UClass* UTgControlModule_NeZha_Ultimate::pClassPointer = NULL;

// Class TgGame.TgControlModule_Panicked
// 0x0014 (0x00B0 - 0x009C)
class UTgControlModule_Panicked : public UTgControlModule_ThirdPerson
{
public:
	float                                              c_fLastSwitchTime;                                		// 0x009C (0x0004) [0x0000000000000000]              
	float                                              c_fNextSwitchTime;                                		// 0x00A0 (0x0004) [0x0000000000000000]              
	struct FVector                                     c_vCurrentDirection;                              		// 0x00A4 (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 53877 );

		return pClassPointer;
	};

	void UpdateRotation ( float DeltaTime );
	void ChangeDirections ( );
	struct FVector CalcNewAccel ( );
	void OnBecomeActive ( class UTgControlModule* OldModule );
};

UClass* UTgControlModule_Panicked::pClassPointer = NULL;

// Class TgGame.TgControlModule_PlayerOverview
// 0x0000 (0x009C - 0x009C)
class UTgControlModule_PlayerOverview : public UTgControlModule_ThirdPerson
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 53895 );

		return pClassPointer;
	};

	bool IsFixedPitchMode ( );
	void UpdatePitchCurve ( );
};

UClass* UTgControlModule_PlayerOverview::pClassPointer = NULL;

// Class TgGame.TgControlModule_RatatoskrUltimate
// 0x0000 (0x009C - 0x009C)
class UTgControlModule_RatatoskrUltimate : public UTgControlModule_ThirdPerson
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 53901 );

		return pClassPointer;
	};

	struct FVector CalcNewAccel ( );
};

UClass* UTgControlModule_RatatoskrUltimate::pClassPointer = NULL;

// Class TgGame.TgControlModule_Stunned
// 0x0000 (0x009C - 0x009C)
class UTgControlModule_Stunned : public UTgControlModule_ThirdPerson
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 54060 );

		return pClassPointer;
	};

	void UpdateRotation ( float DeltaTime );
	struct FVector CalcNewAccel ( );
	void ProcessMove ( float DeltaTime, struct FVector newAccel, unsigned char DoubleClickMove, struct FRotator DeltaRot );
};

UClass* UTgControlModule_Stunned::pClassPointer = NULL;

// Class TgGame.TgControlModule_StunDisoriented
// 0x0010 (0x00AC - 0x009C)
class UTgControlModule_StunDisoriented : public UTgControlModule_Stunned
{
public:
	int                                                m_nInitialYaw;                                    		// 0x009C (0x0004) [0x0000000000000000]              
	int                                                m_nTargetYaw;                                     		// 0x00A0 (0x0004) [0x0000000000000000]              
	float                                              m_fInterpTime;                                    		// 0x00A4 (0x0004) [0x0000000000000002]              ( CPF_Const )
	float                                              m_fRemainingInterpTime;                           		// 0x00A8 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 54071 );

		return pClassPointer;
	};

	void UpdateRotation ( float DeltaTime );
	void OnBecomeActive ( class UTgControlModule* OldModule );
};

UClass* UTgControlModule_StunDisoriented::pClassPointer = NULL;

// Class TgGame.TgControlModule_Test
// 0x0000 (0x009C - 0x009C)
class UTgControlModule_Test : public UTgControlModule_ThirdPerson
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 54110 );

		return pClassPointer;
	};

	void AdjustAimingView ( struct FVector* ViewLocation, struct FRotator* ViewRotation );
	void UpdateRotation ( float DeltaTime );
	struct FVector CalcNewAccel ( );
	struct FRotator GetBaseAimRotation ( class AWeapon* W, unsigned long bIgnoreAutoLock );
	void OnBecomeInActive ( class UTgControlModule* NewModule );
	void OnBecomeActive ( class UTgControlModule* OldModule );
};

UClass* UTgControlModule_Test::pClassPointer = NULL;

// Class TgGame.TgCTFVolume
// 0x0004 (0x0268 - 0x0264)
class ATgCTFVolume : public APhysicsVolume
{
public:
	int                                                m_nDefenderTeamIndex;                             		// 0x0264 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 54215 );

		return pClassPointer;
	};

	void eventTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	int SortByTimestamp ( class ATgPawn* A, class ATgPawn* B );
	bool IsValidToucher ( class ATgPawn_Character* TgP );
	void TimerPop ( class AVolumeTimer* T );
};

UClass* ATgCTFVolume::pClassPointer = NULL;

// Class TgGame.TgDamageType_AnubisDeathGaze
// 0x0000 (0x00C8 - 0x00C8)
class UTgDamageType_AnubisDeathGaze : public UTgDamageType
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 54256 );

		return pClassPointer;
	};

};

UClass* UTgDamageType_AnubisDeathGaze::pClassPointer = NULL;

// Class TgGame.TgDamageType_GeneralAfflicted
// 0x0000 (0x00C8 - 0x00C8)
class UTgDamageType_GeneralAfflicted : public UTgDamageType
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 54260 );

		return pClassPointer;
	};

};

UClass* UTgDamageType_GeneralAfflicted::pClassPointer = NULL;

// Class TgGame.TgDamageType_GeneralCharred
// 0x0000 (0x00C8 - 0x00C8)
class UTgDamageType_GeneralCharred : public UTgDamageType
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 54262 );

		return pClassPointer;
	};

};

UClass* UTgDamageType_GeneralCharred::pClassPointer = NULL;

// Class TgGame.TgDamageType_GeneralConcussion
// 0x0000 (0x00C8 - 0x00C8)
class UTgDamageType_GeneralConcussion : public UTgDamageType
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 54265 );

		return pClassPointer;
	};

};

UClass* UTgDamageType_GeneralConcussion::pClassPointer = NULL;

// Class TgGame.TgDamageType_GeneralElectric
// 0x0000 (0x00C8 - 0x00C8)
class UTgDamageType_GeneralElectric : public UTgDamageType
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 54267 );

		return pClassPointer;
	};

};

UClass* UTgDamageType_GeneralElectric::pClassPointer = NULL;

// Class TgGame.TgDamageType_GeneralFlattened
// 0x0000 (0x00C8 - 0x00C8)
class UTgDamageType_GeneralFlattened : public UTgDamageType
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 54269 );

		return pClassPointer;
	};

};

UClass* UTgDamageType_GeneralFlattened::pClassPointer = NULL;

// Class TgGame.TgDamageType_GeneralImpulseOut
// 0x0000 (0x00C8 - 0x00C8)
class UTgDamageType_GeneralImpulseOut : public UTgDamageType
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 54271 );

		return pClassPointer;
	};

};

UClass* UTgDamageType_GeneralImpulseOut::pClassPointer = NULL;

// Class TgGame.TgDamageType_GeneralMidImpulse
// 0x0000 (0x00C8 - 0x00C8)
class UTgDamageType_GeneralMidImpulse : public UTgDamageType
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 54273 );

		return pClassPointer;
	};

};

UClass* UTgDamageType_GeneralMidImpulse::pClassPointer = NULL;

// Class TgGame.TgDamageType_GeneralOnFire
// 0x0000 (0x00C8 - 0x00C8)
class UTgDamageType_GeneralOnFire : public UTgDamageType
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 54275 );

		return pClassPointer;
	};

};

UClass* UTgDamageType_GeneralOnFire::pClassPointer = NULL;

// Class TgGame.TgDamageType_HerculesExcavate
// 0x0000 (0x00C8 - 0x00C8)
class UTgDamageType_HerculesExcavate : public UTgDamageType
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 54277 );

		return pClassPointer;
	};

};

UClass* UTgDamageType_HerculesExcavate::pClassPointer = NULL;

// Class TgGame.TgDamageType_Medusa_Dev2
// 0x0000 (0x00C8 - 0x00C8)
class UTgDamageType_Medusa_Dev2 : public UTgDamageType
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 54279 );

		return pClassPointer;
	};

};

UClass* UTgDamageType_Medusa_Dev2::pClassPointer = NULL;

// Class TgGame.TgDamageType_MegaKill
// 0x0000 (0x00C8 - 0x00C8)
class UTgDamageType_MegaKill : public UTgDamageType_GeneralConcussion
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 54281 );

		return pClassPointer;
	};

};

UClass* UTgDamageType_MegaKill::pClassPointer = NULL;

// Class TgGame.TgDamageType_MeleeBasicAttack
// 0x0000 (0x00C8 - 0x00C8)
class UTgDamageType_MeleeBasicAttack : public UTgDamageType
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 54283 );

		return pClassPointer;
	};

};

UClass* UTgDamageType_MeleeBasicAttack::pClassPointer = NULL;

// Class TgGame.TgDamageType_MeleeBasicAttackImpulse
// 0x0000 (0x00C8 - 0x00C8)
class UTgDamageType_MeleeBasicAttackImpulse : public UTgDamageType
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 54285 );

		return pClassPointer;
	};

	float GetRagdollImpulseMultiplier ( class AActor* DamageInstigator );
};

UClass* UTgDamageType_MeleeBasicAttackImpulse::pClassPointer = NULL;

// Class TgGame.TgDamageType_RaCelestialBeam
// 0x0000 (0x00C8 - 0x00C8)
class UTgDamageType_RaCelestialBeam : public UTgDamageType
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 54291 );

		return pClassPointer;
	};

};

UClass* UTgDamageType_RaCelestialBeam::pClassPointer = NULL;

// Class TgGame.TgDamageType_RangedBasicAttack
// 0x0000 (0x00C8 - 0x00C8)
class UTgDamageType_RangedBasicAttack : public UTgDamageType
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 54293 );

		return pClassPointer;
	};

};

UClass* UTgDamageType_RangedBasicAttack::pClassPointer = NULL;

// Class TgGame.TgDamageType_RangedBasicAttackImpulse
// 0x0000 (0x00C8 - 0x00C8)
class UTgDamageType_RangedBasicAttackImpulse : public UTgDamageType
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 54295 );

		return pClassPointer;
	};

};

UClass* UTgDamageType_RangedBasicAttackImpulse::pClassPointer = NULL;

// Class TgGame.TgDamageType_SobekTailWhip
// 0x0000 (0x00C8 - 0x00C8)
class UTgDamageType_SobekTailWhip : public UTgDamageType
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 54297 );

		return pClassPointer;
	};

};

UClass* UTgDamageType_SobekTailWhip::pClassPointer = NULL;

// Class TgGame.TgDamageType_Terra_MegaPunch
// 0x0000 (0x00C8 - 0x00C8)
class UTgDamageType_Terra_MegaPunch : public UTgDamageType_GeneralConcussion
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 54299 );

		return pClassPointer;
	};

};

UClass* UTgDamageType_Terra_MegaPunch::pClassPointer = NULL;

// Class TgGame.TgDamageType_ThanatosExecute
// 0x0000 (0x00C8 - 0x00C8)
class UTgDamageType_ThanatosExecute : public UTgDamageType_GeneralConcussion
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 54301 );

		return pClassPointer;
	};

};

UClass* UTgDamageType_ThanatosExecute::pClassPointer = NULL;

// Class TgGame.TgDamageType_ThanatosExecuteMinion
// 0x0000 (0x00C8 - 0x00C8)
class UTgDamageType_ThanatosExecuteMinion : public UTgDamageType_ThanatosExecute
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 54303 );

		return pClassPointer;
	};

};

UClass* UTgDamageType_ThanatosExecuteMinion::pClassPointer = NULL;

// Class TgGame.TgDamageType_ThorAnvilOfDawn
// 0x0000 (0x00C8 - 0x00C8)
class UTgDamageType_ThorAnvilOfDawn : public UTgDamageType
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 54305 );

		return pClassPointer;
	};

};

UClass* UTgDamageType_ThorAnvilOfDawn::pClassPointer = NULL;

// Class TgGame.TgDamageType_VulcanBackfire
// 0x0000 (0x00C8 - 0x00C8)
class UTgDamageType_VulcanBackfire : public UTgDamageType
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 54307 );

		return pClassPointer;
	};

};

UClass* UTgDamageType_VulcanBackfire::pClassPointer = NULL;

// Class TgGame.TgDebugCameraController
// 0x0000 (0x05F8 - 0x05F8)
class ATgDebugCameraController : public ADebugCameraController
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 54309 );

		return pClassPointer;
	};

	void DisableDebugCamera ( );
	void Camera ( struct FName NewMode );
};

UClass* ATgDebugCameraController::pClassPointer = NULL;

// Class TgGame.TgDebugCameraInput
// 0x0000 (0x0268 - 0x0268)
class UTgDebugCameraInput : public UDebugCameraInput
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 54316 );

		return pClassPointer;
	};

};

UClass* UTgDebugCameraInput::pClassPointer = NULL;

// Class TgGame.TgDefensePoint
// 0x0018 (0x02CC - 0x02B4)
class ATgDefensePoint : public ATgNavigationPoint
{
public:
	class AController*                                 CurrentUser;                                      		// 0x02B4 (0x0004) [0x0000000000000000]              
	class ATgDefensePoint*                             NextDefensePoint;                                 		// 0x02B8 (0x0004) [0x0000000000000000]              
	unsigned long                                      bFirstScript : 1;                                 		// 0x02BC (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      bSniping : 1;                                     		// 0x02BC (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      bDontChangePosition : 1;                          		// 0x02BC (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      bAvoid : 1;                                       		// 0x02BC (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      bDisabled : 1;                                    		// 0x02BC (0x0004) [0x0000000000000000] [0x00000010] 
	unsigned long                                      bNotInVehicle : 1;                                		// 0x02BC (0x0004) [0x0000000000000001] [0x00000020] ( CPF_Edit )
	unsigned char                                      Priority;                                         		// 0x02C0 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	class UClass*                                      WeaponPreference;                                 		// 0x02C4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              NumChecked;                                       		// 0x02C8 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 54318 );

		return pClassPointer;
	};

	class AActor* GetMoveTarget ( );
	bool HigherPriorityThan ( class ATgDefensePoint* S, class ATgAIController* B );
	void PreBeginPlay ( );
	void FreePoint ( );
	void Reset ( );
};

UClass* ATgDefensePoint::pClassPointer = NULL;

// Class TgGame.TgSeqAct_RestartPlayers
// 0x0000 (0x00C4 - 0x00C4)
class UTgSeqAct_RestartPlayers : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 55293 );

		return pClassPointer;
	};

};

UClass* UTgSeqAct_RestartPlayers::pClassPointer = NULL;

// Class TgGame.TgSeqAct_TgCameraShake
// 0x0008 (0x00CC - 0x00C4)
class UTgSeqAct_TgCameraShake : public USequenceAction
{
public:
	class UTgCameraShake*                              m_CameraShake;                                    		// 0x00C4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class AActor*                                      m_LocationActor;                                  		// 0x00C8 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 55398 );

		return pClassPointer;
	};

};

UClass* UTgSeqAct_TgCameraShake::pClassPointer = NULL;

// Class TgGame.TgSeqAct_LogTutorialAction
// 0x0008 (0x00CC - 0x00C4)
class UTgSeqAct_LogTutorialAction : public USequenceAction
{
public:
	int                                                PlayerAction;                                     		// 0x00C4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                EventData;                                        		// 0x00C8 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 55409 );

		return pClassPointer;
	};

};

UClass* UTgSeqAct_LogTutorialAction::pClassPointer = NULL;

// Class TgGame.TgTutorialAnnouncer
// 0x0014 (0x0050 - 0x003C)
class UTgTutorialAnnouncer : public UObject
{
public:
	TArray< class USoundCue* >                         QueuedSounds;                                     		// 0x003C (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	class UAudioComponent*                             CurrentSoundAC;                                   		// 0x0048 (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )
	class ATgPlayerController*                         OwnerPC;                                          		// 0x004C (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 55603 );

		return pClassPointer;
	};

	void StopAnnouncement ( unsigned long bFlushOthers );
	void PlayAnnouncement ( class USoundCue* CueToPlay, unsigned long bPlayImmediately, unsigned long bFlushOthers );
	void AudioFinishedPlaying ( class UAudioComponent* AC );
	void Destroyed ( );
	void Init ( );
};

UClass* UTgTutorialAnnouncer::pClassPointer = NULL;

// Class TgGame.TgSeqEvent_CrowdEvent
// 0x0000 (0x00DC - 0x00DC)
class UTgSeqEvent_CrowdEvent : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 55620 );

		return pClassPointer;
	};

};

UClass* UTgSeqEvent_CrowdEvent::pClassPointer = NULL;

// Class TgGame.TgSavedMove
// 0x0020 (0x0108 - 0x00E8)
class UTgSavedMove : public USavedMove
{
public:
	unsigned char                                      m_nChargeNumber;                                  		// 0x00E8 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_eChargeState;                                   		// 0x00E9 (0x0001) [0x0000000000000000]              
	int                                                m_nChargeInitialYaw;                              		// 0x00EC (0x0004) [0x0000000000000000]              
	struct FVector                                     m_vChargeInitialLocation;                         		// 0x00F0 (0x000C) [0x0000000000000000]              
	float                                              m_fChargeSpeed;                                   		// 0x00FC (0x0004) [0x0000000000000000]              
	float                                              m_fChargeRange;                                   		// 0x0100 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bChargeIgnoreHumanoidBlocking : 1;              		// 0x0104 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bWantsCharge : 1;                               		// 0x0104 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_bSavedWantsCharge : 1;                          		// 0x0104 (0x0004) [0x0000000000000000] [0x00000004] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 55818 );

		return pClassPointer;
	};

	unsigned char SetFlags ( unsigned char Flags, class APlayerController* PC );
	unsigned char CompressedFlags ( );
	void ResetMoveFor ( class APawn* P );
	void PrepMoveFor ( class APawn* P );
	bool CanCombineWith ( class USavedMove* NewMove, class APawn* inPawn, float MaxDelta );
	void SetMoveFor ( class APlayerController* P, float DeltaTime, struct FVector newAccel, unsigned char InDoubleClick );
	bool IsImportantMove ( struct FVector CompareAccel );
	void PostUpdate ( class APlayerController* P );
	void Clear ( );
};

UClass* UTgSavedMove::pClassPointer = NULL;

// Class TgGame.TgSpectatorTempCam
// 0x0004 (0x0378 - 0x0374)
class ATgSpectatorTempCam : public ADynamicCameraActor
{
public:
	unsigned long                                      bIsViewTarget : 1;                                		// 0x0374 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      bIsBookmark : 1;                                  		// 0x0374 (0x0004) [0x0000000000000000] [0x00000002] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 56011 );

		return pClassPointer;
	};

	void DestroyIfNeeded ( );
	void eventSetIsBookmark ( unsigned long bBookmark );
	void eventEndViewTarget ( class APlayerController* PC );
	void eventBecomeViewTarget ( class APlayerController* PC );
};

UClass* ATgSpectatorTempCam::pClassPointer = NULL;

// Class TgGame.TgDeploy_Bellona_VeniVidiVici
// 0x0000 (0x0310 - 0x0310)
class ATgDeploy_Bellona_VeniVidiVici : public ATgDeploy_EffectVolume
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 57095 );

		return pClassPointer;
	};

};

UClass* ATgDeploy_Bellona_VeniVidiVici::pClassPointer = NULL;

// Class TgGame.TgDeploy_Chronos_SlowTime
// 0x0004 (0x02F8 - 0x02F4)
class ATgDeploy_Chronos_SlowTime : public ATgDeployable
{
public:
	class ATgTimeDilationVolume*                       m_TimeVolume;                                     		// 0x02F4 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 57099 );

		return pClassPointer;
	};

	void Destroyed ( );
	void DestroyIt ( unsigned long bSkipFx );
	void DeployComplete ( );
};

UClass* ATgDeploy_Chronos_SlowTime::pClassPointer = NULL;

// Class TgGame.TgTimeDilationVolume
// 0x0020 (0x0284 - 0x0264)
class ATgTimeDilationVolume : public APhysicsVolume
{
public:
	float                                              m_fTimeMultiplier;                                		// 0x0264 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bAffectInstigator : 1;                          		// 0x0268 (0x0004) [0x0000000000000000] [0x00000001] 
	TArray< class AActor* >                            m_AffectedActors;                                 		// 0x026C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class APawn* >                             m_AffectedPawns;                                  		// 0x0278 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 57101 );

		return pClassPointer;
	};

	void eventDestroyed ( );
	void eventPawnLeavingVolume ( class APawn* Other );
	void eventPawnEnteredVolume ( class APawn* Other );
	void eventActorLeavingVolume ( class AActor* Other );
	void eventActorEnteredVolume ( class AActor* Other );
	void eventPostBeginPlay ( );
};

UClass* ATgTimeDilationVolume::pClassPointer = NULL;

// Class TgGame.TgDeploy_Geb_Ultimate
// 0x0000 (0x0320 - 0x0320)
class ATgDeploy_Geb_Ultimate : public ATgDeploy_HitOnLanded
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 57180 );

		return pClassPointer;
	};

	void FireAmmunitionDeployable ( );
	void OnActorLanded ( class AActor* Other );
	struct FImpactInfo CalcDeviceFire ( struct FVector StartTrace, struct FVector EndTrace, TArray< struct FImpactInfo >* ImpactList );
};

UClass* ATgDeploy_Geb_Ultimate::pClassPointer = NULL;

// Class TgGame.TgDeploy_Ravana_PranaOnslaught
// 0x0000 (0x0398 - 0x0398)
class ATgDeploy_Ravana_PranaOnslaught : public ATgDeploy_ExplodingCylinder
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 57298 );

		return pClassPointer;
	};

};

UClass* ATgDeploy_Ravana_PranaOnslaught::pClassPointer = NULL;

// Class TgGame.TgDeploy_SunWukong_MastersWill
// 0x0000 (0x0310 - 0x0310)
class ATgDeploy_SunWukong_MastersWill : public ATgDeploy_EffectVolume
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 57323 );

		return pClassPointer;
	};

	class AProjectile* SpawnReturnProjectile ( );
	void Cleanup ( );
};

UClass* ATgDeploy_SunWukong_MastersWill::pClassPointer = NULL;

// Class TgGame.TgDeployable_Agni_FlameWave
// 0x0000 (0x0380 - 0x0380)
class ATgDeployable_Agni_FlameWave : public ATgDeploy_MovingEffectVolume
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 57343 );

		return pClassPointer;
	};

};

UClass* ATgDeployable_Agni_FlameWave::pClassPointer = NULL;

// Class TgGame.TgProj_AhMuzenCab_Num2
// 0x0014 (0x02E0 - 0x02CC)
class ATgProj_AhMuzenCab_Num2 : public ATgProj_Simulated
{
public:
	unsigned long                                      m_bInitialHit : 1;                                		// 0x02CC (0x0004) [0x0000000000000000] [0x00000001] 
	TArray< class AActor* >                            m_PreviouslyHitTargets;                           		// 0x02D0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class ATgAhMuzenCabSwarmInstance*                  m_Strain;                                         		// 0x02DC (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 57494 );

		return pClassPointer;
	};

	void ShutDown ( );
	void HitTarget ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal );
	void ProcessTouch ( class AActor* Other, struct FVector HitLocation, struct FVector HitNormal );
};

UClass* ATgProj_AhMuzenCab_Num2::pClassPointer = NULL;

// Class TgGame.TgRepInfo_AhMuzenCab_Stinger
// 0x0000 (0x0364 - 0x0364)
class ATgRepInfo_AhMuzenCab_Stinger : public ATgRepInfo_Deployable
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 57540 );

		return pClassPointer;
	};

};

UClass* ATgRepInfo_AhMuzenCab_Stinger::pClassPointer = NULL;

// Class TgGame.TgDeployable_AhPuch_EmptyTheCrypts
// 0x0030 (0x0324 - 0x02F4)
class ATgDeployable_AhPuch_EmptyTheCrypts : public ATgDeployable
{
public:
	float                                              m_fFiringTimer;                                   		// 0x02F4 (0x0004) [0x0000000000000000]              
	int                                                m_nNumberOfCreepLanes;                            		// 0x02F8 (0x0004) [0x0000000000000000]              
	int                                                m_nCreepsBeforeLaneRepeat;                        		// 0x02FC (0x0004) [0x0000000000000000]              
	int                                                m_nCurrentLane;                                   		// 0x0300 (0x0004) [0x0000000000000000]              
	float                                              m_fMinCreepRefire;                                		// 0x0304 (0x0004) [0x0000000000000000]              
	float                                              m_fMaxCreepRefire;                                		// 0x0308 (0x0004) [0x0000000000000000]              
	struct FVector                                     m_vAdditionalSpawnOffset;                         		// 0x030C (0x000C) [0x0000000000000000]              
	TArray< int >                                      m_LaneHistory;                                    		// 0x0318 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 57611 );

		return pClassPointer;
	};

	void TimeDeviceFiring ( );
	struct FVector GetPhysicalFireAimDirection ( struct FVector fireLoc, struct FVector TargetLocation );
	struct FVector GetPhysicalFireStartLoc ( );
	struct FVector GetLaneCenter ( int nLane, float fLaneWidth, struct FVector Left );
	void FireAmmunitionDeployable ( );
	void AddToLaneHistory ( int nLane );
	int ChooseNextLane ( );
	void eventStartFire ( );
	void eventStartDeploy ( );
};

UClass* ATgDeployable_AhPuch_EmptyTheCrypts::pClassPointer = NULL;

// Class TgGame.TgDeployable_AoKuang_Tempest
// 0x000C (0x0300 - 0x02F4)
class ATgDeployable_AoKuang_Tempest : public ATgDeployable_PulseEffectVolume
{
public:
	TArray< class AActor* >                            m_HitActors;                                      		// 0x02F4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 57676 );

		return pClassPointer;
	};

	void ApplyHit ( TArray< struct FImpactInfo >* ImpactList );
	bool ShouldHit ( class AActor* Other );
};

UClass* ATgDeployable_AoKuang_Tempest::pClassPointer = NULL;

// Class TgGame.TgDeployable_AoKuang_WildStorm
// 0x0004 (0x039C - 0x0398)
class ATgDeployable_AoKuang_WildStorm : public ATgDeploy_ExplodingCylinder
{
public:
	unsigned long                                      m_bUsePassive : 1;                                		// 0x0398 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 57702 );

		return pClassPointer;
	};

	void ApplyHit ( TArray< struct FImpactInfo >* ImpactList );
	void eventStartDeploy ( );
};

UClass* ATgDeployable_AoKuang_WildStorm::pClassPointer = NULL;

// Class TgGame.TgDeployable_Aphrodite_LoveBirds
// 0x0000 (0x0380 - 0x0380)
class ATgDeployable_Aphrodite_LoveBirds : public ATgDeploy_MovingEffectVolume
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 57740 );

		return pClassPointer;
	};

	void TurnCollisionOff ( );
	void TurnCollisionOn ( );
	void FireAmmunitionDeployable ( );
};

UClass* ATgDeployable_Aphrodite_LoveBirds::pClassPointer = NULL;

// Class TgGame.TgDeployable_Athena_ShieldWall
// 0x0004 (0x02F8 - 0x02F4)
class ATgDeployable_Athena_ShieldWall : public ATgDeployable
{
public:
	class UTgAnimNodeSlot*                             m_FullBodyAnimNode;                               		// 0x02F4 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 57847 );

		return pClassPointer;
	};

	void eventPlayFireFx ( );
};

UClass* ATgDeployable_Athena_ShieldWall::pClassPointer = NULL;

// Class TgGame.TgDeployable_Buff_MonsterStacking
// 0x0000 (0x030C - 0x030C)
class ATgDeployable_Buff_MonsterStacking : public ATgDeployable_Buff_Monster
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 57888 );

		return pClassPointer;
	};

	void TriggerBuff ( class AActor* Other );
};

UClass* ATgDeployable_Buff_MonsterStacking::pClassPointer = NULL;

// Class TgGame.TgDeployable_Chaac_Num1Axe
// 0x0000 (0x02F4 - 0x02F4)
class ATgDeployable_Chaac_Num1Axe : public ATgDeployable
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 57976 );

		return pClassPointer;
	};

	void eventDestroyIt ( unsigned long bSkipFx );
	void DeployComplete ( );
};

UClass* ATgDeployable_Chaac_Num1Axe::pClassPointer = NULL;

// Class TgGame.TgDeployable_Chaac_Num3Rain
// 0x0010 (0x0304 - 0x02F4)
class ATgDeployable_Chaac_Num3Rain : public ATgDeployable
{
public:
	class ATgCollisionProxy*                           s_CollisionProxy;                                 		// 0x02F4 (0x0004) [0x0000000000000000]              
	TArray< class AActor* >                            s_AppliedList;                                    		// 0x02F8 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 57987 );

		return pClassPointer;
	};

	void Cleanup ( );
	void eventDestroyed ( );
	void eventDestroyIt ( unsigned long bSkipFx );
	void eventProxyUnTouch ( class AActor* Other );
	void eventProxyTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void DeployComplete ( );
};

UClass* ATgDeployable_Chaac_Num3Rain::pClassPointer = NULL;

// Class TgGame.TgDeployable_Cupid_SpeedPad
// 0x0000 (0x02F4 - 0x02F4)
class ATgDeployable_Cupid_SpeedPad : public ATgDeployable_PulseEffectVolume
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 58061 );

		return pClassPointer;
	};

};

UClass* ATgDeployable_Cupid_SpeedPad::pClassPointer = NULL;

// Class TgGame.TgDeployable_Janus_Transitions
// 0x0000 (0x0310 - 0x0310)
class ATgDeployable_Janus_Transitions : public ATgDeploy_EffectVolume
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 58193 );

		return pClassPointer;
	};

};

UClass* ATgDeployable_Janus_Transitions::pClassPointer = NULL;

// Class TgGame.TgDeployable_Kukulkan_Tempest
// 0x000C (0x0300 - 0x02F4)
class ATgDeployable_Kukulkan_Tempest : public ATgDeployable_PulseEffectVolume
{
public:
	TArray< class AActor* >                            m_HitActors;                                      		// 0x02F4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 58312 );

		return pClassPointer;
	};

	void ApplyHit ( TArray< struct FImpactInfo >* ImpactList );
	bool ShouldHit ( class AActor* Other );
};

UClass* ATgDeployable_Kukulkan_Tempest::pClassPointer = NULL;

// Class TgGame.TgDeployable_Mercury_Num4AOE
// 0x0000 (0x02F4 - 0x02F4)
class ATgDeployable_Mercury_Num4AOE : public ATgDeployable
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 58350 );

		return pClassPointer;
	};

};

UClass* ATgDeployable_Mercury_Num4AOE::pClassPointer = NULL;

// Class TgGame.TgDeployable_NuWa_Fog
// 0x000C (0x0300 - 0x02F4)
class ATgDeployable_NuWa_Fog : public ATgDeployable
{
public:
	TArray< class AActor* >                            m_AlreadyHitOnce;                                 		// 0x02F4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 58441 );

		return pClassPointer;
	};

	void ApplyHit ( TArray< struct FImpactInfo >* ImpactList );
};

UClass* ATgDeployable_NuWa_Fog::pClassPointer = NULL;

// Class TgGame.TgDeployable_NuWa_Meteor
// 0x0000 (0x02F4 - 0x02F4)
class ATgDeployable_NuWa_Meteor : public ATgDeployable
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 58451 );

		return pClassPointer;
	};

	void ApplyHit ( TArray< struct FImpactInfo >* ImpactList );
	void eventStartFire ( );
};

UClass* ATgDeployable_NuWa_Meteor::pClassPointer = NULL;

// Class TgGame.TgDeployable_Ram_Circle
// 0x0000 (0x0310 - 0x0310)
class ATgDeployable_Ram_Circle : public ATgDeploy_EffectVolume
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 58680 );

		return pClassPointer;
	};

};

UClass* ATgDeployable_Ram_Circle::pClassPointer = NULL;

// Class TgGame.TgDeployable_Ratatoskr_ExplosiveAcorn
// 0x0000 (0x02F4 - 0x02F4)
class ATgDeployable_Ratatoskr_ExplosiveAcorn : public ATgDeployable
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 58697 );

		return pClassPointer;
	};

	struct FImpactInfo CalcDeviceFire ( struct FVector StartTrace, struct FVector EndTrace, TArray< struct FImpactInfo >* ImpactList );
};

UClass* ATgDeployable_Ratatoskr_ExplosiveAcorn::pClassPointer = NULL;

// Class TgGame.TgDeployable_Ratatoskr_Tree
// 0x0010 (0x0304 - 0x02F4)
class ATgDeployable_Ratatoskr_Tree : public ATgDeployable
{
public:
	float                                              m_fOpacity;                                       		// 0x02F4 (0x0004) [0x0000000000000000]              
	struct FName                                       m_OpacityParamName;                               		// 0x02F8 (0x0008) [0x0000000000000000]              
	float                                              m_fOpacityFadeOutTime;                            		// 0x0300 (0x0004) [0x0000000000000002]              ( CPF_Const )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 58710 );

		return pClassPointer;
	};

	void Tick ( float DeltaSeconds );
};

UClass* ATgDeployable_Ratatoskr_Tree::pClassPointer = NULL;

// Class TgGame.TgDeployable_Scylla_Number2
// 0x0000 (0x0310 - 0x0310)
class ATgDeployable_Scylla_Number2 : public ATgDeploy_EffectVolume
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 58729 );

		return pClassPointer;
	};

	void eventDestroyIt ( unsigned long bSkipIt );
	void DeployComplete ( );
};

UClass* ATgDeployable_Scylla_Number2::pClassPointer = NULL;

// Class TgGame.TgDeployable_ScyllaWardNoLOS
// 0x0000 (0x0328 - 0x0328)
class ATgDeployable_ScyllaWardNoLOS : public ATgDeployable_ScyllaWard
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 58743 );

		return pClassPointer;
	};

};

UClass* ATgDeployable_ScyllaWardNoLOS::pClassPointer = NULL;

// Class TgGame.TgDeployable_Skadi_Ice
// 0x0000 (0x0314 - 0x0314)
class ATgDeployable_Skadi_Ice : public ATgDeploy_Scaling_EffectVolume
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 58751 );

		return pClassPointer;
	};

	void ApplyHit ( TArray< struct FImpactInfo >* ImpactList );
};

UClass* ATgDeployable_Skadi_Ice::pClassPointer = NULL;

// Class TgGame.TgDevice_Susano_Dev4
// 0x0000 (0x039C - 0x039C)
class ATgDevice_Susano_Dev4 : public ATgDevice_TogglableDeployable
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 58855 );

		return pClassPointer;
	};

	void OnTravelStarted ( class ATgDeployable* deployable );
};

UClass* ATgDevice_Susano_Dev4::pClassPointer = NULL;

// Class TgGame.TgDeployable_Thanatos_DeathGrip
// 0x0000 (0x02F4 - 0x02F4)
class ATgDeployable_Thanatos_DeathGrip : public ATgDeployable
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 59033 );

		return pClassPointer;
	};

	void FireAmmunitionDeployable ( );
};

UClass* ATgDeployable_Thanatos_DeathGrip::pClassPointer = NULL;

// Class TgGame.TgDeployable_Vulcan_ProximityMine
// 0x0000 (0x033C - 0x033C)
class ATgDeployable_Vulcan_ProximityMine : public ATgDeployable_TriggerableWard
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 59144 );

		return pClassPointer;
	};

	void eventSpawningDeviceToggledOff ( );
	void eventDestroyIt ( unsigned long bSkipIt );
};

UClass* ATgDeployable_Vulcan_ProximityMine::pClassPointer = NULL;

// Class TgGame.TgDeployable_WardSentryNoLOS
// 0x0000 (0x0320 - 0x0320)
class ATgDeployable_WardSentryNoLOS : public ATgDeployable_WardSentry
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 59153 );

		return pClassPointer;
	};

};

UClass* ATgDeployable_WardSentryNoLOS::pClassPointer = NULL;

// Class TgGame.TgDeployable_Zeus_Shield
// 0x0010 (0x0304 - 0x02F4)
class ATgDeployable_Zeus_Shield : public ATgDeployable
{
public:
	TArray< int >                                      m_HitProjectiles;                                 		// 0x02F4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                r_nExplodeTicker;                                 		// 0x0300 (0x0004) [0x0000000000000020]              ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 59179 );

		return pClassPointer;
	};

	void HitByProjectile ( class ATgProj_Simulated* Proj );
	void ApplyHit ( TArray< struct FImpactInfo >* ImpactList );
	void eventDestroyIt ( unsigned long bSkipFx );
	void SpawnReturnProjectile ( );
	void eventInitReplicationInfo ( );
	void PlaySpecialExplodeFx ( );
	void FlashSpecialExplodeFx ( );
	void InstantFireDeployable ( );
	void eventReplicatedEvent ( struct FName VarName );
};

UClass* ATgDeployable_Zeus_Shield::pClassPointer = NULL;

// Class TgGame.TgRepInfo_ZeusShield
// 0x0000 (0x0364 - 0x0364)
class ATgRepInfo_ZeusShield : public ATgRepInfo_Deployable
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 59216 );

		return pClassPointer;
	};

};

UClass* ATgRepInfo_ZeusShield::pClassPointer = NULL;

// Class TgGame.TgDeployable_ZeusV2_LightningStorm
// 0x0004 (0x02F8 - 0x02F4)
class ATgDeployable_ZeusV2_LightningStorm : public ATgDeployable
{
public:
	unsigned long                                      m_bFirstHit : 1;                                  		// 0x02F4 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 59217 );

		return pClassPointer;
	};

	void FireAmmunitionDeployable ( );
};

UClass* ATgDeployable_ZeusV2_LightningStorm::pClassPointer = NULL;

// Class TgGame.TgDeployable_ZhongKui_Exorcism
// 0x0000 (0x0380 - 0x0380)
class ATgDeployable_ZhongKui_Exorcism : public ATgDeployable_ChangE_Sweep
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 59222 );

		return pClassPointer;
	};

	void TurnCollisionOff ( );
	void TurnCollisionOn ( );
};

UClass* ATgDeployable_ZhongKui_Exorcism::pClassPointer = NULL;

// Class TgGame.TgDeployable_ZhongKui_ExorcismSplit
// 0x0000 (0x0380 - 0x0380)
class ATgDeployable_ZhongKui_ExorcismSplit : public ATgDeployable_ChangE_Sweep
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 59227 );

		return pClassPointer;
	};

	void DeployComplete ( );
};

UClass* ATgDeployable_ZhongKui_ExorcismSplit::pClassPointer = NULL;

// Class TgGame.TgDevice_AoKuang_BasicAttack
// 0x0004 (0x03C4 - 0x03C0)
class ATgDevice_AoKuang_BasicAttack : public ATgDevice_ChainedMelee
{
public:
	unsigned long                                      m_bFromSheath : 1;                                		// 0x03C0 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 90864 );

		return pClassPointer;
	};

	void eventDeliverQueuedPendingHits ( );
};

UClass* ATgDevice_AoKuang_BasicAttack::pClassPointer = NULL;

// Class TgGame.TgProj_AoKuang_DragonCall
// 0x0008 (0x02D4 - 0x02CC)
class ATgProj_AoKuang_DragonCall : public ATgProj_Simulated
{
public:
	unsigned long                                      m_bUsePassive : 1;                                		// 0x02CC (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	int                                                m_nNumDragonsAbsorbed;                            		// 0x02D0 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 90910 );

		return pClassPointer;
	};

	bool ApplyHit ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal, int HitItem );
};

UClass* ATgProj_AoKuang_DragonCall::pClassPointer = NULL;

// Class TgGame.TgDevice_ThorAnvilStaging
// 0x0000 (0x03AC - 0x03AC)
class ATgDevice_ThorAnvilStaging : public ATgDevice_Staging
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 91108 );

		return pClassPointer;
	};

	bool FireEndStageDevice ( );
	void eventOnStageShooterStopFire ( unsigned long bInterrupted );
	void eventOnStageShooterStartBuildup ( );
};

UClass* ATgDevice_ThorAnvilStaging::pClassPointer = NULL;

// Class TgGame.TgDevice_AoKuang_UltimateStaging
// 0x0008 (0x03B4 - 0x03AC)
class ATgDevice_AoKuang_UltimateStaging : public ATgDevice_ThorAnvilStaging
{
public:
	int                                                s_nCooldownMode;                                  		// 0x03AC (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bUsePassive : 1;                                		// 0x03B0 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 91107 );

		return pClassPointer;
	};

	struct FImpactInfo CalcWeaponFire ( struct FAimData Aim, TArray< struct FImpactInfo >* ImpactList );
	void ClientStartSecondStage ( );
	bool StartSecondStage ( int nCooldownMode );
};

UClass* ATgDevice_AoKuang_UltimateStaging::pClassPointer = NULL;

// Class TgGame.TgDevice_AoKuang_WildStorm
// 0x0004 (0x038C - 0x0388)
class ATgDevice_AoKuang_WildStorm : public ATgDevice_Deployable
{
public:
	unsigned long                                      c_bUsingEnergy : 1;                               		// 0x0388 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 91411 );

		return pClassPointer;
	};

	void eventDeviceConsumePowerPool ( unsigned char FireModeNum );
};

UClass* ATgDevice_AoKuang_WildStorm::pClassPointer = NULL;

// Class TgGame.TgDevice_Aphrodite_ManaToHealth
// 0x0000 (0x0388 - 0x0388)
class ATgDevice_Aphrodite_ManaToHealth : public ATgDevice_HitPulse
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 91517 );

		return pClassPointer;
	};

	void CustomFire ( );
};

UClass* ATgDevice_Aphrodite_ManaToHealth::pClassPointer = NULL;

// Class TgGame.TgDevice_Apollo_ChariotSummon
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_Apollo_ChariotSummon : public ATgDevice_Range
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 91550 );

		return pClassPointer;
	};

	bool eventShouldLockFiring ( class ATgDevice* Current );
};

UClass* ATgDevice_Apollo_ChariotSummon::pClassPointer = NULL;

// Class TgGame.TgDevice_ApolloInHand
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_ApolloInHand : public ATgDevice
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 91579 );

		return pClassPointer;
	};

	void FireAmmunition ( );
};

UClass* ATgDevice_ApolloInHand::pClassPointer = NULL;

// Class TgGame.TgDevice_Arachne_CreepyCrawly
// 0x0000 (0x03AC - 0x03AC)
class ATgDevice_Arachne_CreepyCrawly : public ATgDevice_Staging
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 91591 );

		return pClassPointer;
	};

	bool FireEndStageDevice ( );
	void eventOnStageShooterStopFire ( unsigned long bInterrupted );
	void eventOnStageShooterStartBuildup ( );
};

UClass* ATgDevice_Arachne_CreepyCrawly::pClassPointer = NULL;

// Class TgGame.TgDevice_Arachne_CreepyCrawlyShooter
// 0x0000 (0x0398 - 0x0398)
class ATgDevice_Arachne_CreepyCrawlyShooter : public ATgDevice_AnvilSlamBase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 91618 );

		return pClassPointer;
	};

};

UClass* ATgDevice_Arachne_CreepyCrawlyShooter::pClassPointer = NULL;

// Class TgGame.TgDevice_Arachne_Stim
// 0x000C (0x038C - 0x0380)
class ATgDevice_Arachne_Stim : public ATgDevice
{
public:
	TArray< int >                                      m_DoNotBlockFiring;                               		// 0x0380 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 91634 );

		return pClassPointer;
	};

	bool eventShouldInterruptInhand ( );
	bool eventApplyGlobalOffhandCooldown ( );
	bool eventShouldLockFiring ( class ATgDevice* Current );
};

UClass* ATgDevice_Arachne_Stim::pClassPointer = NULL;

// Class TgGame.TgDevice_Ares_Tether
// 0x000C (0x038C - 0x0380)
class ATgDevice_Ares_Tether : public ATgDevice
{
public:
	TArray< struct FImpactInfo >                       ImpactsOnFireStart;                               		// 0x0380 (0x000C) [0x0000000000480000]              ( CPF_Component | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 91720 );

		return pClassPointer;
	};

	struct FImpactInfo CalcWeaponFire ( struct FAimData Aim, TArray< struct FImpactInfo >* ImpactList );
};

UClass* ATgDevice_Ares_Tether::pClassPointer = NULL;

// Class TgGame.TgDevice_Artemis_Inhand
// 0x0008 (0x0388 - 0x0380)
class ATgDevice_Artemis_Inhand : public ATgDevice_Range
{
public:
	class ATgPawn_Artemis*                             m_Artemis;                                        		// 0x0380 (0x0004) [0x0000000000000000]              
	int                                                m_ProjOverrideId;                                 		// 0x0384 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 91738 );

		return pClassPointer;
	};

	int GetProjectileIDOverride ( int ProjectileIndex );
};

UClass* ATgDevice_Artemis_Inhand::pClassPointer = NULL;

// Class TgGame.TgDevice_Athena_DefenderOfOlympus
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_Athena_DefenderOfOlympus : public ATgDevice
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 91746 );

		return pClassPointer;
	};

	bool eventShouldTriggerCastReactionItems ( );
	bool eventShouldInterruptInhand ( );
};

UClass* ATgDevice_Athena_DefenderOfOlympus::pClassPointer = NULL;

// Class TgGame.TgDevice_Athena_DefenderOfOlympusShooter
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_Athena_DefenderOfOlympusShooter : public ATgDevice_LockOnShooter
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 91758 );

		return pClassPointer;
	};

	void eventInterruptFiring ( );
};

UClass* ATgDevice_Athena_DefenderOfOlympusShooter::pClassPointer = NULL;

// Class TgGame.TgDevice_Athena_LeapingLunge
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_Athena_LeapingLunge : public ATgDevice
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 91765 );

		return pClassPointer;
	};

	void eventInterruptFiring ( );
	bool eventShouldInterruptInhand ( );
	bool eventShouldTriggerCastReactionItems ( );
};

UClass* ATgDevice_Athena_LeapingLunge::pClassPointer = NULL;

// Class TgGame.TgDevice_Athena_LeapingLungeSub
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_Athena_LeapingLungeSub : public ATgDevice
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 91775 );

		return pClassPointer;
	};

	bool eventCanBeCanceled ( );
	void eventInterruptFiring ( );
};

UClass* ATgDevice_Athena_LeapingLungeSub::pClassPointer = NULL;

// Class TgGame.TgDevice_AthenaInHand
// 0x0000 (0x03C0 - 0x03C0)
class ATgDevice_AthenaInHand : public ATgDevice_ChainedMelee
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 91783 );

		return pClassPointer;
	};

};

UClass* ATgDevice_AthenaInHand::pClassPointer = NULL;

// Class TgGame.TgDevice_Aura_PawnsInProximity
// 0x0000 (0x0398 - 0x0398)
class ATgDevice_Aura_PawnsInProximity : public ATgDevice_PassiveAura
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 91792 );

		return pClassPointer;
	};

	void eventRemoveFromAllHitAura ( );
	bool RemoveHitAura ( class AActor* Other, unsigned long bRemoveFromList );
	void ApplyHitAura ( class AActor* Other );
};

UClass* ATgDevice_Aura_PawnsInProximity::pClassPointer = NULL;

// Class TgGame.TgDevice_Awilix_KittenCannon
// 0x0000 (0x0388 - 0x0388)
class ATgDevice_Awilix_KittenCannon : public ATgDevice_Deployable
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 91893 );

		return pClassPointer;
	};

};

UClass* ATgDevice_Awilix_KittenCannon::pClassPointer = NULL;

// Class TgGame.TgDevice_Awilix_MountLeap
// 0x0001 (0x0381 - 0x0380)
class ATgDevice_Awilix_MountLeap : public ATgDevice
{
public:
	unsigned char                                      m_LeapTweenState;                                 		// 0x0380 (0x0001) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 91914 );

		return pClassPointer;
	};

	void eventInterruptFiring ( );
	bool eventCanJumpWhileFiring ( );
	bool eventShouldTriggerCastReactionItems ( );
	bool eventApplyGlobalOffhandCooldown ( );
	bool eventShouldInterruptInhand ( );
	bool eventCanBeCanceled ( );
};

UClass* ATgDevice_Awilix_MountLeap::pClassPointer = NULL;

// Class TgGame.TgDevice_Bacchus_BellyFlop
// 0x0000 (0x0388 - 0x0388)
class ATgDevice_Bacchus_BellyFlop : public ATgDevice_TweenBase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 92013 );

		return pClassPointer;
	};

};

UClass* ATgDevice_Bacchus_BellyFlop::pClassPointer = NULL;

// Class TgGame.TgDevice_BastetPounceV2
// 0x0000 (0x03B0 - 0x03B0)
class ATgDevice_BastetPounceV2 : public ATgDevice_BastetPounce
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 92121 );

		return pClassPointer;
	};

	void FireAmmunition ( );
	bool ShouldConsumePowerPoolAfterFire ( );
	void StartPounceForwardCooldown ( );
};

UClass* ATgDevice_BastetPounceV2::pClassPointer = NULL;

// Class TgGame.TgDevice_Bellona_Scourge
// 0x0001 (0x0381 - 0x0380)
class ATgDevice_Bellona_Scourge : public ATgDevice
{
public:
	unsigned char                                      m_eSwitchToSet;                                   		// 0x0380 (0x0001) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 92129 );

		return pClassPointer;
	};

	void eventInterruptFiring ( );
};

UClass* ATgDevice_Bellona_Scourge::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_HouYi_DiveBomb
// 0x0000 (0x0198 - 0x0198)
class UTgDeviceForm_HouYi_DiveBomb : public UTgDeviceForm_TwoPhase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 92437 );

		return pClassPointer;
	};

};

UClass* UTgDeviceForm_HouYi_DiveBomb::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_Bellona_SpinToStrike
// 0x0000 (0x0198 - 0x0198)
class UTgDeviceForm_Bellona_SpinToStrike : public UTgDeviceForm_HouYi_DiveBomb
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 92436 );

		return pClassPointer;
	};

};

UClass* UTgDeviceForm_Bellona_SpinToStrike::pClassPointer = NULL;

// Class TgGame.TgDevice_Cabrakan_Basic
// 0x0000 (0x03C0 - 0x03C0)
class ATgDevice_Cabrakan_Basic : public ATgDevice_ChainedMelee
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 92483 );

		return pClassPointer;
	};

	bool eventShouldLockFiring ( class ATgDevice* Current );
};

UClass* ATgDevice_Cabrakan_Basic::pClassPointer = NULL;

// Class TgGame.TgDevice_Cabrakan_Dev1
// 0x001C (0x03CC - 0x03B0)
class ATgDevice_Cabrakan_Dev1 : public ATgDevice_Charge
{
public:
	struct FVector                                     m_fStartLocation;                                 		// 0x03B0 (0x000C) [0x0000000000000000]              
	unsigned char                                      m_bHitBlocker;                                    		// 0x03BC (0x0001) [0x0000000000000000]              
	TArray< struct FChargeHitInfo >                    m_HitInfos;                                       		// 0x03C0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 92489 );

		return pClassPointer;
	};

	bool eventStartFire ( );
	bool eventCanBeCanceled ( );
};

UClass* ATgDevice_Cabrakan_Dev1::pClassPointer = NULL;

// Class TgGame.TgDevice_Cabrakan_Dev4_Ult
// 0x0000 (0x0388 - 0x0388)
class ATgDevice_Cabrakan_Dev4_Ult : public ATgDevice_Deployable
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 92533 );

		return pClassPointer;
	};

};

UClass* ATgDevice_Cabrakan_Dev4_Ult::pClassPointer = NULL;

// Class TgGame.TgDevice_Cabrakan_ShadowZone
// 0x0000 (0x0398 - 0x0398)
class ATgDevice_Cabrakan_ShadowZone : public ATgDevice_PassiveAura
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 92535 );

		return pClassPointer;
	};

};

UClass* ATgDevice_Cabrakan_ShadowZone::pClassPointer = NULL;

// Class TgGame.TgDevice_Camazotz_ToothAndNail
// 0x0000 (0x0388 - 0x0388)
class ATgDevice_Camazotz_ToothAndNail : public ATgDevice_TweenBase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 92605 );

		return pClassPointer;
	};

	bool eventCanBeCanceled ( );
};

UClass* ATgDevice_Camazotz_ToothAndNail::pClassPointer = NULL;

// Class TgGame.TgProj_Chiron_Passive
// 0x0004 (0x02EC - 0x02E8)
class ATgProj_Chiron_Passive : public ATgProj_SimulatedSeeking
{
public:
	int                                                m_nChironLevel;                                   		// 0x02E8 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 92672 );

		return pClassPointer;
	};

	bool eventUseAOE ( );
	bool ApplyHit ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal, int HitItem );
	void UpdateSeekingDirection ( float fDeltaTime );
};

UClass* ATgProj_Chiron_Passive::pClassPointer = NULL;

// Class TgGame.TgDevice_Chronos_Fast
// 0x0000 (0x0388 - 0x0388)
class ATgDevice_Chronos_Fast : public ATgDevice_TogglableHitPulse
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 92782 );

		return pClassPointer;
	};

	bool eventShouldTriggerCastReactionItems ( );
	bool eventShouldLockFiring ( class ATgDevice* Current );
	bool eventCanBeCanceled ( );
};

UClass* ATgDevice_Chronos_Fast::pClassPointer = NULL;

// Class TgGame.TgDevice_ErlangShen_Pin
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_ErlangShen_Pin : public ATgDevice_Range
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 92870 );

		return pClassPointer;
	};

	int GetAnimMode ( float fAimDist );
	void HandleDeviceFormStartFire ( int nDeviceModeNum, float fRefireTime, struct FAimData* Aim );
};

UClass* ATgDevice_ErlangShen_Pin::pClassPointer = NULL;

// Class TgGame.TgDevice_Fenrir_DoubleTargetLeap
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_Fenrir_DoubleTargetLeap : public ATgDevice
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 93301 );

		return pClassPointer;
	};

};

UClass* ATgDevice_Fenrir_DoubleTargetLeap::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Fenrir_DoubleLeap
// 0x0004 (0x017C - 0x0178)
class UTgDeviceFire_Fenrir_DoubleLeap : public UTgDeviceFire
{
public:
	float                                              m_fCooldownTimeModifier;                          		// 0x0178 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 93305 );

		return pClassPointer;
	};

	float eventGetCooldownTime ( );
	bool eventApplyHit ( struct FImpactInfo Impact, class AActor* DamageInstigator );
	void SetCooldownModifier ( float NewValue );
};

UClass* UTgDeviceFire_Fenrir_DoubleLeap::pClassPointer = NULL;

// Class TgGame.TgDevice_Fenrir_Ragnarok
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_Fenrir_Ragnarok : public ATgDevice
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 93317 );

		return pClassPointer;
	};

	void eventInterruptFiring ( );
	bool eventCanBeCanceled ( );
};

UClass* ATgDevice_Fenrir_Ragnarok::pClassPointer = NULL;

// Class TgGame.TgDevice_Freya_CloakOfFeathers
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_Freya_CloakOfFeathers : public ATgDevice
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 93325 );

		return pClassPointer;
	};

	void ClientInterrupt ( );
	void eventInterruptFiring ( );
	bool CloakTakedown ( );
};

UClass* ATgDevice_Freya_CloakOfFeathers::pClassPointer = NULL;

// Class TgGame.TgDevice_Freya_ValkyrieShooter
// 0x0002 (0x0388 - 0x0386)
class ATgDevice_Freya_ValkyrieShooter : public ATgDevice_TimerFromParent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 93331 );

		return pClassPointer;
	};

};

UClass* ATgDevice_Freya_ValkyrieShooter::pClassPointer = NULL;

// Class TgGame.TgDevice_Geb_Boulder
// 0x000C (0x03BC - 0x03B0)
class ATgDevice_Geb_Boulder : public ATgDevice_Charge
{
public:
	float                                              m_fStartChargeTimeStamp;                          		// 0x03B0 (0x0004) [0x0000000000000000]              
	float                                              m_fStartFireGroundSpeed;                          		// 0x03B4 (0x0004) [0x0000000000000000]              
	class UTgEffectGroup*                              s_CCImmunity;                                     		// 0x03B8 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 93442 );

		return pClassPointer;
	};

	void InstantFire ( );
	float CalcFinalSpeed ( );
	void DeviceShutDown ( unsigned long bDeactiveMode, unsigned long bResetCooldowns );
	void RemoveCCImmunity ( );
	void ApplyDamageReduction ( struct FImpactInfo* Impact );
	bool ShouldApplyHitSpecialOnTouch ( class AActor* Target );
	float GetAccelTime ( );
	void TransformBack ( );
	void TransformTo ( );
	bool eventCanBeCanceled ( );
};

UClass* ATgDevice_Geb_Boulder::pClassPointer = NULL;

// Class TgGame.TgDevice_Geb_Boulder_PVERounds
// 0x0000 (0x03BC - 0x03BC)
class ATgDevice_Geb_Boulder_PVERounds : public ATgDevice_Geb_Boulder
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 93509 );

		return pClassPointer;
	};

};

UClass* ATgDevice_Geb_Boulder_PVERounds::pClassPointer = NULL;

// Class TgGame.TgDevice_Geb_Shield
// 0x0000 (0x0384 - 0x0384)
class ATgDevice_Geb_Shield : public ATgDevice_GroundTarget_LockOn
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 93519 );

		return pClassPointer;
	};

};

UClass* ATgDevice_Geb_Shield::pClassPointer = NULL;

// Class TgGame.TgDevice_GuanYuV2UltDismount
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_GuanYuV2UltDismount : public ATgDevice_Melee
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 93521 );

		return pClassPointer;
	};

	bool eventApplyGlobalOffhandCooldown ( );
};

UClass* ATgDevice_GuanYuV2UltDismount::pClassPointer = NULL;

// Class TgGame.TgDevice_GuanYuV2UltShooter
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_GuanYuV2UltShooter : public ATgDevice_Melee
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 93525 );

		return pClassPointer;
	};

	bool eventApplyGlobalOffhandCooldown ( );
};

UClass* ATgDevice_GuanYuV2UltShooter::pClassPointer = NULL;

// Class TgGame.TgDevice_HeBo_CrushingWave
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_HeBo_CrushingWave : public ATgDevice_Range
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 93529 );

		return pClassPointer;
	};

	bool eventShouldLockFiring ( class ATgDevice* Current );
};

UClass* ATgDevice_HeBo_CrushingWave::pClassPointer = NULL;

// Class TgGame.TgDevice_Hercules_BatterUp
// 0x0000 (0x0384 - 0x0384)
class ATgDevice_Hercules_BatterUp : public ATgDevice_GroundTarget_LockOn
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 93542 );

		return pClassPointer;
	};

};

UClass* ATgDevice_Hercules_BatterUp::pClassPointer = NULL;

// Class TgGame.TgDevice_HouYi_DivebombStaging
// 0x0000 (0x03AC - 0x03AC)
class ATgDevice_HouYi_DivebombStaging : public ATgDevice_Staging
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 93671 );

		return pClassPointer;
	};

	bool FireEndStageDevice ( );
	void ClientInterrupt ( );
	bool eventCanBeInterrupted ( );
};

UClass* ATgDevice_HouYi_DivebombStaging::pClassPointer = NULL;

// Class TgGame.TgDevice_HouYi_GoldenCrow
// 0x0000 (0x0384 - 0x0384)
class ATgDevice_HouYi_GoldenCrow : public ATgDevice_GroundTarget_LockOn
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 93696 );

		return pClassPointer;
	};

	bool eventUsesTrackingTarget ( );
};

UClass* ATgDevice_HouYi_GoldenCrow::pClassPointer = NULL;

// Class TgGame.TgDevice_Isis_DeathWard
// 0x0000 (0x0384 - 0x0384)
class ATgDevice_Isis_DeathWard : public ATgDevice_GroundTarget_LockOn
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 93713 );

		return pClassPointer;
	};

};

UClass* ATgDevice_Isis_DeathWard::pClassPointer = NULL;

// Class TgGame.TgDevice_Izanami_Dev2
// 0x0004 (0x0384 - 0x0380)
class ATgDevice_Izanami_Dev2 : public ATgDevice_Range
{
public:
	unsigned long                                      m_bHasMasStacks : 1;                              		// 0x0380 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 93782 );

		return pClassPointer;
	};

	int GetProjectileIDOverride ( int ProjectileIndex );
};

UClass* ATgDevice_Izanami_Dev2::pClassPointer = NULL;

// Class TgGame.TgDevice_Jumong_FanOfArrows
// 0x001C (0x039C - 0x0380)
class ATgDevice_Jumong_FanOfArrows : public ATgDevice
{
public:
	int                                                s_CurrentFanId;                                   		// 0x0380 (0x0004) [0x0000000000000000]              
	TArray< struct ATgDevice_Jumong_FanOfArrows_FFanInformation > s_FanInfos;                                       		// 0x0384 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class ATgProj_Jumong_FanArrow* >           s_SpawnedProjectiles;                             		// 0x0390 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 94221 );

		return pClassPointer;
	};

	void eventGetAdjustedAim ( int nShotIndex, struct FAimData* Aim );
	class AProjectile* ProjectileFire ( int ProjectileIndex );
	void OnProjectileDestroyed ( class ATgProj_Jumong_FanArrow* SpawnedProjectile );
	void FireAmmunition ( );
};

UClass* ATgDevice_Jumong_FanOfArrows::pClassPointer = NULL;

// Class TgGame.TgProj_Jumong_FanArrow
// 0x0004 (0x02D0 - 0x02CC)
class ATgProj_Jumong_FanArrow : public ATgProj_Simulated
{
public:
	int                                                s_FanId;                                          		// 0x02CC (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 94227 );

		return pClassPointer;
	};

	void Destroyed ( );
	bool ApplyHit ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal, int HitItem );
};

UClass* ATgProj_Jumong_FanArrow::pClassPointer = NULL;

// Class TgGame.TgDevice_Kaldr_Basic
// 0x0000 (0x03D0 - 0x03D0)
class ATgDevice_Kaldr_Basic : public ATgDevice_ActiveMode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 94257 );

		return pClassPointer;
	};

};

UClass* ATgDevice_Kaldr_Basic::pClassPointer = NULL;

// Class TgGame.TgDevice_Kaldr_Passive
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_Kaldr_Passive : public ATgDevice
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 94328 );

		return pClassPointer;
	};

	bool eventCanBeFiredWhileTweening ( );
	bool eventShouldLockFiring ( class ATgDevice* Current );
	void FireAmmunition ( );
	bool eventApplyGlobalOffhandCooldown ( );
};

UClass* ATgDevice_Kaldr_Passive::pClassPointer = NULL;

// Class TgGame.TgDevice_Kali_Destruction
// 0x0000 (0x0388 - 0x0388)
class ATgDevice_Kali_Destruction : public ATgDevice_HitPulse
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 94344 );

		return pClassPointer;
	};

	void RecoverHealth ( );
};

UClass* ATgDevice_Kali_Destruction::pClassPointer = NULL;

// Class TgGame.TgDevice_Kali_NimbleStrike
// 0x0000 (0x03B0 - 0x03B0)
class ATgDevice_Kali_NimbleStrike : public ATgDevice_Charge
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 94374 );

		return pClassPointer;
	};

};

UClass* ATgDevice_Kali_NimbleStrike::pClassPointer = NULL;

// Class TgGame.TgDevice_Kumbhakarna_Num2Sub
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_Kumbhakarna_Num2Sub : public ATgDevice
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 94559 );

		return pClassPointer;
	};

	bool ShouldConsumePowerPoolAfterFire ( );
	bool ShouldConsumePowerPoolOnStartFire ( );
};

UClass* ATgDevice_Kumbhakarna_Num2Sub::pClassPointer = NULL;

// Class TgGame.TgDevice_Kumbhakarna_Num4
// 0x0000 (0x03B0 - 0x03B0)
class ATgDevice_Kumbhakarna_Num4 : public ATgDevice_Charge
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 94565 );

		return pClassPointer;
	};

	void ClientForcePostFire ( );
	bool ShouldStopOnThisHit ( class AActor* Other );
};

UClass* ATgDevice_Kumbhakarna_Num4::pClassPointer = NULL;

// Class TgGame.TgDevice_Medusa_Dev3
// 0x0000 (0x03B0 - 0x03B0)
class ATgDevice_Medusa_Dev3 : public ATgDevice_Charge
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 94662 );

		return pClassPointer;
	};

};

UClass* ATgDevice_Medusa_Dev3::pClassPointer = NULL;

// Class TgGame.TgDevice_Mercury_Num1
// 0x0010 (0x0390 - 0x0380)
class ATgDevice_Mercury_Num1 : public ATgDevice
{
public:
	TArray< struct FImpactInfo >                       m_QueuedHits;                                     		// 0x0380 (0x000C) [0x0000000000480000]              ( CPF_Component | CPF_NeedCtorLink )
	float                                              m_fHitInterval;                                   		// 0x038C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 94689 );

		return pClassPointer;
	};

	bool eventCanBeInterrupted ( );
	void ApplyNextHit ( );
	void eventDeliverQueuedPendingHits ( );
};

UClass* ATgDevice_Mercury_Num1::pClassPointer = NULL;

// Class TgGame.TgDevice_Mercury_Num2
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_Mercury_Num2 : public ATgDevice
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 94706 );

		return pClassPointer;
	};

	bool eventShouldLockFiring ( class ATgDevice* Current );
};

UClass* ATgDevice_Mercury_Num2::pClassPointer = NULL;

// Class TgGame.TgDevice_Mercury_Num4
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_Mercury_Num4 : public ATgDevice
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 94711 );

		return pClassPointer;
	};

	bool eventShouldTriggerCastReactionItems ( );
	bool eventShouldInterruptInhand ( );
	bool ShouldConsumePowerPoolAfterFire ( );
	bool ShouldConsumePowerPoolOnStartFire ( );
	bool ShouldCooldownAfterFire ( );
};

UClass* ATgDevice_Mercury_Num4::pClassPointer = NULL;

// Class TgGame.TgDevice_Neith_ThreadOfLife
// 0x000C (0x038C - 0x0380)
class ATgDevice_Neith_ThreadOfLife : public ATgDevice
{
public:
	TArray< class AActor* >                            s_ActorHitList;                                   		// 0x0380 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 94832 );

		return pClassPointer;
	};

	void eventGetAdjustedAim ( int nShotIndex, struct FAimData* Aim );
	void FireAmmunition ( );
};

UClass* ATgDevice_Neith_ThreadOfLife::pClassPointer = NULL;

// Class TgGame.TgDevice_Neith_WorldWeaverStance
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_Neith_WorldWeaverStance : public ATgDevice
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 94850 );

		return pClassPointer;
	};

	bool eventShouldTriggerCastReactionItems ( );
	void ForceDeviceConsumePowerPool ( unsigned char FireModeNum );
	void DeviceConsumePowerPool ( unsigned char FireModeNum );
};

UClass* ATgDevice_Neith_WorldWeaverStance::pClassPointer = NULL;

// Class TgGame.TgDevice_Nemesis_Num2
// 0x0000 (0x0388 - 0x0388)
class ATgDevice_Nemesis_Num2 : public ATgDevice_HitPulse
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 94872 );

		return pClassPointer;
	};

	void eventGetAdjustedAim ( int nShotIndex, struct FAimData* Aim );
	void eventInstantFire ( );
	bool eventCanBeInterrupted ( );
	bool eventCanBeCanceled ( );
};

UClass* ATgDevice_Nemesis_Num2::pClassPointer = NULL;

// Class TgGame.TgDevice_NeZha_WindFireWheels
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_NeZha_WindFireWheels : public ATgDevice
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 94925 );

		return pClassPointer;
	};

	void ClientOnPossibleDryFire ( );
	void eventInterruptFiring ( );
};

UClass* ATgDevice_NeZha_WindFireWheels::pClassPointer = NULL;

// Class TgGame.TgDevice_NoFire
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_NoFire : public ATgDevice
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 94979 );

		return pClassPointer;
	};

	bool eventStartFire ( );
	bool eventUse ( );
};

UClass* ATgDevice_NoFire::pClassPointer = NULL;

// Class TgGame.TgDevice_NuWa_ClaySoldierCharge
// 0x0000 (0x03B0 - 0x03B0)
class ATgDevice_NuWa_ClaySoldierCharge : public ATgDevice_Charge
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 95069 );

		return pClassPointer;
	};

};

UClass* ATgDevice_NuWa_ClaySoldierCharge::pClassPointer = NULL;

// Class TgGame.TgDevice_NuWa_StealthAura
// 0x0004 (0x039C - 0x0398)
class ATgDevice_NuWa_StealthAura : public ATgDevice_PassiveAura
{
public:
	class ATgCollisionProxy_PawnListener*              s_StealthCancelProxy;                             		// 0x0398 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 95214 );

		return pClassPointer;
	};

	void eventDestroyed ( );
	void eventEndAura ( );
	void eventBeginAura ( );
	void OnPawnDeviceStartFire ( class ATgPawn* Other, class ATgDevice* OtherDevice );
	void Tick ( float DeltaTime );
	void ApplyHitAura ( class AActor* Other );
	bool CanApplyAura ( class AActor* Other );
};

UClass* ATgDevice_NuWa_StealthAura::pClassPointer = NULL;

// Class TgGame.TgDevice_Poseidon_Deployable
// 0x0000 (0x0388 - 0x0388)
class ATgDevice_Poseidon_Deployable : public ATgDevice_Deployable
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 95418 );

		return pClassPointer;
	};

	void eventOnDeployableSpawned ( class ATgDeployable* deployable );
};

UClass* ATgDevice_Poseidon_Deployable::pClassPointer = NULL;

// Class TgGame.TgDevice_Ram_Basic
// 0x0000 (0x03D0 - 0x03D0)
class ATgDevice_Ram_Basic : public ATgDevice_ActiveMode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 95703 );

		return pClassPointer;
	};

	class AProjectile* ProjectileFire ( int ProjectileIndex );
};

UClass* ATgDevice_Ram_Basic::pClassPointer = NULL;

// Class TgGame.TgDevice_Ratatoskr_AcornPurchase
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_Ratatoskr_AcornPurchase : public ATgDevice
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 95782 );

		return pClassPointer;
	};

	void FireAmmunition ( );
	void ClientForceStartFire ( );
	bool eventStartFire ( );
	bool ShouldCancelStealth ( );
	bool eventCustomCanDeviceFireNow ( unsigned char FireModeNum, struct FAimData Aim, unsigned long bDeviceFailLog, unsigned char* failType );
};

UClass* ATgDevice_Ratatoskr_AcornPurchase::pClassPointer = NULL;

// Class TgGame.TgDevice_Ratatoskr_FlurryV2
// 0x0000 (0x0388 - 0x0388)
class ATgDevice_Ratatoskr_FlurryV2 : public ATgDevice_HitPulse
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 95909 );

		return pClassPointer;
	};

	bool eventCanBeInterrupted ( );
	bool eventCanJumpWhileFiring ( );
	bool eventCanBeCanceled ( );
};

UClass* ATgDevice_Ratatoskr_FlurryV2::pClassPointer = NULL;

// Class TgGame.TgDevice_Ratatoskr_UltimateStaging
// 0x0004 (0x03B4 - 0x03B0)
class ATgDevice_Ratatoskr_UltimateStaging : public ATgDevice_StagingRefresh
{
public:
	unsigned long                                      s_bForceStraightDown : 1;                         		// 0x03B0 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 96042 );

		return pClassPointer;
	};

	void eventInterruptFiring ( );
	bool FireEndStageDevice ( );
	void eventOnStageShooterStopFire ( unsigned long bInterrupted );
	void FireAmmunition ( );
	bool LockStageShooterFiring ( );
	bool CanRefreshPostHitDelay ( );
	bool ShouldSwapInHandOnShooterStopFire ( );
	bool ShouldSetStageShooterFired ( );
	void ServerOnRightMousePressed ( );
	void OnRightMousePressed ( );
	bool eventCanBeCanceled ( );
};

UClass* ATgDevice_Ratatoskr_UltimateStaging::pClassPointer = NULL;

// Class TgGame.TgDevice_Ravana_Dev1
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_Ravana_Dev1 : public ATgDevice
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 96094 );

		return pClassPointer;
	};

	bool eventShouldInterruptInhand ( );
};

UClass* ATgDevice_Ravana_Dev1::pClassPointer = NULL;

// Class TgGame.TgDevice_Ravana_Dev2
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_Ravana_Dev2 : public ATgDevice_Range
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 96098 );

		return pClassPointer;
	};

};

UClass* ATgDevice_Ravana_Dev2::pClassPointer = NULL;

// Class TgGame.TgDevice_Scylla_Num2
// 0x0000 (0x039C - 0x039C)
class ATgDevice_Scylla_Num2 : public ATgDevice_TogglableDeployable
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 96136 );

		return pClassPointer;
	};

};

UClass* ATgDevice_Scylla_Num2::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_Scylla_Num3
// 0x0004 (0x0198 - 0x0194)
class UTgDeviceForm_Scylla_Num3 : public UTgDeviceForm_NuWa_ClaySoldiers
{
public:
	unsigned long                                      m_bInSuppressionMode : 1;                         		// 0x0194 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 96213 );

		return pClassPointer;
	};

	void eventStopFire ( int nFireModeNum );
	void eventStartFire ( int nFireMode, float fRefireTime, class AActor* Target );
	void eventBuildUp ( int nFireMode, int nEquipSlot, int nSocketIndex, float fBuildupTime );
	void BeginDeviceSuppression ( );
};

UClass* UTgDeviceForm_Scylla_Num3::pClassPointer = NULL;

// Class TgGame.TgDevice_Serqet_Backflip
// 0x0000 (0x03B0 - 0x03B0)
class ATgDevice_Serqet_Backflip : public ATgDevice_Charge
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 96423 );

		return pClassPointer;
	};

	bool eventCanDeviceFireNow ( unsigned char FireModeNum, struct FAimData Aim, unsigned long bDeviceFailLog, unsigned long bSkipStunCheck, unsigned char* failType );
};

UClass* ATgDevice_Serqet_Backflip::pClassPointer = NULL;

// Class TgGame.TgDevice_Serqet_PassiveLeap
// 0x0001 (0x0381 - 0x0380)
class ATgDevice_Serqet_PassiveLeap : public ATgDevice
{
public:
	unsigned char                                      m_LeapTweenState;                                 		// 0x0380 (0x0001) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 96697 );

		return pClassPointer;
	};

	bool eventCustomCanDeviceFireNow ( unsigned char FireModeNum, struct FAimData Aim, unsigned long bDeviceFailLog, unsigned char* failType );
	bool eventApplyGlobalOffhandCooldown ( );
	bool eventShouldInterruptInhand ( );
	bool eventCanBeCanceled ( );
};

UClass* ATgDevice_Serqet_PassiveLeap::pClassPointer = NULL;

// Class TgGame.TgDevice_Sobek_TailWhip
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_Sobek_TailWhip : public ATgDevice
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 96789 );

		return pClassPointer;
	};

	bool eventCanBeInterrupted ( );
};

UClass* ATgDevice_Sobek_TailWhip::pClassPointer = NULL;

// Class TgGame.TgDevice_Sol_SolarFlair
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_Sol_SolarFlair : public ATgDevice
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 97020 );

		return pClassPointer;
	};

	struct FImpactInfo CalcWeaponFire ( struct FAimData Aim, TArray< struct FImpactInfo >* ImpactList );
};

UClass* ATgDevice_Sol_SolarFlair::pClassPointer = NULL;

// Class TgGame.TgDevice_SunWukong_SomersaultSlam
// 0x0000 (0x0398 - 0x0398)
class ATgDevice_SunWukong_SomersaultSlam : public ATgDevice_AnvilSlamBase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 97095 );

		return pClassPointer;
	};

	void FireAmmunition ( );
};

UClass* ATgDevice_SunWukong_SomersaultSlam::pClassPointer = NULL;

// Class TgGame.TgDevice_SunWukong_TransformEagle
// 0x0000 (0x03C8 - 0x03C8)
class ATgDevice_SunWukong_TransformEagle : public ATgDevice_SunWukong_Transform
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 97320 );

		return pClassPointer;
	};

};

UClass* ATgDevice_SunWukong_TransformEagle::pClassPointer = NULL;

// Class TgGame.TgDevice_SunWukong_TransformTiger
// 0x0004 (0x03CC - 0x03C8)
class ATgDevice_SunWukong_TransformTiger : public ATgDevice_SunWukong_Transform
{
public:
	unsigned long                                      m_bTriggerPounce : 1;                             		// 0x03C8 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 97322 );

		return pClassPointer;
	};

	void ClientTriggerPounce ( );
	void TriggerPounce ( );
	void eventInterruptFiring ( );
	void TransformBack ( );
};

UClass* ATgDevice_SunWukong_TransformTiger::pClassPointer = NULL;

// Class TgGame.TgDevice_Sylvanus_Deploy
// 0x0000 (0x0388 - 0x0388)
class ATgDevice_Sylvanus_Deploy : public ATgDevice_Deployable
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 97460 );

		return pClassPointer;
	};

};

UClass* ATgDevice_Sylvanus_Deploy::pClassPointer = NULL;

// Class TgGame.TgDevice_Sylvanus_Ground
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_Sylvanus_Ground : public ATgDevice_Range
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 97462 );

		return pClassPointer;
	};

};

UClass* ATgDevice_Sylvanus_Ground::pClassPointer = NULL;

// Class TgGame.TgDevice_Terra_BasicAttack
// 0x0000 (0x03C0 - 0x03C0)
class ATgDevice_Terra_BasicAttack : public ATgDevice_ChainedMelee
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 97583 );

		return pClassPointer;
	};

};

UClass* ATgDevice_Terra_BasicAttack::pClassPointer = NULL;

// Class TgGame.TgDevice_Thanatos_ScentOfDeath
// 0x0010 (0x03A8 - 0x0398)
class ATgDevice_Thanatos_ScentOfDeath : public ATgDevice_Aura
{
public:
	int                                                m_nMaxBuffStacks;                                 		// 0x0398 (0x0004) [0x0000000000000000]              
	TArray< class AActor* >                            m_PotentialTargets;                               		// 0x039C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 97718 );

		return pClassPointer;
	};

	void DeviceShutDown ( unsigned long bDeactiveMode, unsigned long bResetCooldowns );
	void FireAmmunition ( );
	void Tick ( float DeltaTime );
	void eventRemoveFromAllHitAura ( );
	bool RemoveHitAura ( class AActor* Other, unsigned long bRemoveFromList );
	void ApplyHitAura ( class AActor* Other );
	bool eventIsAuraActive ( );
	bool eventCanBeCanceled ( );
};

UClass* ATgDevice_Thanatos_ScentOfDeath::pClassPointer = NULL;

// Class TgGame.TgDevice_Thoth_Assault
// 0x0000 (0x03AC - 0x03AC)
class ATgDevice_Thoth_Assault : public ATgDevice_Staging
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 97781 );

		return pClassPointer;
	};

	bool eventCustomCanDeviceFireNow ( unsigned char FireModeNum, struct FAimData Aim, unsigned long bDeviceFailLog, unsigned char* failType );
	bool eventShouldTriggerCastReactionItemsOnFire ( );
	bool eventShouldTriggerCastReactionItems ( );
	bool ShouldConsumePowerPoolAfterFire ( );
	bool ShouldConsumePowerPoolOnStartFire ( );
	void eventOnStageShooterFire ( );
	bool eventCanBeCanceled ( );
	bool eventCanJumpWhileFiring ( );
};

UClass* ATgDevice_Thoth_Assault::pClassPointer = NULL;

// Class TgGame.TgDevice_Thoth_Assault_Shooter
// 0x0010 (0x0390 - 0x0380)
class ATgDevice_Thoth_Assault_Shooter : public ATgDevice_Thoth_RangeExtension
{
public:
	int                                                m_ProjectileIdsPerPage[ 0x4 ];                    		// 0x0380 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 97804 );

		return pClassPointer;
	};

	int GetProjectileIDOverride ( int ProjectileIndex );
	bool eventCustomCanDeviceFireNow ( unsigned char FireModeNum, struct FAimData Aim, unsigned long bDeviceFailLog, unsigned char* failType );
};

UClass* ATgDevice_Thoth_Assault_Shooter::pClassPointer = NULL;

// Class TgGame.TgDevice_Tyr_AggressiveStance1
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_Tyr_AggressiveStance1 : public ATgDevice
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 97850 );

		return pClassPointer;
	};

	bool eventShouldLockFiring ( class ATgDevice* Current );
};

UClass* ATgDevice_Tyr_AggressiveStance1::pClassPointer = NULL;

// Class TgGame.TgDevice_Tyr_AggressiveStance2
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_Tyr_AggressiveStance2 : public ATgDevice
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 97856 );

		return pClassPointer;
	};

};

UClass* ATgDevice_Tyr_AggressiveStance2::pClassPointer = NULL;

// Class TgGame.TgDevice_Vulcan_ForgeCannon
// 0x0000 (0x03B0 - 0x03B0)
class ATgDevice_Vulcan_ForgeCannon : public ATgDevice_Charge
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 97885 );

		return pClassPointer;
	};

	float eventGetChargeRange ( );
};

UClass* ATgDevice_Vulcan_ForgeCannon::pClassPointer = NULL;

// Class TgGame.TgDevice_Xbalanque_PoisonDarts
// 0x0018 (0x03A0 - 0x0388)
class ATgDevice_Xbalanque_PoisonDarts : public ATgDevice_HitPulse
{
public:
	TArray< struct ATgDevice_Xbalanque_PoisonDarts_FFanInformation > s_FanInfos;                                       		// 0x0388 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class ATgProjectile* >                     s_ActiveProjectiles;                              		// 0x0394 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 97962 );

		return pClassPointer;
	};

	void OnProjectileShutdown ( class ATgProjectile* Proj );
	class AProjectile* ProjectileFire ( int nProjectileIndex );
	void eventGetAdjustedAim ( int nShotIndex, struct FAimData* Aim );
	float eventGetPersistPulseHitTime ( int nMode );
	bool ShouldApplyHit ( class ATgProjectile* Proj, class AActor* HitActor, int* nHitCount );
};

UClass* ATgDevice_Xbalanque_PoisonDarts::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_XingTian_AxeSweepShieldBash
// 0x0000 (0x0198 - 0x0198)
class UTgDeviceForm_XingTian_AxeSweepShieldBash : public UTgDeviceForm_TwoPhase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 98054 );

		return pClassPointer;
	};

};

UClass* UTgDeviceForm_XingTian_AxeSweepShieldBash::pClassPointer = NULL;

// Class TgGame.TgDevice_XingTian_AxeSweepShieldBashV2
// 0x0002 (0x0384 - 0x0382)
class ATgDevice_XingTian_AxeSweepShieldBashV2 : public ATgDevice_XingTian_AxeSweepShieldBash
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 98071 );

		return pClassPointer;
	};

};

UClass* ATgDevice_XingTian_AxeSweepShieldBashV2::pClassPointer = NULL;

// Class TgGame.TgProj_XingTian_Battlecry
// 0x0004 (0x02E0 - 0x02DC)
class ATgProj_XingTian_Battlecry : public ATgProj_SimulatedPassThrough
{
public:
	unsigned long                                      bCachedEnragedOnFire : 1;                         		// 0x02DC (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 98089 );

		return pClassPointer;
	};

	void HitTarget ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal );
};

UClass* ATgProj_XingTian_Battlecry::pClassPointer = NULL;

// Class TgGame.TgDevice_Zeus_Coffin
// 0x0004 (0x0384 - 0x0380)
class ATgDevice_Zeus_Coffin : public ATgDevice
{
public:
	unsigned long                                      m_bCollisionOff : 1;                              		// 0x0380 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 98331 );

		return pClassPointer;
	};

	void FireAmmunition ( );
	void TurnOnInstigatorCollision ( );
	void TurnOffInstigatorCollision ( );
};

UClass* ATgDevice_Zeus_Coffin::pClassPointer = NULL;

// Class TgGame.TgDevice_Zeus_FlashOfLightning
// 0x0000 (0x0388 - 0x0388)
class ATgDevice_Zeus_FlashOfLightning : public ATgDevice_TweenBase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 98341 );

		return pClassPointer;
	};

};

UClass* ATgDevice_Zeus_FlashOfLightning::pClassPointer = NULL;

// Class TgGame.TgProj_ZhongKui_RecallDemons
// 0x0028 (0x0310 - 0x02E8)
class ATgProj_ZhongKui_RecallDemons : public ATgProj_SimulatedSeeking
{
public:
	unsigned long                                      m_bIsCharged : 1;                                 		// 0x02E8 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bExplodeFlashed : 1;                            		// 0x02E8 (0x0004) [0x0000000000000000] [0x00000002] 
	float                                              m_fExplosionDelay;                                		// 0x02EC (0x0004) [0x0000000000000000]              
	class AActor*                                      m_ExplodeTarget;                                  		// 0x02F0 (0x0004) [0x0000000000000000]              
	struct FVector                                     m_vExplodeHitLocation;                            		// 0x02F4 (0x000C) [0x0000000000000000]              
	struct FVector                                     m_vExplodeHitNormal;                              		// 0x0300 (0x000C) [0x0000000000000000]              
	float                                              m_fInitialLifeSpan;                               		// 0x030C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 98480 );

		return pClassPointer;
	};

	bool ApplyHit ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal, int HitItem );
	void ExplodeOnTargetTimer ( );
	void eventExplodeOnTarget ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal );
	void eventPostProjectileInitialize ( );
};

UClass* ATgProj_ZhongKui_RecallDemons::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_AhPuch_Dev1
// 0x0003 (0x017C - 0x0179)
class UTgDeviceFire_AhPuch_Dev1 : public UTgDeviceFire_TwoPhase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 98956 );

		return pClassPointer;
	};

	float eventGetPostHitDelay ( );
	float eventGetPreHitDelay ( );
	float eventGetBuildupTime ( );
	float eventGetRefireTime ( );
};

UClass* UTgDeviceFire_AhPuch_Dev1::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_AhPuch_EmptyTheCrypts
// 0x0003 (0x017C - 0x0179)
class UTgDeviceFire_AhPuch_EmptyTheCrypts : public UTgDeviceFire_TwoPhase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 99058 );

		return pClassPointer;
	};

};

UClass* UTgDeviceFire_AhPuch_EmptyTheCrypts::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_AoKuang_DragonCall
// 0x0003 (0x017C - 0x0179)
class UTgDeviceFire_AoKuang_DragonCall : public UTgDeviceFire_TwoPhase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 99074 );

		return pClassPointer;
	};

	class UTgEffectGroup* GetNewEffectGroupForAbsorbDragons ( class UTgEffectGroup* Original, struct FImpactInfo* Impact );
	void SubmitHitEffects ( class AActor* DamageInstigator, struct FImpactInfo Impact, int nType );
};

UClass* UTgDeviceFire_AoKuang_DragonCall::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_AoKuang_UltimateJumpDown
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_AoKuang_UltimateJumpDown : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 99103 );

		return pClassPointer;
	};

	void eventSubmitEffect ( struct FImpactInfo Impact, class UTgEffectGroup* effectGroup, unsigned long bRemove, int StackCount );
};

UClass* UTgDeviceFire_AoKuang_UltimateJumpDown::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_AoKuang_WildStorm
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_AoKuang_WildStorm : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 99115 );

		return pClassPointer;
	};

	void HandleSuccessfulHit ( class AActor* DamageInstigator, class APawn* OwnerInstigator, struct FImpactInfo Impact, int nHitType, int nSituationalType );
};

UClass* UTgDeviceFire_AoKuang_WildStorm::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Ares_Tether
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_Ares_Tether : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 99171 );

		return pClassPointer;
	};

	bool eventApplyHit ( struct FImpactInfo Impact, class AActor* DamageInstigator );
};

UClass* UTgDeviceFire_Ares_Tether::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Athena_ShieldWall
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_Athena_ShieldWall : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 99185 );

		return pClassPointer;
	};

	bool eventApplyHit ( struct FImpactInfo Impact, class AActor* DamageInstigator );
};

UClass* UTgDeviceFire_Athena_ShieldWall::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Bastet_UsePassive
// 0x0008 (0x0180 - 0x0178)
class UTgDeviceFire_Bastet_UsePassive : public UTgDeviceFire
{
public:
	unsigned long                                      m_bApplyExtraDamage : 1;                          		// 0x0178 (0x0004) [0x0000000000000000] [0x00000001] 
	float                                              m_fDefaultExtraDamageAmount;                      		// 0x017C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 99239 );

		return pClassPointer;
	};

	void SubmitHitEffects ( class AActor* DamageInstigator, struct FImpactInfo Impact, int nType );
	bool eventApplyHit ( struct FImpactInfo Impact, class AActor* DamageInstigator );
};

UClass* UTgDeviceFire_Bastet_UsePassive::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_BastetPounce
// 0x0000 (0x0180 - 0x0180)
class UTgDeviceFire_BastetPounce : public UTgDeviceFire_Bastet_UsePassive
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 99269 );

		return pClassPointer;
	};

	bool eventApplyHit ( struct FImpactInfo Impact, class AActor* DamageInstigator );
};

UClass* UTgDeviceFire_BastetPounce::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Bellona_VeniVidiVici
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_Bellona_VeniVidiVici : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 99299 );

		return pClassPointer;
	};

	void GetHitType ( struct FImpactInfo Impact, class AActor* DamageInstigator, int* nHitType, int* nSituationalType );
};

UClass* UTgDeviceFire_Bellona_VeniVidiVici::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Camazotz_SiphonPower
// 0x0000 (0x017C - 0x017C)
class UTgDeviceFire_Camazotz_SiphonPower : public UTgDeviceFire_GroundTarget_LockOn
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 99343 );

		return pClassPointer;
	};

};

UClass* UTgDeviceFire_Camazotz_SiphonPower::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Chaac_Num2
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_Chaac_Num2 : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 99345 );

		return pClassPointer;
	};

	void HandleSuccessfulHit ( class AActor* DamageInstigator, class APawn* OwnerInstigator, struct FImpactInfo Impact, int nHitType, int nSituationalType );
};

UClass* UTgDeviceFire_Chaac_Num2::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Chiron_ChargeLong
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_Chiron_ChargeLong : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 99355 );

		return pClassPointer;
	};

	bool eventApplyHit ( struct FImpactInfo Impact, class AActor* DamageInstigator );
};

UClass* UTgDeviceFire_Chiron_ChargeLong::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Fafnir_Dev2
// 0x0000 (0x017C - 0x017C)
class UTgDeviceFire_Fafnir_Dev2 : public UTgDeviceFire_GroundTarget_LockOn
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 99417 );

		return pClassPointer;
	};

};

UClass* UTgDeviceFire_Fafnir_Dev2::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Fenrir_Howl
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_Fenrir_Howl : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 99431 );

		return pClassPointer;
	};

	void SubmitHitEffects ( class AActor* DamageInstigator, struct FImpactInfo Impact, int nType );
};

UClass* UTgDeviceFire_Fenrir_Howl::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Hercules_Batterup
// 0x0000 (0x017C - 0x017C)
class UTgDeviceFire_Hercules_Batterup : public UTgDeviceFire_GroundTarget_LockOn
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 99531 );

		return pClassPointer;
	};

	bool eventApplyHit ( struct FImpactInfo Impact, class AActor* DamageInstigator );
};

UClass* UTgDeviceFire_Hercules_Batterup::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_HitAsInHand
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_HitAsInHand : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 99546 );

		return pClassPointer;
	};

	bool eventApplyHit ( struct FImpactInfo Impact, class AActor* DamageInstigator );
};

UClass* UTgDeviceFire_HitAsInHand::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_HouYi_Dev1_Shooter
// 0x0000 (0x0180 - 0x0180)
class UTgDeviceFire_HouYi_Dev1_Shooter : public UTgDeviceFire_Spline
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 99599 );

		return pClassPointer;
	};

};

UClass* UTgDeviceFire_HouYi_Dev1_Shooter::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Izanami_Inhand
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_Izanami_Inhand : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 99611 );

		return pClassPointer;
	};

};

UClass* UTgDeviceFire_Izanami_Inhand::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_JingWei_Dev2
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_JingWei_Dev2 : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 99635 );

		return pClassPointer;
	};

	void GetHitType ( struct FImpactInfo Impact, class AActor* DamageInstigator, int* nHitType, int* nSituationalType );
};

UClass* UTgDeviceFire_JingWei_Dev2::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Neith_WorldWeaver
// 0x0004 (0x017C - 0x0178)
class UTgDeviceFire_Neith_WorldWeaver : public UTgDeviceFire
{
public:
	class ATgPawn_Neith*                               m_OwningNeith;                                    		// 0x0178 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 99779 );

		return pClassPointer;
	};

	bool eventApplyHit ( struct FImpactInfo Impact, class AActor* DamageInstigator );
	void AdjustStun ( struct FImpactInfo Impact, class AActor* DamageInstigator );
};

UClass* UTgDeviceFire_Neith_WorldWeaver::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Nemesis_Num4
// 0x0000 (0x017C - 0x017C)
class UTgDeviceFire_Nemesis_Num4 : public UTgDeviceFire_GroundTarget_LockOn
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 99801 );

		return pClassPointer;
	};

	void eventSubmitEffect ( struct FImpactInfo Impact, class UTgEffectGroup* effectGroup, unsigned long bRemove, int StackCount );
};

UClass* UTgDeviceFire_Nemesis_Num4::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Nemesis_Num4SelfHitSub
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_Nemesis_Num4SelfHitSub : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 99813 );

		return pClassPointer;
	};

	void eventSubmitEffect ( struct FImpactInfo Impact, class UTgEffectGroup* effectGroup, unsigned long bRemove, int StackCount );
};

UClass* UTgDeviceFire_Nemesis_Num4SelfHitSub::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Nemesis_Passive
// 0x0004 (0x017C - 0x0178)
class UTgDeviceFire_Nemesis_Passive : public UTgDeviceFire
{
public:
	float                                              m_fPhysicalPowerToAdd;                            		// 0x0178 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 99823 );

		return pClassPointer;
	};

	void eventSubmitEffect ( struct FImpactInfo Impact, class UTgEffectGroup* effectGroup, unsigned long bRemove, int StackCount );
};

UClass* UTgDeviceFire_Nemesis_Passive::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_NeZha_Passive
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_NeZha_Passive : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 99841 );

		return pClassPointer;
	};

	void eventSubmitEffect ( struct FImpactInfo Impact, class UTgEffectGroup* effectGroup, unsigned long bRemove, int StackCount );
};

UClass* UTgDeviceFire_NeZha_Passive::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_NoSuccessfulHitOnStructures
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_NoSuccessfulHitOnStructures : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 99850 );

		return pClassPointer;
	};

	void HandleSuccessfulHit ( class AActor* DamageInstigator, class APawn* OwnerInstigator, struct FImpactInfo Impact, int nHitType, int nSituationalType );
};

UClass* UTgDeviceFire_NoSuccessfulHitOnStructures::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Osiris
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_Osiris : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 99929 );

		return pClassPointer;
	};

	bool eventApplyHit ( struct FImpactInfo Impact, class AActor* DamageInstigator );
};

UClass* UTgDeviceFire_Osiris::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Osiris_MummyWrap
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_Osiris_MummyWrap : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 99939 );

		return pClassPointer;
	};

	bool eventApplyHit ( struct FImpactInfo Impact, class AActor* DamageInstigator );
};

UClass* UTgDeviceFire_Osiris_MummyWrap::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Raijin_Dev1
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_Raijin_Dev1 : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 99949 );

		return pClassPointer;
	};

};

UClass* UTgDeviceFire_Raijin_Dev1::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Ram_AstralQuiver2
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_Ram_AstralQuiver2 : public UTgDeviceFire_Deploy
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 99961 );

		return pClassPointer;
	};

};

UClass* UTgDeviceFire_Ram_AstralQuiver2::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Ratatoskr_AcornThrowV2
// 0x0010 (0x0188 - 0x0178)
class UTgDeviceFire_Ratatoskr_AcornThrowV2 : public UTgDeviceFire
{
public:
	int                                                m_CurrentFiringInstance;                          		// 0x0178 (0x0004) [0x0000000000000000]              
	TArray< struct FAcornThrowHitData >                m_HitData;                                        		// 0x017C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 100001 );

		return pClassPointer;
	};

	void HandleSuccessfulHit ( class AActor* DamageInstigator, class APawn* OwnerInstigator, struct FImpactInfo Impact, int nHitType, int nSituationalType );
};

UClass* UTgDeviceFire_Ratatoskr_AcornThrowV2::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Ratatoskr_Dart
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_Ratatoskr_Dart : public UTgDeviceFire_Ratatoskr_Base
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 100021 );

		return pClassPointer;
	};

	void SubmitEffect ( struct FImpactInfo Impact, class UTgEffectGroup* effectGroup, unsigned long bRemove, int StackCount );
	void HandleSuccessfulHit ( class AActor* DamageInstigator, class APawn* OwnerInstigator, struct FImpactInfo Impact, int nHitType, int nSituationalType );
	bool ApplyHit ( struct FImpactInfo Impact, class AActor* DamageInstigator );
	bool AllowAcornBasedHits ( struct FImpactInfo Impact, class AActor* DamageInstigator );
};

UClass* UTgDeviceFire_Ratatoskr_Dart::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Ratatoskr_FlurryV2
// 0x0010 (0x0188 - 0x0178)
class UTgDeviceFire_Ratatoskr_FlurryV2 : public UTgDeviceFire
{
public:
	TArray< struct FAcornThrowHitData >                m_HitData;                                        		// 0x0178 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                m_CurrentFiringInstance;                          		// 0x0184 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 100056 );

		return pClassPointer;
	};

	void HandleSuccessfulHit ( class AActor* DamageInstigator, class APawn* OwnerInstigator, struct FImpactInfo Impact, int nHitType, int nSituationalType );
};

UClass* UTgDeviceFire_Ratatoskr_FlurryV2::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Ratatoskr_TailSpin
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_Ratatoskr_TailSpin : public UTgDeviceFire_Ratatoskr_Base
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 100072 );

		return pClassPointer;
	};

	bool AllowAcornBasedHits ( struct FImpactInfo Impact, class AActor* DamageInstigator );
};

UClass* UTgDeviceFire_Ratatoskr_TailSpin::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Ratatoskr_UltimateShooter
// 0x0003 (0x017C - 0x0179)
class UTgDeviceFire_Ratatoskr_UltimateShooter : public UTgDeviceFire_TwoPhase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 100080 );

		return pClassPointer;
	};

};

UClass* UTgDeviceFire_Ratatoskr_UltimateShooter::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Ravana_Dev4
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_Ravana_Dev4 : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 100082 );

		return pClassPointer;
	};

	void HandleSuccessfulHit ( class AActor* DamageInstigator, class APawn* OwnerInstigator, struct FImpactInfo Impact, int nHitType, int nSituationalType );
	void GetHitType ( struct FImpactInfo Impact, class AActor* DamageInstigator, int* nHitType, int* nSituationalType );
};

UClass* UTgDeviceFire_Ravana_Dev4::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_RotationAsImpact
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_RotationAsImpact : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 100096 );

		return pClassPointer;
	};

	bool eventApplyHit ( struct FImpactInfo Impact, class AActor* DamageInstigator );
};

UClass* UTgDeviceFire_RotationAsImpact::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_ScaryPotion
// 0x0008 (0x0180 - 0x0178)
class UTgDeviceFire_ScaryPotion : public UTgDeviceFire
{
public:
	float                                              m_fMinEffectGroupLifeTime;                        		// 0x0178 (0x0004) [0x0000000000000000]              
	float                                              m_fMaxEffectGroupLifeTime;                        		// 0x017C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 100102 );

		return pClassPointer;
	};

	void eventSubmitEffect ( struct FImpactInfo Impact, class UTgEffectGroup* effectGroup, unsigned long bRemove, int StackCount );
};

UClass* UTgDeviceFire_ScaryPotion::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Scylla_Num1
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_Scylla_Num1 : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 100117 );

		return pClassPointer;
	};

	bool eventApplyHit ( struct FImpactInfo Impact, class AActor* DamageInstigator );
};

UClass* UTgDeviceFire_Scylla_Num1::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Serqet_InHand
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_Serqet_InHand : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 100125 );

		return pClassPointer;
	};

	bool IsTargetPoisoned ( class AActor* Target );
	void GetHitType ( struct FImpactInfo Impact, class AActor* DamageInstigator, int* nHitType, int* nSituationalType );
};

UClass* UTgDeviceFire_Serqet_InHand::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Sol_SolarFlair
// 0x0000 (0x0180 - 0x0180)
class UTgDeviceFire_Sol_SolarFlair : public UTgDeviceFire_Spline
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 100162 );

		return pClassPointer;
	};

	void eventSubmitEffect ( struct FImpactInfo Impact, class UTgEffectGroup* effectGroup, unsigned long bRemove, int StackCount );
	void GetHitType ( struct FImpactInfo Impact, class AActor* DamageInstigator, int* nHitType, int* nSituationalType );
};

UClass* UTgDeviceFire_Sol_SolarFlair::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_SoulMates
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_SoulMates : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 100198 );

		return pClassPointer;
	};

	void HandleSuccessfulHit ( class AActor* DamageInstigator, class APawn* OwnerInstigator, struct FImpactInfo Impact, int nHitType, int nSituationalType );
};

UClass* UTgDeviceFire_SoulMates::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_SunWukong_Passive
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_SunWukong_Passive : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 100212 );

		return pClassPointer;
	};

	void eventSubmitEffect ( struct FImpactInfo Impact, class UTgEffectGroup* effectGroup, unsigned long bRemove, int StackCount );
};

UClass* UTgDeviceFire_SunWukong_Passive::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_XingTian_HeroicLeap
// 0x0003 (0x017C - 0x0179)
class UTgDeviceFire_XingTian_HeroicLeap : public UTgDeviceFire_TwoPhase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 100361 );

		return pClassPointer;
	};

};

UClass* UTgDeviceFire_XingTian_HeroicLeap::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_XingTian_UltSweep
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_XingTian_UltSweep : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 100363 );

		return pClassPointer;
	};

	void eventSubmitEffect ( struct FImpactInfo Impact, class UTgEffectGroup* effectGroup, unsigned long bRemove, int StackCount );
};

UClass* UTgDeviceFire_XingTian_UltSweep::pClassPointer = NULL;

// Class TgGame.TgDeviceFire_Zeus_Coffin
// 0x0000 (0x0178 - 0x0178)
class UTgDeviceFire_Zeus_Coffin : public UTgDeviceFire
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 100401 );

		return pClassPointer;
	};

};

UClass* UTgDeviceFire_Zeus_Coffin::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_AhMuzenCab_Hive
// 0x0000 (0x0188 - 0x0188)
class UTgDeviceForm_AhMuzenCab_Hive : public UTgDeviceForm
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 100647 );

		return pClassPointer;
	};

	void eventExitTargetingMode ( );
	void eventEnterTargetingMode ( );
};

UClass* UTgDeviceForm_AhMuzenCab_Hive::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_AhMuzenCab_Honey
// 0x0000 (0x0188 - 0x0188)
class UTgDeviceForm_AhMuzenCab_Honey : public UTgDeviceForm
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 100658 );

		return pClassPointer;
	};

	void eventExitTargetingMode ( );
	void eventEnterTargetingMode ( );
};

UClass* UTgDeviceForm_AhMuzenCab_Honey::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_AhPuch_EmptyTheCrypts
// 0x0000 (0x0198 - 0x0198)
class UTgDeviceForm_AhPuch_EmptyTheCrypts : public UTgDeviceForm_TwoPhase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 100701 );

		return pClassPointer;
	};

};

UClass* UTgDeviceForm_AhPuch_EmptyTheCrypts::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_AoKuang_DragonCall
// 0x0000 (0x0198 - 0x0198)
class UTgDeviceForm_AoKuang_DragonCall : public UTgDeviceForm_TwoPhase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 100716 );

		return pClassPointer;
	};

};

UClass* UTgDeviceForm_AoKuang_DragonCall::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_Aphrodite_Kiss
// 0x0000 (0x0198 - 0x0198)
class UTgDeviceForm_Aphrodite_Kiss : public UTgDeviceForm_TargetIndicator
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 100754 );

		return pClassPointer;
	};

};

UClass* UTgDeviceForm_Aphrodite_Kiss::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_Arachne_WebShooter
// 0x0000 (0x0190 - 0x0190)
class UTgDeviceForm_Arachne_WebShooter : public UTgDeviceForm_LineCone
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 100757 );

		return pClassPointer;
	};

};

UClass* UTgDeviceForm_Arachne_WebShooter::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_Bellona_ShieldBash
// 0x0000 (0x0190 - 0x0190)
class UTgDeviceForm_Bellona_ShieldBash : public UTgDeviceForm_LineCone
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 100809 );

		return pClassPointer;
	};

};

UClass* UTgDeviceForm_Bellona_ShieldBash::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_ChangE_CrescentMoonDance
// 0x0000 (0x0194 - 0x0194)
class UTgDeviceForm_ChangE_CrescentMoonDance : public UTgDeviceForm_RadialSweep
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 100832 );

		return pClassPointer;
	};

	void eventStopFire ( int nFireModeNum );
};

UClass* UTgDeviceForm_ChangE_CrescentMoonDance::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_Chiron_Charge
// 0x0000 (0x019C - 0x019C)
class UTgDeviceForm_Chiron_Charge : public UTgDeviceForm_SunWukong_Transform
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 100846 );

		return pClassPointer;
	};

};

UClass* UTgDeviceForm_Chiron_Charge::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_Fafnir_Dev2
// 0x0000 (0x0198 - 0x0198)
class UTgDeviceForm_Fafnir_Dev2 : public UTgDeviceForm_TargetIndicator
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 100857 );

		return pClassPointer;
	};

};

UClass* UTgDeviceForm_Fafnir_Dev2::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_Fafnir_Dev3
// 0x0000 (0x0188 - 0x0188)
class UTgDeviceForm_Fafnir_Dev3 : public UTgDeviceForm
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 100859 );

		return pClassPointer;
	};

	void eventBuildUp ( int nFireMode, int nEquipSlot, int nSocketIndex, float fBuildupTime );
};

UClass* UTgDeviceForm_Fafnir_Dev3::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_Fenrir_Brutalize
// 0x0000 (0x0198 - 0x0198)
class UTgDeviceForm_Fenrir_Brutalize : public UTgDeviceForm_TargetIndicator
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 100867 );

		return pClassPointer;
	};

};

UClass* UTgDeviceForm_Fenrir_Brutalize::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_Geb_StoneShield
// 0x0000 (0x0198 - 0x0198)
class UTgDeviceForm_Geb_StoneShield : public UTgDeviceForm_TargetIndicator
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 100880 );

		return pClassPointer;
	};

};

UClass* UTgDeviceForm_Geb_StoneShield::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_HouYi_Dev1_Shooter
// 0x0000 (0x01BC - 0x01BC)
class UTgDeviceForm_HouYi_Dev1_Shooter : public UTgDeviceForm_SplineTarget
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 100937 );

		return pClassPointer;
	};

};

UClass* UTgDeviceForm_HouYi_Dev1_Shooter::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_HouYi_GoldenCrow
// 0x0000 (0x0198 - 0x0198)
class UTgDeviceForm_HouYi_GoldenCrow : public UTgDeviceForm_TargetIndicator
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 100939 );

		return pClassPointer;
	};

};

UClass* UTgDeviceForm_HouYi_GoldenCrow::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_Janus_DeathGate
// 0x0000 (0x01BC - 0x01BC)
class UTgDeviceForm_Janus_DeathGate : public UTgDeviceForm_SplineTarget
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 100942 );

		return pClassPointer;
	};

};

UClass* UTgDeviceForm_Janus_DeathGate::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_JingWei_Dev4
// 0x0000 (0x0198 - 0x0198)
class UTgDeviceForm_JingWei_Dev4 : public UTgDeviceForm_TwoPhase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 100946 );

		return pClassPointer;
	};

};

UClass* UTgDeviceForm_JingWei_Dev4::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_Khepri_Dev4
// 0x0000 (0x0198 - 0x0198)
class UTgDeviceForm_Khepri_Dev4 : public UTgDeviceForm_TargetIndicator
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 100959 );

		return pClassPointer;
	};

};

UClass* UTgDeviceForm_Khepri_Dev4::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_Loki_Assassinate
// 0x0000 (0x0198 - 0x0198)
class UTgDeviceForm_Loki_Assassinate : public UTgDeviceForm_TargetIndicator
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 100979 );

		return pClassPointer;
	};

};

UClass* UTgDeviceForm_Loki_Assassinate::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_Medusa_Offhand2
// 0x0000 (0x0190 - 0x0190)
class UTgDeviceForm_Medusa_Offhand2 : public UTgDeviceForm_LineCone
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 100995 );

		return pClassPointer;
	};

};

UClass* UTgDeviceForm_Medusa_Offhand2::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_Neith_Unravel
// 0x0000 (0x01B0 - 0x01B0)
class UTgDeviceForm_Neith_Unravel : public UTgDeviceForm_Neith_SpiritArrow
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 101017 );

		return pClassPointer;
	};

};

UClass* UTgDeviceForm_Neith_Unravel::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_Nemesis_Ult
// 0x0000 (0x0198 - 0x0198)
class UTgDeviceForm_Nemesis_Ult : public UTgDeviceForm_TargetIndicator
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 101029 );

		return pClassPointer;
	};

};

UClass* UTgDeviceForm_Nemesis_Ult::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_NuWa_ShiningMetal
// 0x0000 (0x01B0 - 0x01B0)
class UTgDeviceForm_NuWa_ShiningMetal : public UTgDeviceForm_Neith_SpiritArrow
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 101039 );

		return pClassPointer;
	};

};

UClass* UTgDeviceForm_NuWa_ShiningMetal::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_PreFire
// 0x0000 (0x0188 - 0x0188)
class UTgDeviceForm_PreFire : public UTgDeviceForm
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 101058 );

		return pClassPointer;
	};

};

UClass* UTgDeviceForm_PreFire::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_Ratatoskr_UltimateShooter
// 0x0000 (0x0198 - 0x0198)
class UTgDeviceForm_Ratatoskr_UltimateShooter : public UTgDeviceForm_TwoPhase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 101082 );

		return pClassPointer;
	};

};

UClass* UTgDeviceForm_Ratatoskr_UltimateShooter::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_Ravana_Dev4
// 0x0000 (0x0198 - 0x0198)
class UTgDeviceForm_Ravana_Dev4 : public UTgDeviceForm_TargetIndicator
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 101084 );

		return pClassPointer;
	};

};

UClass* UTgDeviceForm_Ravana_Dev4::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_Scylla_Monster
// 0x0000 (0x01A0 - 0x01A0)
class UTgDeviceForm_Scylla_Monster : public UTgDeviceForm_MultipleTargetIndicator
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 101086 );

		return pClassPointer;
	};

};

UClass* UTgDeviceForm_Scylla_Monster::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_Serqet_Deathbane
// 0x0000 (0x01BC - 0x01BC)
class UTgDeviceForm_Serqet_Deathbane : public UTgDeviceForm_SplineTarget
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 101102 );

		return pClassPointer;
	};

};

UClass* UTgDeviceForm_Serqet_Deathbane::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_Skadi_Dev1
// 0x0000 (0x01B0 - 0x01B0)
class UTgDeviceForm_Skadi_Dev1 : public UTgDeviceForm_Neith_SpiritArrow
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 101123 );

		return pClassPointer;
	};

};

UClass* UTgDeviceForm_Skadi_Dev1::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_Skadi_Dev2
// 0x0000 (0x0198 - 0x0198)
class UTgDeviceForm_Skadi_Dev2 : public UTgDeviceForm_TargetIndicator
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 101125 );

		return pClassPointer;
	};

};

UClass* UTgDeviceForm_Skadi_Dev2::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_Skadi_Dev4
// 0x0000 (0x01B0 - 0x01B0)
class UTgDeviceForm_Skadi_Dev4 : public UTgDeviceForm_Neith_SpiritArrow
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 101128 );

		return pClassPointer;
	};

};

UClass* UTgDeviceForm_Skadi_Dev4::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_Sol_SolarFlair
// 0x0000 (0x01BC - 0x01BC)
class UTgDeviceForm_Sol_SolarFlair : public UTgDeviceForm_SplineTarget
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 101130 );

		return pClassPointer;
	};

};

UClass* UTgDeviceForm_Sol_SolarFlair::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_Susano_Dev2
// 0x0000 (0x0198 - 0x0198)
class UTgDeviceForm_Susano_Dev2 : public UTgDeviceForm_Nemesis_Num2
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 101132 );

		return pClassPointer;
	};

};

UClass* UTgDeviceForm_Susano_Dev2::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_Susano_Dev2_Part3
// 0x0000 (0x0188 - 0x0188)
class UTgDeviceForm_Susano_Dev2_Part3 : public UTgDeviceForm
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 101134 );

		return pClassPointer;
	};

};

UClass* UTgDeviceForm_Susano_Dev2_Part3::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_Thoth_Dev1
// 0x0000 (0x0198 - 0x0198)
class UTgDeviceForm_Thoth_Dev1 : public UTgDeviceForm_TwoPhase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 101165 );

		return pClassPointer;
	};

};

UClass* UTgDeviceForm_Thoth_Dev1::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_XingTian_SkyCuttingAxe
// 0x0000 (0x0198 - 0x0198)
class UTgDeviceForm_XingTian_SkyCuttingAxe : public UTgDeviceForm_Bellona_SpinToStrike
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 101177 );

		return pClassPointer;
	};

};

UClass* UTgDeviceForm_XingTian_SkyCuttingAxe::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_XingTian_UltSweep
// 0x0000 (0x0194 - 0x0194)
class UTgDeviceForm_XingTian_UltSweep : public UTgDeviceForm_RadialSweep
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 101179 );

		return pClassPointer;
	};

};

UClass* UTgDeviceForm_XingTian_UltSweep::pClassPointer = NULL;

// Class TgGame.TgDeviceVolumeInfo
// 0x0004 (0x01F4 - 0x01F0)
class ATgDeviceVolumeInfo : public AInfo
{
public:
	class ATgDeviceVolume*                             V;                                                		// 0x01F0 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 101197 );

		return pClassPointer;
	};

	void eventTimer ( );
	void eventPostBeginPlay ( );
};

UClass* ATgDeviceVolumeInfo::pClassPointer = NULL;

// Class TgGame.TgEffectDamage_ReapplyInterval
// 0x0000 (0x0088 - 0x0088)
class UTgEffectDamage_ReapplyInterval : public UTgEffectDamage
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 101694 );

		return pClassPointer;
	};

};

UClass* UTgEffectDamage_ReapplyInterval::pClassPointer = NULL;

// Class TgGame.TgEffectForm_Arachne_LoveFangs
// 0x0000 (0x00A4 - 0x00A4)
class UTgEffectForm_Arachne_LoveFangs : public UTgEffectForm_WithMeshes
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 101766 );

		return pClassPointer;
	};

};

UClass* UTgEffectForm_Arachne_LoveFangs::pClassPointer = NULL;

// Class TgGame.TgEffectForm_Nox_ShieldBreak
// 0x0000 (0x00A4 - 0x00A4)
class UTgEffectForm_Nox_ShieldBreak : public UTgEffectForm_BulwarkOfHope
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 101815 );

		return pClassPointer;
	};

};

UClass* UTgEffectForm_Nox_ShieldBreak::pClassPointer = NULL;

// Class TgGame.TgEffectForm_NuWa_Meteor
// 0x0000 (0x00A4 - 0x00A4)
class UTgEffectForm_NuWa_Meteor : public UTgEffectForm_WithMeshes
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 101817 );

		return pClassPointer;
	};

};

UClass* UTgEffectForm_NuWa_Meteor::pClassPointer = NULL;

// Class TgGame.TgEffectForm_Odin_RavenShout
// 0x0000 (0x00A4 - 0x00A4)
class UTgEffectForm_Odin_RavenShout : public UTgEffectForm_BulwarkOfHope
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 101819 );

		return pClassPointer;
	};

};

UClass* UTgEffectForm_Odin_RavenShout::pClassPointer = NULL;

// Class TgGame.TgEffectForm_Sylvanus_Hand
// 0x0000 (0x00A4 - 0x00A4)
class UTgEffectForm_Sylvanus_Hand : public UTgEffectForm_WithMeshes
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 101832 );

		return pClassPointer;
	};

};

UClass* UTgEffectForm_Sylvanus_Hand::pClassPointer = NULL;

// Class TgGame.TgElevatingVolume
// 0x0000 (0x0264 - 0x0264)
class ATgElevatingVolume : public APhysicsVolume
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 102414 );

		return pClassPointer;
	};

};

UClass* ATgElevatingVolume::pClassPointer = NULL;

// Class TgGame.TgEmitterCrashlanding
// 0x0014 (0x0210 - 0x01FC)
class ATgEmitterCrashlanding : public ATgEmitterSpawnable
{
public:
	class UStaticMeshComponent*                        m_PrimaryMesh;                                    		// 0x01FC (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class UStaticMeshComponent*                        m_SecondaryMesh;                                  		// 0x0200 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	float                                              ParticleDurationAfterImpact;                      		// 0x0204 (0x0004) [0x0000000000000000]              
	class ULensFlareComponent*                         m_LensFlare;                                      		// 0x0208 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class UAudioComponent*                             m_AudioComponent;                                 		// 0x020C (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 102427 );

		return pClassPointer;
	};

	void PostImpactComplete ( );
	void OnImpact ( );
	void SetAudio ( class USoundCue* SoundCueToSet );
	void SetSecondaryMesh ( class UStaticMesh* StaticMeshToSet );
	void SetPrimaryMesh ( class UStaticMesh* StaticMeshToSet );
};

UClass* ATgEmitterCrashlanding::pClassPointer = NULL;

// Class TgGame.TgFadingEnvironmentInterface
// 0x0000 (0x003C - 0x003C)
class UTgFadingEnvironmentInterface : public UInterface
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 102448 );

		return pClassPointer;
	};

	void SetFading ( unsigned long bShouldBeFaded, unsigned long bImmediate );
};

UClass* UTgFadingEnvironmentInterface::pClassPointer = NULL;

// Class TgGame.TgOnlineGameSettings
// 0x0000 (0x00F4 - 0x00F4)
class UTgOnlineGameSettings : public UOnlineGameSettings
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 102775 );

		return pClassPointer;
	};

};

UClass* UTgOnlineGameSettings::pClassPointer = NULL;

// Class TgGame.TgSeqEvent_Training_QuestComplete
// 0x0004 (0x00E0 - 0x00DC)
class UTgSeqEvent_Training_QuestComplete : public USequenceEvent
{
public:
	int                                                m_nEventId;                                       		// 0x00DC (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 103257 );

		return pClassPointer;
	};

};

UClass* UTgSeqEvent_Training_QuestComplete::pClassPointer = NULL;

// Class TgGame.TgGame_Battle_Clash_Training
// 0x0000 (0x0598 - 0x0598)
class ATgGame_Battle_Clash_Training : public ATgGame_Battle_Clash_Practice
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 103474 );

		return pClassPointer;
	};

};

UClass* ATgGame_Battle_Clash_Training::pClassPointer = NULL;

// Class TgGame.TgGame_Battle_Conquest_Casual_1_10
// 0x0000 (0x0598 - 0x0598)
class ATgGame_Battle_Conquest_Casual_1_10 : public ATgGame_Battle_Conquest
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 103486 );

		return pClassPointer;
	};

};

UClass* ATgGame_Battle_Conquest_Casual_1_10::pClassPointer = NULL;

// Class TgGame.TgGame_Battle_Conquest_Casual_3_6
// 0x0000 (0x0598 - 0x0598)
class ATgGame_Battle_Conquest_Casual_3_6 : public ATgGame_Battle_Conquest
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 103488 );

		return pClassPointer;
	};

};

UClass* ATgGame_Battle_Conquest_Casual_3_6::pClassPointer = NULL;

// Class TgGame.TgGame_Battle_Conquest_Casual_5_0
// 0x0000 (0x0598 - 0x0598)
class ATgGame_Battle_Conquest_Casual_5_0 : public ATgGame_Battle_Conquest
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 103490 );

		return pClassPointer;
	};

};

UClass* ATgGame_Battle_Conquest_Casual_5_0::pClassPointer = NULL;

// Class TgGame.TgGame_Battle_Joust_Casual_3_10
// 0x0000 (0x0598 - 0x0598)
class ATgGame_Battle_Joust_Casual_3_10 : public ATgGame_Battle_Joust
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 103632 );

		return pClassPointer;
	};

};

UClass* ATgGame_Battle_Joust_Casual_3_10::pClassPointer = NULL;

// Class TgGame.TgGame_Battle_Joust_Casual_5_0
// 0x0000 (0x0598 - 0x0598)
class ATgGame_Battle_Joust_Casual_5_0 : public ATgGame_Battle_Joust
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 103634 );

		return pClassPointer;
	};

};

UClass* ATgGame_Battle_Joust_Casual_5_0::pClassPointer = NULL;

// Class TgGame.TgIdol
// 0x0010 (0x0200 - 0x01F0)
class ATgIdol : public AActor
{
public:
	int                                                r_nDefenderTaskForce;                             		// 0x01F0 (0x0004) [0x0000000000002020]              ( CPF_Net | CPF_Transient )
	class ATgPawn_Character*                           m_Holder;                                         		// 0x01F4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class ATgRepInfo_Player*                           r_HolderPRI;                                      		// 0x01F8 (0x0004) [0x0000000000002020]              ( CPF_Net | CPF_Transient )
	class ATgPawn_Character*                           m_OldHolder;                                      		// 0x01FC (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 103811 );

		return pClassPointer;
	};

};

UClass* ATgIdol::pClassPointer = NULL;

// Class TgGame.TgHoldSpot
// 0x0004 (0x02D0 - 0x02CC)
class ATgHoldSpot : public ATgDefensePoint
{
public:
	class AVehicle*                                    HoldVehicle;                                      		// 0x02CC (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 103938 );

		return pClassPointer;
	};

	void FreePoint ( );
	class AActor* GetMoveTarget ( );
};

UClass* ATgHoldSpot::pClassPointer = NULL;

// Class TgGame.TgInterpolatingCameraActor
// 0x0018 (0x038C - 0x0374)
class ATgInterpolatingCameraActor : public ACameraActor
{
public:
	TArray< struct FInterpolatingCameraInfo >          m_CameraArray;                                    		// 0x0374 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	int                                                m_nCurrentCameraIndex;                            		// 0x0380 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fCurrentInterpValue;                            		// 0x0384 (0x0004) [0x0000000000000000]              
	float                                              m_fTargetInterpValue;                             		// 0x0388 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 104018 );

		return pClassPointer;
	};

	void eventTick ( float DeltaTime );
	void GetCameraView ( float DeltaTime, struct FTPOV* OutPOV );
	void eventGetActorEyesViewPoint ( struct FVector* out_Location, struct FRotator* out_Rotation );
};

UClass* ATgInterpolatingCameraActor::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_Heartseeker
// 0x0000 (0x00A8 - 0x00A8)
class UTgInventoryObject_Listen_Heartseeker : public UTgInventoryObject_Listen_SoulStone_S3
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 104330 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_Heartseeker::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_HydrasDemise
// 0x0000 (0x00A4 - 0x00A4)
class UTgInventoryObject_Listen_HydrasDemise : public UTgInventoryObject_Listen_NextAttack
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 104340 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_HydrasDemise::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_HydrasStar
// 0x0000 (0x00AC - 0x00AC)
class UTgInventoryObject_Listen_HydrasStar : public UTgInventoryObject_Listen_HydrasLament
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 104346 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_HydrasStar::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_SerqetCatalystWithRemove
// 0x0000 (0x00C0 - 0x00C0)
class UTgInventoryObject_Listen_SerqetCatalystWithRemove : public UTgInventoryObject_Listen_SerqetCatalyst
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 104482 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_SerqetCatalystWithRemove::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Listen_Thyrsus
// 0x0000 (0x00A4 - 0x00A4)
class UTgInventoryObject_Listen_Thyrsus : public UTgInventoryObject_Listen_OnEffectCategoryRemoved
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 104514 );

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Listen_Thyrsus::pClassPointer = NULL;

// Class TgGame.TgKismetTestActor
// 0x0030 (0x025C - 0x022C)
class ATgKismetTestActor : public ADynamicSMActor
{
public:
	int                                                m_nTestCount;                                     		// 0x022C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                r_nCurrentTest;                                   		// 0x0230 (0x0004) [0x0000000000000021]              ( CPF_Edit | CPF_Net )
	int                                                r_nPassCount;                                     		// 0x0234 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nFailCount;                                     		// 0x0238 (0x0004) [0x0000000000000020]              ( CPF_Net )
	TArray< class UTexture2D* >                        c_aTextures;                                      		// 0x023C (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	class USoundCue*                                   c_PassSound;                                      		// 0x0248 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class USoundCue*                                   c_FailSound;                                      		// 0x024C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	TArray< class AInterpActor* >                      c_aResultActors;                                  		// 0x0250 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 104683 );

		return pClassPointer;
	};

	void eventReplicatedEvent ( struct FName VarName );
	void StartTest ( int Num );
	void FailTest ( int Num );
	void PassTest ( int Num );
	void eventPostBeginPlay ( );
	void SetTestColor ( int Num, struct FLinearColor Col );
	class APlayerController* GetLocalPlayer ( );
	void OnTestResult ( class UTgSeqAct_TestResult* Action );
};

UClass* ATgKismetTestActor::pClassPointer = NULL;

// Class TgGame.TgSeqAct_TestResult
// 0x0000 (0x00C4 - 0x00C4)
class UTgSeqAct_TestResult : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 104696 );

		return pClassPointer;
	};

};

UClass* UTgSeqAct_TestResult::pClassPointer = NULL;

// Class TgGame.TgSeqEvent_LobbyCameraSetActive
// 0x0000 (0x00DC - 0x00DC)
class UTgSeqEvent_LobbyCameraSetActive : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 104746 );

		return pClassPointer;
	};

};

UClass* UTgSeqEvent_LobbyCameraSetActive::pClassPointer = NULL;

// Class TgGame.TgMenuTransitionActor
// 0x000C (0x01FC - 0x01F0)
class ATgMenuTransitionActor : public AActor
{
public:
	class UParticleSystemComponent*                    m_IntroPSC;                                       		// 0x01F0 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class UParticleSystemComponent*                    m_LoopPSC;                                        		// 0x01F4 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class UParticleSystemComponent*                    m_OutroPSC;                                       		// 0x01F8 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 104928 );

		return pClassPointer;
	};

	void StopLoop ( );
	void PlayLoop ( );
	void PlayOutro ( );
	void PlayIntro ( );
};

UClass* ATgMenuTransitionActor::pClassPointer = NULL;

// Class TgGame.TgSeqAct_ParentAnimComponent
// 0x0004 (0x00C8 - 0x00C4)
class UTgSeqAct_ParentAnimComponent : public USequenceAction
{
public:
	unsigned long                                      bDetach : 1;                                      		// 0x00C4 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 105074 );

		return pClassPointer;
	};

};

UClass* UTgSeqAct_ParentAnimComponent::pClassPointer = NULL;

// Class TgGame.TgPawn_ArenaJuggernaut_RA2015a
// 0x0013 (0x1C38 - 0x1C25)
class ATgPawn_ArenaJuggernaut_RA2015a : public ATgPawn_WiseCleric
{
public:
	float                                              r_fDespawnHealthPercent;                          		// 0x1C28 (0x0004) [0x0000000000000020]              ( CPF_Net )
	TArray< struct FName >                             m_DespawnAnimNames;                               		// 0x1C2C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 106506 );

		return pClassPointer;
	};

	struct FName eventGetDespawnAnimName ( );
	void eventDespawn ( );
};

UClass* ATgPawn_ArenaJuggernaut_RA2015a::pClassPointer = NULL;

// Class TgGame.TgSkeletalMeshActor_DestructibleTowerChunk
// 0x0004 (0x026C - 0x0268)
class ATgSkeletalMeshActor_DestructibleTowerChunk : public ATgSkeletalMeshActorSpawnable
{
public:
	class UTgSkeletalMeshComponent*                    TgSkeletalMeshComp;                               		// 0x0268 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 106835 );

		return pClassPointer;
	};

	bool eventPlayParticleEffect ( class UAnimNotify_PlayParticleEffect* AnimNotifyData );
	void PlayDestruction ( int MeshId, class ATgPawn_Tower* OwningTower );
};

UClass* ATgSkeletalMeshActor_DestructibleTowerChunk::pClassPointer = NULL;

// Class TgGame.TgPawn_AsgardTower
// 0x0000 (0x1BA8 - 0x1BA8)
class ATgPawn_AsgardTower : public ATgPawn_Tower
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 106872 );

		return pClassPointer;
	};

};

UClass* ATgPawn_AsgardTower::pClassPointer = NULL;

// Class TgGame.TgPawn_Bakasura_Minion
// 0x0000 (0x1B8C - 0x1B8C)
class ATgPawn_Bakasura_Minion : public ATgPawn_Familiar
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 107419 );

		return pClassPointer;
	};

	struct FName eventGetDeathAnimName ( );
};

UClass* ATgPawn_Bakasura_Minion::pClassPointer = NULL;

// Class TgGame.TgPawn_CapturePointGuard
// 0x0000 (0x1C3C - 0x1C3C)
class ATgPawn_CapturePointGuard : public ATgPawn_Monster
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 107866 );

		return pClassPointer;
	};

	bool CanDespawn ( );
};

UClass* ATgPawn_CapturePointGuard::pClassPointer = NULL;

// Class TgGame.TgPawn_Chaac_UltStorm
// 0x0000 (0x1B8C - 0x1B8C)
class ATgPawn_Chaac_UltStorm : public ATgPawn_Familiar
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 108055 );

		return pClassPointer;
	};

	bool eventDied ( class AController* Killer, class UClass* dmgType, struct FVector HitLocation );
};

UClass* ATgPawn_Chaac_UltStorm::pClassPointer = NULL;

// Class TgGame.TgPawn_Egypt_Ba
// 0x0000 (0x1C3C - 0x1C3C)
class ATgPawn_Egypt_Ba : public ATgPawn_Fury
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 108818 );

		return pClassPointer;
	};

	struct FName eventGetDeathAnimName ( );
};

UClass* ATgPawn_Egypt_Ba::pClassPointer = NULL;

// Class TgGame.TgPawn_Gryphon
// 0x0000 (0x1BA8 - 0x1BA8)
class ATgPawn_Gryphon : public ATgPawn_Tower_ArenaBase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 109562 );

		return pClassPointer;
	};

};

UClass* ATgPawn_Gryphon::pClassPointer = NULL;

// Class TgGame.TgPawn_JoustBoss_CJ2016a
// 0x0000 (0x1C40 - 0x1C40)
class ATgPawn_JoustBoss_CJ2016a : public ATgPawn_JoustBoss
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 110697 );

		return pClassPointer;
	};

};

UClass* ATgPawn_JoustBoss_CJ2016a::pClassPointer = NULL;

// Class TgGame.TgPawn_MiniBastet
// 0x0000 (0x1B28 - 0x1B28)
class ATgPawn_MiniBastet : public ATgPawn
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 111744 );

		return pClassPointer;
	};

};

UClass* ATgPawn_MiniBastet::pClassPointer = NULL;

// Class TgGame.TgPawn_Minion_RA2015a
// 0x000C (0x1C30 - 0x1C24)
class ATgPawn_Minion_RA2015a : public ATgPawn_Minion
{
public:
	TArray< struct FName >                             m_DespawnAnimNames;                               		// 0x1C24 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 111751 );

		return pClassPointer;
	};

	struct FName eventGetDespawnAnimName ( );
};

UClass* ATgPawn_Minion_RA2015a::pClassPointer = NULL;

// Class TgGame.TgProj_NeZha_ArmillarySash
// 0x0000 (0x02CC - 0x02CC)
class ATgProj_NeZha_ArmillarySash : public ATgProj_Simulated
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 112212 );

		return pClassPointer;
	};

	void ShutDown ( );
	void eventSpawnFlightEffects ( );
	void Tick ( float DeltaSeconds );
	bool ApplyHit ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal, int HitItem );
	void eventHitWall ( struct FVector HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp );
	void RangeReached ( );
	void ProcessTouch ( class AActor* Other, struct FVector HitLocation, struct FVector HitNormal );
};

UClass* ATgProj_NeZha_ArmillarySash::pClassPointer = NULL;

// Class TgGame.TgPawn_Phoenix_GreekConquest
// 0x0000 (0x1B60 - 0x1B60)
class ATgPawn_Phoenix_GreekConquest : public ATgPawn_Phoenix
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 113018 );

		return pClassPointer;
	};

};

UClass* ATgPawn_Phoenix_GreekConquest::pClassPointer = NULL;

// Class TgGame.TgPawn_Tower_Arena
// 0x0000 (0x1BA8 - 0x1BA8)
class ATgPawn_Tower_Arena : public ATgPawn_Tower_ArenaBase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 114995 );

		return pClassPointer;
	};

};

UClass* ATgPawn_Tower_Arena::pClassPointer = NULL;

// Class TgGame.TgPawn_Tower_Olympus
// 0x0000 (0x1BA8 - 0x1BA8)
class ATgPawn_Tower_Olympus : public ATgPawn_Tower
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 115003 );

		return pClassPointer;
	};

};

UClass* ATgPawn_Tower_Olympus::pClassPointer = NULL;

// Class TgGame.TgPawn_Tower_AsgardLava
// 0x0000 (0x1BA8 - 0x1BA8)
class ATgPawn_Tower_AsgardLava : public ATgPawn_Tower_Olympus
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 115011 );

		return pClassPointer;
	};

};

UClass* ATgPawn_Tower_AsgardLava::pClassPointer = NULL;

// Class TgGame.TgPawn_Tower_AsgardNew
// 0x0000 (0x1BA8 - 0x1BA8)
class ATgPawn_Tower_AsgardNew : public ATgPawn_Tower_Olympus
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 115019 );

		return pClassPointer;
	};

};

UClass* ATgPawn_Tower_AsgardNew::pClassPointer = NULL;

// Class TgGame.TgPawn_Tower_Invader
// 0x0000 (0x1BA8 - 0x1BA8)
class ATgPawn_Tower_Invader : public ATgPawn_Tower_Olympus
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 115050 );

		return pClassPointer;
	};

};

UClass* ATgPawn_Tower_Invader::pClassPointer = NULL;

// Class TgGame.TgPawn_Tower_Joust
// 0x0000 (0x1BA8 - 0x1BA8)
class ATgPawn_Tower_Joust : public ATgPawn_Tower
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 115058 );

		return pClassPointer;
	};

};

UClass* ATgPawn_Tower_Joust::pClassPointer = NULL;

// Class TgGame.TgPawn_Tower_Mayan
// 0x0000 (0x1BA8 - 0x1BA8)
class ATgPawn_Tower_Mayan : public ATgPawn_Tower
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 115066 );

		return pClassPointer;
	};

	void OnSwapToDestroyedMesh ( );
};

UClass* ATgPawn_Tower_Mayan::pClassPointer = NULL;

// Class TgGame.TgPawn_Tower_MayanRed
// 0x0000 (0x1BA8 - 0x1BA8)
class ATgPawn_Tower_MayanRed : public ATgPawn_Tower_Mayan
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 115077 );

		return pClassPointer;
	};

};

UClass* ATgPawn_Tower_MayanRed::pClassPointer = NULL;

// Class TgGame.TgPawn_Tower_OlympusV2
// 0x0000 (0x1BA8 - 0x1BA8)
class ATgPawn_Tower_OlympusV2 : public ATgPawn_Tower_Olympus
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 115125 );

		return pClassPointer;
	};

	void eventPostDemoRewind ( );
};

UClass* ATgPawn_Tower_OlympusV2::pClassPointer = NULL;

// Class TgGame.TgPawn_Tower_RA2015a
// 0x0000 (0x1BA8 - 0x1BA8)
class ATgPawn_Tower_RA2015a : public ATgPawn_Tower
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 115144 );

		return pClassPointer;
	};

};

UClass* ATgPawn_Tower_RA2015a::pClassPointer = NULL;

// Class TgGame.TgPhysAnimTestActor
// 0x0088 (0x0278 - 0x01F0)
class ATgPhysAnimTestActor : public AActor
{
public:
	TArray< struct FName >                             LowerBoneNames;                                   		// 0x01F0 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< struct FName >                             LinearBoneSpringNames;                            		// 0x01FC (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< struct FName >                             AngularBoneSpringNames;                           		// 0x0208 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	class USkeletalMeshComponent*                      SkeletalMeshComponent;                            		// 0x0214 (0x0004) [0x0000000004080009]              ( CPF_Edit | CPF_ExportObject | CPF_Component | CPF_EditInline )
	unsigned char                                      CurrentState;                                     		// 0x0218 (0x0001) [0x0000000000000000]              
	unsigned long                                      bBlendToGetUp : 1;                                		// 0x021C (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      bBlendingBack : 1;                                		// 0x021C (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      bRampingDownMotors : 1;                           		// 0x021C (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      bNextPokeKnocksDown : 1;                          		// 0x021C (0x0004) [0x0000000000000000] [0x00000008] 
	float                                              GetUpBlendStartTime;                              		// 0x0220 (0x0004) [0x0000000000000000]              
	float                                              GetUpBlendTime;                                   		// 0x0224 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              GetUpToIdleTime;                                  		// 0x0228 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              ActorOriginHeight;                                		// 0x022C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              PokePauseTime;                                    		// 0x0230 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              PokeBlendTime;                                    		// 0x0234 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              BlendBackStartTime;                               		// 0x0238 (0x0004) [0x0000000000000000]              
	float                                              MotorDownStartTime;                               		// 0x023C (0x0004) [0x0000000000000000]              
	float                                              MotorDownTime;                                    		// 0x0240 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              MotorDownAnimTime;                                		// 0x0244 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              BlendStaggerAnimTime;                             		// 0x0248 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              StaggerSpeedAdj;                                  		// 0x024C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              StaggerVel;                                       		// 0x0250 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FVector                                     MoveDir;                                          		// 0x0254 (0x000C) [0x0000000000000000]              
	float                                              AngularHipDriveScale;                             		// 0x0260 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              StaggerMuscleScale;                               		// 0x0264 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UAnimNodeBlend*                              blendNode;                                        		// 0x0268 (0x0004) [0x0000000000000000]              
	class UAnimNodeSequence*                           GetUpNode;                                        		// 0x026C (0x0004) [0x0000000000000000]              
	class UAnimNodeSequence*                           RunNode;                                          		// 0x0270 (0x0004) [0x0000000000000000]              
	class URB_BodyInstance*                            HipBody;                                          		// 0x0274 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 116235 );

		return pClassPointer;
	};

	void eventOnAnimEnd ( class UAnimNodeSequence* SeqNode, float PlayedTime, float ExcessTime );
	void Tick ( float DeltaSeconds );
	void SetAllMotorsAngularDriveStrength ( float InAngularSpringStrength, float InAngularDampingStrength, float InAngularForceLimitStrength, class USkeletalMeshComponent* SkelMeshComp );
	void RecoverFromRagdoll ( );
	void SetBoneSprings ( unsigned long bEnabled );
	bool IsAngularBoneSpringName ( struct FName InName );
	bool IsLinearBoneSpringName ( struct FName InName );
	void SetLowerFixed ( );
	void DetachAttachments ( );
	bool IsLowerBodyName ( struct FName InName );
	void SetBodiesFixed ( unsigned long InFixed );
	void EnableMotors ( unsigned long InEnabled );
	void SetPATAState ( unsigned char NewState );
	void EndGrab ( );
	bool PreGrab ( );
	bool PrePokeActor ( struct FVector PokeDir );
	void BoneImpulse ( struct FVector Impulse, struct FName BoneName );
	void PostBeginPlay ( );
};

UClass* ATgPhysAnimTestActor::pClassPointer = NULL;

// Class TgGame.TgPickupFactory_Item
// 0x0014 (0x02FC - 0x02E8)
class ATgPickupFactory_Item : public ATgPickupFactory
{
public:
	class USoundCue*                                   PickupSound;                                      		// 0x02E8 (0x0004) [0x0000000000000000]              
	struct FString                                     PickupMessage;                                    		// 0x02EC (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	float                                              RespawnTime;                                      		// 0x02F8 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 116363 );

		return pClassPointer;
	};

	float BotDesireability ( class APawn* P );
	float GetRespawnTime ( );
	void SetRespawn ( );
	void SpawnCopyFor ( class APawn* Recipient );
	struct FString GetLocalString ( int Switch, class APlayerReplicationInfo* RelatedPRI, class APlayerReplicationInfo* RelatedPRI01 );
	void InitializePickup ( );
};

UClass* ATgPickupFactory_Item::pClassPointer = NULL;

// Class TgGame.TgProj_AhMuzenCab_BeeFlockAttack
// 0x0000 (0x02E8 - 0x02E8)
class ATgProj_AhMuzenCab_BeeFlockAttack : public ATgProj_SimulatedSeeking
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 116884 );

		return pClassPointer;
	};

	void eventExplodeOnTarget ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal );
};

UClass* ATgProj_AhMuzenCab_BeeFlockAttack::pClassPointer = NULL;

// Class TgGame.TgProj_AhMuzenCab_Stinger
// 0x0010 (0x02DC - 0x02CC)
class ATgProj_AhMuzenCab_Stinger : public ATgProj_Simulated
{
public:
	unsigned long                                      m_bInitialHit : 1;                                		// 0x02CC (0x0004) [0x0000000000000000] [0x00000001] 
	TArray< class AActor* >                            m_PreviouslyHitTargets;                           		// 0x02D0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 116911 );

		return pClassPointer;
	};

	void HitTarget ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal );
	void ProcessTouch ( class AActor* Other, struct FVector HitLocation, struct FVector HitNormal );
};

UClass* ATgProj_AhMuzenCab_Stinger::pClassPointer = NULL;

// Class TgGame.TgProj_AhPuch_Dev3
// 0x0004 (0x02F4 - 0x02F0)
class ATgProj_AhPuch_Dev3 : public ATgProj_SimulatedGroundTarget_FixedVelocity_XY_MinAirTime
{
public:
	unsigned long                                      m_bHitTarget : 1;                                 		// 0x02F0 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 117013 );

		return pClassPointer;
	};

	void ShutDown ( );
	bool ApplyHit ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal, int HitItem );
};

UClass* ATgProj_AhPuch_Dev3::pClassPointer = NULL;

// Class TgGame.TgProj_Anubis_Mummify
// 0x0000 (0x02CC - 0x02CC)
class ATgProj_Anubis_Mummify : public ATgProj_Simulated
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 117120 );

		return pClassPointer;
	};

};

UClass* ATgProj_Anubis_Mummify::pClassPointer = NULL;

// Class TgGame.TgProj_AoKuang_WildStorm
// 0x0000 (0x02CC - 0x02CC)
class ATgProj_AoKuang_WildStorm : public ATgProj_Simulated
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 117172 );

		return pClassPointer;
	};

};

UClass* ATgProj_AoKuang_WildStorm::pClassPointer = NULL;

// Class TgGame.TgProj_Aphrodite_SoulMates
// 0x0000 (0x02E8 - 0x02E8)
class ATgProj_Aphrodite_SoulMates : public ATgProj_SimulatedSeeking
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 117176 );

		return pClassPointer;
	};

	bool IsValidTarget ( class AActor* A );
};

UClass* ATgProj_Aphrodite_SoulMates::pClassPointer = NULL;

// Class TgGame.TgProj_Ares_Shackle
// 0x000C (0x02E8 - 0x02DC)
class ATgProj_Ares_Shackle : public ATgProj_SimulatedPassThrough
{
public:
	class UTgStaticMeshComponent*                      c_ConnectedShackleMeshComponent;                  		// 0x02DC (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	float                                              c_ShackleDestroyProgressPercentage;               		// 0x02E0 (0x0004) [0x0000000000000000]              
	unsigned long                                      c_ExplodedOnTarget : 1;                           		// 0x02E4 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 117199 );

		return pClassPointer;
	};

	void Destroyed ( );
	void eventExplodeOnTarget ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal );
	void ProcessTouch ( class AActor* Other, struct FVector HitLocation, struct FVector HitNormal );
	void eventTick ( float DeltaSeconds );
	void eventSpawnFlightEffects ( );
	void UpdateShackleChainComponent ( float DeltaSeconds );
};

UClass* ATgProj_Ares_Shackle::pClassPointer = NULL;

// Class TgGame.TgProj_Athena_ReachingStrike
// 0x0000 (0x02DC - 0x02DC)
class ATgProj_Athena_ReachingStrike : public ATgProj_SimulatedPassThrough
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 117233 );

		return pClassPointer;
	};

};

UClass* ATgProj_Athena_ReachingStrike::pClassPointer = NULL;

// Class TgGame.TgProj_Chaac_Num1Axe
// 0x0000 (0x02E8 - 0x02E8)
class ATgProj_Chaac_Num1Axe : public ATgProj_SimulatedGroundTarget_FixedVelocity_XY
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 117376 );

		return pClassPointer;
	};

	void eventExplodeOnTarget ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal );
};

UClass* ATgProj_Chaac_Num1Axe::pClassPointer = NULL;

// Class TgGame.TgProj_Chaac_Num4
// 0x0010 (0x02DC - 0x02CC)
class ATgProj_Chaac_Num4 : public ATgProj_Simulated
{
public:
	unsigned long                                      m_bInitialHit : 1;                                		// 0x02CC (0x0004) [0x0000000000000000] [0x00000001] 
	TArray< class AActor* >                            m_PreviouslyHitTargets;                           		// 0x02D0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 117389 );

		return pClassPointer;
	};

	void HitTarget ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal );
	void ProcessTouch ( class AActor* Other, struct FVector HitLocation, struct FVector HitNormal );
};

UClass* ATgProj_Chaac_Num4::pClassPointer = NULL;

// Class TgGame.TgProj_Chiron_TrainingExercise
// 0x0000 (0x02F0 - 0x02F0)
class ATgProj_Chiron_TrainingExercise : public ATgProj_SimulatedGroundTarget_FixedTime
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 117428 );

		return pClassPointer;
	};

	void eventSetGroundTarget ( struct FVector GTLocation );
};

UClass* ATgProj_Chiron_TrainingExercise::pClassPointer = NULL;

// Class TgGame.TgProj_CoinReturnStroke
// 0x0000 (0x02EC - 0x02EC)
class ATgProj_CoinReturnStroke : public ATgProj_SimulatedReturnStroke
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 117477 );

		return pClassPointer;
	};

	void UpdateSeekingDirection ( float fDeltaTime );
};

UClass* ATgProj_CoinReturnStroke::pClassPointer = NULL;

// Class TgGame.TgProj_ErlangShen_Pin
// 0x0000 (0x02F0 - 0x02F0)
class ATgProj_ErlangShen_Pin : public ATgProj_SimulatedGroundTarget_FixedVelocity_XY_MinAirTime
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 117516 );

		return pClassPointer;
	};

	void CalcAoeFire ( struct FAimData Aim, TArray< struct FImpactInfo >* ImpactList );
};

UClass* ATgProj_ErlangShen_Pin::pClassPointer = NULL;

// Class TgGame.TgProj_Fafnir_Dev1
// 0x0000 (0x02DC - 0x02DC)
class ATgProj_Fafnir_Dev1 : public ATgProj_SimulatedPassThroughUntilGod
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 117527 );

		return pClassPointer;
	};

	void eventPostProjectileInitialize ( );
};

UClass* ATgProj_Fafnir_Dev1::pClassPointer = NULL;

// Class TgGame.TgProj_Fafnir_Dev2
// 0x0000 (0x02E8 - 0x02E8)
class ATgProj_Fafnir_Dev2 : public ATgProj_SimulatedSeeking
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 117532 );

		return pClassPointer;
	};

	void ProcessTouch ( class AActor* Other, struct FVector HitLocation, struct FVector HitNormal );
	void eventSetTarget ( class AActor* TargetActor, struct FVector TargetLocation );
	bool eventUseAOE ( );
};

UClass* ATgProj_Fafnir_Dev2::pClassPointer = NULL;

// Class TgGame.TgProj_Grenade
// 0x0000 (0x02C4 - 0x02C4)
class ATgProj_Grenade : public ATgProj_Bounce
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 117650 );

		return pClassPointer;
	};

};

UClass* ATgProj_Grenade::pClassPointer = NULL;

// Class TgGame.TgProj_Isis_SandTwister
// 0x0000 (0x02DC - 0x02DC)
class ATgProj_Isis_SandTwister : public ATgProj_SimulatedPassThrough
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 117758 );

		return pClassPointer;
	};

};

UClass* ATgProj_Isis_SandTwister::pClassPointer = NULL;

// Class TgGame.TgProj_Janus_DeathGate
// 0x0000 (0x02FC - 0x02FC)
class ATgProj_Janus_DeathGate : public ATgProj_SimulatedSinusoid
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 117870 );

		return pClassPointer;
	};

};

UClass* ATgProj_Janus_DeathGate::pClassPointer = NULL;

// Class TgGame.TgProj_Janus_DeathGate_Mirror
// 0x0000 (0x02FC - 0x02FC)
class ATgProj_Janus_DeathGate_Mirror : public ATgProj_Janus_DeathGate
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 117874 );

		return pClassPointer;
	};

};

UClass* ATgProj_Janus_DeathGate_Mirror::pClassPointer = NULL;

// Class TgGame.TgProj_Kali_Incense
// 0x0000 (0x02F0 - 0x02F0)
class ATgProj_Kali_Incense : public ATgProj_SimulatedGroundTarget_FixedTime
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 117899 );

		return pClassPointer;
	};

};

UClass* ATgProj_Kali_Incense::pClassPointer = NULL;

// Class TgGame.TgProj_Kumbhakarna_Num2Boulder
// 0x0000 (0x02F0 - 0x02F0)
class ATgProj_Kumbhakarna_Num2Boulder : public ATgProj_SimulatedGroundTarget_FixedTime
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 117954 );

		return pClassPointer;
	};

	void eventExplodeOnTarget ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal );
};

UClass* ATgProj_Kumbhakarna_Num2Boulder::pClassPointer = NULL;

// Class TgGame.TgProj_Medusa_Dev1
// 0x0000 (0x02E8 - 0x02E8)
class ATgProj_Medusa_Dev1 : public ATgProj_SimulatedSeeking
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 117963 );

		return pClassPointer;
	};

	struct FVector eventGetSeekLocation ( );
};

UClass* ATgProj_Medusa_Dev1::pClassPointer = NULL;

// Class TgGame.TgProj_Neith_BrokenWeaveUser
// 0x0008 (0x02D4 - 0x02CC)
class ATgProj_Neith_BrokenWeaveUser : public ATgProj_Simulated
{
public:
	unsigned long                                      m_bDestroyWeaveOnHit : 1;                         		// 0x02CC (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bSkipFxOnDestroyWeave : 1;                      		// 0x02CC (0x0004) [0x0000000000000000] [0x00000002] 
	class UTgDeviceFire_Neith_BrokenWeaveUser*         s_OwnerSpecialFireMode;                           		// 0x02D0 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 118076 );

		return pClassPointer;
	};

	void HandleBrokenWeaveHit ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal, int HitItem );
	bool IsValidTarget ( class AActor* A );
	bool ApplyHit ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal, int HitItem );
};

UClass* ATgProj_Neith_BrokenWeaveUser::pClassPointer = NULL;

// Class TgGame.TgProj_Neith_SpiritArrow
// 0x0010 (0x02E4 - 0x02D4)
class ATgProj_Neith_SpiritArrow : public ATgProj_Neith_BrokenWeaveUser
{
public:
	unsigned long                                      m_bInitialHit : 1;                                		// 0x02D4 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bExplodeOnBlocker : 1;                          		// 0x02D4 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_bSkipFriendlies : 1;                            		// 0x02D4 (0x0004) [0x0000000000000000] [0x00000004] 
	TArray< class AActor* >                            m_PreviouslyHitTargets;                           		// 0x02D8 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 118139 );

		return pClassPointer;
	};

	void HitTarget ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal );
	void ProcessTouch ( class AActor* Other, struct FVector HitLocation, struct FVector HitNormal );
};

UClass* ATgProj_Neith_SpiritArrow::pClassPointer = NULL;

// Class TgGame.TgProj_Neith_ThreadOfLife
// 0x0000 (0x02D4 - 0x02D4)
class ATgProj_Neith_ThreadOfLife : public ATgProj_Neith_BrokenWeaveUser
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 118156 );

		return pClassPointer;
	};

	bool ApplyHit ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal, int HitItem );
};

UClass* ATgProj_Neith_ThreadOfLife::pClassPointer = NULL;

// Class TgGame.TgProj_Net
// 0x000C (0x02C4 - 0x02B8)
class ATgProj_Net : public ATgProjectile
{
public:
	struct FVector                                     c_Dir;                                            		// 0x02B8 (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 118213 );

		return pClassPointer;
	};

	void Init ( struct FVector Direction );
};

UClass* ATgProj_Net::pClassPointer = NULL;

// Class TgGame.TgProj_Nox_Dev1
// 0x0000 (0x02CC - 0x02CC)
class ATgProj_Nox_Dev1 : public ATgProj_Simulated
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 118249 );

		return pClassPointer;
	};

	void eventHitWall ( struct FVector HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp );
	void RangeReached ( );
};

UClass* ATgProj_Nox_Dev1::pClassPointer = NULL;

// Class TgGame.TgProj_Nox_Ult
// 0x0000 (0x02DC - 0x02DC)
class ATgProj_Nox_Ult : public ATgProj_SimulatedPassThrough
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 118260 );

		return pClassPointer;
	};

	bool eventUseAOE ( );
	void RangeReached ( );
	void eventHitWall ( struct FVector HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp );
	bool IsObjectivePawn ( class AActor* Other );
	bool ShouldExplode ( class AActor* Other, struct FVector HitLocation, struct FVector HitNormal );
};

UClass* ATgProj_Nox_Ult::pClassPointer = NULL;

// Class TgGame.TgProj_NuWa_ShiningMetal
// 0x000C (0x02E8 - 0x02DC)
class ATgProj_NuWa_ShiningMetal : public ATgProj_SimulatedPassThrough
{
public:
	TArray< class AActor* >                            m_ExemptList;                                     		// 0x02DC (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 118280 );

		return pClassPointer;
	};

	bool ExplodeMinion ( class ATgPawn* Target, int HitItem );
	bool ApplyHit ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal, int HitItem );
	bool IsValidTarget ( class AActor* A );
	bool IsFriendlyFamiliar ( class AActor* Target );
};

UClass* ATgProj_NuWa_ShiningMetal::pClassPointer = NULL;

// Class TgGame.TgProj_Ram_Quiver2
// 0x0000 (0x02F0 - 0x02F0)
class ATgProj_Ram_Quiver2 : public ATgProj_SimulatedGroundTarget_FixedTime
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 118530 );

		return pClassPointer;
	};

};

UClass* ATgProj_Ram_Quiver2::pClassPointer = NULL;

// Class TgGame.TgProj_Ratatoskr_AcornThrowBlue
// 0x0000 (0x02DC - 0x02DC)
class ATgProj_Ratatoskr_AcornThrowBlue : public ATgProj_Ratatoskr_AcornThrow
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 118545 );

		return pClassPointer;
	};

	bool eventApplyHit ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal, int HitItem );
};

UClass* ATgProj_Ratatoskr_AcornThrowBlue::pClassPointer = NULL;

// Class TgGame.TgProj_Ravana_Dev3
// 0x0000 (0x02DC - 0x02DC)
class ATgProj_Ravana_Dev3 : public ATgProj_SimulatedPassThroughUntilGod
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 118617 );

		return pClassPointer;
	};

	bool ShouldExplode ( class AActor* Other, struct FVector HitLocation, struct FVector HitNormal );
};

UClass* ATgProj_Ravana_Dev3::pClassPointer = NULL;

// Class TgGame.TgProj_Scylla_Num2
// 0x0000 (0x02F0 - 0x02F0)
class ATgProj_Scylla_Num2 : public ATgProj_SimulatedGroundTarget_FixedVelocity_XY_MinAirTime
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 118671 );

		return pClassPointer;
	};

	void HideProjectile ( );
	void UpdateVisualsOnSetGroundTarget ( );
};

UClass* ATgProj_Scylla_Num2::pClassPointer = NULL;

// Class TgGame.TgProj_Skadi_Dev1
// 0x0000 (0x02DC - 0x02DC)
class ATgProj_Skadi_Dev1 : public ATgProj_SimulatedPassThrough
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 118710 );

		return pClassPointer;
	};

	bool IsValidTarget ( class AActor* A );
	bool ApplyHit ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal, int HitItem );
};

UClass* ATgProj_Skadi_Dev1::pClassPointer = NULL;

// Class TgGame.TgProj_Sol_SolarFlair_Mirror
// 0x0000 (0x0310 - 0x0310)
class ATgProj_Sol_SolarFlair_Mirror : public ATgProj_Sol_SolarFlair
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 118759 );

		return pClassPointer;
	};

};

UClass* ATgProj_Sol_SolarFlair_Mirror::pClassPointer = NULL;

// Class TgGame.TgProj_Teleporter
// 0x0004 (0x02C4 - 0x02C0)
class ATgProj_Teleporter : public ATgProj_FreeGrenade
{
public:
	unsigned long                                      m_bCollisionUpdated : 1;                          		// 0x02C0 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 118763 );

		return pClassPointer;
	};

	void TargetReached ( struct FVector vLocation );
	void eventHitWall ( struct FVector HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp );
	void eventLanded ( struct FVector HitNormal, class AActor* FloorActor );
	void SpawnExplosionEffects ( struct FVector HitLocation, struct FVector HitNormal );
	void GotoLocation ( struct FVector Loc );
	void CancelTeleporting ( );
	void CheckInterruptTeleport ( );
	void RangeReached ( );
	void Timer ( );
	void SetMeshCollision ( );
	void PostBeginPlay ( );
};

UClass* ATgProj_Teleporter::pClassPointer = NULL;

// Class TgGame.TgProj_StraightTeleporter
// 0x0000 (0x02C4 - 0x02C4)
class ATgProj_StraightTeleporter : public ATgProj_Teleporter
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 118799 );

		return pClassPointer;
	};

};

UClass* ATgProj_StraightTeleporter::pClassPointer = NULL;

// Class TgGame.TgProj_SunWukong_MastersWillBack
// 0x0000 (0x02E4 - 0x02E4)
class ATgProj_SunWukong_MastersWillBack : public ATgProj_VamanaUmbrella
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 118842 );

		return pClassPointer;
	};

};

UClass* ATgProj_SunWukong_MastersWillBack::pClassPointer = NULL;

// Class TgGame.TgProj_SunWukong_MastersWillOut
// 0x0010 (0x02FC - 0x02EC)
class ATgProj_SunWukong_MastersWillOut : public ATgProj_SimulatedGroundTarget_FixedVelocity_NoLob
{
public:
	unsigned long                                      m_bInitialHit : 1;                                		// 0x02EC (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bExplodeOnBlocker : 1;                          		// 0x02EC (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_bSkipFriendlies : 1;                            		// 0x02EC (0x0004) [0x0000000000000000] [0x00000004] 
	TArray< class AActor* >                            m_PreviouslyHitTargets;                           		// 0x02F0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 118846 );

		return pClassPointer;
	};

	void HitTarget ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal );
	void ProcessTouch ( class AActor* Other, struct FVector HitLocation, struct FVector HitNormal );
};

UClass* ATgProj_SunWukong_MastersWillOut::pClassPointer = NULL;

// Class TgGame.TgProj_SunWukong_SomersaultCloudReturn
// 0x0008 (0x02F0 - 0x02E8)
class ATgProj_SunWukong_SomersaultCloudReturn : public ATgProj_SimulatedSeeking
{
public:
	struct FName                                       m_TargetSocket;                                   		// 0x02E8 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 118864 );

		return pClassPointer;
	};

	struct FVector eventGetSeekLocation ( );
	struct FVector GetDesiredHitLocation ( );
	bool CheckProjectileRange ( struct FVector vLocOverride );
	void RangeReached ( );
	void ProcessTouch ( class AActor* Other, struct FVector HitLocation, struct FVector HitNormal );
};

UClass* ATgProj_SunWukong_SomersaultCloudReturn::pClassPointer = NULL;

// Class TgGame.TgProj_Sylvanus_Dev1
// 0x0000 (0x02E8 - 0x02E8)
class ATgProj_Sylvanus_Dev1 : public ATgProj_SimulatedGroundTarget_FixedVelocity_XY
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 118892 );

		return pClassPointer;
	};

	void HideProjectile ( );
	void UpdateVisualsOnSetGroundTarget ( );
};

UClass* ATgProj_Sylvanus_Dev1::pClassPointer = NULL;

// Class TgGame.TgProj_Sylvanus_Dev2
// 0x0000 (0x02E8 - 0x02E8)
class ATgProj_Sylvanus_Dev2 : public ATgProj_SimulatedSeeking
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 118904 );

		return pClassPointer;
	};

	bool eventUseAOE ( );
	void UpdateSeekingDirection ( float fDeltaTime );
};

UClass* ATgProj_Sylvanus_Dev2::pClassPointer = NULL;

// Class TgGame.TgProj_Sylvanus_Inhand
// 0x0000 (0x02F0 - 0x02F0)
class ATgProj_Sylvanus_Inhand : public ATgProj_SimulatedGroundTarget_FixedVelocity_XY_MinAirTime
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 118922 );

		return pClassPointer;
	};

};

UClass* ATgProj_Sylvanus_Inhand::pClassPointer = NULL;

// Class TgGame.TgProj_Vulcan_Bomb
// 0x0000 (0x02F0 - 0x02F0)
class ATgProj_Vulcan_Bomb : public ATgProj_SimulatedGroundTarget_FixedTime
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 119031 );

		return pClassPointer;
	};

};

UClass* ATgProj_Vulcan_Bomb::pClassPointer = NULL;

// Class TgGame.TgProj_Vulcan_Tossed_Thumper
// 0x0000 (0x02F0 - 0x02F0)
class ATgProj_Vulcan_Tossed_Thumper : public ATgProj_SimulatedGroundTarget_FixedTime
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 119066 );

		return pClassPointer;
	};

};

UClass* ATgProj_Vulcan_Tossed_Thumper::pClassPointer = NULL;

// Class TgGame.TgProj_Xbalanque_PoisonDarts
// 0x0000 (0x02CC - 0x02CC)
class ATgProj_Xbalanque_PoisonDarts : public ATgProj_Simulated
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 119070 );

		return pClassPointer;
	};

	bool ApplyHit ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal, int HitItem );
};

UClass* ATgProj_Xbalanque_PoisonDarts::pClassPointer = NULL;

// Class TgGame.TgProj_Xbalanque_Raining_Dart
// 0x0000 (0x02E8 - 0x02E8)
class ATgProj_Xbalanque_Raining_Dart : public ATgProj_SimulatedSeeking
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 119082 );

		return pClassPointer;
	};

};

UClass* ATgProj_Xbalanque_Raining_Dart::pClassPointer = NULL;

// Class TgGame.TgProj_XingTian_ChestRoar
// 0x0000 (0x02DC - 0x02DC)
class ATgProj_XingTian_ChestRoar : public ATgProj_SimulatedPassThrough
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 119135 );

		return pClassPointer;
	};

};

UClass* ATgProj_XingTian_ChestRoar::pClassPointer = NULL;

// Class TgGame.TgProj_Zeus_BasicAttack
// 0x0000 (0x02CC - 0x02CC)
class ATgProj_Zeus_BasicAttack : public ATgProj_Simulated
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 119139 );

		return pClassPointer;
	};

	bool ApplyHit ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal, int HitItem );
	bool IsValidTarget ( class AActor* A );
};

UClass* ATgProj_Zeus_BasicAttack::pClassPointer = NULL;

// Class TgGame.TgProj_Zeus_ChainLightning
// 0x0000 (0x02CC - 0x02CC)
class ATgProj_Zeus_ChainLightning : public ATgProj_Simulated
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 119152 );

		return pClassPointer;
	};

	bool IsValidTarget ( class AActor* A );
};

UClass* ATgProj_Zeus_ChainLightning::pClassPointer = NULL;

// Class TgGame.TgProj_Zeus_Coffin
// 0x0000 (0x02F4 - 0x02F4)
class ATgProj_Zeus_Coffin : public ATgProj_SimulatedGroundTarget_FixedVelocity_XY_MinAirTime_NoLob
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 119159 );

		return pClassPointer;
	};

	bool eventUseAOE ( );
};

UClass* ATgProj_Zeus_Coffin::pClassPointer = NULL;

// Class TgGame.TgProxyStaticMeshActor
// 0x0000 (0x01FC - 0x01FC)
class ATgProxyStaticMeshActor : public AStaticMeshActor
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 119642 );

		return pClassPointer;
	};

};

UClass* ATgProxyStaticMeshActor::pClassPointer = NULL;

// Class TgGame.TgSeqEvent_ControlPointOwnershipPercent
// 0x0008 (0x00E4 - 0x00DC)
class UTgSeqEvent_ControlPointOwnershipPercent : public USequenceEvent
{
public:
	float                                              OwnershipPercent;                                 		// 0x00DC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                PointIndex;                                       		// 0x00E0 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 119703 );

		return pClassPointer;
	};

};

UClass* UTgSeqEvent_ControlPointOwnershipPercent::pClassPointer = NULL;

// Class TgGame.TgSeqEvent_TaskForceScoreUpdated
// 0x0008 (0x00E4 - 0x00DC)
class UTgSeqEvent_TaskForceScoreUpdated : public USequenceEvent
{
public:
	int                                                DefenderTaskForce;                                		// 0x00DC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                CurrentScore;                                     		// 0x00E0 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 120080 );

		return pClassPointer;
	};

};

UClass* UTgSeqEvent_TaskForceScoreUpdated::pClassPointer = NULL;

// Class TgGame.TgSeqAct_ActivateGlobeCamera
// 0x0010 (0x00D4 - 0x00C4)
class UTgSeqAct_ActivateGlobeCamera : public USequenceAction
{
public:
	int                                                m_nYawRotation;                                   		// 0x00C4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_nPitchRotation;                                 		// 0x00C8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_nTiledShotAmount;                               		// 0x00CC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class ACameraActor*                                m_Camera;                                         		// 0x00D0 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 120145 );

		return pClassPointer;
	};

	void eventActivated ( );
	class ATgPlayerController* GetLocalPlayer ( );
};

UClass* UTgSeqAct_ActivateGlobeCamera::pClassPointer = NULL;

// Class TgGame.TgSeqAct_AddAnimSets
// 0x001C (0x00E0 - 0x00C4)
class UTgSeqAct_AddAnimSets : public USequenceAction
{
public:
	TArray< class UAnimSet* >                          m_MaleAnimSets;                                   		// 0x00C4 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< class UAnimSet* >                          m_FemaleAnimSets;                                 		// 0x00D0 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	unsigned long                                      m_bAppendToExisting : 1;                          		// 0x00DC (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 120158 );

		return pClassPointer;
	};

};

UClass* UTgSeqAct_AddAnimSets::pClassPointer = NULL;

// Class TgGame.TgSeqAct_AIStartFireAt
// 0x0001 (0x00C5 - 0x00C4)
class UTgSeqAct_AIStartFireAt : public USequenceAction
{
public:
	unsigned char                                      ForcedFireMode;                                   		// 0x00C4 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 120168 );

		return pClassPointer;
	};

};

UClass* UTgSeqAct_AIStartFireAt::pClassPointer = NULL;

// Class TgGame.TgSeqAct_AIStopFire
// 0x0000 (0x00C4 - 0x00C4)
class UTgSeqAct_AIStopFire : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 120171 );

		return pClassPointer;
	};

};

UClass* UTgSeqAct_AIStopFire::pClassPointer = NULL;

// Class TgGame.TgSeqAct_GetCharClass
// 0x0000 (0x00C4 - 0x00C4)
class UTgSeqAct_GetCharClass : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 120186 );

		return pClassPointer;
	};

};

UClass* UTgSeqAct_GetCharClass::pClassPointer = NULL;

// Class TgGame.TgSeqAct_HackBot
// 0x0004 (0x00C8 - 0x00C4)
class UTgSeqAct_HackBot : public USequenceAction
{
public:
	class AActor*                                      m_ControlPawn;                                    		// 0x00C4 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 120204 );

		return pClassPointer;
	};

};

UClass* UTgSeqAct_HackBot::pClassPointer = NULL;

// Class TgGame.TgSeqAct_LaunchHomeInstance
// 0x0000 (0x00C4 - 0x00C4)
class UTgSeqAct_LaunchHomeInstance : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 120210 );

		return pClassPointer;
	};

};

UClass* UTgSeqAct_LaunchHomeInstance::pClassPointer = NULL;

// Class TgGame.TgSeqAct_MarkSpawnReturn
// 0x0004 (0x00C8 - 0x00C4)
class UTgSeqAct_MarkSpawnReturn : public USequenceAction
{
public:
	class ATeleporter*                                 m_Teleporter;                                     		// 0x00C4 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 120213 );

		return pClassPointer;
	};

	void eventActivated ( );
};

UClass* UTgSeqAct_MarkSpawnReturn::pClassPointer = NULL;

// Class TgGame.TgSeqAct_PlayCameraAnim
// 0x0014 (0x00D8 - 0x00C4)
class UTgSeqAct_PlayCameraAnim : public USequenceAction
{
public:
	class UCameraAnim*                                 AnimToPlay;                                       		// 0x00C4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              BlendInTime;                                      		// 0x00C8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              BlendOutTime;                                     		// 0x00CC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              Rate;                                             		// 0x00D0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              IntensityScale;                                   		// 0x00D4 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 120230 );

		return pClassPointer;
	};

	int eventGetObjClassVersion ( );
};

UClass* UTgSeqAct_PlayCameraAnim::pClassPointer = NULL;

// Class TgGame.TgSeqAct_SetSkelPosture
// 0x0001 (0x00C5 - 0x00C4)
class UTgSeqAct_SetSkelPosture : public USequenceAction
{
public:
	unsigned char                                      m_Posture;                                        		// 0x00C4 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 120263 );

		return pClassPointer;
	};

};

UClass* UTgSeqAct_SetSkelPosture::pClassPointer = NULL;

// Class TgGame.TgSeqAct_SpawnProjectile
// 0x0004 (0x00C8 - 0x00C4)
class UTgSeqAct_SpawnProjectile : public USequenceAction
{
public:
	class UClass*                                      ProjectileClass;                                  		// 0x00C4 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 120275 );

		return pClassPointer;
	};

	void eventActivated ( );
};

UClass* UTgSeqAct_SpawnProjectile::pClassPointer = NULL;

// Class TgGame.TgSeqAct_TriggerInterpActor
// 0x000C (0x00D0 - 0x00C4)
class UTgSeqAct_TriggerInterpActor : public USequenceAction
{
public:
	struct FString                                     m_sStateName;                                     		// 0x00C4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 120304 );

		return pClassPointer;
	};

};

UClass* UTgSeqAct_TriggerInterpActor::pClassPointer = NULL;

// Class TgGame.TgSeqEvent_SiegePush
// 0x0000 (0x00DC - 0x00DC)
class UTgSeqEvent_SiegePush : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 120366 );

		return pClassPointer;
	};

};

UClass* UTgSeqEvent_SiegePush::pClassPointer = NULL;

// Class TgGame.TgSiegePushActor
// 0x0028 (0x0218 - 0x01F0)
class ATgSiegePushActor : public AActor
{
public:
	class ATgCollisionProxy_Cylinder*                  s_CollisionProxy;                                 		// 0x01F0 (0x0004) [0x0000000000000000]              
	float                                              m_fCollisionProxyRadius;                          		// 0x01F4 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	float                                              m_fCollisionProxyHeight;                          		// 0x01F8 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	class USkeletalMeshComponent*                      m_SkelMesh;                                       		// 0x01FC (0x0004) [0x0000000004080009]              ( CPF_Edit | CPF_ExportObject | CPF_Component | CPF_EditInline )
	class UStaticMeshComponent*                        m_RadiusMesh;                                     		// 0x0200 (0x0004) [0x0000000004080009]              ( CPF_Edit | CPF_ExportObject | CPF_Component | CPF_EditInline )
	int                                                m_nTF1Count;                                      		// 0x0204 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_nTF2Count;                                      		// 0x0208 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_nDefenderTaskForce;                             		// 0x020C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_CurrentPushState;                               		// 0x0210 (0x0001) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_fPendingReverseTime;                            		// 0x0214 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 120393 );

		return pClassPointer;
	};

	void SetCurrentPushState ( unsigned char NewPushState );
	void SetReversePushState ( );
	void NearbyPawnsUpdated ( );
	void eventCollisionProxyOnUnTouch ( class AActor* Other );
	void eventCollisionProxyOnTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void eventPostBeginPlay ( );
};

UClass* ATgSiegePushActor::pClassPointer = NULL;

// Class TgGame.TgSkeletalMeshActor_MercuryGhost
// 0x0004 (0x026C - 0x0268)
class ATgSkeletalMeshActor_MercuryGhost : public ATgSkeletalMeshActorSpawnable
{
public:
	class UTgSkeletalMeshComponent*                    TgSkeletalMeshComp;                               		// 0x0268 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 120784 );

		return pClassPointer;
	};

	void eventOnAnimEnd ( class UAnimNodeSequence* SeqNode, float PlayedTime, float ExcessTime );
	void Init ( );
};

UClass* ATgSkeletalMeshActor_MercuryGhost::pClassPointer = NULL;

// Class TgGame.TgSoundInsulationVolume
// 0x0000 (0x0268 - 0x0268)
class ATgSoundInsulationVolume : public AReverbVolume
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 120870 );

		return pClassPointer;
	};

};

UClass* ATgSoundInsulationVolume::pClassPointer = NULL;

// Class TgGame.TgVolume
// 0x0000 (0x021C - 0x021C)
class ATgVolume : public AVolume
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 121383 );

		return pClassPointer;
	};

};

UClass* ATgVolume::pClassPointer = NULL;

// Class TgGame.TgWaterVolume
// 0x0000 (0x0274 - 0x0274)
class ATgWaterVolume : public AWaterVolume
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 121391 );

		return pClassPointer;
	};

};

UClass* ATgWaterVolume::pClassPointer = NULL;

// Class TgGame.TgAILocalPositionSolver_PVEMinion
// 0x0000 (0x0070 - 0x0070)
class UTgAILocalPositionSolver_PVEMinion : public UTgAILocalPositionSolver_Pet
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 121773 );

		return pClassPointer;
	};

};

UClass* UTgAILocalPositionSolver_PVEMinion::pClassPointer = NULL;

// Class TgGame.TgCameraModule_Racer
// 0x000C (0x0088 - 0x007C)
class UTgCameraModule_Racer : public UTgCameraModule_ThirdPerson
{
public:
	unsigned long                                      m_ForceFreeCam : 1;                               		// 0x007C (0x0004) [0x0000000000000000] [0x00000001] 
	float                                              m_LastRotation;                                   		// 0x0080 (0x0004) [0x0000000000000000]              
	float                                              m_PostWallBumpFaceRate;                           		// 0x0084 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 121789 );

		return pClassPointer;
	};

	void UpdateCamera ( class APawn* P, class ATgPlayerCamera* CameraActor, float DeltaTime, struct FTViewTarget* OutVT );
};

UClass* UTgCameraModule_Racer::pClassPointer = NULL;

// Class TgGame.TgControlModule_Racer
// 0x0000 (0x009C - 0x009C)
class UTgControlModule_Racer : public UTgControlModule_ThirdPerson
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 121813 );

		return pClassPointer;
	};

	void OnRightMouseReleased ( );
	void OnRightMousePressed ( );
	void UpdateRotation ( float DeltaTime );
	struct FVector CalcNewAccel ( );
};

UClass* UTgControlModule_Racer::pClassPointer = NULL;

// Class TgGame.TgDamageType_AnubisT5_HighImpulse
// 0x0000 (0x00C8 - 0x00C8)
class UTgDamageType_AnubisT5_HighImpulse : public UTgDamageType
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 121828 );

		return pClassPointer;
	};

};

UClass* UTgDamageType_AnubisT5_HighImpulse::pClassPointer = NULL;

// Class TgGame.TgDamageType_AnubisT5_MidImpulse
// 0x0000 (0x00C8 - 0x00C8)
class UTgDamageType_AnubisT5_MidImpulse : public UTgDamageType
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 121830 );

		return pClassPointer;
	};

};

UClass* UTgDamageType_AnubisT5_MidImpulse::pClassPointer = NULL;

// Class TgGame.TgDeployableFactory_TimedRepeat
// 0x0008 (0x0240 - 0x0238)
class ATgDeployableFactory_TimedRepeat : public ATgDeployableFactory
{
public:
	unsigned long                                      s_bRefire : 1;                                    		// 0x0238 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	float                                              s_fRefireTime;                                    		// 0x023C (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 121897 );

		return pClassPointer;
	};

	void SpawnTimerExpired ( );
	void PostBeginPlay ( );
};

UClass* ATgDeployableFactory_TimedRepeat::pClassPointer = NULL;

// Class TgGame.TgDevice_G84_Dev1Stage
// 0x0000 (0x03AC - 0x03AC)
class ATgDevice_G84_Dev1Stage : public ATgDevice_Staging
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 121940 );

		return pClassPointer;
	};

	bool eventShouldTriggerCastReactionItemsOnFire ( );
	bool eventShouldTriggerCastReactionItems ( );
	bool ShouldConsumePowerPoolAfterFire ( );
	bool ShouldConsumePowerPoolOnStartFire ( );
	void eventOnStageShooterFire ( );
	bool eventCanBeCanceled ( );
	bool eventCanJumpWhileFiring ( );
};

UClass* ATgDevice_G84_Dev1Stage::pClassPointer = NULL;

// Class TgGame.TgDevice_Racer_HandBrake
// 0x0000 (0x0380 - 0x0380)
class ATgDevice_Racer_HandBrake : public ATgDevice
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 121973 );

		return pClassPointer;
	};

};

UClass* ATgDevice_Racer_HandBrake::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_Apep_AcidSpray
// 0x0000 (0x0188 - 0x0188)
class UTgDeviceForm_Apep_AcidSpray : public UTgDeviceForm
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 122052 );

		return pClassPointer;
	};

	void eventExitTargetingMode ( );
	void eventEnterTargetingMode ( );
};

UClass* UTgDeviceForm_Apep_AcidSpray::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_Thoth_Assault
// 0x0000 (0x0198 - 0x0198)
class UTgDeviceForm_Thoth_Assault : public UTgDeviceForm_TwoPhase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 122068 );

		return pClassPointer;
	};

};

UClass* UTgDeviceForm_Thoth_Assault::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_Thoth_Dev2_Shooter
// 0x0000 (0x0198 - 0x0198)
class UTgDeviceForm_Thoth_Dev2_Shooter : public UTgDeviceForm_TwoPhase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 122078 );

		return pClassPointer;
	};

};

UClass* UTgDeviceForm_Thoth_Dev2_Shooter::pClassPointer = NULL;

// Class TgGame.TgPawn_Phoenix_PVE_Tier2
// 0x0000 (0x1B60 - 0x1B60)
class ATgPawn_Phoenix_PVE_Tier2 : public ATgPawn_Phoenix_PVE
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 122242 );

		return pClassPointer;
	};

};

UClass* ATgPawn_Phoenix_PVE_Tier2::pClassPointer = NULL;

// Class TgGame.TgProj_Apep_BasicAttack
// 0x0000 (0x02E8 - 0x02E8)
class ATgProj_Apep_BasicAttack : public ATgProj_SimulatedSeeking
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->GetIndex( 122333 );

		return pClassPointer;
	};

	void eventPostProjectileInitialize ( );
};

UClass* ATgProj_Apep_BasicAttack::pClassPointer = NULL;


#ifdef _MSC_VER
	#pragma pack ( pop )
#endif